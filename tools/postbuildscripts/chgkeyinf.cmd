@echo off
REM  ------------------------------------------------------------------
REM
REM  chgkeyinf.cmd
REM     Change txtsetup.sif, layout.inf, dosnet.inf  file  for the adding mui resource files
REM                 
REM
REM  Copyright (c) Microsoft Corporation. All rights reserved.
REM
REM  ------------------------------------------------------------------
perl -x "%~f0" %*
goto :EOF
#!perl
use strict;
use File::Basename;
use IO::File;

use lib $ENV{RAZZLETOOLPATH} . "\\PostBuildScripts";
use lib $ENV{RAZZLETOOLPATH};
use PbuildEnv;
use ParseArgs;
use Logmsg;
use cksku;
require Exporter;

BEGIN {
      $ENV{SCRIPT_NAME} = 'chgkeyinf.cmd';
}

sub Usage { print<<USAGE; exit(1) }
chgkeyinf  [-l lang]

   Change txtsetup.sif, layout.inf, dosnet.inf  file  for the adding mui resource files
   Read nttree\\build_logs\\LgNeutral\\lgnbuildlist.txt,  which generated by lgndata.cmd, to
   get the list of binaries to be added to the said INFs.
   

USAGE

# Global variables

my ($lang);
my (%CDDataSKUs,  %INFPathSKUs, $Neutral_LogDir, $LGNBuildList, $LGNCMFList, $LGNDirs, $LGNDirs_Localized);
my (@ItemsList, $LGNTagStart, $LGNTagEnd, $LGNItemEntry, $LGNDirs_Tag, $LGNDirs_TagReg);

my( $LogFilename );
my( $TempDir );
my( $nttree, $razpath, $TempDir);
my($fNeedGenerateCMF);

##################
#
# parse command line
#
##################
parseargs(	'?' => \&Usage,						
	              'l:' => \$lang
              );
&Main();


#
# Check if Language Neutral is enabled or not
#
sub IsLGNActivated()
{
    my ($MUI_MAGIC, $Result);

    $Result = 0;
    
    $MUI_MAGIC= $ENV{ "MUI_MAGIC" };

    if ( defined($MUI_MAGIC))
    {
       $Result=1;
    }
    return $Result

}
sub IsCMFActivated()
{
    my ($MUI_MAGIC_CMF, $Result);

    $Result = 0;
    
    $MUI_MAGIC_CMF= $ENV{ "MUI_MAGIC_CMF" };

    if ( defined($MUI_MAGIC_CMF))
    {
       $Result=1;
    }
    return $Result
}
sub Main
{

	# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
	# Begin Main code section
	# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
	# Return when you want to exit on error
	#    
       my ($Mylang, $MyError, $Sku, $MyLCID);
       my ($Path_Dosnet, $Path_Txtsetup, $Path_Layout, $Path_Dir);
       my ($Path_Dosnet_sign, $Path_Txtsetup_sign, $Path_Layout_sign, $Path_Dir_sign);
       my ($Backup_Path, $ErrCnt);

       if (! &IsLGNActivated())
       {
          return 0;
       }     
       #
       # $lang must be set. Default is usa
       #
       if ( ! defined($lang))
       { 
           $lang = $ENV{LANG};
           if (! defined($lang))
           {              
              $lang="usa";                           
           }
        }
        $Mylang="\L$lang";
        if ( ($Mylang ne "usa" ) && ($Mylang ne "psu" ) )
        {
             return 0;
        }
       #
       # Check If CMF is enabled
       #
       $fNeedGenerateCMF=&IsCMFActivated();
       #
       # Set important path
       #
	$nttree = $ENV{ "_NTPostBld" };
	$razpath= $ENV{ "RazzleToolPath" };
	$TempDir = $ENV{ "TMP" };
    	
	     	
	
	$Logmsg::DEBUG = 0; # set to 1 to activate logging of dbgmsg's
	$LogFilename = $ENV{ "LOGFILE" };        

       if ( ! defined( $LogFilename ) )
	{
		$TempDir = $ENV{ "TMP" };
		$LogFilename = "$TempDir\\$0.log";
	}
	$Neutral_LogDir = $nttree."\\build_logs\\LgNeutral"; 
	$LGNBuildList = $Neutral_LogDir."\\lgnbuildlist.txt";
       $LGNCMFList  = $Neutral_LogDir."\\lgnCMFlist.txt";	
       $LGNTagStart     = "; Following are entries added for Language neutral resource files:\$\$\$ ";
       $LGNTagEnd       = "; End of entries for Language neutral resource files: \$\$\$";
       $LGNDirs_Tag     = "190 = mui\\fallback\\";
       $LGNDirs_TagReg ="190 = mui\\\\fallback\\\\";
       $LGNDirs            = $LGNDirs_Tag."0409";
       
       $LGNItemEntry   = " = 1,,2048,,,,,190,0,0";

       if (! GetLCIDofLang($lang,\$MyLCID))
       {
           errmsg("Fatal: can't get LCID for $lang");
           return 0;
       }
       $LGNDirs_Localized="$LGNDirs_Tag$MyLCID";       
       
       $MyError=0;
       #
	# Check Language Neutral working directory
	#       
       unless (-d $Neutral_LogDir)
       {
		errmsg("Fatal: Directory $Neutral_LogDir does not exist");
		$MyError=1;		
	}	
	if ($fNeedGenerateCMF)
	{
          unless (-e $LGNCMFList)
	  {
                errmsg("Fatal: Language Neutral CMF list not found : $LGNCMFList");
                $MyError=1;
	  }	
       }
       else
       {
          unless (-e $LGNBuildList)
	  {
             errmsg("Fatal: Language Neutral build list not found : $LGNBuildList");
             $MyError=1;
	  }
       }	
	if ($MyError != 0)
       {
           exit(1);
       }
       if ($fNeedGenerateCMF)
       {
          #
          # Read CMF binaries into @ItemsList
          #
          unless ( open(INFILE, $LGNCMFList))
          {
                errmag("Fatal: Can't open $LGNCMFList");
                $MyError=1;
                exit(1);
          }
          @ItemsList=<INFILE>;
          close(INFFILE);
       }
       else
       {
          #
          # Read LGN binaries into @ItemsList
          #
          unless ( open(INFILE, $LGNBuildList))
          {
                errmag("Fatal: Can't open $LGNBuildList");
                $MyError=1;
                exit(1);
          }
          @ItemsList=<INFILE>;
          close(INFFILE);
        }
        #
        # Build path of INFs for SKUs
        #
        BuildArray();  
       #
       # For Each SKUs, update the KEY INFS
       #
       $ErrCnt=0;
       foreach $Sku ( keys(%CDDataSKUs))
       {
            # SKU populated ?
            if ($CDDataSKUs{$Sku})
            {
               if ( !defined($INFPathSKUs{$Sku} ))
               {
                  errmag("Fatal: $Sku has no corr. entry in INFPathSKUs");
                  exit(1);
               }
               #
               # Read the INFs path for the SKU
               #               
               ($Path_Dosnet,$Path_Txtsetup,$Path_Layout,$Path_Dir, $Path_Dosnet_sign,$Path_Txtsetup_sign,$Path_Layout_sign,$Path_Dir_sign)=@{$INFPathSKUs{$Sku}};
                              
               $Backup_Path="$Neutral_LogDir\\$Path_Dir";
               #
               #Change for DosNet
               #
               if (! DoDosNetChange($Path_Dosnet, \@ItemsList, $Backup_Path))
               {
                  $ErrCnt++;
                  errmsg("Fatal: Update Dosnet.inf faild for $Sku");
               }               
               #Change for Txtsetup
               
               if (! DoTxtsetupNLayoutChange($Path_Txtsetup, \@ItemsList, $Backup_Path))
               {
                  $ErrCnt++;
                  errmsg("Fatal: Update Txtsetup.sif faild for $Sku");
               }
               # Change for Layout               
               if (! DoTxtsetupNLayoutChange($Path_Layout, \@ItemsList, $Backup_Path))
               {
                  $ErrCnt++;
                  errmsg("Fatal: Update layout.inf faild for $Sku");
               }
               #
               #
               #
               $Backup_Path="$Neutral_LogDir\\$Path_Dir_sign";
               #
               #Change for DosNet
               #
               if (! DoDosNetChange($Path_Dosnet_sign, \@ItemsList, $Backup_Path))
               {
                  $ErrCnt++;
                  errmsg("Fatal: Update Dosnet.inf faild for $Sku");
               }               
               #Change for Txtsetup
               
               if (! DoTxtsetupNLayoutChange($Path_Txtsetup_sign, \@ItemsList, $Backup_Path))
               {
                  $ErrCnt++;
                  errmsg("Fatal: Update Txtsetup.sif faild for $Sku");
               }
               # Change for Layout               
               if (! DoTxtsetupNLayoutChange($Path_Layout_sign, \@ItemsList, $Backup_Path))
               {
                  $ErrCnt++;
                  errmsg("Fatal: Update layout.inf faild for $Sku");
               }



               
            }
       }
       if ( !$ErrCnt)
       {       
            timemsg( "Update KEY INFs successfully");
       }
       else
       {
            timemsg( "Update KEY INFs Failed with $ErrCnt errors, please check Log");
       }
        
       
       # /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
	# End Main code section
	# /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
}

#
# Get LCID of a given language
#
sub GetLCIDofLang
{
   my($Mylang, $LCID) = @_;
    
   my ($CODEFILE,@data, $Result, $LCIDShort);

   $CODEFILE = $ENV{RAZZLETOOLPATH} ."\\codes.txt";  
   $Result = 0;   

   $Mylang="\L$Mylang";
   if ( $Mylang eq "usa")
   {
      $$LCID="0409";
      $Result =1;
      return  $Result;
   }
    #
    # Search CODEFILE for $Special_Lang, $LCID, $LANG_ISO, etc.
    #
    if(!open(CODEFILE, "$CODEFILE")) 
    {
        errmsg ("Can't open lcid file $CODEFILE for reading.");
        return $Result;
    }
    CODES_LOOP: while (<CODEFILE>) 
    {
        if (/^$Mylang\s+/i) 
        {
            @data = split(/\s+/,$_);
            last CODES_LOOP;
        }
    }
    close(CODEFILE);

    if(!@data)
    {
        errmsg("fatal: can't find LCID for $Mylang");
        return $Result;
    }

    $LCIDShort = $data[2];    
    $LCIDShort  =~ s/^0x//;
    $$LCID=$LCIDShort;
    $Result =1; 
   
    return $Result;
} # GetLCIDofLang
#
# Add LGN binaries to dosnet.inf
#
sub DoDosNetChange
{
      my ($FilePath, $pItemsList, $BackupPath) = @_;

      my (@Items, @ItemsInSection, $Section, $Result, $nStart, $nEnd, $nStartTag1, $nStartTag2);
      my ($Replace, $Line, $Entry);
      my (@AddedItems, $FileName, $Path, $Idx, $Item_no);

      $Result = 0;
      # Open he dosnet.inf
      unless ( open(INFILE, $FilePath) )
      {
           errmsg ("Can't open $FilePath");
           return $Result;
      }
      # Read into @Items
      @Items=<INFILE>;
      close(INFILE);
      
      $Section="Files";
      $nStartTag1=0;
      $nStartTag2=0;      
      #
      # Read [Files] Section, position in nStart, nEnd
      # Find LGN tag, position in nStartTag1, nStartTag2      
      #
      # [Note] There are multiply [Files] in Dosnet.inf. We are looking the one which notepad.exe exists
      #  
      if (!ReadSectionDosNet($Section,\@Items,  \$nStart, \$nEnd, \$nStartTag1, \$nStartTag2,
                               $LGNTagStart,$LGNTagEnd))
      {
         errmsg("Fatal: Can't find $Section in $FilePath");
         return $Result;
      }

      #
      # Search the LGN Tag
      #
      $nStartTag1=-1;
      $nStartTag2=-1;
      $Replace="FALSE";
      $Idx=-1;
      foreach (@Items)
      {
           chomp($_);
           $Idx++;
            # Find$ LGN tag, position in nStartTag1, nStartTag2
           if ( $_ eq $LGNTagStart)
           {
               $nStartTag1 = $Idx;   
            }
           if ( $_ eq $LGNTagEnd)
           {
               $nStartTag2 = $Idx;     
           }            
      }                
      
      if ( ($nStartTag1 != -1) && ($nStartTag2 != -1))
      {          
          $Replace = "TRUE";
      }
      else
      {
          logmsg("StartTag/EndTag not found in $FilePath, it may be a fresh one");
      }
      #
      # LGN resource files list in @$pItemsList
      # Let's add items in @$pItemsList to @AddedItems
      #
      foreach $Line (@$pItemsList)
      {
          chomp($Line);
          if (! $fNeedGenerateCMF)
          {
             $Entry = "d1,$Line.mui";
          }
          else
          {
             $Entry = "d1,$Line";
          }
          push(@AddedItems,$Entry);
      }
      #
      # backup the dosnet.inf before the modification
      #
      if ( ! -d  $BackupPath)
      {
          system("md $BackupPath");          
      }
      unless ( -d $BackupPath)
      {
          errmsg("Fatal: Can't open backup path $BackupPath");
      }
      #
      # Get File name from path
      #
      ($FileName, $Path ) = fileparse($FilePath);      
      
      if ( system("copy/y $FilePath $BackupPath\\$FileName.Bak") != 0)
      {
          errmsg("Fatal: Can't backup $FilePath to $BackupPath\\$FileName.Bak");
          return $Result;
      }
      #
      # Generate the dosnet.inf with added LGN resource files
      #
      system ("attrib -r $FilePath 2>null");
      unless ( open(OUTFILE, ">$FilePath") )
      {
          errmsg("Fatal: Can't open output for $FilePath");          
          return $Result;
      }
      $Item_no=scalar(@Items);
      
      if ( $Replace eq "TRUE")
      {
           for ($Idx=0; $Idx <= $nStartTag1; $Idx++)
           {
                chomp($Items[$Idx]);
                print (OUTFILE "$Items[$Idx]\n");
           }
           foreach $Line  (@AddedItems)
           {
                print (OUTFILE "$Line\n");
           }
          
           for ($Idx=$nStartTag2; $Idx < $Item_no; $Idx++)
           {
                chomp($Items[$Idx]);
                print (OUTFILE "$Items[$Idx]\n");
           }
      } 
        else
        {
           for ($Idx=0; $Idx <= $nEnd; $Idx++)
           {
                chomp($Items[$Idx]);
                print (OUTFILE "$Items[$Idx]\n");
           }
           #
           # Add LGN resource files, enclosed them with Tag
           #
           print  (OUTFILE "$LGNTagStart\n");
           foreach $Line  (@AddedItems)
           {
                print (OUTFILE "$Line\n");
           }
           print (OUTFILE "$LGNTagEnd\n\n");
           
           for ($Idx=$nEnd+1; $Idx < $Item_no; $Idx++)
           {
                chomp($Items[$Idx]);
                print (OUTFILE "$Items[$Idx]\n");
           }
        }
        close(OUTFILE);
        $Result = 1;
        logmsg("Success: Update $FilePath");
        return $Result;
      
}
#
# Add LGN binaries to txtsetup.sif/layout.inf
#
sub DoTxtsetupNLayoutChange
{
      my ($FilePath, $pItemsList, $BackupPath) = @_;

      my (@Items, @ItemsInSection, $Section, $Result, $nStart, $nEnd, $nStartTag1, $nStartTag2,$nStartDirs,$nEndDirs);
      my ($nStart_Dir,$nEnd_Dir);
      my ($ReplaceDirs, $Replace, $Line, $Entry);
      my (@AddedItems, $FileName, $Path, $Idx, $Item_no);
      my (%RenameTable, $FileRenamed, $nUppbound);
      my ($NoAlt,  $BldArch, $AltSection,$nAltStart,$nAltEnd, $bLGNDirs);

      $Result = 0;
      # Open he dosnet.inf
      unless ( open(INFILE, $FilePath) )
      {
           errmsg ("Can't open $FilePath");
           return $Result;
      }
      # Read into @Items
      @Items=<INFILE>;
      close(INFILE);

      #
      # First, we have to read [WinntDirectories] section to see if  '190 = mui\fallback\0409' is there
      #
      $Section="WinntDirectories";
      $nStartDirs=0;
      $nEndDirs=0;      
      #
      # Read [WinntDirectories] Section, position in nStart, nEnd 
      #
      if (!ReadSection($Section,\@Items, \@ItemsInSection, \$nStart_Dir, \$nEnd_Dir, \$nStartDirs, \$nEndDirs,
                               $LGNDirs,"Nothing"))
      {
         errmsg("Fatal: Can't find $Section in $FilePath");
         return $Result;
      }      

      $Section="SourceDisksFiles";      
      $nStartTag1=0;
      $nStartTag2=0;
      #
      # Read [SourceDisksFiles] Section, position in nStart, nEnd     
      #
      if (!ReadSection($Section,\@Items, \@ItemsInSection, \$nStart, \$nEnd, \$nStartTag1, \$nStartTag2,
                               $LGNTagStart,$LGNTagEnd))
      {
         errmsg("Fatal: Can't find $Section in $FilePath");
         return $Result;
      }    
      #
      # Read [SourceDisksFiles.<BldArch>] Section. This section contains platform specific files
      #
      my ($NoAlt,  $BldArch, $AltSection);
      $NoAlt=0;
      $BldArch = $ENV{ "\_BuildArch" };
      if (  $BldArch =~ /x86/i )
      {
         $AltSection= "$Section.x86";
      }
      elsif ( $BldArch =~ /amd64/i)
      {
           $AltSection= "$Section.amd64";
      }
      elsif ( $BldArch =~ /ia64/i )
      {
           $AltSection= "$Section.ia64";
      }
      else
      {
            $AltSection= "$Section.x86";
      }
      if (!ReadSection($AltSection,\@Items, \@ItemsInSection, \$nAltStart, \$nAltEnd, \$nStartTag1, \$nStartTag2,
                               $LGNTagStart,$LGNTagEnd))
      {
         errmsg(" Can't find $AltSection in $FilePath");         
         $NoAlt=1;
      }         
      #
      # Search Tag here
      #
      $nStartDirs=-1;
      $nEndDirs=-1;
      $nStartTag1=-1;
      $nStartTag2=-1;
      $ReplaceDirs="FALSE";
      $Replace="FALSE";
      $Idx=-1;
      foreach (@Items)
      {
           chomp($_);
           $Idx++;
           # Find $LGNDirs, position in nStartDirs
           if ( $_ eq $LGNDirs)
           {
               $nStartDirs = $Idx;
           }
           # Find$ LGN tag, position in nStartTag1, nStartTag2
           if ( $_ eq $LGNTagStart)
           {
               $nStartTag1 = $Idx;   
            }
           if ( $_ eq $LGNTagEnd)
           {
               $nStartTag2 = $Idx;     
           }            
      }
      if ($nStartDirs != -1)
      {          
          $ReplaceDirs = "TRUE";
      }
      if ( ($nStartTag1 != -1)  && ($nStartTag2 != -1))
      {          
          $Replace = "TRUE";
      }    

      #
      # Build up rename table here !
      # Windows sepcify the renaming in txtsetup.txt and layout.inf
      #
      %RenameTable={};  
      if ($Replace eq "TRUE")
      {
          $nUppbound = $nStartTag1;          
      }
      else
      {
          $nUppbound = $nEnd;
      }
      if (! &BuildRenameTable(\@Items,$nStart, $nUppbound,\%RenameTable))
      {
		errmsg("Can't build File Rename Table");
		return $Result;
      } 
      if ( ! $NoAlt )
      {
           if (! &BuildRenameTable(\@Items,$nAltStart, $nAltEnd,\%RenameTable))
          {
		errmsg("Can't build File Rename Table from $AltSection");
	   }    
      }
      #      
      # LGN resource files list in @$pItemsList
      # Let's add LGN binaries to @AddedItems
      #
      foreach $Line (@$pItemsList)
      {          
          chomp($Line);
          if (! $fNeedGenerateCMF)
          {
             $Entry = "$Line.mui$LGNItemEntry";
             #
             # If file exists in rename table, append rename entry 
             #                    
             $FileRenamed=$RenameTable{$Line};
             if ( defined($FileRenamed) )
             {
                 $Entry="$Entry,$FileRenamed.mui";
             }
          }
          else
          {
             $Entry = "$Line$LGNItemEntry";
          }         
          push(@AddedItems,$Entry);
      }
      #
      # backup the txtsetup.sif / layout.inf  before the modification
      #
      if ( ! -d  $BackupPath)
      {
          system("md $BackupPath");          
      }
      unless ( -d $BackupPath)
      {
          errmsg("Fatal: Can't open backup path $BackupPath");
      }
      #
      # Get File name from path
      #
      ($FileName, $Path ) = fileparse($FilePath);
      
      if (system("copy/y $FilePath $BackupPath\\$FileName.Bak") != 0)
      {
          errmsg("Fatal: Can't backup $FilePath to $BackupPath\\$FileName.Bak");
          return $Result;
      }
      #
      # Generate the txtsetup.sif / layout.inf  with added LGN resource files
      #
      system ("attrib -r $FilePath");
      unless ( open(OUTFILE, ">$FilePath") )
      {
          errmsg("Fatal: Can't open output for $FilePath");          
          return $Result;
      }
      $Item_no=scalar(@Items);

      $bLGNDirs=0;
      for ($Idx=0; $Idx <= $nEnd_Dir; $Idx++)
      {
               chomp($Items[$Idx]);
               if ( ($Idx > $nStart_Dir) && ( $Items[$Idx] =~ /^$LGNDirs_TagReg/) )
               {
                   $Items[$Idx] = $LGNDirs_Localized;
                   $bLGNDirs=1;
               }
               print (OUTFILE "$Items[$Idx]\n");
      }               
      #if ($ReplaceDirs eq "FALSE")
      if ( ! $bLGNDirs)
      {           
              print (OUTFILE "$LGNDirs_Localized\n\n");                    
      }
      #
      # Add/Replace items in [SourceDisksFiles] Section
      #
      
      if ( $Replace eq "TRUE")
      {
           for ($Idx=$nEnd_Dir + 1 ; $Idx <= $nStartTag1; $Idx++)
           {
                chomp($Items[$Idx]);
                print (OUTFILE "$Items[$Idx]\n");
           }
           foreach $Line  (@AddedItems)
           {
                
                print (OUTFILE "$Line\n");
           }
          
           for ($Idx=$nStartTag2; $Idx < $Item_no; $Idx++)
           {
                chomp($Items[$Idx]);
                print (OUTFILE "$Items[$Idx]\n");
           }
        } 
        else
        {
          
           for ($Idx=$nEnd_Dir + 1; $Idx <= $nEnd; $Idx++)
           {
                chomp($Items[$Idx]);
                print (OUTFILE "$Items[$Idx]\n");
           }
           #
           # Add LGN resource files, enclosed them with Tag
           #
           print (OUTFILE "$LGNTagStart\n");
           foreach $Line  (@AddedItems)
           {
                print (OUTFILE "$Line\n");
           }
           print (OUTFILE "$LGNTagEnd\n\n");
          
           
           for ($Idx=$nEnd+1; $Idx < $Item_no; $Idx++)
           {
                chomp($Items[$Idx]);
                print (OUTFILE "$Items[$Idx]\n");
           }
        }
        close(OUTFILE);
        $Result = 1;
         logmsg("Success: Update $FilePath");
        return $Result;
     
 }
#
#
# Scan the entries of txtsetup.sif/layout.inf to find the files to be renamed
#
# If a file is renamed, then its associated mui file should be renamed also
#
sub BuildRenameTable
{

       my ($pItems,$nStart, $nEnd,$pRenameTable)= @_;
       my ($Line, $Trash, $Idx,$OldName,$NewName);
                       
                   
       
       for ($Idx = $nStart; $Idx <= $nEnd; $Idx++)
       {
       
           $Line=$$pItems[$Idx];
           chomp($Line);
           
           if ( length($Line) == 0)
           {
              next;
           }
           if (substr($Line,0,1) eq ";")
           {
              next;
           }           
               
         if ($Line =~ /=\s*[^,]*,[^,]*,[^,]*,[^,]*,[^,]*,[^,]*,[^,]*,[^,]*,[^,]*,[^,]*,([^,]+)/ )
           {
               $NewName=$1;
               ($OldName,$Trash) = split ( /=+/, $Line);
               $OldName =~ s/\s//g;                              
               $NewName=~ s/\s//g;                   
               $$pRenameTable{$OldName}=$NewName;
           }           
       }
       return 1;

}

#
# Search a Section of a INFs. INFs stored in @$pItemsList
#

sub ReadSection
{

       my ($Section, $pItemsList, $pItemsInSection, $pnStart, $pnEnd, $pnStartTag1, $pnStartTag2, $Tag1,$Tag2) = @_;
       my ($Index, $SectionStart, $SectionEnd, $Line, $Line_Org, $ReadFlag, $Result);

       $ReadFlag = "FALSE";
       $Index= -1;
       $SectionStart = -1;
       $SectionEnd = -1;
       $Result = 0;

       #
       # Read The section
       #
LINE:  foreach $Line_Org (@$pItemsList)
       {
            $Line = $Line_Org;            
            chomp($Line);
            $Index++;
            if ( (length($Line) == 0) || (substr($Line,0,1) eq ";")  || (substr($Line,0,1) eq "#") )
            {
                if ( $ReadFlag eq "TRUE" )
                {
                     push (@$pItemsInSection, $Line_Org);
                }
                 next;
            }
            if ( $Line =~ /^\[/ )
            {
                
                if ( $ReadFlag eq "TRUE")
                {
                    $ReadFlag = "FALSE";
                    if ( $SectionStart != -1)     
                    {
                         if ($SectionEnd == -1)
                         {
                             $SectionEnd = $Index-1;
                         }
                    }
                    last LINE;
                }                
                
            }
            if ( $Line =~ /^\[$Section\]/ )     # pattern in $Section !!!            
            {                
                $ReadFlag = "TRUE";
                $SectionStart=$Index;
            }
            if ($ReadFlag eq "TRUE")
            {
                # Check if it's a LGN starting Tag
                if ( $$pnStartTag1 != 0)
                {
                    if ($Line eq $Tag1)
                    {                        
                        $$pnStartTag1 = $Index;
                    }
                 }
                 # Check if it's a LGN ending Tag
                 if ( $$pnStartTag2 != 0)
                 {
                    if ($Line eq $Tag2)
                    {                        
                        $$pnStartTag2 = $Index;
                    }
                 }
                  
                push(@$pItemsInSection, $Line_Org);
            }
        }
       if ( $SectionStart != -1)
       {
            if ( $SectionEnd == -1)
            {
                $SectionEnd = $Index;
            }
            $Result = 1;            
            $$pnStart = $SectionStart;
            $$pnEnd   = $SectionEnd;
       } 
       return $Result;
}
#
# Search a Section of a INFs. INFs stored in @$pItemsList
#

sub ReadSectionDosNet
{

       my ($Section, $pItemsList, $pnStart, $pnEnd, $pnStartTag1, $pnStartTag2, $Tag1,$Tag2) = @_;
       my ($Index, $SectionStart, $SectionEnd, $Line,  $ReadFlag, $Result, $NotepadFound, $NotepadTag);

       $ReadFlag = 0;
       $NotepadFound=0;
       $Index= -1;
       $SectionStart = -1;
       $SectionEnd = -1;
       $Result = 0;
       $NotepadTag="d1,notepad.exe";

       #
       # Read The section
       #
LINE:  foreach $Line (@$pItemsList)
       {                        
            chomp($Line);
            $Index++;
            if ( (length($Line) == 0) || (substr($Line,0,1) eq ";")  || (substr($Line,0,1) eq "#") )
            {                
                 next;
            }
            #
            # A  start of section
            #
            if ( $Line =~ /^\[/ )
            {                
                if ( $ReadFlag)
                {
                    $ReadFlag = 0;
                    #
                    # Is it the section we want ?
                    #
                    if ($NotepadFound)
                    {
                         if ( $SectionStart != -1)     
                         {
                              if ($SectionEnd == -1)
                              {
                                  $SectionEnd = $Index-1;
                              }
                         }
                         # Done ! and Exit the loop
                         last LINE;
                    }
                    else
                    {
                        $SectionStart= -1;
                        $SectionEnd = -1;                          
                    }
                }                
                
            }
            if ( $Line =~ /^\[$Section\]/ )     # pattern in $Section !!!            
            {                
                $ReadFlag = 1;
                $SectionStart=$Index;
            }
            if ($ReadFlag)
            {                                
                if ( $Line =~ /$NotepadTag/ )
                {
                    $NotepadFound=1;
                    
                }
            }
        }
       if ( ($SectionStart != -1) && $NotepadFound )
       {
            if ( $SectionEnd == -1)
            {
                $SectionEnd = $Index;
            }
            $Result = 1;            
            $$pnStart = $SectionStart;
            $$pnEnd   = $SectionEnd;
       } 
       return $Result;
}

#
#  Build  hash of array which contians path of KEY INFS 
#
sub BuildArray
{


       my ($BigDosnet, $PerDosnet,  $BlaDosnet, $SbsDosnet, $SrvDosnet , $EntDosnet , $DtcDosnet);      
       my ($BigDosnet_sign, $PerDosnet_sign,  $BlaDosnet_sign, $SbsDosnet_sign, $SrvDosnet_sign , $EntDosnet_sign , $DtcDosnet_sign);
       
       my ($BigTxtsetup, $PerTxtsetup,  $BlaTxtsetup, $SbsTxtsetup, $SrvTxtsetup, $EntTxtsetup, $DtcTxtsetup);
       my ($BigTxtsetup_sign, $PerTxtsetup_sign,  $BlaTxtsetup_sign, $SbsTxtsetup_sign, $SrvTxtsetup_sign, $EntTxtsetup_sign, $DtcTxtsetup_sign);
       
       my ($BigLayout, $PerLayout, $BlaLayout, $SbsLayout, $SrvLayout , $EntLayout, $DtcLayout);
       my ($BigLayout_sign, $PerLayout_sign, $BlaLayout_sign, $SbsLayout_sign, $SrvLayout_sign , $EntLayout_sign, $DtcLayout_sign);
       
       my ($Path_Dosnet, $Path_Txtsetup, $Path_Layout, $Path_Dir);
       my ($Path_Dosnet_sign, $Path_Txtsetup_sign, $Path_Layout_sign, $Path_Dir_sign);

       

       #
       # Get SKUs
       #
       %CDDataSKUs = map({uc$_ => cksku::CkSku($_, $lang, $ENV{_BuildArch})} qw(PRO PER SRV BLA SBS ADS DTC));
       #
       # Build Key INFs for SKUs
       #
       $BigDosnet = $nttree . "\\dosnet.inf";
       $PerDosnet = $nttree . "\\perinf\\dosnet.inf";
       $BlaDosnet = $nttree . "\\blainf\\dosnet.inf";
       $SbsDosnet = $nttree . "\\sbsinf\\dosnet.inf";
       $SrvDosnet = $nttree . "\\srvinf\\dosnet.inf";
       $EntDosnet = $nttree . "\\entinf\\dosnet.inf";
       $DtcDosnet = $nttree . "\\dtcinf\\dosnet.inf";

       $BigTxtsetup = $nttree . "\\txtsetup.sif";
       $PerTxtsetup = $nttree . "\\perinf\\txtsetup.sif";
       $BlaTxtsetup = $nttree . "\\blainf\\txtsetup.sif";
       $SbsTxtsetup = $nttree . "\\sbsinf\\txtsetup.sif";
       $SrvTxtsetup = $nttree . "\\srvinf\\txtsetup.sif";
       $EntTxtsetup = $nttree . "\\entinf\\txtsetup.sif";
       $DtcTxtsetup = $nttree . "\\dtcinf\\txtsetup.sif";


       $BigLayout    = $nttree . "\\layout.inf";
       $PerLayout  = $nttree . "\\perinf\\layout.inf";
       $BlaLayout  = $nttree . "\\blainf\\layout.inf";
       $SbsLayout  = $nttree . "\\sbsinf\\layout.inf";
       $SrvLayout  = $nttree . "\\srvinf\\layout.inf";
       $EntLayout  = $nttree . "\\entinf\\layout.inf";
       $DtcLayout  = $nttree . "\\dtcinf\\layout.inf";       


       $BigDosnet_sign = $nttree . "\\realsign\\dosnet.inf";
       $PerDosnet_sign = $nttree . "\\perinf\\realsign\\dosnet.inf";
       $BlaDosnet_sign = $nttree . "\\blainf\\realsign\\dosnet.inf";
       $SbsDosnet_sign = $nttree . "\\sbsinf\\realsign\\dosnet.inf";
       $SrvDosnet_sign = $nttree . "\\srvinf\\realsign\\dosnet.inf";
       $EntDosnet_sign = $nttree . "\\entinf\\realsign\\dosnet.inf";
       $DtcDosnet_sign = $nttree . "\\dtcinf\\realsign\\dosnet.inf";

       $BigTxtsetup_sign = $nttree . "\\realsign\\txtsetup.sif";
       $PerTxtsetup_sign = $nttree . "\\perinf\\realsign\\txtsetup.sif";
       $BlaTxtsetup_sign = $nttree . "\\blainf\\realsign\\txtsetup.sif";
       $SbsTxtsetup_sign = $nttree . "\\sbsinf\\realsign\\txtsetup.sif";
       $SrvTxtsetup_sign = $nttree . "\\srvinf\\realsign\\txtsetup.sif";
       $EntTxtsetup_sign = $nttree . "\\entinf\\realsign\\txtsetup.sif";
       $DtcTxtsetup_sign = $nttree . "\\dtcinf\\realsign\\txtsetup.sif";


       $BigLayout_sign    = $nttree . "\\realsign\\layout.inf";
       $PerLayout_sign  = $nttree . "\\perinf\\realsign\\layout.inf";
       $BlaLayout_sign  = $nttree . "\\blainf\\realsign\\layout.inf";
       $SbsLayout_sign  = $nttree . "\\sbsinf\\realsign\\layout.inf";
       $SrvLayout_sign  = $nttree . "\\srvinf\\realsign\\layout.inf";
       $EntLayout_sign  = $nttree . "\\entinf\\realsign\\layout.inf";
       $DtcLayout_sign  = $nttree . "\\dtcinf\\realsign\\layout.inf";        

       # PRO
       $Path_Dosnet    =$BigDosnet;
       $Path_Txtsetup  =$BigTxtsetup;
       $Path_Layout     =$BigLayout;
       $Path_Dir          ="ProInf";
       $Path_Dosnet_sign    =$BigDosnet_sign;
       $Path_Txtsetup_sign  =$BigTxtsetup_sign;
       $Path_Layout_sign     =$BigLayout_sign;
       $Path_Dir_sign          ="ProInf\\realsign";       
       $INFPathSKUs{"PRO"} = [ ($Path_Dosnet,$Path_Txtsetup,$Path_Layout,$Path_Dir, $Path_Dosnet_sign,$Path_Txtsetup_sign,$Path_Layout_sign,$Path_Dir_sign) ];

       #PER
       $Path_Dosnet   =$PerDosnet;
       $Path_Txtsetup =$PerTxtsetup;
       $Path_Layout    =$PerLayout;
       $Path_Dir         ="PerInf";
       $Path_Dosnet_sign   =$PerDosnet_sign;
       $Path_Txtsetup_sign =$PerTxtsetup_sign;
       $Path_Layout_sign    =$PerLayout_sign;
       $Path_Dir_sign         ="PerInf\\realsign";             
       $INFPathSKUs{"PER"} = [ ($Path_Dosnet,$Path_Txtsetup,$Path_Layout,$Path_Dir, $Path_Dosnet_sign,$Path_Txtsetup_sign,$Path_Layout_sign,$Path_Dir_sign) ];

       #SRV
       $Path_Dosnet   =$SrvDosnet;
       $Path_Txtsetup =$SrvTxtsetup;
       $Path_Layout    =$SrvLayout;
       $Path_Dir         ="SrvInf";   
       $Path_Dosnet_sign   =$SrvDosnet_sign;
       $Path_Txtsetup_sign =$SrvTxtsetup_sign;
       $Path_Layout_sign    =$SrvLayout_sign;
       $Path_Dir_sign         ="SrvInf\\realsign";        
       $INFPathSKUs{"SRV"} = [ ($Path_Dosnet,$Path_Txtsetup,$Path_Layout,$Path_Dir, $Path_Dosnet_sign,$Path_Txtsetup_sign,$Path_Layout_sign,$Path_Dir_sign) ];

       #BLA
       $Path_Dosnet   =$BlaDosnet;
       $Path_Txtsetup =$BlaTxtsetup;
       $Path_Layout    =$BlaLayout;
       $Path_Dir         ="BlaInf";       
       $Path_Dosnet_sign   =$BlaDosnet_sign;
       $Path_Txtsetup_sign =$BlaTxtsetup_sign;
       $Path_Layout_sign    =$BlaLayout_sign;
       $Path_Dir_sign         ="BlaInf\\realsign";        
       $INFPathSKUs{"BLA"} = [ ($Path_Dosnet,$Path_Txtsetup,$Path_Layout,$Path_Dir, $Path_Dosnet_sign,$Path_Txtsetup_sign,$Path_Layout_sign,$Path_Dir_sign) ];
       
       #SBS
       $Path_Dosnet   =$SbsDosnet;
       $Path_Txtsetup =$SbsTxtsetup;
       $Path_Layout    =$SbsLayout;
       $Path_Dir         ="SbsInf";       
       $Path_Dosnet_sign    =$SbsDosnet_sign ;
       $Path_Txtsetup_sign  =$SbsTxtsetup_sign ;
       $Path_Layout_sign     =$SbsLayout_sign ;
       $Path_Dir_sign          ="SbsInf\\realsign";        
       $INFPathSKUs{"SBS"} = [ ($Path_Dosnet,$Path_Txtsetup,$Path_Layout,$Path_Dir, $Path_Dosnet_sign,$Path_Txtsetup_sign,$Path_Layout_sign,$Path_Dir_sign) ];

       #ADS (ENT)
       $Path_Dosnet   =$EntDosnet;
       $Path_Txtsetup =$EntTxtsetup;
       $Path_Layout    =$EntLayout;
       $Path_Dir         ="EntInf";       
       $Path_Dosnet_sign   =$EntDosnet_sign;
       $Path_Txtsetup_sign =$EntTxtsetup_sign;
       $Path_Layout_sign    =$EntLayout_sign;
       $Path_Dir_sign         ="EntInf\\realsign";
       $INFPathSKUs{"ADS"} = [ ($Path_Dosnet,$Path_Txtsetup,$Path_Layout,$Path_Dir, $Path_Dosnet_sign,$Path_Txtsetup_sign,$Path_Layout_sign,$Path_Dir_sign) ]; 

       #DTC
       $Path_Dosnet   =$DtcDosnet;
       $Path_Txtsetup =$DtcTxtsetup;
       $Path_Layout    =$DtcLayout;
       $Path_Dir         ="DtcInf";       
       $Path_Dosnet_sign   =$DtcDosnet_sign;
       $Path_Txtsetup_sign =$DtcTxtsetup_sign;
       $Path_Layout_sign    =$DtcLayout_sign;
       $Path_Dir_sign         ="DtcInf\\realsign";
       $INFPathSKUs{"DTC"} = [ ($Path_Dosnet,$Path_Txtsetup,$Path_Layout,$Path_Dir, $Path_Dosnet_sign,$Path_Txtsetup_sign,$Path_Layout_sign,$Path_Dir_sign) ];    


       return 1;
       
}      
 
