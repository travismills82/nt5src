#ifndef __FILEPARSER_HPP__
#define __FILEPARSER_HPP__
/*---------------------------------------------------------------------------
  File: FileParser.hpp

  Comments: Classes to parse text files generated by the Domain Admin dispatcher and agent.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/26/99 15:16:31

 ---------------------------------------------------------------------------
*/

#include "Common.hpp"
#include "UString.hpp"
#include "EaLen.hpp"
#include "ServList.hpp"




#define AR_Status_Created           (0x00000001)
#define AR_Status_Replaced          (0x00000002)
#define AR_Status_AlreadyExisted    (0x00000004)
#define AR_Status_RightsUpdated     (0x00000008)
#define AR_Status_DomainChanged     (0x00000010)
#define AR_Status_Rebooted          (0x00000020)
#define AR_Status_Warning           (0x40000000)
#define AR_Status_Error             (0x80000000)


class TFileParser
{
protected:
   FILE                    * m_pFile;
   WCHAR                     m_filename[MAX_PATH];
   BOOL                      m_bValidData;        
public:
   TFileParser()
   {
      m_filename[0] = 0;
      m_pFile = NULL;
      m_bValidData = FALSE;
   }
   ~TFileParser()
   {
      if ( m_pFile )
         fclose(m_pFile);
   }

   BOOL Open(WCHAR const * filename)
   {
      safecopy(m_filename,filename);
      
      if ( *m_filename )
      {
         m_pFile = _wfopen(m_filename,L"rb");
      }
      else
      {
         m_pFile = 0;
      }
   
      return ( m_pFile != 0 );
   }

   BOOL IsOpen() { return ( m_pFile != 0 ); }
   void Close() { if ( m_pFile ) { fclose(m_pFile); m_pFile = NULL; } }
   BOOL IsEof() { return m_pFile ? feof(m_pFile) : TRUE; }
   BOOL Restart() 
   { 
      BOOL                   bRc = FALSE;
      if ( m_pFile ) 
      { 
         bRc = ( fseek(m_pFile,0,SEEK_SET) == 0 );
      }
      return bRc;
   }
   virtual BOOL ScanEntry() = 0;
};

class TErrorLogParser:public TFileParser
{
   int                       m_Severity;
   int                       m_SourceLine;         // 
   WCHAR                     m_Timestamp[100];     // the timestamp of the entry
   WCHAR                     m_Message[1000];      // the message text part of the entry
   WCHAR                     m_strBuf[1000];       // a line from the log file
public:                                         
   virtual BOOL ScanEntry() 
   { 
      MCSASSERT(m_pFile);
      m_bValidData = FALSE;
      if ( m_pFile && fgetws(m_strBuf,1000,m_pFile) )
      {
         m_bValidData = ScanFileEntry(m_strBuf,m_Timestamp,&m_Severity,&m_SourceLine,m_Message);
            
      }
      return m_bValidData;
   }
   
   int GetSeverity() { MCSASSERT(m_bValidData); return m_Severity; }
   int GetSourceLine() { MCSASSERT(m_bValidData); return m_SourceLine; }
   WCHAR const * GetTimestamp() { MCSASSERT(m_bValidData); return m_Timestamp; }
   WCHAR const * GetMessage() { MCSASSERT(m_bValidData); return m_Message; }
protected:
   BOOL 
   ScanFileEntry(
      WCHAR                * string,      // in - line from TError log file
      WCHAR                * timestamp,   // out- timestamp from this line
      int                  * pSeverity,   // out- severity level of this message
      int                  * pSourceLine, // out- the source line for this message
      WCHAR                * msgtext      // out- the textual part of the message
   );

};

void ParseInputFile(WCHAR const * gLogFile);

void 
   ReadResults(
      TServerNode          * pServer,
      WCHAR          const * directory,
      WCHAR          const * filename,
      WCHAR          const * dbName
   );


#endif //__FILEPARSER_HPP__