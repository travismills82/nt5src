//Copyright (c) 1998 - 2001 Microsoft Corporation

#ifndef _WIN32_WINNT
#define _WIN32_WINNT	0x0500
#endif
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <tchar.h>
#include "DigPid1.h"
#include "PidGen.h"
#include "ValidDP.h"
#include "LicenseCodeLite.h"
#include "SequenceRanges.h"

#define GROUP12TXT		_TEXT("06")
#define GROUP14TXT      _TEXT("07")
#define GROUP0TXT		_TEXT("00")


DWORD GetLCProductType(TCHAR * tcLicenceCode, TCHAR ** tcProductType, DWORD * dwGroupID)
{
	BOOL fOk = false;				// success flag
	TCHAR *pszMpc= _TEXT("12345");	// 5 numeral Microsoft Product Code
	TCHAR szPid2[32];				// Microsoft Product ID
	BYTE abPid3[DIGITALPIDMAXLEN];	// new Digital Product ID
	DWORD dwSeq = 0;				// 9 digit sequence number
	BOOL fOEM = FALSE;				// [IN] Is this an OEM Product Key, default to Retail
	BOOL fCCP = FALSE;				// [OUT] Compliance Checking Product (Is upgrade?)
	DWORD dwPge;					// PidGenError
	DWORD dwSearchLoop;
	TCHAR * tcGroupId;
	DWORD dwRetVal = ERROR_SUCCESS;

	szPid2[0] = _TEXT('\0');

		// Must set the first DWORD of abPid3 to the total length of the
		// buffer.  On return the first DWORD will be set the the length
		// actually used.

	*(LPDWORD)abPid3 = sizeof(abPid3);

		// Both Unicode and ANSI versions of PIDGenSimp are supported
#ifdef UNICODE
		// return value is a PidGenError (see PidGen.h)
	dwPge = PIDGenStatic(
			tcLicenceCode,	// [IN] 25-character Secure CD-Key (gets U-Cased)
			pszMpc,			// [IN] 5-character Microsoft Product Code
			L"",			// [IN] Stock Keeping Unit (formatted like 123-12345)
			NULL,			// [IN] 4-character OEM ID or NULL
			NULL,			// [IN] pointer to optional public key or NULL
			0,				// [IN] byte length of optional public key
			0,				// [IN] key pair index optional public key
			fOEM,			// [IN] is this an OEM install?

			szPid2,			// [OUT] PID 2.0, pass in ptr to 24 character array
			abPid3,			// [IN/OUT] pointer to binary PID3 buffer.
			&dwSeq,			// [OUT] optional ptr to sequence number (can be NULL)
			NULL);			// [OUT] ptr to Compliance Checking flag or NULL
#else
		// return value is a PidGenError (see PidGen.h)
	dwPge = PIDGenStatic(
			tcLicenceCode,	// [IN] 25-character Secure CD-Key (gets U-Cased)
			pszMpc,			// [IN] 5-character Microsoft Product Code
			"",				// [IN] Stock Keeping Unit (formatted like 123-12345)
			NULL,			// [IN] 4-character OEM ID or NULL
			fOEM,			// [IN] is this an OEM install?

			szPid2,			// [OUT] PID 2.0, pass in ptr to 24 character array
			abPid3,			// [IN/OUT] pointer to binary PID3 buffer.
			&dwSeq,			// [OUT] optional ptr to sequence number (can be NULL)
			NULL);			// [OUT] ptr to Compliance Checking flag or NULL
#endif

	if (pgeSuccess != dwPge)
	{
		dwRetVal = INVALID_PRODUCT_KEY;
		goto done;
	}

	//Using the PID2 object generated by PIDGen determine the GroupID
	//The ValidDP12.lib provides the PIDGen interface and is configured for only Group 12 and 0.
	tcGroupId = szPid2+18;

	if (!_tcsncmp( tcGroupId, GROUP12TXT, 2 ))
	{
		*dwGroupID = 12;
	} 
	else if (!_tcsncmp( tcGroupId, GROUP0TXT, 2 ))
	{
		*dwGroupID = 0;
	}
    else if(!_tcsncmp( tcGroupId, GROUP14TXT, 2 ))
    {
        *dwGroupID = 14;
    }
	else
	{
		*dwGroupID = -1;
		dwRetVal = INVALID_GROUP_ID;
		goto done;
	}


	//Check if the sequence number falls into one of the predefined product type ranges.
	for (dwSearchLoop = 0; dwSearchLoop < RANGE_SIZE; dwSearchLoop++)
	{
		if (g_ProductTypeRanges[dwSearchLoop].dwRangeStart <= dwSeq &&
			g_ProductTypeRanges[dwSearchLoop].dwRangeEnd >= dwSeq)
		{
			*tcProductType = g_ProductTypeRanges[dwSearchLoop].szProductType;
			fOk = true;	
			break;
		}
	}
	if (!fOk)
		dwRetVal = INVALID_SERIAL_NUMBER;

done:

	return dwRetVal;

}