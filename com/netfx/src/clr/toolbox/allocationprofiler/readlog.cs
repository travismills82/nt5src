// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace AllocationProfiler
{
    using System;
	using System.IO;
	using System.Collections;

    /// <summary>
    ///    Summary description for ReadLog.
    /// </summary>
    public class ReadLog
    {
		Graph	graph;
        public ReadLog(Graph graph)
        {
			this.graph = graph;
        }

		static bool IsStackTraceLine(String s)
		{
			int inx = s.IndexOf("    ");
			return inx >= 8 && inx <= 12;
		}

		public void Readfile(String filename)
		{
			StreamReader r = new StreamReader(filename);
			String curLine;
			ArrayList traceList = new ArrayList();
			curLine = r.ReadLine();
			while	(curLine != null)
			{
				if	(curLine.IndexOf("Allocated") >= 0)
				{
					// Remove stuff we don't want from the allocated line
					curLine = curLine.Substring(curLine.IndexOf("Allocated") + "Allocated".Length);
					String [] curItems = curLine.Split(null);

					// first squeeze out any empty items generated by multiple separators
					int i;
					int itemCount = 0;
					for (i = 0; i < curItems.Length; i++)
					{
						if (curItems[i].Length > 0)
						{
							curItems[itemCount++] = curItems[i];
						}
					}
					for (i = itemCount; i < curItems.Length; i++)
					{
						curItems[i] = null;
					}

					int size = 0;
					i = 0;

					// if there's "REF_TYPE", skip it
					if (curItems[i] == "REF_TYPE")
					{
						i++;
					}

					// if there's the hex address of the object, skip it
					if (   curItems[i].Length >= 2
						&& curItems[i][0] == '0'
						&& curItems[i][1] == 'x')
					{
						i++;
					}

					if (curItems[i].Length > 0 && System.Char.IsDigit(curItems[i][0]))
					{
						size = Int32.Parse(curItems[i]);
						i++;
					}

					if (curItems[i] == "bytes")
					{
						i++;
					}

					if (curItems[i] == "for")
					{
						i++;
					}
					
					traceList.Clear();

					traceList.Add(curItems[i]);

					// Read the stack trace lines and append them to the trace list
					while	((curLine = r.ReadLine()) != null)
					{
						if (curLine.Equals(""))
							continue;
						if (curLine.IndexOf("EE Frame") >= 0)
							continue;
						if (curLine.IndexOf("Allocated") >= 0)
							break;
						int indentInx = curLine.IndexOf("     ");
						if (indentInx < 0 || indentInx > 12)
							break;
						curLine = curLine.Substring(indentInx + 5);
						curLine = curLine.Split(null, 2)[0];
						traceList.Add(curLine);
					}

					AddTrace(traceList, size);
				}
				else
					curLine = r.ReadLine();
			}
		}

		public void AddTrace(ArrayList trace, int weight)
		{
			for (int i = trace.Count; i >= 0; i--)
			{
				string fromVertex = i < trace.Count ? (string)trace[i] : "<root>";
				string toVertex   = i - 1 >= 0 ? (string)trace[i - 1 ] : "<bottom>";
				AddEdge(fromVertex, toVertex, weight);
			}
		}

		public void AddEdge(string fromVertexString, string toVertexString, int weight)
		{
			Vertex fromVertex = graph.FindOrCreateVertex(fromVertexString, null);
			Vertex toVertex = graph.FindOrCreateVertex(toVertexString, null);
			Edge edge = graph.FindOrCreateEdge(fromVertex, toVertex);
			edge.AddWeight(weight);
		}
	}
}
