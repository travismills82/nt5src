// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// CGENSHX.H -
//
// Various helper routines for generating alpha assembly code.
//
// 

#ifndef _SH3_
#error Should only include cgenshx.h for SHx builds
#endif


#ifndef _CGENSHX_H_
#define _CGENSHX_H_

#include "stublink.h"

// default return value type
typedef INT32 PlatformDefaultReturnType;

// Implemented in STUBSHX.SRC
extern "C" void __cdecl PreStubTemplate(void);
// BUGBUG--ARULM: We're not correctly supporting 64-bit return values yet!! TODO--ARULM
extern "C" INT32 __cdecl CallWorker_WilDefault(const BYTE  *pStubTarget, UINT32 numArgSlots, PCCOR_SIGNATURE pSig, 
                                               Module *pmodule, const BYTE  *pArgsEnd, BOOL fIsStatic);
extern "C" INT32 __cdecl CallDllFunction(LPVOID pTarget, LPVOID pEndArguments, UINT32 numArgumentSlots, BOOL fThisCall);
#ifdef DEBUG
extern "C" void __stdcall WrapCall(void *target);
#endif

// Implemented in CGENSHX.CPP
extern "C" void CopyPreStubTemplate(Stub *preStub);

// Non-CPU-specific helper functions called by the CPU-dependent code in STUBSHX.SRC
extern "C" VOID __stdcall ArgFiller_WilDefault(BOOL fIsStatic, PCCOR_SIGNATURE pSig, Module *pmodule, BYTE *psrc, BYTE *pdst);
extern "C" const BYTE * __stdcall PreStubWorker(PrestubMethodFrame *pPFrame);

// Non-CPU-specific helper functions called by the CPU-dependent code generated by CGENSHX.CPP
// BUGBUG--ARULM: We're not correctly supporting 64-bit return values yet!! TODO--ARULM
extern "C" INT32 __stdcall NDirectGenericStubWorker(Thread *pThread, NDirectMethodFrame *pFrame);
extern "C" INT32 __stdcall ComPlusToComWorker(Thread *pThread, ComPlusMethodFrame* pFrame);
VOID OnStubObjectTripThread();
VOID OnStubScalarTripThread();

// required alignment for data
#define DATA_ALIGNMENT 4

inline void getFPReturn(BYTE rt, INT64 retval)
{
    // @TODO SH4 (SH3 doesn't need anything)
}
inline void getFPReturnSmall(INT32 *retval)
{
    // @TODO SH4 (SH3 doesn't need anything)
}
inline void setFPReturn(BYTE rt, INT64 retVal)
{
    // @TODO SH4 (SH3 doesn't need anything)
}

class StubLinkerSHX : public StubLinker
{
  public:
    VOID SHXEmitCurrentThreadFetch();   
    VOID EmitMethodStubProlog(LPVOID pFrameVptr);
    VOID EmitECallMethodStub(__int16 numargbytes, StubStyle style); 
    void CreateNDirectOrComPlusStubBody(LPVOID pfnHelper, BOOL fRequiresCleanup);   
    VOID EmitMethodStubEpilog(__int16 numargbytes, StubStyle style, 
                              __int16 shadowStackArgBytes = 0);


    //===========================================================================
    // Emits code to adjust for a static delegate target.
    VOID EmitShuffleThunk(struct ShuffleEntry *pShuffeEntryArray)
    {
        //@todo: implement.
    }


    //===========================================================================
    // Emits code for MulticastDelegate.Invoke()
    VOID EmitMulticastInvoke(UINT32 sizeofactualfixedargstack, BOOL fSingleCast, BOOL fReturnFloat)
    {
        //@todo: implement.
    }
};

//----------------------------------------------------------------------
// Method Stub and Align Defines....
//----------------------------------------------------------------------
//
// The StubCall we insert at the starts of each Function Desc consists of
//      MOV.L   @(4, PC), R1    ; load stub address from just below 
//      MOVA    @(8, PC), R0    ; move MethodDesc address to R0 for stub    
//      JMP     @R1             ; jump to it (don't call or we'll trash PR) 
//      NOP                     ; branch delay & also dword-align   
//      .data.l <stub address>  ; 4-byte stub absolute address  

struct StubCallInstrs {
    WORD    mov1;   
    WORD    mov2;   
    WORD    jmp;    
    WORD    nop;    
    DWORD   stubaddr;   
};

#define METHOD_CALL_PRESTUB_SIZE    sizeof(StubCallInstrs) 
#define METHOD_PREPAD               METHOD_CALL_PRESTUB_SIZE   // # extra bytes to allocate in addition to sizeof(Method)
#define METHOD_ALIGN                1 // required alignment for StubCallInstrs


//**********************************************************************
// Parameter size
//**********************************************************************

#define NATIVE_STACK_ELEM_SIZE      4   

typedef INT32 StackElemType;
#define STACK_ELEM_SIZE sizeof(StackElemType)

void SetupSlotToAddrMap(StackElemType *psrc, const void **pArgSlotToAddrMap, CallSig &callSig);

// !! This expression assumes STACK_ELEM_SIZE is a power of 2.
#define StackElemSize(parmSize) (((parmSize) + STACK_ELEM_SIZE - 1) & ~((ULONG)(STACK_ELEM_SIZE - 1)))

// Get address of actual arg within widened arg
#define ArgTypeAddr(stack, type)      ((type *) ((BYTE*)stack + StackElemSize(sizeof(type)) - sizeof(type)))    

// Get value of actual arg within widened arg
#define ExtractArg(stack, type)   (*(type *) ((BYTE*)stack + StackElemSize(sizeof(type)) - sizeof(type)))   

#define CEE_PARM_SIZE(size) (max(size), sizeof(INT32))
#define CEE_SLOT_COUNT(size) ((max(size), sizeof(INT32))/INT32)

#define DECLARE_ECALL_DEFAULT_ARG(vartype, varname)   \
    vartype varname;    

#define DECLARE_ECALL_OBJECTREF_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);    

#define DECLARE_ECALL_PTR_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);    

#define DECLARE_ECALL_I1_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_I2_ARG(vartype, varname)   \
    vartype varname;    

#define DECLARE_ECALL_I4_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);    

#define DECLARE_ECALL_R4_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);    

#define DECLARE_ECALL_I8_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);    

#define DECLARE_ECALL_R8_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);    


//**********************************************************************
// Frames
//**********************************************************************

//--------------------------------------------------------------------
// This represents the TransitionFrame fields that are
// stored at negative offsets.
//--------------------------------------------------------------------
struct CalleeSavedRegisters {
// SHx saves 7 registers
    INT32       reg1;
    INT32       reg2;
    INT32       reg3;
    INT32       reg4;
    INT64       reg5;
    INT64       reg6;
    INT64       reg7;
};

#define ARGUMENTREGISTERS_SIZE 0


#define PLATFORM_FRAME_ALIGN(val) (val)

#define VC5FRAME_SIZE   0   


#define DECLARE_PLATFORM_FRAME_INFO \
    UINT32      m_eip;              \
    UINT32      m_esp;              \
    UINT32 *getIPSaveAddr() {       \
        return &m_eip;              \
    }                               \
    UINT32 *getSPSaveAddr() {       \
        return &m_esp;              \
    }                               \
    UINT32 getIPSaveVal() {         \
        return m_eip;               \
    }                               \
    UINT32 getSPSaveVal() {         \
        return m_esp;               \
    }   

//**********************************************************************
// Exception handling
//**********************************************************************

inline LPVOID GetIP(CONTEXT *context) {
    return (LPVOID)(context->Fir);
}

inline void SetIP(CONTEXT *context, LPVOID eip) {
    context->Fir = (UINT32)eip;
}

inline LPVOID GetSP(CONTEXT *context) {
    _ASSERTE(!"nyi");
}

inline BYTE *getStubCallAddr(MethodDesc *fd) {
    return ((BYTE*)fd) - METHOD_CALL_PRESTUB_SIZE;
}

inline const BYTE *getStubAddr(MethodDesc *fd) {
    // The stub address is located in the last DWORD before the the MethodDesc  
    // Note on SHX this is now an *absolute* address    
    return (LPBYTE) (*(((DWORD*)fd)-1));
}

inline UINT32 getStubDisp(MethodDesc *fd) {
    return getStubAddr(fd) - (const BYTE*)fd;
}

inline UINT32 setStubAddrInterlocked(MethodDesc *pFD, UINT32 stubAddr) {
    // The offset must be 32-bit aligned for atomicity to be guaranteed.
    _ASSERTE( 0 == (((UINT32)pFD) & 3) );
    // The stub address is located in the last DWORD before the the MethodDesc  
    // Note on SHX this is now an *absolute* address    
    return InterlockedExchange((PLONG)(((DWORD*)pFD)-1), stubAddr);
}

inline Stub *setStubCallPointInterlocked(MethodDesc *pFD, Stub *pStub) {
    BYTE *prevAddr = (BYTE *) setStubAddrInterlocked(pFD, (UINT32)pStub->GetEntryPoint());    
    return Stub::RecoverStub(prevAddr);
}

inline void emitStubCall(MethodDesc *pFD, BYTE *stubAddr) {
    WORD *target = (WORD*)getStubCallAddr(pFD);
    _ASSERTE(0 == (((UINT32)pFD) & 3));
    _ASSERTE(0 == (((UINT32)target) & 3));
    target[0] = 0xD101; // MOV.L @(4, PC), R1   ; load stub address from just below 
    target[1] = 0xC702; // MOVA  @(8, PC), R0   ; move MethodDesc address to R0 for stub    
    target[2] = 0x412B; // JMP   @R1            ; jump to it (don't call or we'll trash PR) 
    target[3] = 0x0009; // NOP                  ; branch delay & also dword-align   
    setStubAddrInterlocked(pFD, stubAddr);  
}



inline void emitCall(LPBYTE pBuffer, LPVOID target)
{
    _ASSERTE(!"NYI");
}

inline LPVOID getCallTarget(const BYTE *pCall)
{
    _ASSERTE(!"NYI");
    return NULL;
}


// Used for Marshalling Language (RunML function)

typedef INT32 SignedParmSourceType;
typedef UINT32 UnsignedParmSourceType;
typedef float FloatParmSourceType;
typedef double DoubleParmSourceType;
typedef INT32 SignedI1TargetType;
typedef UINT32 UnsignedI1TargetType;
typedef INT32 SignedI2TargetType;
typedef UINT32 UnsignedI2TargetType;
typedef INT32 SignedI4TargetType;
typedef UINT32 UnsignedI4TargetType;



#define PTRDST(type)            ((type*)( ((BYTE*&)pdst) -= sizeof(LPVOID) ))

#define STDST(type,val)         (*((type*)( ((BYTE*&)pdst) -= sizeof(type) )) = (val))


#define STPTRDST(type, val) STDST(type, val)    
#define LDSTR4()                STDST(UINT32, (UINT32)LDSRC(UnsignedParmSourceType))    
#define LDSTR8()                STDST(UNALIGNED UINT64, LDSRC(UNALIGNED UINT64))    


inline MLParmSize(int parmSize)
{
    return ((parmSize + sizeof(INT32) - 1) & ~((ULONG)(sizeof(INT32) - 1)));
}


// Routines used by debugger support functions such as codepatch.cpp or
// exception handling code.
//

inline unsigned short CORDbgGetInstruction(const unsigned char* address)
{
    // SHX instructions are all 2-bytes
    return *((unsigned short*)address);
}

inline void CORDbgInsertBreakpoint(const unsigned char* address)
{
    // insert: trapa #00000001
    *(unsigned short *) (address) = 0xC301;
}

inline void CORDbgSetInstruction(const unsigned char* address,
                                 unsigned short instruction)
{
    // SHX instructions are all 2-bytes
    *((unsigned short*)address) = instruction;
}

inline void CORDbgAdjustPCForBreakInstruction(CONTEXT* pContext)
{
    // @todo: implement for SHX. This may be a no-op on SHX.
}

#define CORDbg_BREAK_INSTRUCTION_SIZE 2


// Some platform-specific stuff in support of the "Contexts" feature:
//
// When we generate thunks for CtxProxy VTables, they look something like:
//
//  MOV.L   @(, PC), R1 ; load address of CtxProxy::HandleCall from just below  
//  MOV.W   @(, PC), R0 ; load slot number from below that  
//  JMP     @R1         ; jump to it    
//  NOP                 ; delay slot & dword align  
//  .data.  <CtxProxy::HandleCall>  ; absolute address of CtxProxy::HandleCall  
//  .data.l <slot number>   ; 4-byte stub absolute address  
//
// Total is (unfortunately) 16 bytes

#define ThunkChunk_ThunkSize    16      // size of the above code.


// Adjust the generic interlocked operations for any platform specific ones we
// might have.
void InitFastInterlockOps();


VOID __cdecl RareDisableHelper(Thread *pThread)
{
    _ASSERTE(!"NYI");
}

inline BOOL IsUnmanagedValueTypeReturnedByRef(UINT sizeofvaluetype) 
{
	return TRUE;
}

inline BOOL IsManagedValueTypeReturnedByRef(UINT sizeofvaluetype) 
{
	return TRUE;
}



#endif _CGENSHX_H_

