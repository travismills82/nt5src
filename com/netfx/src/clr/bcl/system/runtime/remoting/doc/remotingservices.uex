<docs>
	<doc for="RemotingServices.LogRemotingStage">
		<nodoc/>
		<summary>
			<para>Public reserved method, for internal use only.</para>
		</summary>
	</doc><doc for="InternalRemotingServices"><nodoc/>
		<summary>
			<para>Reserved class for internal use only.</para>
		</summary>
	</doc><doc for="InternalRemotingServices.DebugOutChnl"><nodoc/>
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc><doc for="InternalRemotingServices.RemotingTrace"><nodoc/>
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc><doc for="InternalRemotingServices.RemotingAssert"><nodoc/>
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc><doc for="InternalRemotingServices.SetServerIdentity"><nodoc/>
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc><doc for="InternalRemotingServices.GetCachedSoapAttribute"><nodoc/>
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc><doc for="RemotingServices">
		<summary>
			<para> Provides several methods for using and publishing remoted objects and proxies. This class cannot be
      inherited.</para>
		</summary>
		<remarks>
			<para>Unless you are a service provider dealing with issues such as activation,
      lifetime management, or transactions, you do not need to distinguish between
      proxy references and object references. The remoting infrastructure
      uses transparent proxies that give the impression that the remote objects
      reside in the client's space. Proxies achieve this by forwarding calls
      made on them to the real objects at remote locations.</para>
		</remarks>
	</doc><doc for="RemotingServices.IsTransparentProxy">
		<summary>
			<para> Returns a Boolean value indicating whether the given
      object
      is a transparent proxy or a real object.</para>
		</summary>
		<param name="proxy">The reference to the object to check.</param>
		<returns>
			<para>A Boolean value indicating whether the object specified
      in the <paramref name="proxy "/>parameter is a transparent
      proxy or a real object.</para>
		</returns>
		<remarks>
			<para>A client that uses an object across any kind of a remoting boundary is
      actually using a transparent proxy for the object. The transparent proxy
      gives the impression that the actual object resides in the client's space. It
      achieves this by forwarding calls made on it to the real object using the
      remoting infrastructure. </para>
			<para>The transparent proxy is itself housed by an instance of a managed runtime
      class of type <see cref="System.Runtime.Remoting.Proxies.RealProxy"/>. The <see cref="System.Runtime.Remoting.Proxies.RealProxy"/> implements
      a part of the functionality needed to forward the operations from
      the transparent proxy. A proxy object inherits the associated semantics of managed objects such
      as garbage collection, support for fields and methods, and can be extended to
      form new classes. Thus the proxy has a dual nature; on the one hand it needs to act as
      an object of the same class as the remote object (transparent proxy), and on the
      other it is a managed object itself. </para>
			<para>A proxy object can be used without regard to any
      remoting subdivisions within an <see cref="System.AppDomain"/>. Applications need not
      distinguish between proxy references and object references. However, service
      providers dealing with issues such as activation, lifetime management, and transactions need to
      make such distinctions. </para>
		</remarks>
		<example>
			<para>The following example demonstrates the
      use of the <see cref="System.Runtime.Remoting.RemotingServices.IsTransparentProxy"/> method to determine
      whether an object is a proxy or a real object. For the complete example
      code, see the example for the <see cref="System.Runtime.Remoting.Messaging.AsyncResult"/> class.</para>
			<codelink SampleID="AsyncResult.NewExamples" SnippetID="6"/>
		</example>
		<seealso cref="T:System.Runtime.Remoting.Proxies.RealProxy"/>
		<seealso cref="T:System.Runtime.Remoting.ObjRef"/>
	</doc><doc for="RemotingServices.IsObjectOutOfContext">
		<summary>
			<para>Returns a Boolean value indicating whether the object
      represented by the given proxy is contained in a different context than the object
      that called the current method.</para>
		</summary>
		<param name="tp">The object to check.</param>
		<returns>
			<para><see langword="true "/>if
   the object is out of the current
   context; otherwise, <see langword="false"/>.</para>
		</returns>
		<remarks>
			<para>A context is an ordered sequence of properties that
      define an environment for the objects that reside inside it. Contexts are created
      during the activation process for objects that are configured to require certain
      automatic services such synchronization, transactions, just-in-time activation,
      security, and so on. Multiple objects can live inside a context.</para>
		</remarks>
		<example>
			<codelink SampleID="RemotingServices IsObject Snippets" SnippetID="1"/>
		</example>
		<seealso cref="System.Runtime.Remoting.Contexts.Context"/>
	</doc><doc for="RemotingServices.IsObjectOutOfAppDomain">
		<summary>
			<para>Returns a Boolean value indicating whether the object specified by the given transparent proxy is
      contained in a different AppDomain than the object that called the current
      method.</para>
		</summary>
		<param name="tp">The object to check.</param>
		<returns>
			<para><see langword="true"/> if the object is out of the current
   AppDomain; otherwise, <see langword="false"/>.
   </para>
		</returns>
		<remarks>
			<para>For information on AppDomains see <see topic="cpconApplicationDomains"/>.</para>
		</remarks>
		<example>
			<codelink SampleID="RemotingServices IsObject Snippets" SnippetID="1"/>
		</example>
		<seealso topic="cpconApplicationDomains"/>
	</doc><doc for="RemotingServices.GetRealProxy">
		<summary>
			<para>Returns the real proxy backing the specified transparent proxy.</para>
		</summary>
		<param name="proxy">A transparent proxy.</param>
		<returns>
			<para> The real proxy instance backing the transparent proxy.</para>
		</returns>
		<remarks>
			<para> A client that uses an object across any kind of remoting boundary is
      actually using a transparent proxy for the object. The transparent proxy
      gives the impression that the actual object resides in the client's space. It
      achieves this by forwarding calls made on it to the real object using the
      remoting infrastructure. </para>
			<para> The transparent proxy is backed by an instance of a managed runtime
      class of type <see cref="System.Runtime.Remoting.Proxies.RealProxy"/>. The <see cref="System.Runtime.Remoting.Proxies.RealProxy"/>
      
      implements a part of the functionality needed to forward the operations
      from the transparent proxy. Note that a proxy object inherits the associated semantics
      of managed objects such as garbage collection, support for fields and methods, and can be extended to form new
      classes. The proxy acts as an object of the same class as the remote object (transparent
      proxy), and is also a managed object. </para>
		</remarks>
		<exception cref="System.Security.SecurityException">The immediate caller does not have infrastructure permission.</exception>
		<permission cref="System.Security.Permissions.SecurityPermission">for operating with infrastructure code. Demand value: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.Infrastructure" qualify="true"/></permission>
		<seealso cref="T:System.Runtime.Remoting.Proxies.RealProxy"/>
		<seealso cref="T:System.Runtime.Remoting.ObjRef"/>
	</doc>
	<doc for="RemotingServices.GetSessionIdForMethodMessage">
		<summary>
			<para>Retrieves a session ID for a message.</para>
		</summary>
		<param name="msg">The <see cref="System.Runtime.Remoting.Messaging.IMethodMessage"/> for which a session ID is requested.</param>
		<returns>
			<para>A session ID string that uniquely identifies the current
      session.</para>
		</returns>
		<remarks>
			<para>The same session ID might be returned for objects in the
      same application, but this method will never return the same session ID for two
      objects in different remote applications.
      </para>
			<para> For more information on
      identifying sessions and session IDs, see <see topic="cpconsessionstate"/>. </para>
		</remarks>
		<example>
			<para>The following example demonstrates how to get the session ID string for the
      current session.</para>
			<codelink SampleID="RemotingServices.ExecuteMessage" SnippetID="1"/>
		</example>
		<exception cref="System.Security.SecurityException">The immediate caller does not have infrastructure permission.</exception>
		<permission cref="System.Security.Permissions.SecurityPermission">for operating with infrastructure code. Demand value: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.Infrastructure" qualify="true"/></permission>
		<seealso topic="cpconsessionstate"/>
	</doc>
	<doc for="RemotingServices.GetLifetimeService">
		<summary>
			<para> Returns a lifetime service object that controls
      the lifetime policy of the specified object.</para>
		</summary>
		<param name="obj">The object to obtain lifetime service for.</param>
		<returns>
			<para> The object that controls the lifetime of <paramref name="obj"/>.
   </para>
		</returns>
		<remarks>
			<para>For the default lifetime service the returned object will be an object of type <see cref="System.Runtime.Remoting.Lifetime.ILease"/>. If the <paramref name="obj"/> parameter is
<see langword="null"/> , 
   the method returns <see langword="null"/>.</para>
		</remarks>
		<exception cref="System.Security.SecurityException">The immediate caller does not have infrastructure permission.</exception>
		<permission cref="System.Security.Permissions.SecurityPermission">for operating with infrastructure code. Demand value: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.Infrastructure" qualify="true"/></permission>
		<example>
			<para>The following example demonstrates how to use the
      <see cref="System.Runtime.Remoting.RemotingServices.GetLifetimeService"/> method
      to get a lifetime lease for the specified object.</para>
			<codelink SampleID="RemotingServices.TimerSample" SnippetID="1"/>
		</example>
	</doc>
	<doc for="RemotingServices.GetObjectUri">
		<summary>
			<para>Retrieves the URI for the specified object.</para>
		</summary>
		<param name="obj">The <see cref="System.MarshalByRefObject"/> for which a URI is requested.</param>
		<returns>
			<para>The URI of the specified object if it has one, or
      <see langword="null"/> if the object has not yet been marshaled.</para>
		</returns>
		<exception cref="System.Security.SecurityException">The immediate caller does not have infrastructure permission.</exception>
		<permission cref="System.Security.Permissions.SecurityPermission">for operating with infrastructure code. Demand value: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.Infrastructure" qualify="true"/></permission>
		<example>
			<codelink SampleID="System.Runtime.Remoting.RemotingServices" SnippetID="18"/>
		</example>
	</doc>
	<doc for="RemotingServices.SetObjectUriForMarshal">
		<summary>
			<para> Sets the URI for the subsequent call to the <see cref="System.Runtime.Remoting.RemotingServices.Marshal"/> method.
   </para>
		</summary>
		<param name="obj">The object to set a URI for.</param>
		<param name=" uri">The URI to assign to the specified object.</param>
		<exception cref="System.Runtime.Remoting.RemotingException"><paramref name="obj "/>is not a local object, has already been marshaled, or the current method has already been called on.</exception>
		<remarks>
			<para> The URI set by the current method is used when marshaling the given
      object.</para>
			<note type="note">
      After marshaling,
      the URI of the specified object is set to the string in the
      <paramref name="uri"/> parameter appended onto the <see cref="System.Guid"/> of the current <see cref="System.AppDomain"/>.
      
      </note>
			<note type="note">
      If the current application is
      listening on an HTTP port, then both the string specified in the <paramref name="uri
      "/>parameter and the <paramref name="uri"/> string appended onto the
      <see cref="System.Guid"/> of the
      current <see cref="System.AppDomain"/>
      route to the specified object. For example, if
      the application is listening on HTTP port 9000, then both http://localhost:9000/objectUri,
      and
      http://localhost:9000/&lt;appdomainguid&gt;/objectUri route to the object specified in the <paramref name="obj"/> parameter.
      
      </note>
		</remarks>
		<exception cref="System.Security.SecurityException">At least one of the callers higher in the callstack does not have 

permission to configure remoting types and channels. </exception>
		<permission cref="System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand 

value: <see cref="System.Security.Permissions.SecurityAction.Demand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" qualify="true"/></permission>
		<example>
			<para>The following example demonstrates how to set the URI that will be used by
      the <see cref="System.Runtime.Remoting.RemotingServices.Marshal"/> method when marshaling the specified
      object.</para>
			<codelink SampleID="RemotingServices.SetObjectUriForMarshal" SnippetID="1"/>
		</example>
		<seealso cref="T:System.Uri"/>
		<seealso cref="T:System.Guid"/>
	</doc>
	<doc for="RemotingServices.Marshal">
		<overload>
			<para> Converts the given <see cref="System.MarshalByRefObject"/> into an
   instance of the <see cref="System.Runtime.Remoting.ObjRef"/> class,
   which can be serialized
   for transmission between application domains and over a
   network.</para>
		</overload>
		<summary>
			<para> Takes a <see cref="System.MarshalByRefObject"/>, registers it with the
   remoting infrastructure, and converts it into an instance of the
<see cref="System.Runtime.Remoting.ObjRef"/> 
class.</para>
		</summary>
		<param name="Obj">The object to convert. </param>
		<returns>
			<para> An instance of the <see cref="System.Runtime.Remoting.ObjRef"/> class representing the object specified
   in
   the <paramref name="Obj"/> parameter.</para>
		</returns>
		<exception cref="System.Runtime.Remoting.RemotingException">The <paramref name="Obj"/> parameter is an object proxy.</exception>
		<exception cref="System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels. </exception>
		<remarks>
			<para>An <see cref="System.Runtime.Remoting.ObjRef"/> is a serializable
   representation of an object used to transfer an object reference across an
   AppDomain boundary. Creating an <see cref="System.Runtime.Remoting.ObjRef"/> for an object is known as marshaling. The
<see cref="System.Runtime.Remoting.ObjRef"/> can be transferred through a channel into 
   another AppDomain (possibly on another process or computer). Once in the other
   AppDomain, the <see cref="System.Runtime.Remoting.ObjRef"/> must be parsed to create a proxy for the
   object, generally connected to the real object. This operation is known as
   unmarshaling. <see cref="System.Runtime.Remoting.ObjRef"/>s contain information that describes the
<see cref="System.Type"/> and 
   class of the object being marshaled, a URI that
   uniquely identifies the specific object instance, and communication related information on how to
   reach the remoting subdivision where the object is
   located. </para>
			<para>During marshaling, the context from the current thread
   is used, not the context that was active when the object was created. If
   a URI was not explicitly set by the <see cref="System.Runtime.Remoting.RemotingServices.SetObjectUriForMarshal"/> method, it
   is
   automatically generated by the remoting identity infrastructure.</para>
			<para>You cannot associate a URI with a proxy for one of two reasons: either the URI was
   generated at the server side for the object it represents, or the object is well known, in
   which case the URI is known. For this reason, if the <paramref name="Obj"/>
   parameter is a proxy, an exception will be thrown. For custom proxies
   this restriction is relaxed because the transparent proxy is treated as the server
   object.</para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="System.Security.Permissions.SecurityAction.Demand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" qualify="true"/></permission>
		<seealso cref="T:System.Uri"/>
		<seealso topic="cpconApplicationDomains"/>
		<seealso cref="T:System.Runtime.Remoting.Proxies.RealProxy"/>
		<seealso cref="T:System.Runtime.Remoting.ObjRef"/>
	</doc>
	<doc for="RemotingServices.Marshal1">
		<summary>
			<para> Converts the given <see cref="System.MarshalByRefObject"/> into an instance
   of the <see cref="System.Runtime.Remoting.ObjRef"/> class with the specified URI.</para>
		</summary>
		<param name="Obj">The object to convert. </param>
		<param name="URI">The specified URI with which to initialize the new <see cref="System.Runtime.Remoting.ObjRef"/>. Can be <see langword="null"/> . </param>
		<returns>
			<para>An instance of the <see cref="System.Runtime.Remoting.ObjRef"/> class representing the
   object specified in the <paramref name="Obj"/> parameter. </para>
		</returns>
		<exception cref="System.Runtime.Remoting.RemotingException"><paramref name="Obj"/> is an object proxy, and the <paramref name="URI"/> parameter is not <see langword="null"/>.</exception>
		<remarks>
			<para>An <see cref="System.Runtime.Remoting.ObjRef"/> is a serializable representation of an
   object used to transfer an object reference across an AppDomain boundary.
   Creating an <see cref="System.Runtime.Remoting.ObjRef"/> for an object is known as marshaling.
   The <see cref="System.Runtime.Remoting.ObjRef"/> can be transferred through a channel
   into another AppDomain (possibly on another process or computer). Once in the
   other AppDomain, the <see cref="System.Runtime.Remoting.ObjRef"/> must be parsed to create a proxy for
   the object, generally connected to the real object. This operation is known as
   unmarshaling. <see cref="System.Runtime.Remoting.ObjRef"/>s contain information that describes the
<see cref="System.Type"/> and class 
   of the object being marshaled, a URI that uniquely identifies the specific
   object instance, and communication related information on how to reach the
   remoting subdivision where the object is located. </para>
			<para>During marshaling, the context from the current thread is used, not the
   context that was active when the object was created.</para>
			<para>You cannot associate a URI with a proxy for one of two reasons: either the
   URI was generated at the server side for the object it represents, or the object
   is well known, in which case the URI is known. For this reason, if the
<paramref name="Obj"/> parameter is a proxy, an exception will be thrown. For custom proxies 
   this restriction is relaxed because the transparent proxy is treated as the
   server object.</para>
		</remarks>
		<exception cref="System.Security.SecurityException">At least one of the callers higher in the callstack does not have 

permission to configure remoting types and channels. </exception>
		<permission cref="System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand 

value: <see cref="System.Security.Permissions.SecurityAction.Demand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" qualify="true"/></permission>
		<example>
			<para>The following example demonstrates how to use the current <see cref="System.Runtime.Remoting.RemotingServices.Marshal"/> method to marshal a specified
   object.</para>
			<codelink SampleID="RemotingServices.BasicSample" SnippetID="2"/>
		</example>
		<seealso cref="T:System.Uri"/>
		<seealso topic="cpconApplicationDomains"/>
		<seealso cref="T:System.Runtime.Remoting.Proxies.RealProxy"/>
		<seealso cref="T:System.Runtime.Remoting.ObjRef"/>
	</doc>
	<doc for="RemotingServices.Marshal2">
		<summary>
			<para>Takes a <see cref="System.MarshalByRefObject"/> and converts it into an instance of the
<see cref="System.Runtime.Remoting.ObjRef"/> class with the specified URI, and the provided <see cref="System.Type"/>
.</para>
		</summary>
		<param name="Obj">The object to convert into an <see cref="System.Runtime.Remoting.ObjRef"/> .</param>
		<param name="ObjURI">The URI the object specified in the <paramref name="Obj"/> parameter is marshaled with. Can be <see langword="null"/> .</param>
		<param name="RequestedType">The <see cref="System.Type"/>
			<paramref name="Obj"/> is marshaled as. Can be <see langword="null"/> .</param>
		<returns>
			<para>An instance of the <see cref="System.Runtime.Remoting.ObjRef"/> class representing the
   object specified in the <paramref name="Obj"/> parameter.</para>
		</returns>
		<exception cref="System.Runtime.Remoting.RemotingException"><paramref name="Obj"/> is a proxy of a remote object, and the <paramref name="ObjUri"/> parameter is not <see langword="null"/>.</exception>
		<exception cref="System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels. </exception>
		<remarks>
			<para>An <see cref="System.Runtime.Remoting.ObjRef"/> is a serializable representation of an
   object used to transfer an object reference across an AppDomain boundary.
   Creating an <see cref="System.Runtime.Remoting.ObjRef"/> for an object is known as marshaling.
   The <see cref="System.Runtime.Remoting.ObjRef"/> can be transferred through a channel
   into another AppDomain (possibly on another process or computer). Once in the
   other AppDomain, the <see cref="System.Runtime.Remoting.ObjRef"/> must be parsed to create a proxy for
   the object, generally connected to the real object. This operation is known as
   unmarshaling. <see cref="System.Runtime.Remoting.ObjRef"/>s contain information that describes the
<see cref="System.Type"/> and class 
   of the object being marshaled, a URI that uniquely identifies the specific
   object instance, and communication related information on how to reach the
   remoting subdivision where the object is located. </para>
			<para>The specified <see cref="System.Type"/> is used by the remoting
infrastructure to limit the scope of the exposed type hierarchy. For example, if
object A derives from object B, which derives from object C, and <see cref="System.Runtime.Remoting.RemotingServices.Marshal"/> is called, then the
client can cast the proxy between C and B but not to A. </para>
			<para>During marshaling, the context from the current thread is used, not the
   context that was active when the object was created.</para>
			<para>You cannot associate a URI with a proxy for one of two reasons: either the
   URI was generated at the server side for the object it represents, or the object
   is well known, in which case the URI is known. For this reason, if the
<paramref name="Obj"/> parameter is a proxy, an exception will be thrown. For custom proxies 
   this restriction is relaxed because the transparent proxy is treated as the
   server object.</para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="System.Security.Permissions.SecurityAction.Demand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" qualify="true"/></permission>
		<permission cref="System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" qualify="true"/>.</permission>
		<seealso cref="T:System.Uri"/>
		<seealso topic="cpconApplicationDomains"/>
		<seealso cref="T:System.Runtime.Remoting.Proxies.RealProxy"/>
		<seealso cref="T:System.Runtime.Remoting.ObjRef"/>
	</doc>
	<doc for="RemotingServices.GetObjectData">
		<summary>
			<para>Serializes the specified marshal by reference object into
      the provided <see cref="System.Runtime.Serialization.SerializationInfo"/>.</para>
		</summary>
		<param name="obj">The object to serialize.</param>
		<param name=" info">The <see cref="System.Runtime.Serialization.SerializationInfo"/> into which the object is serialized.</param>
		<param name=" context">The source and destination of the serialization.</param>
		<exception cref="System.ArgumentNullException">The <paramref name="obj "/>or <paramref name="info"/> parameter is <see langword="null"/>.</exception>
		<exception cref="System.Security.SecurityException">The immediate caller does not have infrastructure permission.</exception>
		<permission cref="System.Security.Permissions.SecurityPermission">for operating with infrastructure code. Demand value: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.Infrastructure" qualify="true"/></permission>
		<seealso cref="System.Runtime.Serialization.ISerializable"/>
	</doc>
	<doc for="RemotingServices.Unmarshal">
		<overload>
			<para>Converts a given <see cref="System.Runtime.Remoting.ObjRef"/> into a proxy object.</para>
		</overload>
		<summary>
			<para> Takes an <see cref="System.Runtime.Remoting.ObjRef"/>
and creates a proxy object out of it.</para>
		</summary>
		<param name="objectRef">The <see cref="System.Runtime.Remoting.ObjRef"/> that represents the remote object for which the proxy is being created. </param>
		<returns>
			<para> A proxy to the object that the given <see cref="System.Runtime.Remoting.ObjRef"/> represents.
   </para>
		</returns>
		<exception cref="System.ArgumentException">The <see cref="System.Runtime.Remoting.ObjRef"/> instance specified in the <paramref name="objectRef"/> parameter is not well formed.</exception>
		<exception cref="System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels. </exception>
		<remarks>
			<para>An <see cref="System.Runtime.Remoting.ObjRef"/>
is a serializable representation of an object used to
transfer an object reference across an AppDomain boundary. Creating an <see cref="System.Runtime.Remoting.ObjRef"/> for an object is known as marshaling. The
<see cref="System.Runtime.Remoting.ObjRef"/> can be 
transferred through a channel into another AppDomain (possibly on another process or
computer). Once in the other AppDomain, the <see cref="System.Runtime.Remoting.ObjRef"/> must be parsed to create a proxy for the
object, generally connected to the real object. This operation is known as
unmarshaling. During unmarshaling, the <see cref="System.Runtime.Remoting.ObjRef"/> is parsed to extract
the method information of the remote object and both the transparent proxy and
<see cref="System.Runtime.Remoting.Proxies.RealProxy"/> objects are created. The 
content of the parsed <see cref="System.Runtime.Remoting.ObjRef"/> is added to the transparent proxy
before the transparent proxy is registered with the common language runtime.</para>
			<para><see cref="System.Runtime.Remoting.ObjRef"/>s contain
information that describes the <see cref="System.Type"/> and class of the
object being marshaled, a URI that uniquely
identifies the specific object instance, and communication related information
on how to reach the remoting subdivision where the object is located. </para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="System.Security.Permissions.SecurityAction.Demand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" qualify="true"/></permission>
		<example>
			<para>The following example demonstrates how to unmarshal an object.</para>
			<codelink SampleID="RemotingServices.Unmarshal" SnippetID="2"/>
		</example>
		<seealso cref="T:System.Runtime.Remoting.Proxies.RealProxy"/>
		<seealso cref="T:System.Runtime.Remoting.ObjRef"/>
	</doc>
	<doc for="RemotingServices.Unmarshal1">
		<summary>
			<para>Takes an <see cref="System.Runtime.Remoting.ObjRef"/> and creates a proxy object out of it,
   refining it to the type on the server.</para>
		</summary>
		<param name="objectRef">The <see cref="System.Runtime.Remoting.ObjRef"/> that represents the remote object for which the proxy is being created.</param>
		<param name=" fRefine"><see langword="true"/> to refine the proxy to the type on the server; otherwise, <see langword="false"/>.</param>
		<returns>
			<para>A proxy to the object that the given <see cref="System.Runtime.Remoting.ObjRef"/> represents. </para>
		</returns>
		<exception cref="System.ArgumentException">The <see cref="System.Runtime.Remoting.ObjRef"/> instance specified in the <paramref name="objectRef"/> parameter is not well formed.</exception>
		<exception cref="System.Security.SecurityException">At least one of the callers higher in the callstack does not have permission to configure remoting types and channels. </exception>
		<remarks>
			<para>An <see cref="System.Runtime.Remoting.ObjRef"/> is a serializable representation of an
   object used to transfer an object reference across an AppDomain boundary.
   Creating an <see cref="System.Runtime.Remoting.ObjRef"/> for an object is known as marshaling.
   The <see cref="System.Runtime.Remoting.ObjRef"/> can be transferred through a channel
   into another AppDomain (possibly on another process or computer). Once in the
   other AppDomain, the <see cref="System.Runtime.Remoting.ObjRef"/> must be parsed to create a proxy for
   the object, generally connected to the real object. This operation is known as
   unmarshaling. During unmarshaling, the <see cref="System.Runtime.Remoting.ObjRef"/> is parsed to extract
   the method information of the remote object and both the transparent proxy and
<see cref="System.Runtime.Remoting.Proxies.RealProxy"/> objects are created. The 
   content of the parsed <see cref="System.Runtime.Remoting.ObjRef"/> is added to the transparent proxy before
   the transparent proxy is registered with the common language runtime.</para>
			<para><see cref="System.Runtime.Remoting.ObjRef"/>s contain information that describes the
<see cref="System.Type"/> and class 
of the object being marshaled, a URI that uniquely identifies the specific
object instance, and communication related information on how to reach the
remoting subdivision where the object is located. </para>
			<para> When first created, the proxy is of type <see cref="System.MarshalByRefObject"/> . As you cast it into
different types, the remoting infrastructure keeps track of the most used type
to avoid loading the type unnecessarily.</para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="System.Security.Permissions.SecurityAction.Demand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" qualify="true"/></permission>
		<seealso cref="T:System.Runtime.Remoting.Proxies.RealProxy"/>
		<seealso cref="T:System.Runtime.Remoting.ObjRef"/>
	</doc>
	<doc for="RemotingServices.Connect">
		<overload>
			<para>Creates a proxy for a well-known object.</para>
		</overload>
		<summary>
			<para>Creates a proxy for a well-known object, given the
   <see cref="System.Type"/>
   and URL.</para>
		</summary>
		<param name="classToProxy">The <see cref="System.Type"/> of a well-known object on the server end to which you want to connect. </param>
		<param name="url">The URL of the server class. </param>
		<returns>
			<para> A proxy to the remote object that points to an
      endpoint served by the specified well-known object.
      </para>
		</returns>
		<exception cref="System.Security.SecurityException">The immediate caller does not have permission to configure remoting types and channels.</exception>
		<remarks>
			<para> The returned proxy object points to an endpoint served
      by the specified well-known object. No messages are sent over the network
      until a method is called on the proxy.</para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" qualify="true"/></permission>
		<example>
			<para>The following example demonstrates how to use the <see cref="System.Runtime.Remoting.RemotingServices.Connect"/> method to create a proxy to a
   well-known object.</para>
			<codelink SampleID="RemotingServices.BasicSample" SnippetID="1"/>
		</example>
	</doc>
	<doc for="RemotingServices.Connect1">
		<summary>
			<para>Creates a proxy for a well-known object, given the <see cref="System.Type"/>, URL, and channel-specific data.</para>
		</summary>
		<param name="classToProxy">The <see cref="System.Type"/> of the well-known object to which you want to connect. </param>
		<param name="url">The URL of the well-known object. </param>
		<param name="data">Channel specific data. Can be <see langword="null"/> . </param>
		<returns>
			<para> A proxy that points to an endpoint that is served by
      the requested well-known object.
      </para>
		</returns>
		<exception cref="System.Security.SecurityException">The immediate caller does not have permission to configure remoting types and channels.</exception>
		<remarks>
			<para> The returned proxy object points to an endpoint served by the specified
      well-known object. No messages are sent over the network until a method is called on
      the proxy.</para>
			<para>The <paramref name="data"/> object is used to communicate information to the channel, and is passed to the <see cref="System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink" qualify="true"/> method.</para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure. Demand value: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" qualify="true"/></permission>
	</doc>
	<doc for="RemotingServices.Disconnect">
		<summary>
			<para>Stops an object from receiving any further messages through the registered remoting channels.</para>
		</summary>
		<param name="obj">Object to disconnect from its channel. </param>
		<returns>
			<para><see langword="true"/> if the object
   was disconnected from the registered remoting
   channels successfully; otherwise, <see langword="false"/>.
   </para>
		</returns>
		<exception cref="System.ArgumentNullException">The <paramref name="obj "/> parameter is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException">The <paramref name="obj"/> parameter is a proxy.</exception>
		<exception cref="System.Security.SecurityException">The immediate caller does not have permission to configure remoting types 

and channels.</exception>
		<permission cref="System.Security.Permissions.SecurityPermission">for configuration of the remoting infrastructure.  Demand 

value: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" qualify="true"/></permission>
		<example>
			<para>The following example demonstrates how to use the <see cref="System.Runtime.Remoting.RemotingServices.Disconnect"/> method to disconnect an object from the
   remoting channels.</para>
			<codelink SampleID="RemotingServices.BasicSample" SnippetID="2"/>
		</example>
	</doc>
	<doc for="RemotingServices.GetEnvoyChainForProxy">
		<summary>
			<para> Returns a chain of envoy sinks that should be used
      when sending messages to the remote object represented by the specified proxy.</para>
		</summary>
		<param name="obj">The proxy of the remote object that requested envoy sinks are associated with.</param>
		<returns>
			<para>A chain of envoy sinks associated with the specified proxy.</para>
		</returns>
		<remarks>
			<para>Envoy sinks are sinks sent along with the <see cref="System.Runtime.Remoting.ObjRef"/>
of an object that is used when returning messages to that
object. The current method returns the envoy sinks that are used during
communication between the proxy of the object and the object itself.</para>
		</remarks>
		<exception cref="System.Security.SecurityException">The immediate caller does not have infrastructure permission.</exception>
		<permission cref="System.Security.Permissions.SecurityPermission">for operating with infrastructure code. Demand value: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.Infrastructure" qualify="true"/></permission>
		<seealso cref="System.Runtime.Remoting.IEnvoyInfo"/>
		<seealso cref="System.Runtime.Remoting.ObjRef"/>
	</doc>
	<doc for="RemotingServices.GetObjRefForProxy">
		<summary>
			<para>Returns the <see cref="System.Runtime.Remoting.ObjRef"/> that represents the
   remote object from the specified proxy.</para>
		</summary>
		<param name="obj">A proxy connected to the object you want to create an <see cref="System.Runtime.Remoting.ObjRef"/> for.</param>
		<returns>
			<para>An <see cref="System.Runtime.Remoting.ObjRef"/>
representing the remote object the specified proxy is connected to, or
<see langword="null"/> if the object
or proxy have not been marshaled.</para>
		</returns>
		<remarks>
			<para>An <see cref="System.Runtime.Remoting.ObjRef"/> is a serializable
   representation of an object used to transfer an object reference across an
   AppDomain boundary. Creating an <see cref="System.Runtime.Remoting.ObjRef"/> for an object is known as marshaling. The
<see cref="System.Runtime.Remoting.ObjRef"/> can be transferred through a channel into 
   another AppDomain (possibly on another process or computer). Once in the other
   AppDomain, the <see cref="System.Runtime.Remoting.ObjRef"/> must be parsed to create a proxy for the
   object, generally connected to the real object. This operation is known as
   unmarshaling. During unmarshaling, the <see cref="System.Runtime.Remoting.ObjRef"/> is parsed to extract
   the method information of the remote object and both the transparent proxy and
<see cref="System.Runtime.Remoting.Proxies.RealProxy"/> objects are created. </para>
			<para><see cref="System.Runtime.Remoting.ObjRef"/>s contain information that describes the
<see cref="System.Type"/> and class 
of the object being marshaled, a URI that
uniquely identifies the specific object instance, and communication related
information on how to reach the remote application where the object is
located. </para>
		</remarks>
		<exception cref="System.Security.SecurityException">The immediate caller does not have infrastructure permission.</exception>
		<permission cref="System.Security.Permissions.SecurityPermission">for operating with infrastructure code. Demand value: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.Infrastructure" qualify="true"/></permission>
		<example>
			<para>The following example demonstrates how to get an <see cref="System.Runtime.Remoting.ObjRef"/>
instance for the specified object. </para>
			<codelink SampleID="RemotingServices.GetObjRefForProxy" SnippetID="1"/>
		</example>
	</doc>
	<doc for="RemotingServices.GetMethodBaseFromMethodMessage">
		<summary>
			<para>Returns the method base from the given <see cref="System.Runtime.Remoting.Messaging.IMethodMessage"/> .</para>
		</summary>
		<param name="msg">The method message to extract the method base from.</param>
		<returns>
			<para>The method base extracted from the <paramref name="msg"/> parameter.</para>
		</returns>
		<exception cref="System.Security.SecurityException">Either the immediate caller does not have infrastructure permission, or at least one of the callers higher in the callstack does not have permission to retrieve the type information of non-public members.</exception>
		<remarks>
			<para>This determines the method base from the <see cref="System.Runtime.Remoting.Messaging.IMethodMessage.TypeName"/>, <see cref="System.Runtime.Remoting.Messaging.IMethodMessage.MethodName"/>, and <see cref="System.Runtime.Remoting.Messaging.IMethodMessage.MethodSignature"/> properties of <see cref="System.Runtime.Remoting.Messaging.IMethodMessage"/> and is used by classes
   implementing the <see cref="System.Runtime.Remoting.Messaging.IMethodMessage"/> interface. Consumers of
<see cref="System.Runtime.Remoting.Messaging.IMethodMessage"/> classes should reference the 
<see cref="System.Runtime.Remoting.Messaging.IMethodMessage.MethodBase" qualify="true"/> property.</para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">for operating with infrastructure code. Demand value: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.Infrastructure" qualify="true"/></permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">to retrieve the type information of non-public members. Demand value: <see cref="System.Security.Permissions.SecurityAction.Demand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
	</doc>
	<doc for="RemotingServices.IsMethodOverloaded">
		<summary>
			<para>Returns a Boolean value indicating whether the method in the given message is overloaded.</para>
		</summary>
		<param name="msg">The message containing a call to the method in question.</param>
		<returns>
			<para><see langword="true"/> if the method called in <paramref name="msg"/> is
   overloaded; otherwise, <see langword="false"/>.</para>
		</returns>
		<exception cref="System.Security.SecurityException">The immediate caller does not have infrastructure permission.</exception>
		<permission cref="System.Security.Permissions.SecurityPermission">for operating with infrastructure code. Demand value: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.Infrastructure" qualify="true"/></permission>
	</doc>
	<doc for="RemotingServices.IsOneWay">
		<summary>
			<para> Returns a Boolean value indicating whether the
      client that called the method specified in the given message is waiting for the server to finish processing the method
      before continuing execution.</para>
		</summary>
		<param name="method">The method in question.</param>
		<returns>
			<para><see langword="true"/> if the method is one way; otherwise, <see langword="false"/>.</para>
		</returns>
		<remarks>
			<para> When a one way method is called, the client does not
      wait for the server to finish processing the message. The client method returns
      to the application with no knowledge of whether or not the server will
      successfully process the message. Methods are marked as one way using the
      <see cref="System.Runtime.Remoting.Messaging.OneWayAttribute"/>
   
   .</para>
			<para> One way methods cannot have a return value or any out
   parameters.</para>
		</remarks>
		<exception cref="System.Security.SecurityException">The immediate caller does not have infrastructure permission.</exception>
		<permission cref="System.Security.Permissions.SecurityPermission">for operating with infrastructure code. Demand value: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.Infrastructure" qualify="true"/></permission>
		<example>
			<codelink SampleID="System.Runtime.Remoting.RemotingServices" SnippetID="2"/>
		</example>
	</doc>
	<doc for="RemotingServices.GetServerTypeForUri">
		<summary>
			<para>Returns the <see cref="System.Type"/> of the object with the specified URI.</para>
		</summary>
		<param name="URI">The URI of the object whose <see cref="System.Type"/> is requested.</param>
		<returns>
			<para>The <see cref="System.Type"/> of the object with the specified URI.</para>
		</returns>
		<exception cref="System.Security.SecurityException">Either the immediate caller does not have infrastructure permission, or at least one of the callers higher in the callstack does not have permission to retrieve the type information of non-public members.</exception>
		<remarks>
			<para>Since remoting identifies endpoints using URIs,
      the <see cref="System.Runtime.Remoting.RemotingServices.GetServerTypeForUri"/> method is very useful in the
      pluggable parts of the remoting infrastructure (for example channel sinks, dynamic
      sinks, and context sinks) that use <see cref="System.Runtime.Remoting.Messaging.IMessage"/> objects, since the
      current method will return the associated type object from the URI. </para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">for operating with infrastructure code. Demand value: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.Infrastructure" qualify="true"/></permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">to retrieve the type information of non-public members. Demand value: <see cref="System.Security.Permissions.SecurityAction.Demand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<codelink SampleID="System.Runtime.Remoting.RemotingServices" SnippetID="7"/>
		</example>
	</doc>
	<doc for="RemotingServices.ExecuteMessage">
		<summary>
			<para>Connects to the specified remote object, and executes
      the provided <see cref="System.Runtime.Remoting.Messaging.IMethodCallMessage"/> on it.</para>
		</summary>
		<param name="target">The remote object whose method you want to call.</param>
		<param name=" reqMsg">A method call message to the specified remote object's method.</param>
		<returns>
			<para>The response of the remote method.</para>
		</returns>
		<remarks>
			<para>The current method is used in special cases by the
      server to forward the specified method call to another, possibly remote, object. This method can be called only
      when the caller is in the appropriate context.</para>
		</remarks>
		<exception cref="System.Security.SecurityException">The immediate caller does not have infrastructure permission.</exception>
		<permission cref="System.Security.Permissions.SecurityPermission">for operating with infrastructure code. Demand value: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/>; Permission value: <see cref="System.Security.Permissions.SecurityPermissionFlag.Infrastructure" qualify="true"/></permission><example>
			<para>The following example demonstrates how to use the <see cref="System.Runtime.Remoting.RemotingServices.ExecuteMessage"/> method to forward method calls to
   remote objects.</para>
			<codelink SampleID="RemotingServices.ExecuteMessage" SnippetID="1"/>
		</example>
	</doc>
</docs>
