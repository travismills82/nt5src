<docs>
	<doc for="Marshal">
		<summary>
			<para> Provides a collection of methods for allocating unmanaged
      memory, copying unmanaged memory
      blocks, and converting managed to unmanaged types, as well as other miscellaneous methods
      used when interacting with unmanaged code.</para>
		</summary>
		<remarks>
			<para>The <see langword="static"/> methods defined on the <see cref="System.Runtime.InteropServices.Marshal"/> class
   are essential to working with unmanaged code. Most methods defined here are
   typically used by advanced developers building custom marshalers who need to
   provide a bridge between the managed and unmanaged programming models. For example, the <see cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi"/> method copies
   the ANSI characters from a specified string
   (in the managed heap) to a buffer in the unmanaged heap.
   It also allocates the target heap of the right size, as the
   following C# code shows:</para>
			<code>
String s = "Hello";
    IntPtr p = Marshal.StringToHGlobalAnsi(s);
</code>
			<para>The common language runtime provides specific marshaling
   capabilities. For details on marshaling behavior, see <see topic="cpconinteropmarshaling"/>. </para>
			<para>The <see cref="System.Runtime.InteropServices.Marshal"/>
class comprises many diverse members. The following table assigns each member to
the category that best describes its usage. </para>
			<list type="table">
				<listheader>
					<term>Category</term>
					<description>Members</description>
				</listheader>
				<item>
					<term> Advanced marshaling</term>
					<description><see cref="System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr"/>, <see cref="System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr"/>, <see cref="System.Runtime.InteropServices.Marshal.NumParamBytes"/></description>
				</item>
				<item>
					<term> COM library function</term>
					<description><see cref="System.Runtime.InteropServices.Marshal.BindToMoniker"/>, <see cref="System.Runtime.InteropServices.Marshal.GetActiveObject"/></description>
				</item>
				<item>
					<term> COM utilities</term>
					<description><see cref="System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength"/>, <see cref="System.Runtime.InteropServices.Marshal.CreateWrapperOfType"/>, <see cref="System.Runtime.InteropServices.Marshal.GetComObjectData"/>, <see cref="System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo"/>, <see cref="System.Runtime.InteropServices.Marshal.GetEndComSlot"/>, <see cref="System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot"/>, <see cref="System.Runtime.InteropServices.Marshal.GetStartComSlot"/>, <see cref="System.Runtime.InteropServices.Marshal.ReleaseComObject"/>, <see cref="System.Runtime.InteropServices.Marshal.SetComObjectData"/></description>
				</item>
				<item>
					<term> Data transformation</term>
					<description>
						<para>Managed to unmanaged: <see cref="System.Runtime.InteropServices.Marshal.Copy"/>, <see cref="System.Runtime.InteropServices.Marshal.GetComInterfaceForObject"/>, <see cref="System.Runtime.InteropServices.Marshal.GetIDispatchForObject"/>, <see cref="System.Runtime.InteropServices.Marshal.GetIUnknownForObject"/>, <see cref="System.Runtime.InteropServices.Marshal.StringToBSTR"/>, <see cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi"/>, <see cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto"/>, <see cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni"/>, <see cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi"/>, <see cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAuto"/>, <see cref="System.Runtime.InteropServices.Marshal.StringToHGlobalUni"/>, <see cref="System.Runtime.InteropServices.Marshal.StructureToPtr"/>, <see cref="System.Runtime.InteropServices.Marshal.UnsafeAddrOfPinnedArrayElement"/>
						</para>
						<para>Unmanaged to managed: <see cref="System.Runtime.InteropServices.Marshal.Copy"/>, <see cref="System.Runtime.InteropServices.Marshal.GetObjectForIUnknown"/>, <see cref="System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant"/>, <see cref="System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants"/>, <see cref="System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown"/>, <see cref="System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo"/>, <see cref="System.Runtime.InteropServices.Marshal.PtrToStringAnsi"/>, <see cref="System.Runtime.InteropServices.Marshal.PtrToStringAuto"/>, <see cref="System.Runtime.InteropServices.Marshal.PtrToStringBSTR"/>, <see cref="System.Runtime.InteropServices.Marshal.PtrToStringUni"/>
						</para>
						<para>Properties: <see cref="System.Runtime.InteropServices.Marshal.SystemDefaultCharSize"/>, <see cref="System.Runtime.InteropServices.Marshal.SystemMaxDBCSCharSize"/>
						</para></description>
				</item>
				<item>
					<term> Direct reading and writing</term>
					<description><see cref="System.Runtime.InteropServices.Marshal.ReadByte"/>, <see cref="System.Runtime.InteropServices.Marshal.ReadInt16"/>, <see cref="System.Runtime.InteropServices.Marshal.ReadInt32"/>, <see cref="System.Runtime.InteropServices.Marshal.ReadInt64"/>, <see cref="System.Runtime.InteropServices.Marshal.ReadIntPtr"/>, <see cref="System.Runtime.InteropServices.Marshal.WriteByte"/>, <see cref="System.Runtime.InteropServices.Marshal.WriteInt16"/>, <see cref="System.Runtime.InteropServices.Marshal.WriteInt32"/>, <see cref="System.Runtime.InteropServices.Marshal.WriteInt64"/>, <see cref="System.Runtime.InteropServices.Marshal.WriteIntPtr"/></description>
				</item>
				<item>
					<term> Error handling</term>
					<description>
						<para>COM: <see cref="System.Runtime.InteropServices.Marshal.GetHRForException"/>, <see cref="System.Runtime.InteropServices.Marshal.ThrowExceptionForHR"/>
						</para>
						<para>Win32: <see cref="System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>, <see cref="System.Runtime.InteropServices.Marshal.GetExceptionCode"/>, <see cref="System.Runtime.InteropServices.Marshal.GetExceptionPointers"/>
						</para>
						<para>Both: <see cref="System.Runtime.InteropServices.Marshal.GetHRForLastWin32Error"/>
						</para></description>
				</item>
				<item>
					<term> Hosting utilities</term>
					<description><see cref="System.Runtime.InteropServices.Marshal.GetThreadFromFiberCookie"/></description>
				</item>
				<item>
					<term> IUnknown</term>
					<description><see cref="System.Runtime.InteropServices.Marshal.AddRef"/>, <see cref="System.Runtime.InteropServices.Marshal.QueryInterface"/>, <see cref="System.Runtime.InteropServices.Marshal.Release"/></description>
				</item>
				<item>
					<term> Memory management</term>
					<description>
						<para>COM: <see cref="System.Runtime.InteropServices.Marshal.AllocCoTaskMem"/>, <see cref="System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem"/>, <see cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/>, <see cref="System.Runtime.InteropServices.Marshal.FreeBSTR"/>
						</para>
						<para>Win32: <see cref="System.Runtime.InteropServices.Marshal.AllocHGlobal"/>, <see cref="System.Runtime.InteropServices.Marshal.ReAllocHGlobal"/>, <see cref="System.Runtime.InteropServices.Marshal.FreeHGlobal"/>
						</para>
						<para>Both: <see cref="System.Runtime.InteropServices.Marshal.DestroyStructure"/>
						</para></description>
				</item>
				<item>
					<term> Platform invoke utilities</term>
					<description><see cref="System.Runtime.InteropServices.Marshal.Prelink"/>, <see cref="System.Runtime.InteropServices.Marshal.PrelinkAll"/>, <see cref="System.Runtime.InteropServices.Marshal.GetHINSTANCE"/></description>
				</item>
				<item>
					<term> Structure inspection</term>
					<description><see cref="System.Runtime.InteropServices.Marshal.OffsetOf"/>, <see cref="System.Runtime.InteropServices.Marshal.SizeOf"/></description>
				</item>
				<item>
					<term> Type information</term>
					<description><see cref="System.Runtime.InteropServices.Marshal.GenerateGuidForType"/>, <see cref="System.Runtime.InteropServices.Marshal.GenerateProgIdForType"/>, <see cref="System.Runtime.InteropServices.Marshal.GetTypeInfoName"/>, <see cref="System.Runtime.InteropServices.Marshal.GetTypeLibGuid"/>, <see cref="System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly"/>, <see cref="System.Runtime.InteropServices.Marshal.GetTypeLibLcid"/>, <see cref="System.Runtime.InteropServices.Marshal.GetTypeLibName"/>, <see cref="System.Runtime.InteropServices.Marshal.IsComObject"/>, <see cref="System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom"/></description>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="Marshal.SystemDefaultCharSize">
		<summary>
			<para>Represents the default character size on the system; the default is 2 for Unicode systems and 1 for
      ANSI systems. This field is read-only.</para>
		</summary>
		<seealso cref="System.Runtime.InteropServices.Marshal.PtrToStringAuto"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAuto"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto"/>
	</doc>
	<doc for="Marshal.SystemMaxDBCSCharSize">
		<summary>
			<para>Represents the maximum size of a double byte character set (DBCS) size, in bytes, for the current operating system. This field is read-only.</para>
		</summary>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi"/>
	</doc>
	<doc for="Marshal.AllocHGlobal1">
		<summary>
			<para> Allocates memory from the unmanaged memory of the process using
   <see langword="GlobalAlloc"/>.</para>
		</summary>
		<param name="cb">The number of bytes in memory required.</param>
		<returns>
			<para>An <see cref="System.IntPtr"/> to the newly allocated memory. This memory
   must be released using the <see cref="System.Runtime.InteropServices.Marshal.FreeHGlobal" qualify="true"/> method.</para>
		</returns>
		<exception cref="System.OutOfMemoryException">There is insufficient memory to satisfy the request.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.AllocHGlobal"/> is one of two memory allocation API methods in
   the <see cref="System.Runtime.InteropServices.Marshal"/> class. (<see cref="System.Runtime.InteropServices.Marshal.AllocCoTaskMem" qualify="true"/> is the other.) This
   method exposes the
<see langword="GlobalAlloc"/> Win32 API from Kernel32.dll. For
   additional information about <see langword="GlobalAlloc"/>,
   see
   the MSDN Library.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.AllocCoTaskMem"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.FreeHGlobal"/>
	</doc>
	<doc for="Marshal.ReAllocHGlobal">
		<summary>
			<para>Resizes a block of memory previously allocated with
      <see cref="System.Runtime.InteropServices.Marshal.AllocHGlobal"/>.</para>
		</summary>
		<param name="pv">A pointer to memory allocated with <see cref="System.Runtime.InteropServices.Marshal.AllocHGlobal"/>.</param>
		<param name=" cb">The new size of the allocated block.</param>
		<returns>
			<para>An <see cref="System.IntPtr"/> to the reallocated memory. This memory must be
   released using <see cref="System.Runtime.InteropServices.Marshal.FreeHGlobal" qualify="true"/>. </para>
		</returns>
		<exception cref="System.OutOfMemoryException">There is insufficient memory to satisfy the request.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReAllocHGlobal"/> is one of two memory allocation API methods in the <see cref="System.Runtime.InteropServices.Marshal"/> class. (<see cref="System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem" qualify="true"/> is the other.) This
   method exposes the <see langword="GlobalRealloc"/> Win32 API method from Kernel32.dll. The
   returned pointer can differ from the original. For additional information about <see langword="GlobalAlloc"/>, see
   the MSDN Library.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.FreeHGlobal"/>
	</doc>
	<doc for="Marshal.AllocCoTaskMem">
		<summary>
			<para> Allocates a block of memory of specified size from the
      COM task memory allocator.
      </para>
		</summary>
		<param name="cb">The size of the block of memory to be allocated. </param>
		<returns>
			<para> An integer representing the address of the block of
      memory allocated. This memory must be released with <see cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem" qualify="true"/>.
      </para>
		</returns>
		<exception cref="System.OutOfMemoryException">There is insufficient memory to satisfy the request. </exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.AllocCoTaskMem"/> is one of two memory allocation API methods in the
<see cref="System.Runtime.InteropServices.Marshal"/> class. (<see cref="System.Runtime.InteropServices.Marshal.AllocHGlobal" qualify="true"/> is the other.) The 
   initial memory content returned is undefined, and the allocated memory can be
   larger than the requested number of bytes. This method
   exposes the <see langword="CoTaskMemAlloc"/> COM API method, which is referred to as the
   COM task memory allocator. For
   additional information about <see langword="CoTaskMemAlloc"/>, see the MSDN Library.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.AllocHGlobal"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/>
	</doc>
	<doc for="Marshal.ReAllocCoTaskMem">
		<summary>
			<para>Resizes a block of memory previously allocated with
   <see cref="System.Runtime.InteropServices.Marshal.AllocCoTaskMem"/>.</para>
		</summary>
		<param name="pv">A pointer to memory allocated with <see cref="System.Runtime.InteropServices.Marshal.AllocCoTaskMem"/>.</param>
		<param name=" cb">The new size of the allocated block.</param>
		<returns>
			<para>An integer representing the address of the block of
      memory reallocated. This memory must be released with <see cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/>.</para>
		</returns>
		<exception cref="System.OutOfMemoryException">There is insufficient memory to satisfy the request. </exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem"/> is one of two memory reallocation API methods in the <see cref="System.Runtime.InteropServices.Marshal"/> class. (<see cref="System.Runtime.InteropServices.Marshal.ReAllocHGlobal"/> is the other.) The
   beginning of the reallocated memory content is the same as the original content;
   however, the entire memory block can be in a different location. This
   method exposes the
<see langword="CoTaskMemRealloc"/> COM API method, which is referred to as 
   the COM task memory allocator. For additional information about <see langword="CoTaskMemRealloc"/>, see the
   MSDN Library. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.ReAllocHGlobal"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/>
	</doc>
	<doc for="Marshal.StringToHGlobalAnsi">
		<summary>
			<para>Copies the contents of a managed <see cref="System.String"/>
into unmanaged memory, converting
into ANSI format as it copies.</para>
		</summary>
		<param name="s">A managed string to be copied.</param>
		<returns>
			<para>The address, in unmanaged memory, to where <paramref name="s"/> was copied, or 0 if <see langword="null"/> string was supplied.</para>
		</returns>
		<exception cref="System.OutOfMemoryException">There is insufficient memory available.</exception>
		<exception cref="System.ArgumentException"><paramref name="s"/> is <see langword="null"/>.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi"/> is useful for custom
   marshaling or when mixing managed and unmanaged code. Since this method allocates
   the unmanaged memory required for a string, always free the memory by calling <see cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/>.
<see cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi"/> 
provides the opposite
functionality of <see cref="System.Runtime.InteropServices.Marshal.PtrToStringAnsi" qualify="true"/>. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.PtrToStringAnsi"/>
	</doc>
	<doc for="Marshal.StringToCoTaskMemAnsi">
		<summary>
			<para>Copies the contents of a managed <see cref="System.String"/> to a block of memory
   allocated from the unmanaged COM task allocator.</para>
		</summary>
		<param name="s">A managed string to be copied.</param>
		<returns>
			<para> An integer representing a pointer to the block of
      memory allocated for the string, or 0 if <see langword="null"/>
      string was supplied.</para>
		</returns>
		<exception cref="System.OutOfMemoryException">There is insufficient memory available.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi"/> is useful for custom
   marshaling or when mixing managed and unmanaged code. Since this
   method allocates the unmanaged memory required for a string, always free the memory by calling <see cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/>. This method
   provides the opposite
   functionality of <see cref="System.Runtime.InteropServices.Marshal.PtrToStringAnsi" qualify="true"/>. The characters of the
   string are copied as ANSI characters. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.PtrToStringAnsi"/>
	</doc>
	<doc for="Marshal.StringToHGlobalUni">
		<summary>
			<para>Copies the contents of a managed <see cref="System.String"/> into unmanaged memory.</para>
		</summary>
		<param name="s">A managed string to be copied.</param>
		<returns>
			<para>The address, in unmanaged memory, to where the <paramref name="s"/> was copied, or 0 if <see langword="null"/> string was supplied.</para>
		</returns>
		<exception cref="System.OutOfMemoryException">The method could not allocate enough native heap memory.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.StringToHGlobalUni"/> is useful for custom marshaling or
   for use when mixing managed and unmanaged code. Since this method allocates
   the unmanaged memory required for a string, always free the memory by calling <see cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/>. This method
   provides the opposite
   functionality of <see cref="System.Runtime.InteropServices.Marshal.PtrToStringUni" qualify="true"/>. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
			<para><see langword="Note[note]"/> This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/> member, see "Secure Coding Guidelines
for the .NET Framework" in the MSDN Library.</para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.PtrToStringUni"/>
	</doc>
	<doc for="Marshal.StringToCoTaskMemUni">
		<summary>
			<para>Copies the contents of a managed <see cref="System.String"/> to a block of memory
   allocated from the unmanaged COM task allocator.</para>
		</summary>
		<param name="s">A managed string to be copied.</param>
		<returns>
			<para> An integer representing a pointer to the block of
      memory allocated for the string, or 0 if <see langword="null"/>
      string was supplied.</para>
		</returns>
		<exception cref="System.OutOfMemoryException">There is insufficient memory available.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni"/> is useful for custom marshaling or
   for use when mixing managed and unmanaged code. Since this method allocates
   the unmanaged memory required for a string, always free the memory by calling <see cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem" qualify="true"/>. This method
   provides the opposite
   functionality of <see cref="System.Runtime.InteropServices.Marshal.PtrToStringUni" qualify="true"/>. The characters of the
   string are copied as Unicode characters.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.PtrToStringUni"/>
	</doc>
	<doc for="Marshal.StringToHGlobalAuto">
		<summary>
			<para>Copies the contents of a managed <see cref="System.String"/>
into unmanaged memory, converting into ANSI format if required.</para>
		</summary>
		<param name="s">A managed string to be copied.</param>
		<returns>
			<para> The address, in unmanaged memory, to where the string was
      copied, or 0 if <see langword="null"/> string was supplied.</para>
		</returns>
		<exception cref="System.OutOfMemoryException">There is insufficient memory available.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAuto"/> is useful for custom marshaling or
   for use when mixing managed and unmanaged code. Since this method allocates
   the unmanaged memory required for a string, always free the memory by calling <see cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/>. This method
   provides the opposite
   functionality of <see cref="System.Runtime.InteropServices.Marshal.PtrToStringAuto" qualify="true"/>. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.PtrToStringAuto"/>
	</doc>
	<doc for="Marshal.StringToCoTaskMemAuto">
		<summary>
			<para>Copies the contents of a managed <see cref="System.String"/> to a block of memory
   allocated from the unmanaged COM task allocator.</para>
		</summary>
		<param name="s">A managed string to be copied.</param>
		<returns>
			<para> The allocated memory block, or 0 if
      <see langword="null"/> string was supplied.</para>
		</returns>
		<exception cref="System.OutOfMemoryException">There is insufficient memory available.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto"/> is useful for custom marshaling or
   for use when mixing managed and unmanaged code. Since this method allocates
   the unmanaged memory required for a string, always free the memory by calling <see cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/>. This method
   provides the opposite
   functionality of <see cref="System.Runtime.InteropServices.Marshal.PtrToStringAuto" qualify="true"/>. </para>
			<para>The characters of the string are copied as either ANSI or Unicode characters, depending on the operating system where
   the code is executing. On Windows 98, the characters are copied as ANSI
   characters. On Windows NT 4.0, Windows 2000, Windows XP, and the Windows .NET Server family,
   the characters are copied as Unicode characters.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.PtrToStringAuto"/>
	</doc>
	<doc for="Marshal.StringToBSTR">
		<summary>
			<para>Allocates a BSTR and copies the contents of a managed <see cref="System.String"/> into it.</para>
		</summary>
		<param name="s">The managed string to be copied.</param>
		<returns>
			<para> An unmanaged pointer to the BSTR, or
      0 if <see langword="null"/> string was supplied.</para>
		</returns>
		<exception cref="System.OutOfMemoryException">There is insufficient memory available.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.StringToBSTR"/> is useful for custom
   marshaling or when mixing managed and unmanaged code. Since this method allocates
   the unmanaged memory required for a string, always free the BSTR
   when finished by calling <see cref="System.Runtime.InteropServices.Marshal.FreeBSTR" qualify="true"/>. This method
   provides the opposite
   functionality of <see cref="System.Runtime.InteropServices.Marshal.PtrToStringBSTR" qualify="true"/>. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.PtrToStringBSTR"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.FreeBSTR"/>
	</doc>
	<doc for="Marshal.SizeOf">
		<overload>
			<para> Returns the unmanaged size, in bytes, of a class using <see cref="System.Runtime.InteropServices.Marshal"/>.</para>
		</overload>
		<summary>
			<para> Returns the unmanaged size of an object in bytes.</para>
		</summary>
		<param name="structure">The object whose size is to be returned.</param>
		<returns>
			<para>The size of the <paramref name="structure"/>
parameter in unmanaged code.</para>
		</returns>
		<exception cref="System.ArgumentException"><para>
				<paramref name="structure"/> is not a <see cref="System.Runtime.InteropServices.Marshal"/> class.</para>
			<para>-or-</para>
			<para>
				<paramref name="structure"/> is an array type.</para></exception>
		<exception cref="System.NullReferenceException"><paramref name="structure"/> is <see langword="null"/>.</exception>
		<remarks>
			<para> This method accepts an instance of a structure, which can
      be a reference type or a boxed value type. The layout must be sequential or explicit.</para>
			<para> The size returned is the size of the unmanaged object. The unmanaged and managed
      sizes of an object can differ. For character types, the size is affected by the <see cref="System.Runtime.InteropServices.CharSet"/> value
      applied to that class.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.CharSet"/>
	</doc>
	<doc for="Marshal.SizeOf1">
		<summary>
			<para> Returns the size of an unmanaged type in bytes.</para>
		</summary>
		<param name="t">The <see cref="System.Type"/> whose size is to be returned.</param>
		<returns>
			<para>The size of the <paramref name="structure"/>
parameter in unmanaged code.</para>
		</returns>
		<exception cref="System.ArgumentException"><para><paramref name="structure"/> is not a <see cref="System.Runtime.InteropServices.Marshal"/> class object.</para>
			<para>-or-</para>
			<para><paramref name="structure"/> is an array type.</para></exception>
		<exception cref="System.NullReferenceException"><paramref name="structure"/> is <see langword="null"/>.</exception>
		<remarks>
			<para>You can use this method when you do not have a structure. The layout must be
      sequential or explicit.</para>
			<para> The size returned is the actually the size of the unmanaged type. The unmanaged and managed sizes of an object can differ.
      For character types, the size is affected by the <see cref="System.Runtime.InteropServices.CharSet"/> value applied to that class.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.CharSet"/>
	</doc>
	<doc for="Marshal.OffsetOf">
		<summary>
			<para>Returns the field offset of the unmanaged form of the managed
      class.</para>
		</summary>
		<param name="t">A <see cref="System.Type"/>, specifying the specified class. You must apply the <see cref="System.Runtime.InteropServices.StructLayoutAttribute"/> to the class.</param>
		<param name="fieldName">The field within the <paramref name="t"/> parameter.</param>
		<returns>
			<para>The offset, in bytes, for the <paramref name="fieldName"/> parameter within the platform
   invoke declared class <paramref name="t"/>.</para>
		</returns>
		<exception cref="System.ArgumentException">The class cannot be exported as a structure or the field is nonpublic.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.OffsetOf"/> provides the offset in terms of the unmanaged structure layout,
   which does not necessarily correspond to the offset of the managed structure
   layout. Marshaling the can transform the layout and alter the
   offset. The <paramref name="t"/> parameter can be a value type or a formatted reference type (with
   either a sequential or explicit layout). You can obtain the size of the entire
   layout by using the <see cref="System.Runtime.InteropServices.Marshal.SizeOf" qualify="true"/> method. For additional information, see <see topic="cpcondefaultmarshalingforvaluetypes"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.SizeOf"/>
	</doc>
	<doc for="Marshal.UnsafeAddrOfPinnedArrayElement">
		<summary>
			<para>Gets the address of the element at the specified
      index
      inside the specified array.</para>
		</summary>
		<param name="arr">The <see cref="System.Array"/> containing the desired element.</param>
		<param name=" index">The index in the <paramref name="arr"/> parameter of the desired element.</param>
		<returns>
			<para>The address of <paramref name="index"/> inside
<paramref name="arr"/>.</para>
		</returns>
		<remarks>
			<para>The array must be pinned using
      a <see cref="System.Runtime.InteropServices.GCHandle"/> before it is passed to this
      method. For maximum performance, this method does no validation on the array
      passed to it; this can result in unexpected
      behavior.</para>
			<note type="note">
      This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
      being called from untrusted code; only the immediate caller is required to have
   <see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
   permission. If your code can be called from partially trusted code, do not pass
   user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
   validation. For important limitations on using the <see langword="LinkDemand"/>
   member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.GCHandle"/>
	</doc>
	<doc for="Marshal.Copy1">
		<overload>
			<para>Copies data from a managed array to an unmanaged memory pointer.</para>
		</overload>
		<summary>
			<para>Copies data from a one-dimensional, managed 32-bit signed integer array to an unmanaged
      memory pointer.</para>
		</summary>
		<param name="source">The one-dimensional array to copy from.</param>
		<param name=" startIndex">The zero-based index into the array where <see langword="Copy"/> should start.</param>
		<param name=" destination">The memory pointer to copy to.</param>
		<param name=" length">The number of array elements to copy.</param>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="startIndex"/> and <paramref name="length"/> are not valid.</exception>
		<remarks>
			<para>You can use this method to copy a subset of a one-dimensional, .NET-based
      array to an unmanaged C-style array.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para>The following example demonstrates how to copy a one-dimensional array to an
      unmanaged memory pointer.</para>
			<code lang="VB">Public Overloads Shared Sub Copy(source As IntPrt(), _
  startIndex As Integer, destination As IntPtr, length As Integer)
      </code>
			<code lang="C#">public static void Copy(IntPtr[] source, int startIndex, 
  IntPtr destination, int length);
      </code>
		</example>
	</doc>
	<doc for="Marshal.Copy3">
		<summary>
			<para>Copies data from a one-dimensional, managed character array to an unmanaged memory
      pointer.</para>
		</summary>
		<param name="source">The one-dimensional array to copy from.</param>
		<param name=" startIndex">The zero-based index into the array where <see langword="Copy"/> should start.</param>
		<param name=" destination">The memory pointer to copy to.</param>
		<param name=" length">The number of array elements to copy.</param>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="startIndex"/> and <paramref name="length"/> are not valid.</exception>
		<remarks>
			<para>You can use this method to copy a subset of a one-dimensional, .NET-based
      array to an unmanaged C-style array.</para>
			<note type="note">
      This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
      being called from untrusted code; only the immediate caller is required to have
   <see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
   permission. If your code can be called from partially trusted code, do not pass
   user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
   validation. For important limitations on using the <see langword="LinkDemand"/>
   member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para>The following example demonstrates how to copy a one-dimensional array to an
      unmanaged memory pointer.</para>
			<code lang="VB">Public Overloads Shared Sub Copy(source As Char(), _
  startIndex As Integer, destination As IntPtr, length As Integer)
   </code>
			<code lang="C#">public static void Copy(char[] source, int startIndex, 
  IntPtr destination, int length);
   </code>
		</example>
	</doc>
	<doc for="Marshal.Copy5">
		<summary>
			<para>Copies data from a one-dimensional, managed 16-bit signed
      integer array to an unmanaged memory pointer.</para>
		</summary>
		<param name="source">The one-dimensional array to copy from.</param>
		<param name=" startIndex">The zero-based index into the array where <see langword="Copy"/> should start.</param>
		<param name=" destination">The memory pointer to copy to.</param>
		<param name=" length">The number of array elements to copy.</param>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="startIndex"/> and <paramref name="length"/> are not valid.</exception>
		<remarks>
			<para>You can use this method to copy a subset of a one-dimensional, .NET-based
      array to an unmanaged C-style array.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para>The following example demonstrates how to copy a one-dimensional array to an
      unmanaged memory pointer.</para>
			<code lang="VB">Public Overloads Shared Sub Copy(source As Short(), _
  startIndex As Integer, destination As IntPtr, length As Integer)
      </code>
			<code lang="C#">public static void Copy(short[] source, int startIndex, 
  IntPtr destination, int length);
      </code>
		</example>
	</doc>
	<doc for="Marshal.Copy7">
		<summary>
			<para>Copies data from a one-dimensional, managed 64-bit signed integer array to
      an unmanaged memory pointer.</para>
		</summary>
		<param name="source">The one-dimensional array to copy from.</param>
		<param name=" startIndex">The zero-based index into the array where <see langword="Copy"/> should start.</param>
		<param name=" destination">The memory pointer to copy to.</param>
		<param name=" length">The number of array elements to copy.</param>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="startIndex"/> and <paramref name="length"/> are not valid.</exception>
		<remarks>
			<para>You can use this method to copy a subset of a one-dimensional, .NET-based
      array to an unmanaged C-style array.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para>The following example demonstrates how to copy a one-dimensional array to an
      unmanaged memory pointer.</para>
			<code lang="VB">Public Overloads Shared Sub Copy(source As Long(), _
  startIndex As Integer, destination As IntPtr, length As Integer)
      </code>
			<code lang="C#">public static void Copy(long[] source, int startIndex, 
  IntPtr destination, int length);
      </code>
		</example>
	</doc>
	<doc for="Marshal.Copy9">
		<summary>
			<para>Copies data from a one-dimensional, managed single-precision floating-point number array
      to an unmanaged memory pointer.</para>
		</summary>
		<param name="source">The one-dimensional array to copy from.</param>
		<param name=" startIndex">The zero-based index into the array where <see langword="Copy"/> should start.</param>
		<param name=" destination">The memory pointer to copy to.</param>
		<param name=" length">The number of array elements to copy.</param>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="startIndex"/> and <paramref name="length"/> are not valid.</exception>
		<remarks>
			<para>You can use this method to copy a subset of a one-dimensional, .NET-based
      array to an unmanaged C-style array.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para>The following example demonstrates how to copy a one-dimensional array to an
      unmanaged memory pointer.</para>
			<code lang="VB">Public Overloads Shared Sub Copy(source As Single(), _
  startIndex As Integer, destination As IntPtr, length As Integer)
      </code>
			<code lang="C#">public static void Copy(float[] source, int startIndex, 
  IntPtr destination, int length);
      </code>
		</example>
	</doc>
	<doc for="Marshal.Copy11">
		<summary>
			<para>Copies data from a one-dimensional, managed double-precision floating-point number array to an unmanaged memory pointer.</para>
		</summary>
		<param name="source">The one-dimensional array to copy from.</param>
		<param name=" startIndex">The zero-based index into the array where <see langword="Copy"/> should start.</param>
		<param name=" destination">The memory pointer to copy to.</param>
		<param name=" length">The number of array elements to copy.</param>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="startIndex"/> and <paramref name="length"/> are not valid.</exception>
		<remarks>
			<para>You can use this method to copy a subset of a one-dimensional, .NET-based
      array to an unmanaged C-style array.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para>The following example demonstrates how to copy a one-dimensional array to an
      unmanaged memory pointer.</para>
			<code lang="VB">Public Overloads Shared Sub Copy(source As Double(), _
  startIndex As Integer, destination As IntPtr, length As Integer)
      </code>
			<code lang="C#">public static void Copy(double[] source, int startIndex, 
  IntPtr destination, int length);
      </code>
		</example>
	</doc>
	<doc for="Marshal.Copy12">
		<summary>
			<para>Copies data from a one-dimensional, managed 8-bit unsigned integer array to an unmanaged memory pointer.</para>
		</summary>
		<param name="source">The one-dimensional array to copy from.</param>
		<param name=" startIndex">The zero-based index into the array where <see langword="Copy"/> should start.</param>
		<param name=" destination">The memory pointer to copy to.</param>
		<param name=" length">The number of array elements to copy.</param>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="startIndex"/> and <paramref name="length"/> are not valid.</exception>
		<remarks>
			<para>You can use this method to copy a subset of a one-dimensional, .NET-based
      array to an unmanaged C-style array.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para>The following example demonstrates how to copy a one-dimensional array to an
      unmanaged memory pointer.</para>
			<code lang="VB">Public Overloads Shared Sub Copy(source As Byte(), _
  startIndex As Integer, destination As IntPtr, length As Integer)
      </code>
			<code lang="C#">public static void Copy(byte[] source, int startIndex, 
  IntPtr destination, int length);
      </code>
		</example>
	</doc>
	<doc for="Marshal.Copy14">
		<summary>
			<para>Copies data from an unmanaged memory pointer to a
      managed 32-bit signed integer array.</para>
		</summary>
		<param name="source">The memory pointer to copy from.</param>
		<param name=" destination">The array to copy to.</param>
		<param name=" startIndex">The zero-based index into the array where <see langword="Copy"/> should start.</param>
		<param name=" length">The number of array elements to copy.</param>
		<remarks>
			<para> Unmanaged, C-style arrays do not contain bounds information, which
      prevents the <paramref name="startIndex"/> and <paramref name="length"/> parameters from being validated. Thus, the
      unmanaged data corresponding to the <paramref name="source"/> parameter populates the managed array
      regardless of its usefulness. You must initalize the managed array with the
      appropriate size before calling the <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/> method.</para>
			<note type="note">
      This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
      being called from untrusted code; only the immediate caller is required to have
   <see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
   permission. If your code can be called from partially trusted code, do not pass
   user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
   validation. For important limitations on using the <see langword="LinkDemand"/>
   member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para> The following example demonstrates how to copy data from an unmanaged memory pointer into
      a managed array.</para>
			<code lang="VB">Public Overloads Shared Sub Copy(source As IntPtr, _
  destination As Integer(), startIndex As Integer, length As Integer)
   </code>
			<code lang="C#">public static void Copy(IntPtr source, int[] destination, 
  int startIndex, int length);
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.Copy16">
		<summary>
			<para>Copies data from an unmanaged memory pointer to a
      managed character array.</para>
		</summary>
		<param name="source">The memory pointer to copy from.</param>
		<param name=" destination">The array to copy to.</param>
		<param name=" startIndex">The zero-based index into the array where <see langword="Copy"/> should start.</param>
		<param name=" length">The number of array elements to copy.</param>
		<remarks>
			<para>Unmanaged, C-style arrays do not contain bounds information,
      which prevents the <paramref name="startIndex"/> and <paramref name="length"/> parameters from being validated.
      Thus, the unmanaged data corresponding to the <paramref name="source"/>
      parameter populates the managed array
      regardless of its usefulness. You must initalize the managed array with the
      appropriate size before calling the <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>
      method.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para> The following example demonstrates how to copy data
      from an unmanaged memory pointer into a managed array.</para>
			<code lang="VB">Public Overloads Shared Sub Copy(source As IntPtr, _
  destination As Char(), startIndex As Integer, length As Integer)
      </code>
			<code lang="C#">public static void Copy(IntPtr source, char[] destination, 
  int startIndex, int length);
      </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.Copy18">
		<summary>
			<para>Copies data from an unmanaged memory pointer to a
      managed 16-bit signed integer array.</para>
		</summary>
		<param name="source">The memory pointer to copy from.</param>
		<param name=" destination">The array to copy to.</param>
		<param name=" startIndex">The zero-based index into the array where <see langword="Copy"/> should start.</param>
		<param name=" length">The number of array elements to copy.</param>
		<remarks>
			<para>Unmanaged, C-style arrays do not contain bounds
      information, which prevents the <paramref name="startIndex"/> and <paramref name="length"/> parameters from being validated.
      Thus, the unmanaged data corresponding to the <paramref name="source"/>
      parameter populates the managed array
      regardless of its usefulness. You must initalize the managed array with the
      appropriate size before calling the <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>
      method.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para> The following example demonstrates how to copy data
      from an unmanaged memory pointer into a managed array.</para>
			<code lang="VB">Public Overloads Shared Sub Copy(source As IntPtr, _
  destination As Short(), startIndex As Integer, length As Integer)
      </code>
			<code lang="C#">public static void Copy(IntPtr source, short[] destination, 
  int startIndex, int length);
      </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.Copy20">
		<summary>
			<para>Copies data from an unmanaged memory pointer to a
      managed 64-bit signed integer array.</para>
		</summary>
		<param name=" source">The memory pointer to copy from.</param>
		<param name=" destination">The array to copy to.</param>
		<param name=" startIndex">The zero-based index into the array where <see langword="Copy"/> should start.</param>
		<param name=" length">The number of array elements to copy.</param>
		<remarks>
			<para>Unmanaged, C-style arrays do not contain bounds
      information, which prevents the <paramref name="startIndex"/> and <paramref name="length"/> parameters from being
      validated. Thus, the unmanaged data corresponding to the <paramref name="source"/> parameter populates the managed array
      regardless of its usefulness. You must initalize the managed array with the
      appropriate size before calling the <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>
      method.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para> The following example demonstrates how to copy data from an unmanaged
      memory pointer into a managed array.</para>
			<code lang="VB">Public Overloads Shared Sub Copy(source As IntPtr, _
  destination As Long(), startIndex As Integer, length As Integer)
      </code>
			<code lang="C#">public static void Copy(IntPtr source, long[] destination, 
  int startIndex, int length);
      </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.Copy21">
		<summary>
			<para>Copies data from an unmanaged memory pointer to a
      managed single-precision floating-point number array.</para>
		</summary>
		<param name="source">The memory pointer to copy from.</param>
		<param name=" destination">The array to copy to.</param>
		<param name=" startIndex">The zero-based index into the array where <see langword="Copy"/> should start.</param>
		<param name=" length">The number of array elements to copy.</param>
		<remarks>
			<para>Unmanaged, C-style arrays do not contain bounds
      information, which prevents the <paramref name="startIndex"/> and <paramref name="length "/> parameters from being
      validated. Thus, the unmanaged data corresponding to the <paramref name="source"/> parameter populates the managed array
      regardless of its usefulness. You must initalize the managed array with the
      appropriate size before calling the <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/> method.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para> The following example demonstrates how to copy data from an unmanaged
      memory pointer into a managed array.</para>
			<code lang="VB">Public Overloads Shared Sub Copy(source As IntPtr, _
  destination As Single(), startIndex As Integer, length As Integer)
      </code>
			<code lang="C#">public static void Copy(IntPtr source, float[] destination, 
  int startIndex, int length);
      </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.Copy23">
		<summary>
			<para>Copies data from an unmanaged memory pointer to a
      managed double-precision floating-point number array.</para>
		</summary>
		<param name="source">The memory pointer to copy from.</param>
		<param name=" destination">The array to copy to.</param>
		<param name=" startIndex">The zero-based index into the array where <see langword="Copy"/> should start.</param>
		<param name=" length">The number of array elements to copy.</param>
		<remarks>
			<para>Unmanaged, C-style arrays do not contain bounds
      information, which prevents the <paramref name="startIndex"/> and <paramref name="length"/> parameters from being
      validated. Thus, the unmanaged data corresponding to the <paramref name="source"/> parameter populates the managed array
      regardless of its usefulness. You must initalize the managed array with the
      appropriate size before calling the <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/> method.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para> The following example demonstrates how to copy data from an unmanaged
      memory pointer into a managed array.</para>
			<code lang="VB">Public Overloads Shared Sub Copy(source As IntPtr, _
  destination As Double(), startIndex As Integer, length As Integer)
      </code>
			<code lang="C#">public static void Copy(IntPtr source, double[] destination, 
  int startIndex, int length);
      </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.Copy24">
		<summary>
			<para>Copies data from an unmanaged memory pointer to a
      managed 8-bit unsigned integer
      array.</para>
		</summary>
		<param name="source">The memory pointer to copy from.</param>
		<param name="destination">The array to copy to.</param>
		<param name="startIndex">The zero-based index into the array where <see langword="Copy"/> should start.</param>
		<param name="length">The number of array elements to copy.</param>
		<remarks>
			<para>Unmanaged, C-style arrays do not contain bounds
      information, which prevents the <paramref name="startIndex"/> and <paramref name="length"/> parameters from being
      validated. Thus, the unmanaged data corresponding to the <paramref name="source"/> parameter populates the managed array
      regardless of its usefulness. You must initalize the managed array with the
      appropriate size before calling the <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/> method.</para>
			<note type="note">
      This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
      being called from untrusted code; only the immediate caller is required to have
   <see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
   permission. If your code can be called from partially trusted code, do not pass
   user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
   validation. For important limitations on using the <see langword="LinkDemand"/>
   member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para> The following example demonstrates how to copy data from an unmanaged
      memory pointer into a managed array.</para>
			<code lang="VB">Public Overloads Shared Sub Copy(source As IntPtr, _
  destination As Byte(), startIndex As Integer, length As Integer)
   </code>
			<code lang="C#">public static void Copy(IntPtr source, byte[] destination, 
  int startIndex, int length);
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.ReadByte">
		<overload>
			<para>Reads a single byte at a given offset (or index) from
      an unmanaged pointer.</para>
		</overload>
		<summary>
			<para>Reads a single byte from an unmanaged pointer.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory of the source object. </param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before reading. </param>
		<returns>
			<para>The byte read from the <paramref name="ptr"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReadByte"/> enables direct interaction with an unmanaged
   C-style byte array, eliminating the expense of copying an entire unmanaged
   array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate
   managed array before reading its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.ReadByte1">
		<summary>
			<para>Reads a single byte at a given offset (or index) from an unmanaged pointer.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory from which to read.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before reading.</param>
		<returns>
			<para>The byte read from the <paramref name="ptr"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReadByte"/> enables direct interaction with an unmanaged
   C-style byte array, eliminating the expense of copying an entire unmanaged
   array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate
   managed array before reading its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<example>
			<para>The following example compares two ways of interacting with an
      unmanaged C-style byte array. The <see cref="System.Runtime.InteropServices.Marshal.ReadByte"/> method provides
      direct access to the element values of the array.</para>
			<code lang="VB">Dim unmanagedArray As IntPtr = ...
Dim i As Integer

' One way to print the 10 elements of the C-style unmanagedArray
Dim newArray As Byte(9)
Marshal.Copy(unmanagedArray, newArray, 0, 10)
For i = 0 To newArray.Length
  Console.WriteLine(newArray(i))
Next i

' Another way to print the 10 elements of the C-style unmanagedArray
For i = 0 To 10
  Console.WriteLine(Marshal.ReadByte(unmanagedArray, i))
Next i
      </code>
			<code lang="C#">IntPtr unmanagedArray = ...;

// One way to print the 10 elements of the C-style unmanagedArray
byte [] newArray = new byte[10];
Marshal.Copy(unmanagedArray, newArray, 0, 10);
for (int i = 0; i &lt; newArray.Length; i++)
  Console.WriteLine(newArray[i]);

// Another way to print the 10 elements of the C-style unmanagedArray
for (int i = 0; i &lt; 10; i++)
  Console.WriteLine(Marshal.ReadByte(unmanagedArray, i));
      </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.ReadByte2">
		<overload>
			<para> Reads a single byte from an unmanaged pointer.
      </para>
		</overload>
		<summary>
			<para> Reads a single byte from an unmanaged pointer.
      </para>
		</summary>
		<param name="ptr">The address in unmanaged memory from which to read. </param>
		<returns>
			<para>The byte read from the <paramref name="ptr"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReadByte"/> has an implied offset of 0. This method enables direct interaction with an unmanaged C-style byte array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a
   separate managed array before reading its element
   values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.ReadInt162">
		<overload>
			<para> Reads a 16-bit signed integer from unmanaged memory.
      </para>
		</overload>
		<summary>
			<para> Reads a 16-bit signed integer from the unmanaged memory.
      </para>
		</summary>
		<param name="ptr">The address in unmanaged memory from which to read. </param>
		<returns>
			<para>The 16-bit signed integer read from the
      <paramref name="ptr"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReadInt16"/> has an implied offset of 0. This method enables direct interaction with an unmanaged C-style Int16 array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before reading its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.ReadInt322">
		<overload>
			<para> Reads a 32-bit signed integer from unmanaged memory.
      </para>
		</overload>
		<summary>
			<para> Reads a 32-bit signed integer from unmanaged memory.
      </para>
		</summary>
		<param name="ptr">The address in unmanaged from which to read. </param>
		<returns>
			<para>The 32-bit signed integer read from the
      <paramref name="ptr"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReadInt32"/> has an implied offset of 0. This method enables direct interaction with an unmanaged C-style Int32 array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before reading its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/> .</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.ReadIntPtr">
		<overload>
			<para>Reads a processor native sized
      integer from the unmanaged memory.</para>
		</overload>
		<summary>
			<para> Reads a processor native sized integer from unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory of the source object.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before reading.</param>
		<returns>
			<para>The <see langword="IntPtr"/> read from the <paramref name="ptr"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReadIntPtr"/> enables direct interaction with an unmanaged C-style IntPtr array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before reading its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.ReadIntPtr1">
		<summary>
			<para> Reads a processor native sized integer from unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory from which to read.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before reading.</param>
		<returns>
			<para>The <see langword="IntPtr"/> read from the <paramref name="ptr"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReadIntPtr"/> enables direct interaction with an unmanaged C-style IntPtr array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before reading its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/> .</para></permission>
		<example>
			<para> The following example compares two ways of interacting with
      an unmanaged C-style IntPtr array. The <see cref="System.Runtime.InteropServices.Marshal.ReadIntPtr"/>
      method provides direct access to the array's element values.</para>
			<code lang="VB">Dim unmanagedArray As IntPtr = ...
Dim i As Integer

' One way to print the 10 elements of the C-style unmanagedArray
Dim newArray As IntPtr(9)
Marshal.Copy(unmanagedArray, newArray, 0, 10)
For i = 0 To newArray.Length
  Console.WriteLine(newArray(i))
Next i

' Another way to print the 10 elements of the C-style unmanagedArray
For i = 0 To 10
  Console.WriteLine(Marshal.ReadIntPtr(unmanagedArray, i))
Next i
      </code>
			<code lang="C#">IntPtr unmanagedArray = ...;

// One way to print the 10 elements of the C-style unmanagedArray
byte [] newArray = new IntPtr[10];
Marshal.Copy(unmanagedArray, newArray, 0, 10);

for (int i = 0; i &lt; newArray.Length; i++)
  Console.WriteLine(newArray[i]);

// Another way to print the 10 elements of the C-style unmanagedArray
for (int i = 0; i &lt; 10; i++)
  Console.WriteLine(Marshal.ReadIntPtr(unmanagedArray, i));
      </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.ReadByte"/>
	</doc>
	<doc for="Marshal.ReadIntPtr2">
		<overload>
			<para> Reads a processor native sized integer from unmanaged memory.
      </para>
		</overload>
		<summary>
			<para> Reads a processor native sized integer from unmanaged memory.
      </para>
		</summary>
		<param name="ptr">The address in unmanaged memory from which to read. </param>
		<returns>
			<para>The <see langword="IntPtr"/> read from the <paramref name="ptr"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReadIntPtr"/> has an implied offset of 0. This method enables direct interaction with an unmanaged C-style IntPtr array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before reading its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/> .</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.ReadInt642">
		<overload>
			<para> Reads a 64-bit signed integer from unmanaged memory.
      </para>
		</overload>
		<summary>
			<para> Reads a 64-bit signed integer from unmanaged memory.
      </para>
		</summary>
		<param name="ptr">The address in unmanaged memory from which to read. </param>
		<returns>
			<para>The 64-bit signed integer read from the
      <paramref name="ptr"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReadInt64"/> has an implied offset of 0. This method enables direct interaction with an unmanaged C-style Int64 array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before reading its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.WriteByte">
		<overload>
			<para> Writes a single byte value
      to unmanaged memory.</para>
		</overload>
		<summary>
			<para> Writes a single byte value to unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory from which to write.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before writing.</param>
		<param name="val">The value to write.</param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteByte"/> enables direct interaction with an unmanaged C-style byte array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>
   ) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<example>
			<para>The following example compares two ways of interacting with an unmanaged
      C-style byte array. The <see cref="System.Runtime.InteropServices.Marshal.WriteByte"/> method provides direct
      access to the element values of the array, setting its ten elements to the
      values 1 through 10.</para>
			<code lang="VB">Dim unmanagedArray As IntPtr = ...
Dim i As Integer

' One way to set the 10 elements of the C-style unmanagedArray
Dim newArray As Byte(9)
Marshal.Copy(unmanagedArray, newArray, 0, 10)
For i = 0 To newArray.Length
  newArray(i) = i+1
Next i
Marshal.Copy(newArray, 0, unmanagedArray, 10)

' Another way to set the 10 elements of the C-style unmanagedArray
For i = 0 To 10
  Marshal.WriteByte(unmanagedArray, i, i+1)
Next i
   </code>
			<code lang="C#">IntPtr unmanagedArray = ...;

// One way to set the 10 elements of the C-style unmanagedArray
byte [] newArray = new byte[10];
Marshal.Copy(unmanagedArray, newArray, 0, 10);
for (int i = 0; i &lt; newArray.Length; i++)
  newArray[i] = i+1;
Marshal.Copy(newArray, 0, unmanagedArray, 10);

// Another way to set the 10 elements of the C-style unmanagedArray
for (int i = 0; i &lt; 10; i++)
  Marshal.WriteByte(unmanagedArray, i, i+1);
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.WriteByte1">
		<summary>
			<para>Writes a single byte value to unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory of the target object.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before writing.</param>
		<param name="val">The value to write.</param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteByte"/> enables direct interaction with an unmanaged C-style byte array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>
   ) to a separate managed array before setting its element
   values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.WriteByte2">
		<overload>
			<para> Writes a single byte value to unmanaged memory.
      </para>
		</overload>
		<summary>
			<para> Writes a single byte value to unmanaged memory.
      </para>
		</summary>
		<param name="ptr">The address in unmanaged memory from which to write. </param>
		<param name="val">The value to write. </param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteByte"/> enables direct interaction with an unmanaged C-style byte array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>
   ) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.WriteIntPtr">
		<overload>
			<para> Writes a processor native
      sized integer value to unmanaged memory.</para>
		</overload>
		<summary>
			<para>Writes a processor native sized integer value to unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory from which to write.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before writing.</param>
		<param name="val">The value to write.</param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteIntPtr"/> enables direct interaction with an unmanaged C-style IntPtr array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para> The following example compares two ways of interacting with an
      unmanaged C-style IntPtr array. The <see cref="System.Runtime.InteropServices.Marshal.WriteIntPtr"/> method provides direct
      access to the element values of the array, setting its ten elements to the
      values 1 through 10.</para>
			<code lang="VB">Dim unmanagedArray As IntPtr = ...
Dim i As Integer

' One way to set the 10 elements of the C-style unmanagedArray
Dim newArray As IntPtr(9)
Marshal.Copy(unmanagedArray, newArray, 0, 10)
For i = 0 To newArray.Length
  newArray(i) = i+1
Next i
Marshal.Copy(newArray, 0, unmanagedArray, 10)

' Another way to set the 10 elements of the C-style unmanagedArray
For i = 0 To 10
  Marshal.WriteIntPtr(unmanagedArray, i, i+1)
Next i
      </code>
			<code lang="C#">IntPtr unmanagedArray = ...;

// One way to set the 10 elements of the C-style unmanagedArray
byte [] newArray = new IntPtr[10];
Marshal.Copy(unmanagedArray, newArray, 0, 10);
for (int i = 0; i &lt; newArray.Length; i++)
  newArray[i] = i+1;
Marshal.Copy(newArray, 0, unmanagedArray, 10);

// Another way to set the 10 elements of the C-style unmanagedArray
for (int i = 0; i &lt; 10; i++)
  Marshal.WriteIntPtr(unmanagedArray, i, i+1);
      </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.WriteByte"/>
	</doc>
	<doc for="Marshal.WriteIntPtr1">
		<summary>
			<para> Writes a processor native sized integer value to unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory of the target object.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before writing.</param>
		<param name="val">The value to write.</param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteIntPtr"/> enables direct interaction with an unmanaged C-style byte array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.WriteIntPtr2">
		<overload>
			<para> Writes a processor native sized integer value to unmanaged memory.
      </para>
		</overload>
		<summary>
			<para> Writes a processor native sized integer value into unmanaged memory.
      </para>
		</summary>
		<param name="ptr">The address in unmanaged memory from which to write. </param>
		<param name="val">The value to write. </param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteIntPtr"/> enables direct interaction with an unmanaged C-style IntPtr array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.GetHRForLastWin32Error">
		<summary>
			<para> Returns the HRESULT corresponding to the last
      error incurred by Win32 code executed using <see cref="System.Runtime.InteropServices.Marshal"/>.</para>
		</summary>
		<returns>
			<para>The HRESULT corresponding to the last Win32 error code.</para>
		</returns>
		<remarks>
			<para> The target function must have had the <see langword="setLastError"/> metadata flag set. For example,
   the <see langword="SetLastError"/> field of the <see cref="System.Runtime.InteropServices.DllImportAttribute" qualify="true"/> must be <see langword="true"/>.
   The process for this varies depending upon the source language used: C# and C++
   are <see langword="false"/> by default,
   but the <see langword="Declare"/> statement in Visual Basic is
<see langword="true"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.DllImportAttribute"/>
	</doc>
	<doc for="Marshal.Prelink">
		<summary>
			<para> Executes one-time method setup tasks
      without calling the method.</para>
		</summary>
		<param name="m">A <see cref="System.Reflection.MethodInfo" qualify="true"/> that identifies the method to be checked.</param>
		<remarks>
			<para> Setup tasks provide early initialization and are performed automatically when the target method is invoked. First-time tasks include:</para>
			<list type="bullet"><item>
					<term>
         Verifying that the platform invoke metadata is
         correctly formatted.</term>
				</item>
				<item>
					<term>
         Verifying that all the managed types are valid
         parameters of platform invoke functions.</term>
				</item>
				<item>
					<term>
         Locating and loading the unmanaged DLL into the
         process.</term>
				</item>
				<item>
					<term>
         Locating the entry point in the process.</term>
				</item>
			</list>
			<para>Calling <see cref="System.Runtime.InteropServices.Marshal.Prelink"/> on a method
outside of platform invoke has no effect. To execute setup tasks on
all platform invoke methods in a type, use <see cref="System.Runtime.InteropServices.Marshal.PrelinkAll" qualify="true"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para>The following example demonstrates
      using <see cref="System.Runtime.InteropServices.Marshal.Prelink"/> on an instance with a private
      static platform invoke signature for the <see langword="MessageBox"/>
      function from USER32.DLL.</para>
			<code lang="VB">' Get a MethodInfo for the Private Shared Sub
Dim mi As MethodInfo = obj.GetType().GetMethod("MessageBox", _
  BindingFlags.Static Or BindingFlags.NonPublic)

' Call Prelink using the MethodInfo instance
Marshal.Prelink(mi)
      </code>
			<code lang="C#">// Get a MethodInfo for the private static method
MethodInfo mi = obj.GetType().GetMethod("MessageBox",
  BindingFlags.Static | BindingFlags.NonPublic);

// Call Prelink using the MethodInfo instance
Marshal.Prelink(mi);
      </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.PrelinkAll"/>
		<seealso cref="System.Reflection.MethodInfo"/>
	</doc>
	<doc for="Marshal.PrelinkAll">
		<summary>
			<para> Performs a pre-link check for all methods
      on a class.</para>
		</summary>
		<param name="c"><para>A <see cref="System.Type"/> that identifies the class whose methods are to be checked.</para></param>
		<exception cref="System.ArgumentNullException"><paramref name="c "/>is not a valid type.</exception>
		<remarks>
			<para>The <see cref="System.Runtime.InteropServices.Marshal.PrelinkAll"/> method invokes <see cref="System.Runtime.InteropServices.Marshal.Prelink" qualify="true"/> on every method for a
   given type. <see cref="System.Runtime.InteropServices.Marshal.Prelink"/> executes one-time method setup
   tasks without calling each method. You can only use <see cref="System.Runtime.InteropServices.Marshal.PrelinkAll"/> for platform invoke calls.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para>The following example demonstrates how to use <see cref="System.Runtime.InteropServices.Marshal.PrelinkAll"/>.</para>
			<code lang="VB">Marshal.PrelinkAll(obj.GetType())
</code>
			<code lang="C#">Marshal.PrelinkAll(obj.GetType());
</code>
			<para><c></c></para>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Prelink"/>
	</doc>
	<doc for="Marshal.NumParamBytes">
		<summary>
			<para> Calculates the number of bytes required to hold the parameters for
      the specified method.
      </para>
		</summary>
		<param name="m">A <see cref="System.Reflection.MethodInfo"/> that identifies the method to be checked. </param>
		<returns>
			<para> The number of bytes required.
      </para>
		</returns>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.NumParamBytes"/> is exposed for complier support only.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
	</doc>
	<doc for="Marshal.GetExceptionPointers">
		<summary>
			<para> Retrieves a computer-independent description
      of an exception, and information about the state that existed for the thread
      when the exception occurred.</para>
		</summary>
		<returns>
			<para>An <see cref="System.IntPtr"/> to an
<see langword="EXCEPTION_POINTERS"/> structure.</para>
		</returns>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.GetExceptionPointers"/> is exposed
   for complier support of structured exception handling (SEH) only.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
	</doc>
	<doc for="Marshal.GetExceptionCode">
		<summary>
			<para>Retrieves a code that identifies the type of the exception that occurred.</para>
		</summary>
		<returns>
			<para> The type of the exception.
      </para>
		</returns>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.GetExceptionCode"/> is exposed for complier support of structured exception handling
   (SEH) only. If called before an exception is thrown, this method returns
   0xCCCCCCCC.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
	</doc>
	<doc for="Marshal.GetTypeLibName">
		<summary>
			<para>Retrieves the name of a type library.</para>
		</summary>
		<param name="pTLB">A <see cref="System.Runtime.InteropServices.UCOMITypeLib"/> that represents an <see langword="ITypeLib"/> pointer.</param>
		<returns>
			<para>The name of the type library pointed to by the <paramref name="pTLB"/> parameter.</para>
		</returns>
		<remarks>
			<para>The name returned by this method is the identifier used with the library statement, such as ADODB for the Microsoft
      ADO type library. The name is not a file name. </para>
			<para>You can also retrieve the type library name by calling the <see cref="System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation" qualify="true"/> method and passing
   a
   -1 for its first parameter.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.UCOMITypeLib.GetDocumentation"/>
	</doc>
	<doc for="Marshal.GetTypeLibGuid">
		<summary>
			<para>Retrieves the library identifier (LIBID) of a type library.</para>
		</summary>
		<param name="pTLB">A <see cref="System.Runtime.InteropServices.UCOMITypeLib"/> that represents an <see langword="ITypeLib"/> pointer.</param>
		<returns>
			<para>The LIBID (that is, the <see cref="System.Guid"/>) of the type library pointed to by the
<paramref name="pTLB"/> parameter.</para>
		</returns>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.GetTypeLibGuid"/> extracts the LIBID directly from an existing
   type library. This action differs from that of the <see cref="System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly" qualify="true"/> method, which calculates
   what the LIBID should be based on the current assembly. For
   additional information about <see langword="ITypeLib"/>, see the MSDN Library. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly"/>
		<seealso cref="System.Runtime.InteropServices.UCOMITypeLib"/>
	</doc>
	<doc for="Marshal.GetTypeLibLcid">
		<summary>
			<para>Retrieves the LCID of a type library.</para>
		</summary>
		<param name="pTLB">A <see cref="System.Runtime.InteropServices.UCOMITypeLib"/> that represents an <see langword="ITypeLib"/> pointer.</param>
		<returns>
			<para>The LCID of the type library pointed to by the <paramref name="pTLB"/> parameter.</para>
		</returns>
		<remarks>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.UCOMITypeLib"/>
	</doc>
	<doc for="Marshal.GetTypeLibGuidForAssembly">
		<summary>
			<para> Retrieves the library identifier (LIBID) that is assigned to a type
      library when it was exported from the specified assembly.</para>
		</summary>
		<param name="asm">A managed <see cref="System.Reflection.Assembly"/> .</param>
		<returns>
			<para> The LIBID (that is, the <see cref="System.Guid"/> ) that is assigned to a type library when it is exported
   from the <paramref name="asm"/> parameter.</para>
		</returns>
		<remarks>
			<para>When assemblies are exported to type libraries, the type
      library is assigned a LIBID. You can set the LIBID explicitly by applying
      the <see cref="System.Runtime.InteropServices.GuidAttribute" qualify="true"/> at the assembly level, or it can
      be generated automatically. The Type Library Exporter (Tlbexp.exe) calculates a
      LIBID value based on the identity of the assembly. <see cref="System.Runtime.InteropServices.Marshal.GetTypeLibGuid"/> returns the LIBID associated
      with the <see cref="System.Runtime.InteropServices.GuidAttribute"/>, if the attribute is applied.
      Otherwise, <see cref="System.Runtime.InteropServices.Marshal.GetTypeLibGuidForAssembly"/> returns the calculated
      value. Alternatively, you can use the <see cref="System.Runtime.InteropServices.Marshal.GetTypeLibGuid" qualify="true"/> method to extract the
      actual LIBID from
      
      an existing type library.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.GuidAttribute"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetTypeLibGuid"/>
	</doc>
	<doc for="Marshal.GetTypeInfoName">
		<summary>
			<para>Retrieves the name of the type represented by an
      <see langword="ITypeInfo"/>.</para>
		</summary>
		<param name="pTI">A <see cref="System.Runtime.InteropServices.UCOMITypeInfo"/> that represents an <see langword="ITypeInfo"/> pointer.</param>
		<returns>
			<para>The name of the type pointed to by the <paramref name="pTI"/> parameter. </para>
		</returns>
		<remarks>
			<para>You can also retrieve the name of the type represented by an
      <see langword="ITypeInfo"/> by
      calling the <see cref="System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation" qualify="true"/> method and passing
      a
      -1 for its first parameter. For additional information about <see langword="ITypeInfo"/>, see
      the MSDN Library.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.UCOMITypeInfo.GetDocumentation"/>
	</doc>
	<doc for="Marshal.GetIUnknownForObject">
		<summary>
			<para>Returns an <see langword="IUnknown "/>interface from a
   managed object.</para>
		</summary>
		<param name="o">The object whose <see langword="IUnknown"/> interface is requested.</param>
		<returns>
			<para>The <see langword="IUnknown"/>
pointer for
the <paramref name="o"/> parameter.</para>
		</returns>
		<remarks>
			<para>In managed code, you seldom work directly with the
      <see langword="IUnknown"/> interface. However, <see cref="System.Runtime.InteropServices.Marshal.GetIUnknownForObject"/> is useful when calling a
      method that exposes a COM object parameter as an <see cref="System.IntPtr"/> type, or with custom marshaling. Calling
      an object with this method causes the reference count to increment on the
      interface pointer before the pointer is returned. Always use <see cref="System.Runtime.InteropServices.Marshal.Release" qualify="true"/> to
      decrement the reference count once you have finished with the pointer. This
      method provides the opposite functionality of the <see cref="System.Runtime.InteropServices.Marshal.GetObjectForIUnknown" qualify="true"/> method. </para>
			<para>You can also use this method on a managed object to
      obtain an interface pointer to the COM callable wrapper for the object. For
      additional information, see <see topic="cpconcomcallablewrapper"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Release"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetObjectForIUnknown"/>
	</doc>
	<doc for="Marshal.GetIDispatchForObject">
		<summary>
			<para>Returns an <see langword="IDispatch"/> interface from a managed object.</para>
		</summary>
		<param name="o">The object whose <see langword="IDispatch"/> interface is requested.</param>
		<returns>
			<para>The <see langword="IDispatch"/>
pointer
for the <paramref name="o"/> parameter.</para>
		</returns>
		<exception cref="System.InvalidCastException"><paramref name="o "/>does not support the requested interface.</exception>
		<remarks>
			<para>In managed code, you seldom work directly with
      the <see langword="IDispatch"/> interface. However, <see cref="System.Runtime.InteropServices.Marshal.GetIDispatchForObject"/> is useful when calling a
      method that exposes a COM object parameter as an <see cref="System.IntPtr"/> type, or with custom marshaling. Calling an object with
      this method causes the reference count to increment on the interface pointer before
      the pointer is returned. Always use <see cref="System.Runtime.InteropServices.Marshal.Release" qualify="true"/>
      to decrement the reference count once you
      have finished with the pointer.</para>
			<para> You can also use this method on a managed object to
      obtain an interface pointer to the COM callable wrapper for the object. For
      additional information, see <see topic="cpconcomcallablewrapper"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Release"/>
	</doc>
	<doc for="Marshal.GetComInterfaceForObject">
		<summary>
			<para>Returns an <see langword="IUnknown "/> pointer representing the
   specified interface for an object.</para>
		</summary>
		<param name=" o">The object providing the interface.</param>
		<param name=" T">The <see cref="System.Type"/> of interface that is requested.</param>
		<returns>
			<para>The
      <see langword="IUnknown "/>pointer representing the interface for the object. </para>
		</returns>
		<exception cref="System.ArgumentException"><para><paramref name="t"/> is not an interface.</para>
			<para>-or- </para>
			<para>The type is not visible to COM.</para></exception>
		<exception cref="System.InvalidCastException"><paramref name="o "/>does not support the requested interface.</exception>
		<remarks>
			<para> This method returns an <see langword="IUnknown"/>
pointer that represents the requested interface on the specified
object. Calling an object with this method causes the reference count
to increment on the interface pointer before the pointer is returned.
Always use <see cref="System.Runtime.InteropServices.Marshal.Release" qualify="true"/> to decrement the reference count
once you have finished with the pointer. You must adhere to the rules defined by
COM when using raw COM interface pointers.</para>
			<para><see cref="System.Runtime.InteropServices.Marshal.GetComInterfaceForObject"/> is useful when
calling a method that exposes a COM object parameter as an <see cref="System.IntPtr"/> type, or with custom marshaling. Although less common,
you can use this method on a managed object to obtain a pointer to the object's
COM callable wrapper. For example, you can use <see cref="System.Runtime.InteropServices.Marshal.GetComInterfaceForObject"/> on a managed object that is
exported to COM to obtain an interface pointer for <see cref="System.Runtime.InteropServices.UCOMIConnectionPointContainer" qualify="true"/>. You cannot obtain a pointer to
a class interface since a class interface lacks the corresponding type to pass
to the second parameter (<paramref name="t"/>). Instead, use <see cref="System.Runtime.InteropServices.Marshal.GetIDispatchForObject" qualify="true"/>
to invoke the members on the default interface of the
COM callable wrapper, which is usually an auto-dispatch class
interface.</para>
			<para>For additional information on runtime callable
   wrappers and COM callable wrappers, see <see topic="cpconcomwrappers"/>. For additional information on class
   interfaces, see <see topic="cpconintroducingclassinterface"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.ComImportAttribute"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.Release"/>
		<seealso cref="System.Runtime.InteropServices.UCOMIConnectionPointContainer"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetIDispatchForObject"/>
	</doc>
	<doc for="Marshal.GetObjectForIUnknown">
		<summary>
			<para> Returns an instance of a type that represents a
      COM object by a pointer to its <see langword="IUnknown"/>
      interface.</para>
		</summary>
		<param name="pUnk">A pointer to the <see langword="IUnknown"/> interface.</param>
		<returns>
			<para>An object
      representing the specified unmanaged COM object.</para>
		</returns>
		<remarks>
			<para>This method calls <see cref="System.Runtime.InteropServices.Marshal.AddRef" qualify="true"/> before the pointer is
   returned. Always use <see cref="System.Runtime.InteropServices.Marshal.Release" qualify="true"/> to decrement the
   reference count once you have finished with the pointer.</para>
			<para>The first parameter, <paramref name="pUnk"/>, represents
an <see langword="IUnknown"/> interface pointer; however, because all COM
interfaces derive directly or indirectly from <see langword="IUnknown"/>, you can
pass any COM interface to this method. The object returned by <see cref="System.Runtime.InteropServices.Marshal.GetObjectForIUnknown"/> is a runtime callable wrapper,
which the common language runtime manages as it does any other managed object.
The type of this wrapper is often a
generic <see langword="System.__ComObject"/> type, which is a hidden type
used when the wrapper type is ambiguous. You can still make late-bound calls to
such a generic type as long as the COM object implements
the <see langword="IDispatch"/> interface. Likewise, you can cast the
returned object to an appropriate COM interface. For additional information, see
<see topic="cpconruntimecallablewrapper"/>.</para>
			<para> For an object to be wrapped with a specific managed class
   type (and not a generic wrapper type), you must adhere to the following
   requirements: </para>
			<list type="bullet"><item>
					<term>
      
      Implement
      the <see langword="IProvideClassInfo"/> interface for the COM object.</term>
				</item>
				<item>
					<term>
      
      Register the containing assembly with the Assembly Registration
      Tool (Regasm.exe).</term>
				</item>
			</list>
			<para>Alternatively, you can avoid these requirements and still
   get an object that is wrapped with a specific managed class type by using the
<see cref="System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown" qualify="true"/>
method.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.AddRef"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.Release"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown"/>
	</doc>
	<doc for="Marshal.GetTypedObjectForIUnknown">
		<summary>
			<para> Returns a managed object of a specified type
      that represents a COM object.</para>
		</summary>
		<param name="pUnk">A pointer to the <see langword="IUnknown"/> interface of the unmanaged object.</param>
		<param name="t">The <see cref="System.Type"/> of the requested managed class.</param>
		<returns>
			<para>An instance of the class corresponding to
      the <see cref="System.Type"/> object that represents the
      requested unmanaged COM object.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="t "/>is not attributed with <see cref="System.Runtime.InteropServices.ComImportAttribute" qualify="true"/>.</exception>
		<remarks>
			<para> The <paramref name="t"/> parameter must be either a COM-imported
   type or a subtype of a COM-imported type. In addition, <paramref name="t
   "/>must be a type whose metadata was imported by the Type
   Library Importer (Tlbimp.exe). This type must be a class and
   not an associated coclass interface, which carries the name of the COM class.
   For example, suppose Tlbimp.exe imports Myclass as a class called MyclassClass and
   a coclass interface called Myclass. Be sure to use MyclassClass, not Myclass
   with this method. For additional information about imported classes and
   coclass interfaces, see <see topic="cpcontlbimptypeconversion"/>.</para>
			<para> If an object has already been obtained for the <paramref name="pUnk"/> parameter, then <paramref name="t"/> is ignored and the existing object is returned. <paramref name="pUnk"/> represents an <see langword="IUnknown"/>
interface pointer; however, because all COM interfaces derive directly or
indirectly from <see langword="IUnknown"/>, you can pass any COM interface to
this method. The object returned by <see cref="System.Runtime.InteropServices.Marshal.GetTypedObjectForIUnknown"/> is a runtime callable
wrapper, which the common language runtime manages as it does any other managed
object. For additional information, see <see topic="cpconruntimecallablewrapper"/>. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.ComImportAttribute"/>
		<seealso topic="cpgrftypelibraryimportertlbimpexe"/>
	</doc>
	<doc for="Marshal.IsComObject">
		<summary>
			<para> Indicates whether a specified object represents a COM
      object.
      </para>
		</summary>
		<param name="o">The object to check. </param>
		<returns>
			<para><see langword="true"/> if the <paramref name="o"/> parameter is a COM type; otherwise, <see langword="false"/>.</para>
		</returns>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.IsComObject"/> returns <see langword="true"/> if the class type of the
   instance is attributed with <see cref="System.Runtime.InteropServices.ComImportAttribute" qualify="true"/> or if it derives directly or
   indirectly from a class attributed with <see cref="System.Runtime.InteropServices.ComImportAttribute"/>. The Type Library Importer (Tlbimp.exe) applies this attribute for you
   when it imports a type library. </para>
			<para> Two other methods also determine whether a
   specified object represents a COM object, but the requirements for returning
<see langword="true"/> differ from this method's 
   requirements. <see cref="System.Type.IsImport" qualify="true"/> returns
<see langword="true"/> 
if the class (or interface) is attributed with <see cref="System.Runtime.InteropServices.ComImportAttribute"/>
directly; it does not return <see langword="true"/>
for derived types. <see cref="System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType" qualify="true"/> returns
<see langword="true"/> if the type is attributed with <see cref="System.Runtime.InteropServices.ComImportAttribute"/> 
or derives from a
type with the same GUID.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.ComImportAttribute"/>
		<seealso cref="System.Type.IsImport"/>
		<seealso cref="System.Runtime.InteropServices.RegistrationServices.TypeRepresentsComType"/>
		<seealso topic="cpgrftypelibraryimportertlbimpexe"/>
	</doc>
	<doc for="Marshal.GetComObjectData">
		<summary>
			<para>Gets data referenced by the specified key from the specified COM
      object.</para>
		</summary>
		<param name="obj">The COM object containing the desired data.</param>
		<param name=" key">The key in the internal hash table of <paramref name="obj"/> to retrieve the data from.</param>
		<returns>
			<para>The data represented by the <paramref name="key"/> parameter in
   the internal hash table of the <paramref name="obj"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para><paramref name="obj"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para><paramref name="key"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><paramref name="obj"/> is not a COM object.</exception>
		<remarks>
			<para>All COM objects wrapped in a runtime callable wrapper
      have an associated hash table, which <see cref="System.Runtime.InteropServices.Marshal.GetComObjectData"/> retrieves. <see cref="System.Runtime.InteropServices.Marshal.SetComObjectData" qualify="true"/> adds data to the hash table. You should never have to call either method from your
      code. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.SetComObjectData"/>
	</doc>
	<doc for="Marshal.CreateWrapperOfType">
		<summary>
			<para> Wraps the specified COM object in
      an object of the specified type.</para>
		</summary>
		<param name="o">The object to be wrapped.</param>
		<param name=" t">The <see cref="System.Type"/> of wrapper to create.</param>
		<returns>
			<para>The newly wrapped object that is an instance of the desired type.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="t"/> must derive from <see langword="__ComObject"/>.</exception>
		<exception cref="System.InvalidCastException"><paramref name="o"/> cannot be converted to the destination type since it does not support all required interfaces.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.CreateWrapperOfType"/> converts one COM class type,
   typically the generic <see langword="__ComObject"/> type, to another COM
   class type. The input COM object, represented by parameter <paramref name="o"/>, is a runtime callable wrapper. If you are
   unfamiliar with this wrapper, see <see topic="cpconruntimecallablewrapper"/>.</para>
			<para> Both the <paramref name="t"/>
and <paramref name="o"/> parameters must be classes whose signatures are attributed
with <see cref="System.Runtime.InteropServices.ComImportAttribute" qualify="true"/>. The
Type Library Importer (Tlbimp.exe) applies this attribute
for you when it imports a type library. If you create the runtime callable
wrapper manually in source code, you should apply this attribute to the managed signature representing
the original coclass to signify its COM origins.</para>
			<para> Tlbimp.exe imports a COM
   coclass as a managed class and an interface. The coclass interface has the same name
   as the original coclass and the managed class has the original coclass name
   appended with Class. For example, a coclass called MyCoclass becomes a
   coclass interface called MyCoclass and a managed class called MyCoclassClass.
   Since <paramref name="t"/>
   
   must be a class, not an interface, be sure to specify the
   managed class (MyCoclassClass) and not the coclass interface.</para>
			<note type="note">
   You lose the identity of the
   input COM object because a new runtime callable wrapper instance wraps
   the <see langword="IUnknown"/> pointer exposed by the original runtime callable wrapper.
</note>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.ComImportAttribute"/>
	</doc>
	<doc for="Marshal.GetThreadFromFiberCookie">
		<summary>
			<para>Converts a fiber cookie into the
      corresponding <see cref="System.Threading.Thread" qualify="true"/>
      instance. </para>
		</summary>
		<param name="cookie">An integer representing a fiber cookie.</param>
		<returns>
			<para>A <see cref="System.Threading.Thread"/>
corresponding to the <paramref name="cookie"/> parameter.</para>
		</returns>
		<remarks>
			<para>Fiber cookies are opaque tokens that are used by the host when alerting the common language runtime to
      its fiber-scheduling decisions. They consist of a stack and register
      context.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Threading.Thread"/>
	</doc>
	<doc for="Marshal.IsTypeVisibleFromCom">
		<summary>
			<para>Indicates whether a type is visible to COM clients.</para>
		</summary>
		<param name="t">The <see cref="System.Type"/> to check for COM visibility.</param>
		<returns>
			<para><see langword="true "/>if the type
   is visible to COM; otherwise, <see langword="false"/>.</para>
		</returns>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.IsTypeVisibleFromCom"/> is useful because it enables you to
   check for COM visibility in one step. Types that are not visible cannot be used from COM. A
   type is visible if the type is <see langword="public"/>
   and is not otherwise
   hidden with the <see cref="System.Runtime.InteropServices.ComVisibleAttribute" qualify="true"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.ComVisibleAttribute"/>
	</doc>
	<doc for="Marshal.AddRef">
		<summary>
			<para> Increments the reference count on the specified interface.</para>
		</summary>
		<param name="pUnk">The interface reference count to increment. </param>
		<returns>
			<para>The new value of the reference count on the
      <paramref name="pUnk"/> parameter. </para>
		</returns>
		<remarks>
			<para> The common language runtime manages the reference count of a COM object for you, making
      it unnecessary to use this method directly. In rare cases, such as testing a custom
      marshaler, you might find it necessary to manipulate an object's lifetime
      manually. After calling <see cref="System.Runtime.InteropServices.Marshal.AddRef"/>, you must decrement the reference count by
      using a method such as <see cref="System.Runtime.InteropServices.Marshal.Release" qualify="true"/>. Do not rely on the
      return value of <see cref="System.Runtime.InteropServices.Marshal.AddRef"/>, as it can sometimes be unstable.</para>
			<para> You can call <see cref="System.Runtime.InteropServices.Marshal.GetComInterfaceForObject" qualify="true"/>, <see cref="System.Runtime.InteropServices.Marshal.GetIUnknownForObject" qualify="true"/>, or
<see cref="System.Runtime.InteropServices.Marshal.GetIDispatchForObject" qualify="true"/> to obtain an <see cref="System.IntPtr"/> value that 
   represents an <see langword="IUnknown"/> interface pointer. You can also use these
   methods and the <see cref="System.Runtime.InteropServices.Marshal.AddRef"/> method on managed
   objects to obtain the COM interfaces represented by the managed object's COM
   callable wrapper. If you are not familiar with the details this wrapper type,
   see <see topic="cpconcomcallablewrapper"/>. For additional information about <see langword="IUnknown::AddRef"/>, see the MSDN
   Library.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>. </para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Release"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.QueryInterface"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetComInterfaceForObject"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetIUnknownForObject"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetIDispatchForObject"/>
	</doc>
	<doc for="Marshal.Release">
		<summary>
			<para> Decrements the reference count on the specified
      interface.
      </para>
		</summary>
		<param name="pUnk">The interface to release. </param>
		<returns>
			<para>The new value of the reference count on the interface specified by the
      <paramref name="pUnk"/> parameter.</para>
		</returns>
		<remarks>
			<para>The common language runtime manages the reference count
      of a COM object for you, making it unnecessary to use this method directly. Use
      this value only for testing purposes. In rare cases, such as testing a custom
      marshaler, you might find it necessary to manipulate an object's lifetime
      manually. Only programs that call <see cref="System.Runtime.InteropServices.Marshal.AddRef" qualify="true"/> should call
      <see cref="System.Runtime.InteropServices.Marshal.Release"/>. Calling <see cref="System.Runtime.InteropServices.Marshal.Release"/>
   after the reference count has reached zero causes undefined behavior.</para>
			<para>You can call <see cref="System.Runtime.InteropServices.Marshal.GetComInterfaceForObject" qualify="true"/>, <see cref="System.Runtime.InteropServices.Marshal.GetIUnknownForObject" qualify="true"/>, or <see cref="System.Runtime.InteropServices.Marshal.GetIDispatchForObject" qualify="true"/> to obtain an <see cref="System.IntPtr"/> value that
represents a <see langword="IUnknown"/> interface pointer to release. You can
also use these methods and the <see cref="System.Runtime.InteropServices.Marshal.Release"/> method on managed objects
to release the COM interfaces represented by the managed object's COM callable
wrapper. If you are not familiar with the details of this wrapper type,
see <see topic="cpconcomcallablewrapper"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para> The following code example demonstrates the use of
      the <see cref="System.Runtime.InteropServices.Marshal.Release"/> method. This example uses
      <see cref="System.Runtime.InteropServices.Marshal.GetIUnknownForObject"/> to obtain an
      <see cref="System.IntPtr"/> value representing the COM
      object's <see langword="IUnknown"/> interface pointer.</para>
			<code lang="VB">Dim pUnk As IntPtr = Marshal.GetIUnknownForObject(myComObject)
Dim refCount As Integer = Marshal.Release(pUnk)
      </code>
			<code lang="C#">IntPtr pUnk = Marshal.GetIUnknownForObject(myComObject);
int refCount = Marshal.Release(pUnk);
      </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.AddRef"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.QueryInterface"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetComInterfaceForObject"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetIUnknownForObject"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetIDispatchForObject"/>
	</doc>
	<doc for="Marshal.StructureToPtr">
		<summary>
			<para>Marshals data from a managed object to an unmanaged
      block of memory.</para>
		</summary>
		<param name="structure">A managed object holding the data to be marshaled. This object must be an instance of a formatted class.</param>
		<param name="ptr">A pointer to an unmanaged block of memory, which must be allocated before this method is called.</param>
		<param name="fDeleteOld"><see langword="true"/> to have the <see cref="System.Runtime.InteropServices.Marshal.DestroyStructure" qualify="true"/> method called on the <paramref name="ptr"/> parameter before this method executes. Note that passing <see langword="false"/> can lead to a memory leak.</param>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.StructureToPtr"/> copies the contents of structure to the pre-allocated block
   of memory pointed to by the <paramref name="ptr"/> parameter. If the <paramref name="fDeleteOld"/>
   parameter is
<see langword="true"/>, the buffer originally pointed to by <paramref name="ptr"/> is deleted 
   with the appropriate delete API on the embedded
   pointer. This method cleans up every reference field specified in the mirrored managed
   class.</para>
			<para>Suppose your unmanaged block of memory is pointed to by
<paramref name="ptr"/>. The layout of this block is described
   by a corresponding managed class, <paramref name="structure"/>. <see cref="System.Runtime.InteropServices.Marshal.StructureToPtr"/>
   marshals field values from
   a structure to a
   pointer. Suppose the <paramref name="ptr"/> block
   includes a reference field, pointing to a string buffer currently holding "abc".
   Suppose the corresponding field on the managed side is a string holding "vwxyz".
   If you do not tell it otherwise, <see cref="System.Runtime.InteropServices.Marshal.StructureToPtr"/>
   
   allocates a new unmanaged
   buffer to hold "vwxyz", and hooks it up to the <paramref name="ptr"/>
   block. This action casts the old buffer "abc" adrift without freeing
   it back to the unmanaged heap. You end up with an orphan buffer that represents a
   memory leak in your code. If you set the <paramref name="fDeleteOld"/> parameter
   true, <see cref="System.Runtime.InteropServices.Marshal.StructureToPtr"/>
   frees the buffer holding "abc"
   before going on to allocate a new buffer for "vwxyz".</para>
			<note type="note">
   To pin an existing structure, instead of
   copying it, use the <see cref="System.Runtime.InteropServices.GCHandle" qualify="true"/> type to create a pinned handle
   for the structure. For details on how to pin, see <see topic="cpconcopyingpinning"/>.
</note>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para>As the following example demonstrates, <see cref="System.Runtime.InteropServices.Marshal.StructureToPtr"/> is useful for swapping one
   structure with another in the same memory location.</para>
			<code lang="VB">Dim IntPtr addressOfStructure1 As IntPtr = ...
Dim structure2 As TYPEATTR = ...
Marshal.StructureToPtr(structure2, addressOfStructure1, True)
</code>
			<code lang="C#">IntPtr addressOfStructure1 = ...;
TYPEATTR structure2 = ...;
Marshal.StructureToPtr(structure2, addressOfStructure1, true);
</code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.DestroyStructure"/>
		<seealso cref="System.Runtime.InteropServices.GCHandle"/>
	</doc>
	<doc for="Marshal.GetNativeVariantForObject">
		<summary>
			<para>Converts an object to a COM VARIANT.</para>
		</summary>
		<param name="obj">The object for which to get a COM VARIANT.</param>
		<param name=" pDstNativeVariant">An <see cref="System.IntPtr"/> to receive the VARIANT corresponding to the <paramref name="obj"/> parameter.</param>
		<remarks>
			<para>The <paramref name="pDstNativeVariant"/> parameter must point to sufficient memory to store the resulting
   VARIANT.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
	</doc>
	<doc for="Marshal.GetObjectForNativeVariant">
		<summary>
			<para>Converts a COM VARIANT to an object.</para>
		</summary>
		<param name="pSrcNativeVariant">An <see cref="System.IntPtr"/> containing a COM VARIANT.</param>
		<returns>
			<para>An object corresponding to the
      <paramref name="pSrcNativeVaraint"/> parameter.</para>
		</returns>
		<exception cref="System.Runtime.InteropServices.InvalidOleVariantTypeException"><paramref name="pSrcNativeVaraint"/> is not a valid VARIANT type. </exception>
		<exception cref="System.NotSupportedException"><paramref name="pSrcNativeVaraint"/> has an unsupported type.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant"/> returns a managed object corresponding to a
   raw pointer to an unmanaged VARIANT type. The interop marshaler performs the
   identical transformation when exposing a VARIANT type to managed
   code. <see cref="System.Runtime.InteropServices.Marshal.GetObjectForNativeVariant"/> provides the
   opposite functionality of <see cref="System.Runtime.InteropServices.Marshal.GetNativeVariantForObject" qualify="true"/>. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetNativeVariantForObject"/>
	</doc>
	<doc for="Marshal.GetObjectsForNativeVariants">
		<summary>
			<para>Converts an array of COM VARIANTs to an array of objects.</para>
		</summary>
		<param name="aSrcNativeVariant">An <see cref="System.IntPtr"/> containing the first element of an array of COM VARIANTs.</param>
		<param name=" cVars">The count of COM VARIANTs in <paramref name="aSrcNativeVariant"/>.</param>
		<returns>
			<para>An object array corresponding to
      <paramref name="aSrcNativeVariant"/>.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="cVars"/> cannot be a negative number.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.GetObjectsForNativeVariants"/> returns an array of managed objects corresponding to a raw pointer
   to a C-style array of unmanaged VARIANT types. The interop marshaler performs
   the identical transformation when exposing a VARIANT type to managed code.
   The method returns an empty array when the <paramref name="cVars"/> parameter is 0.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
	</doc>
	<doc for="Marshal.GetStartComSlot">
		<summary>
			<para>Gets the first slot in the virtual function table (VTBL) that contains user defined
      methods.</para>
		</summary>
		<param name="t">A <see cref="System.Type"/> representing an interface.</param>
		<returns>
			<para>The first VTBL (also called v-table) slot that contains user defined methods. The
      first slot is 3 if the interface is <see langword="IUnknown"/> based, and
      7 if the interface is <see langword="IDispatch"/> based.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="t "/>is not visible from COM.</exception>
		<remarks>
			<para>This method returns the zero-based v-table number for an interface or a
      class. When used on a class, the slot number returned refers to the class
      interface for the class. If the class interface is auto-dispatch, this method always
      returns -1 to indicate that the dispatch-only interface does not expose a
      v-table to managed clients. You can use <see cref="System.Runtime.InteropServices.Marshal.GetStartComSlot"/> and
      <see cref="System.Runtime.InteropServices.Marshal.GetEndComSlot" qualify="true"/> in conjunction with
      <see cref="System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot" qualify="true"/> to pass slots within a
      specified range. For additional information on class interfaces, see
      <see topic="cpconintroducingclassinterface"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetEndComSlot" qualify="true"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot" qualify="true"/>
	</doc>
	<doc for="Marshal.GetEndComSlot">
		<summary>
			<para>Gets the last slot in the virtual function table (VTBL)
      of a type when exposed to COM.</para>
		</summary>
		<param name="t">A <see cref="System.Type"/> representing an interface or class.</param>
		<returns>
			<para>The last VTBL (also called v-table) slot of the interface
      when exposed to COM. If the <paramref name="t"/>
      parameter is a
      class, the returned VTBL slot is the last slot in the interface that is generated
      from the class.</para>
		</returns>
		<remarks>
			<para> This method returns the zero-based, v-table number for an interface or
      a class. When used on a class, the slot number returned refers to the
      class interface for the class. If the class interface is auto-dual, this method
      always returns -1 to indicate that the dispatch-only interface does not expose
      a v-table to managed clients. You can use <see cref="System.Runtime.InteropServices.Marshal.GetEndComSlot"/> and <see cref="System.Runtime.InteropServices.Marshal.GetStartComSlot" qualify="true"/> in conjunction with <see cref="System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot" qualify="true"/> to pass slots within a
      specified range. For additional information on class interfaces, see
      <see topic="cpconintroducingclassinterface"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetStartComSlot" qualify="true"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot" qualify="true"/>
	</doc>
	<doc for="Marshal.GetMethodInfoForComSlot">
		<summary>
			<para>Retrieves <see cref="System.Reflection.MethodInfo"/> for the specified
   virtual function table (VTBL) slot.</para>
		</summary>
		<param name="t">The type for which the <see langword="MethodInfo"/> is to be retrieved.</param>
		<param name=" slot">The VTBL slot.</param>
		<param name=" memberType"><para>On successful return, the type of the member. This is one of the <see cref="System.Runtime.InteropServices.ComMemberType"/> enumeration members.</para></param>
		<returns>
			<para>The <see langword="MemberInfo"/>
that represents the member
at the specified VTBL (also called v-table) slot.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="t "/>is not visible from COM.</exception>
		<remarks>
			<para>The zero-based slot number returned by this method accounts for three
      <see langword="IUnknown"/> and possibly four <see langword="IDispatch"/> methods, making the value
      of the first available slot either 3 or 7. <see cref="System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot"/> provides the opposite
      functionality of <see cref="System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo" qualify="true"/>. You can
      use <see cref="System.Runtime.InteropServices.Marshal.GetEndComSlot" qualify="true"/> and <see cref="System.Runtime.InteropServices.Marshal.GetStartComSlot" qualify="true"/> in conjunction with
      <see cref="System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot"/> to pass slots within a
      specified range.</para>
			<para> The <paramref name="memberType"/> parameter is only important on
   return. It contains the type of the COM member that corresponds to the returned
<see langword="MemberInfo"/>: a regular 
   method or a property accessor (get, set,
   or other).</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetEndComSlot"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetStartComSlot"/>
		<seealso cref="System.Runtime.InteropServices.ComMemberType"/>
	</doc>
	<doc for="Marshal.GetComSlotForMethodInfo">
		<summary>
			<para>Gets the virtual function table (VTBL) slot for a
      specified <see cref="System.Reflection.MemberInfo" qualify="true"/>
      when exposed to COM.</para>
		</summary>
		<param name="m">A <see cref="System.Reflection.MemberInfo"/> that represents an interface method.</param>
		<returns>
			<para>The VTBL (also called v-table) slot <paramref name="m"/>
identifier when it is exposed to COM.</para>
		</returns>
		<remarks>
			<para>The zero-based slot number returned by this method
      accounts for three <see langword="IUnknown"/> and possibly
      four <see langword="IDispatch"/> methods, making the value
      of the first available slot either 3 or 7. <see cref="System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo"/> provides the opposite
      functionality of <see cref="System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot" qualify="true"/>.</para>
			<para> You can use this method to retrieve slot numbers for members of interfaces not
      visible from COM and for members of private interfaces. The slot numbers
      returned correspond to the v-table numbers that would be reserved if the type
      was exposed to COM. COM-invisible members actually occupy a slot in an exposed
      v-table, even though the COM client cannot use the slot. You cannot use
   <see cref="System.Runtime.InteropServices.Marshal.GetComSlotForMethodInfo"/> on a class interface
      by passing <see cref="System.Reflection.MemberInfo"/> from a class. For additional information on class interfaces, see
   <see topic="cpconintroducingclassinterface"/>.</para>
			<note type="note">
      This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
      being called from untrusted code; only the immediate caller is required to have
   <see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
   permission. If your code can be called from partially trusted code, do not pass
   user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
   validation. For important limitations on using the <see langword="LinkDemand"/>
   member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Reflection.MemberInfo"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetMethodInfoForComSlot"/>
	</doc>
	<doc for="Marshal.GetHINSTANCE">
		<summary>
			<para>Returns the instance handle (HINSTANCE) for the specified module.</para>
		</summary>
		<param name="m">The <see cref="System.Reflection.Module"/> whose HINSTANCE is desired.</param>
		<returns>
			<para>The HINSTANCE for <paramref name="m"/>; -1 if the
   module does not have an HINSTANCE.</para>
		</returns>
		<remarks>
			<para> When dynamic or in-memory, modules do not have an HINSTANCE. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
	</doc>
	<doc for="Marshal.ThrowExceptionForHR1">
		<summary>
			<para> Throws an exception with a specific failure HRESULT.</para>
		</summary>
		<param name="errorCode">The HRESULT corresponding to the desired exception.</param>
		<param name=" errorInfo">A pointer to the <see langword="IErrorInfo"/> interface provided by the COM object.</param>
		<remarks>
			<para>This method creates an exception object for the specified failure HRESULT. If
      the HRESULT is 0 or positive (a success code), the method returns without
      creating or throwing an exception.</para>
			<para>Some failure HRESULTs map to well-defined exceptions, while others do not map to a
      defined exception. If the HRESULT maps to a defined exception, <see cref="System.Runtime.InteropServices.Marshal.ThrowExceptionForHR"/> creates an instance of
      the exception and throws it. Otherwise, it creates an instance of <see cref="System.Runtime.InteropServices.COMException" qualify="true"/>, initializes the error code field
      with the HRESULT, and throws that exception. The <paramref name="errorInfo"/> parameter is used to
      retrieve extra information regarding the error.</para>
			<para>For the mapping from each HRESULT to its comparable exception class in the
      .NET Framework, see <see topic="cpconhresultsexceptions"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.COMException"/>
	</doc>
	<doc for="Marshal.GetHRForException">
		<summary>
			<para> Converts the specified exception to
      an HRESULT. </para>
		</summary>
		<param name="e">The <see cref="System.Exception"/> to convert to an HRESULT.</param>
		<returns>
			<para>The HRESULT mapped to the supplied exception.</para>
		</returns>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.GetHRForException"/> also sets up an
<see langword="IErrorInfo"/> interface for the exception that can be obtained by
   calling the <see langword="GetErrorInfo"/> COM
   API
   method. You can use this method to return an HRESULT value on a managed class
   implemention of a COM interface where you apply the <see cref="System.Runtime.InteropServices.PreserveSigAttribute" qualify="true"/>. Have the attributed method
   catch all exceptions and use <see cref="System.Runtime.InteropServices.Marshal.GetHRForException"/> to return the
   appropriate HRESULT value. Allowing an exception to propagate outside the method
   produces incorrect behavior. (In fact, the common language runtime fails to pass
   an exception to a COM client calling such a method through a v-table.) For additional information about the <see langword="IErrorInfo"/>
   interface and <see langword="GetErrorInfo"/>
   
   COM methods, see the MSDN Library. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.PreserveSigAttribute"/>
	</doc>
	<doc for="Marshal.GenerateGuidForType">
		<summary>
			<para> Returns the globally unique identifier (GUID) for the specified type, or
      generates a GUID using the algorithm used by the
      Type
      Library Exporter (Tlbexp.exe).</para>
		</summary>
		<param name="type">The <see cref="System.Type"/> to generate a GUID for.</param>
		<returns>
			<para>A <see cref="System.Guid"/> for the
   specified type.</para>
		</returns>
		<remarks>
			<para> If the type has a GUID in the metadata, it is returned.
      Otherwise, a GUID is automatically generated. You can use this method to
      programmatically determine the COM GUID for any managed type, including
      COM-invisible types. Class interfaces are the only exception since they do not
      correspond to a managed type. <see cref="System.Runtime.InteropServices.Marshal.GenerateGuidForType"/>
      provides the same functionality as the <see cref="System.Type.GUID" qualify="true"/>
      
      property. </para>
			<note type="note">
      This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
      being called from untrusted code; only the immediate caller is required to have
   <see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
   permission. If your code can be called from partially trusted code, do not pass
   user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
   validation. For important limitations on using the <see langword="LinkDemand"/>
   member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Type.GUID"/>
	</doc>
	<doc for="Marshal.GenerateProgIdForType">
		<summary>
			<para> Returns a programmatic identifier (ProgID) for the specified type.</para>
		</summary>
		<param name="type">The <see cref="System.Type"/> to get a ProgID for.</param>
		<returns>
			<para>The ProgID of the specified type.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="type"/> is not a class that can be create by COM. The class must be public, have a public default constructor, and be COM visible.</exception>
		<remarks>
			<para> If the type has a ProgID in the metadata, then it is
      returned. Otherwise a ProgID is generated based on the fully qualified name of
      the type. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
	</doc>
	<doc for="Marshal.GetActiveObject">
		<summary>
			<para>Obtains a running instance of the specified object from
      the Running Object Table (ROT).</para>
		</summary>
		<param name="progID">The ProgID of the object being requested.</param>
		<returns>
			<para> The object requested. You
      can cast this object to any COM interface that it supports.</para>
		</returns>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.GetActiveObject" qualify="true"/> exposes
   the <see langword="GetActiveObject"/> COM API method from OLEAUT32.DLL; however, the
   latter expects a class identifier (CLSID) instead of the programmatic identifier (ProgID) expected by this method. To
   obtain a running instance of a COM object without a registered ProgID, use
   platform invoke to define the <see langword="GetActivateObject"/> COM method. For a description of
   platform invoke, see <see topic="cpconconsumingunmanageddllfunctions"/>. For
   additional information about the <see langword="GetActiveObject"/> COM method, see the MSDN
   Library.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
	</doc>
	<doc for="Marshal.GetUnmanagedThunkForManagedMethodPtr">
		<summary>
			<para> Gets a pointer to a thunk that
      marshals a call from unmanaged to managed code.</para>
		</summary>
		<param name="pfnMethodToWrap">A pointer to the method to marshal. </param>
		<param name=" pbSignature">A pointer to the method signature.</param>
		<param name=" cbSignature">The number of bytes in <paramref name="pbSignature"/>.</param>
		<returns>
			<para> A pointer to the thunk that
      will marshal a call from <paramref name="pfnMethodToWrap"/>.</para>
		</returns>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.GetUnmanagedThunkForManagedMethodPtr"/> is exposed for complier support only.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
	</doc>
	<doc for="Marshal.GetManagedThunkForUnmanagedMethodPtr">
		<summary>
			<para>Gets a pointer to a thunk that marshals a call from
      managed to unmanaged code.</para>
		</summary>
		<param name="pfnMethodToWrap">A pointer to the method to marshal.</param>
		<param name=" pbSignature">A pointer to the method signature.</param>
		<param name=" cbSignature">The number of bytes in <paramref name="pbSignature"/>.</param>
		<returns>
			<para>A pointer to the thunk that will marshal a call from the <paramref name="pfnMethodToWrap"/> parameter.</para>
		</returns>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.GetManagedThunkForUnmanagedMethodPtr"/> is exposed for compiler support only.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
	</doc>
	<doc for="Marshal.ChangeWrapperHandleStrength">
		<summary>
			<para>Changes the strength of a COM callable wrapper's (CCW)
      handle on the object it contains.</para>
		</summary>
		<param name="otp">The object whose COM callable wrapper (CCW) holds a reference counted handle. The handle is strong if the reference count on the CCW is greater than zero; otherwise it is weak.</param>
		<param name=" fIsWeak"><see langword="true"/> to change the strength of the handle on the <paramref name="otp"/> parameter to weak, regardless of its reference count; <see langword="false"/> to reset the handle strength on <paramref name="otp"/> to be reference counted.</param>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ChangeWrapperHandleStrength"/> is used for object pooling functionality and should never be
   called by user code directly.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
	</doc>
	<doc for="Marshal.GetTypeForITypeInfo">
		<summary>
			<para>Converts an <see langword="ITypeInfo"/> into a
   managed <see cref="System.Type"/>
   object.</para>
		</summary>
		<param name="piTypeInfo">The <see langword="ITypeInfo"/> interface to marshal.</param>
		<returns>
			<para>A managed <see cref="System.Type"/> that represents the unmanaged
<see langword="ITypeInfo"/>.</para>
		</returns>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo"/> returns a <see cref="System.Type" qualify="true"/> instance that is based on 
   the original type. You can
   apply the <see cref="System.Runtime.InteropServices.MarshalAsAttribute" qualify="true"/> to replace standard interop
   marshaling behavior with this custom marshaler. The Type Library Importer
   (Tlbimp.exe) uses the custom marshaler to
   translate <see langword="ITypeInfo"/> parameters to <see cref="System.Type"/> parameters.
   However, if you obtain an <see langword="ITypeInfo"/> interface by some
   means other than Tlbimp.exe, you can use <see cref="System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo"/> to manually perform the
   same translation. For additional information about <see langword="ITypeInfo"/>, see the MSDN Library.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetITypeInfoForType"/>
		<seealso cref="System.Runtime.InteropServices.MarshalAsAttribute"/>
	</doc>
	<doc for="Marshal.GetITypeInfoForType">
		<summary>
			<para>Returns an <see langword="ITypeInfo "/>interface from a managed type.</para>
		</summary>
		<param name="t">The <see cref="System.Type"/> whose <see langword="ITypeInfo"/> interface is being requested.</param>
		<returns>
			<para>The <see langword="ITypeInfo"/>
pointer
for the <paramref name="t"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="t"/> is not a visible type to COM.</exception>
		<exception cref="System.Runtime.InteropServices.COMException">A type library is registered for the assembly that contains the type, but the type definition cannot be found.</exception>
		<remarks>
			<para> This method returns a pointer to
      an <see langword="ITypeInfo"/> implementation that is based on the
      original type. Calling an object with <see cref="System.Runtime.InteropServices.Marshal.GetITypeInfoForType"/> causes the
      reference count to increment on the
      interface pointer before the pointer is returned. Always use <see cref="System.Runtime.InteropServices.Marshal.Release" qualify="true"/> to decrement the
      reference count once you have finished with the
      pointer. You can
      apply the <see cref="System.Runtime.InteropServices.MarshalAsAttribute" qualify="true"/> to replace standard interop
      marshaling behavior with this custom marshaler. For additional information about
   <see langword="ITypeInfo"/> 
   , see the MSDN library.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetTypeForITypeInfo"/>
		<seealso cref="System.Runtime.InteropServices.MarshalAsAttribute"/>
	</doc>
	<doc for="Marshal.AllocHGlobal">
		<overload>
			<para>Allocates a block of memory using <see langword="GlobalAlloc"/>.</para>
		</overload>
		<summary>
			<para> Allocates memory from the process's unmanaged memory.</para>
		</summary>
		<param name="cb">The number of bytes in memory required.</param>
		<returns>
			<para> An <see cref="System.IntPtr"/> to the newly allocated memory. This memory must
   be released using the <see cref="System.Runtime.InteropServices.Marshal.FreeHGlobal" qualify="true"/> method.</para>
		</returns>
		<exception cref="System.OutOfMemoryException">There is insufficient memory to satisfy the request.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.AllocHGlobal"/> is one of two memory allocation API methods in the
<see cref="System.Runtime.InteropServices.Marshal"/> class. (<see cref="System.Runtime.InteropServices.Marshal.AllocCoTaskMem" qualify="true"/> is the other.) This 
   method exposes the <see langword="GlobalAlloc"/> Win32 API from Kernel32.dll. For
   additional information about <see langword="GlobalAlloc"/>,
   see
   the
   MSDN Library.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.AllocCoTaskMem"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.FreeHGlobal"/>
	</doc>
	<doc for="Marshal.DestroyStructure">
		<summary>
			<para>Frees all substructures pointed to by the specified unmanaged memory block.</para>
		</summary>
		<param name="ptr">A pointer to an unmanaged block of memory.</param>
		<param name="structuretype">Type of a formatted class. This provides the layout information necessary to delete the buffer in the <paramref name="ptr"/> parameter.</param>
		<exception cref="System.ArgumentException"><paramref name="structureType"/> has an automatic layout. Use sequential or explicit instead.</exception>
		<remarks>
			<para> You can use this method to free reference-type
      fields, such as strings, of an
      unmanaged structure. Unlike its fields, a structure can be
      a value type or reference type. Value-type structures containing value-type
      fields (all blittable) have no references whose memory must
      be freed. <see cref="System.Runtime.InteropServices.Marshal.StructureToPtr"/> uses this method to prevent memory leaks when reusing memory occupied by
      a structure. </para>
			<para><see cref="System.Runtime.InteropServices.Marshal.DestroyStructure"/> calls the
<see langword="SysFreeString"/> COM API method, which in turn frees an allocated 
   string. For additional information about <see langword="SysFreeString"/>, see the MSDN
   Library. </para>
			<para>In addition to <see cref="System.Runtime.InteropServices.Marshal.DestroyStructure"/>,
the <see cref="System.Runtime.InteropServices.Marshal"/> class provides two other
memory-deallocation methods: <see cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem" qualify="true"/> and <see cref="System.Runtime.InteropServices.Marshal.FreeHGlobal" qualify="true"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.FreeHGlobal"/>
	</doc>
	<doc for="Marshal.GetLastWin32Error">
		<summary>
			<para> Returns the error code returned by the last unmanaged
      function called using platform invoke that has the <see cref="System.Runtime.InteropServices.DllImportAttribute.SetLastError" qualify="true"/> flag set.</para>
		</summary>
		<returns>
			<para>The last error code set by a call to the
      Win32 <see langword="SetLastError"/> API method.</para>
		</returns>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> exposes the
   Win32 <see langword="GetLastError"/> API method from Kernel32.DLL.
   This method exists because it is not safe to make a direct platform invoke call
   to <see langword="GetLastError"/> to obtain this information.
   If you want to access this error code, you must call <see cref="System.Runtime.InteropServices.Marshal.GetLastWin32Error"/> rather than writing your own
   platform invoke definition for <see langword="GetLastError"/>
   
   and
   calling it. The common language runtime can make internal calls to APIs that
   overwrite the operating system maintained <see langword="GetLastError"/>.</para>
			<para>You can only use this method to obtain error codes if
   you apply the <see cref="System.Runtime.InteropServices.DllImportAttribute" qualify="true"/> to the method signature and set
   the <see cref="System.Runtime.InteropServices.DllImportAttribute.SetLastError"/> field to <see langword="true"/>. The process for this varies depending upon the
   source language used: C# and C++ are <see langword="false"/> by default, but the
<see langword="Declare"/> statement in Visual Basic is <see langword="true"/>. For additional information about
   the <see langword="GetLastError"/> and <see langword="SetLastError"/> Win32 API methods, see the MSDN Library.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.DllImportAttribute"/>
	</doc>
	<doc for="Marshal.ReadInt16">
		<overload>
			<para> Reads a 16-bit signed
      integer from unmanaged memory.</para>
		</overload>
		<summary>
			<para>Reads a 16-bit signed integer from unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory of the source object.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before reading.</param>
		<returns>
			<para>The 16-bit signed integer read from the
   <paramref name="ptr"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReadInt16"/> enables direct interaction with an unmanaged 16-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before reading its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.PtrToStructure">
		<overload>
			<para>Marshals data from an unmanaged block of memory to a managed
      object.</para>
		</overload>
		<summary>
			<para> Marshals data from an unmanaged block of memory
      to a managed object.</para>
		</summary>
		<param name="ptr">A pointer to an unmanaged block of memory.</param>
		<param name="structure"> The object to which the data is to be copied. This must be an instance of a formatted class.</param>
		<exception cref="System.ArgumentException"><para>Structure layout is not sequential or explicit.</para>
			<para>-or-</para>
			<para> Structure is a boxed value type.</para></exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.PtrToStructure"/> is often necessary in
   COM interop and platform invoke when structure parameters are represented as an
<see cref="System.IntPtr" qualify="true"/> value.
   You cannot use this overload
   method with value types.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
	</doc>
	<doc for="Marshal.PtrToStructure1">
		<summary>
			<para>Marshals data from an unmanaged block of memory to a newly allocated
      managed object of the specified type.</para>
		</summary>
		<param name="ptr">A pointer to an unmanaged block of memory.</param>
		<param name="structureType">The <see cref="System.Type"/> of object to be created. This type object must represent a formatted class or a structure.</param>
		<returns>
			<para>A managed object containing the data pointed to by the
   <paramref name="ptr"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="structureType "/>layout is not sequential or explicit.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.PtrToStructure"/> is often necessary in
   COM interop and platform invoke when structure parameters are represented as an
<see cref="System.IntPtr" qualify="true"/> value. You can pass 
   a value type to this overload method.
   In this case, the returned object is a boxed instance.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para>The following example demonstrates using <see cref="System.Runtime.InteropServices.Marshal.PtrToStructure"/> after calling <see cref="System.Runtime.InteropServices.UCOMITypeInfo.GetTypeAttr" qualify="true"/> to obtain
   a <see langword="TYPEATTR"/> structure. <see cref="System.Runtime.InteropServices.UCOMITypeInfo.GetTypeAttr"/> is defined with a
   by-reference <see cref="System.IntPtr"/> parameter because the unmanaged
   signature's <see langword="TYPEATTR**"/> parameter is not supported by the
   interop marshaler.</para>
			<code lang="VB">Dim typeInfo As UCOMITypeInfo = ... 
Dim ptr As IntPtr = IntPtr.Zero
typeInfo.GetTypeAttr(ptr)
Dim attr As TYPEATTR = _ 
  CType(Marshal.PtrToStructure(ptr, GetType(TYPEATTR)), TYPEATTR)
</code>
			<code lang="C#">UCOMITypeInfo typeInfo = ...; 
IntPtr ptr = IntPtr.Zero; 
typeInfo.GetTypeAttr(ref ptr); 
TYPEATTR attr = (TYPEATTR)Marshal.PtrToStructure(ptr, 
    typeof(TYPEATTR));
</code>
		</example>
		<seealso cref="System.Runtime.InteropServices.UCOMITypeInfo.GetTypeAttr"/>
	</doc>
	<doc for="Marshal.ReadInt161">
		<summary>
			<para>Reads a 16-bit signed integer from unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory from which to read.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before reading.</param>
		<returns>
			<para>The 16-bit signed integer read from
   <paramref name="ptr"/>.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReadInt16"/> enables direct interaction with an unmanaged 16-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before reading its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<example>
			<para> The following example compares two ways of interacting with
      an unmanaged C-style Int16 array. The <see cref="System.Runtime.InteropServices.Marshal.ReadInt16"/>
      method provides direct access to the array's element values.</para>
			<code lang="VB">Dim unmanagedArray As IntPtr = ...
Dim i As Integer

' One way to print the 10 elements of the C-style unmanagedArray
Dim newArray As Int16(9)
Marshal.Copy(unmanagedArray, newArray, 0, 10)
For i = 0 To newArray.Length
  Console.WriteLine(newArray(i))
Next i

' Another way to print the 10 elements of the C-style unmanagedArray
For i = 0 To 10
  Console.WriteLine(Marshal.ReadInt16(unmanagedArray, i))
Next i
   </code>
			<code lang="C#">IntPtr unmanagedArray = ...;

// One way to print the 10 elements of the C-style unmanagedArray
byte [] newArray = new Int16[10];
Marshal.Copy(unmanagedArray, newArray, 0, 10);
for (int i = 0; i &lt; newArray.Length; i++)
  Console.WriteLine(newArray[i]);

// Another way to print the 10 elements of the C-style unmanagedArray
for (int i = 0; i &lt; 10; i++)
  Console.WriteLine(Marshal.ReadInt16(unmanagedArray, i));
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.ReadByte"/>
	</doc>
	<doc for="Marshal.ReadInt32">
		<overload>
			<para> Reads a 32-bit signed integer
      from unmanaged memory.</para>
		</overload>
		<summary>
			<para>Reads a 32-bit signed integer from unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory of the source object.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before reading.</param>
		<returns>
			<para>The 32-bit signed integer read from the
   <paramref name="ptr"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReadInt32"/> enables direct interaction with an unmanaged 32-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before reading its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.ReadInt321">
		<summary>
			<para>Reads a 32-bit signed integer from unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory from which to read.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before reading.</param>
		<returns>
			<para>The 32-bit signed integer read from the
   <paramref name="ptr"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReadInt32"/> enables direct interaction with an unmanaged 32-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before reading its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<example>
			<para> The following example compares two ways of interacting with
      an unmanaged C-style Int32 array. The <see cref="System.Runtime.InteropServices.Marshal.ReadInt32"/>
      method provides direct access to the array's element values.</para>
			<code lang="VB">Dim unmanagedArray As IntPtr = ...
Dim i As Integer

' One way to print the 10 elements of the C-style unmanagedArray
Dim newArray As Int32(9)
Marshal.Copy(unmanagedArray, newArray, 0, 10)
For i = 0 To newArray.Length
  Console.WriteLine(newArray(i))
Next i

' Another way to print the 10 elements of the C-style unmanagedArray
For i = 0 To 10
  Console.WriteLine(Marshal.ReadInt32(unmanagedArray, i))
Next i
   </code>
			<code lang="C#">IntPtr unmanagedArray = ...;

// One way to print the 10 elements of the C-style unmanagedArray
byte [] newArray = new Int32[10];
Marshal.Copy(unmanagedArray, newArray, 0, 10);
for (int i = 0; i &lt; newArray.Length; i++)
  Console.WriteLine(newArray[i]);

// Another way to print the 10 elements of the C-style unmanagedArray
for (int i = 0; i &lt; 10; i++)
  Console.WriteLine(Marshal.ReadInt32(unmanagedArray, i));
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.ReadByte"/>
	</doc>
	<doc for="Marshal.ReadInt64">
		<overload>
			<para> Reads a 64-bit signed
      integer from unmanaged memory.</para>
		</overload>
		<summary>
			<para>Reads a 64-bit signed integer from unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory of the source object.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before reading.</param>
		<returns>
			<para>The 64-bit signed integer read from the
   <paramref name="ptr"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReadInt64"/> enables direct interaction with an unmanaged 64-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before reading its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.ReadInt641">
		<summary>
			<para>Reads a 64-bit signed integer from unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory from which to read.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before reading.</param>
		<returns>
			<para>The 64-bit signed integer read from the
   <paramref name="ptr"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.ReadInt64"/> enables direct interaction with an unmanaged 64-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before reading its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<example>
			<para> The following example compares two ways of interacting with
      an unmanaged C-style Int64 array. The <see cref="System.Runtime.InteropServices.Marshal.ReadInt64"/>
      method provides direct access to the array's element values.</para>
			<code lang="VB">Dim unmanagedArray As IntPtr = ...
Dim i As Integer

' One way to print the 10 elements of the C-style unmanagedArray
Dim newArray As Int64(9)
Marshal.Copy(unmanagedArray, newArray, 0, 10)
For i = 0 To newArray.Length
  Console.WriteLine(newArray(i))
Next i

' Another way to print the 10 elements of the C-style unmanagedArray
For i = 0 To 10
  Console.WriteLine(Marshal.ReadInt64(unmanagedArray, i))
Next i
   </code>
			<code lang="C#">IntPtr unmanagedArray = ...;

// One way to print the 10 elements of the C-style unmanagedArray
byte [] newArray = new Int64[10];
Marshal.Copy(unmanagedArray, newArray, 0, 10);
for (int i = 0; i &lt; newArray.Length; i++)
  Console.WriteLine(newArray[i]);

// Another way to print the 10 elements of the C-style unmanagedArray
for (int i = 0; i &lt; 10; i++)
  Console.WriteLine(Marshal.ReadInt64(unmanagedArray, i));
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.ReadByte"/>
	</doc>
	<doc for="Marshal.WriteInt16">
		<overload>
			<para> Writes a 16-bit signed integer
      value to unmanaged memory.</para>
		</overload>
		<summary>
			<para>Writes a 16-bit signed integer value into unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory from which to write.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before writing.</param>
		<param name="val">The value to write.</param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteInt16"/> enables direct interaction with an unmanaged 16-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<example>
			<para> The following example compares two ways of interacting with an
      unmanaged C-style Int16 array. The <see cref="System.Runtime.InteropServices.Marshal.WriteInt16"/> method provides direct
      access to the element values of the array, setting its ten elements to the
      values 1 through 10.</para>
			<code lang="VB">Dim unmanagedArray As IntPtr = ...
Dim i As Integer

' One way to set the 10 elements of the C-style unmanagedArray
Dim newArray As Short(9)
Marshal.Copy(unmanagedArray, newArray, 0, 10)
For i = 0 To newArray.Length
  newArray(i) = i+1
Next i
Marshal.Copy(newArray, 0, unmanagedArray, 10)

' Another way to set the 10 elements of the C-style unmanagedArray
For i = 0 To 10
  Marshal.WriteInt16(unmanagedArray, i, i+1)
Next i
   </code>
			<code lang="C#">IntPtr unmanagedArray = ...;

// One way to set the 10 elements of the C-style unmanagedArray
byte [] newArray = new short[10];
Marshal.Copy(unmanagedArray, newArray, 0, 10);
for (int i = 0; i &lt; newArray.Length; i++)
  newArray[i] = i+1;
Marshal.Copy(newArray, 0, unmanagedArray, 10);

// Another way to set the 10 elements of the C-style unmanagedArray
for (int i = 0; i &lt; 10; i++)
  Marshal.WriteInt16(unmanagedArray, i, i+1);
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.WriteByte"/>
	</doc>
	<doc for="Marshal.WriteInt161">
		<summary>
			<para> Writes a 16-bit signed integer value to unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory of the target object.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before writing.</param>
		<param name="val">The value to write.</param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteInt16"/> enables direct interaction with an unmanaged 16-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.ArgumentException"></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.WriteInt162">
		<summary>
			<para> Writes a 16-bit integer value to unmanaged memory.</para>
		</summary>
		<param name="ptr">The address in unmanaged memory from which to write.</param>
		<param name=" val">The value to write.</param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/> is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteInt16"/> enables direct interaction with an unmanaged 16-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.WriteInt163">
		<summary>
			<para> Writes a 16-bit signed integer value to unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in the native heap from which to write.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before writing.</param>
		<param name="val">The value to write.</param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteInt16"/> enables direct interaction with an unmanaged 16-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<example>
			<para> The following example compares two ways of interacting with an
      unmanaged C-style Int16 array. The <see cref="System.Runtime.InteropServices.Marshal.WriteInt16"/> method provides direct
      access to the element values of the array, setting its ten elements to the
      values 1 through 10.</para>
			<code lang="VB">Dim unmanagedArray As IntPtr = ...
Dim i As Integer

' One way to set the 10 elements of the C-style unmanagedArray
Dim newArray As Char(9)
Marshal.Copy(unmanagedArray, newArray, 0, 10)
For i = 0 To newArray.Length
  newArray(i) = i+1
Next i
Marshal.Copy(newArray, 0, unmanagedArray, 10)

' Another way to set the 10 elements of the C-style unmanagedArray
For i = 0 To 10
  Marshal.WriteInt16(unmanagedArray, i, i+1)
Next i
   </code>
			<code lang="C#">IntPtr unmanagedArray = ...;

// One way to set the 10 elements of the C-style unmanagedArray
byte [] newArray = new char[10];
Marshal.Copy(unmanagedArray, newArray, 0, 10);
for (int i = 0; i &lt; newArray.Length; i++)
  newArray[i] = i+1;
Marshal.Copy(newArray, 0, unmanagedArray, 10);

// Another way to set the 10 elements of the C-style unmanagedArray
for (int i = 0; i &lt; 10; i++)
  Marshal.WriteInt16(unmanagedArray, i, i+1);
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.WriteByte"/>
	</doc>
	<doc for="Marshal.WriteInt164">
		<summary>
			<para> Writes a 16-bit signed integer value to unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory of the target object.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before writing.</param>
		<param name="val">The value to write.</param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>must be a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteInt16"/> enables direct interaction with an unmanaged 16-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.WriteInt165">
		<overload>
			<para> Writes a 16-bit signed integer value to unmanaged memory.
      </para>
		</overload>
		<summary>
			<para> Writes a 16-bit signed integer value to unmanaged memory.
      </para>
		</summary>
		<param name="ptr">The address in unmanaged memory from which to write. </param>
		<param name="val">The value to write. </param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteInt16"/> enables direct interaction with an unmanaged 16-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.WriteInt32">
		<overload>
			<para> Writes a 32-bit signed integer
      value to unmanaged memory.</para>
		</overload>
		<summary>
			<para>Writes a 32-bit signed integer value into unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory from which to write.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before writing.</param>
		<param name="val">The value to write.</param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteInt32"/> enables direct interaction with an unmanaged 32-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<example>
			<para> The following example compares two ways of interacting with an
      unmanaged C-style Int32 array. The <see cref="System.Runtime.InteropServices.Marshal.WriteInt32"/> method provides direct
      access to the element values of the array, setting its ten elements to the
      values 1 through 10.</para>
			<code lang="VB">Dim unmanagedArray As IntPtr = ...
Dim i As Integer

' One way to set the 10 elements of the C-style unmanagedArray
Dim newArray As Integer(9)
Marshal.Copy(unmanagedArray, newArray, 0, 10)
For i = 0 To newArray.Length
  newArray(i) = i+1
Next i
Marshal.Copy(newArray, 0, unmanagedArray, 10)

' Another way to set the 10 elements of the C-style unmanagedArray
For i = 0 To 10
  Marshal.WriteInt32(unmanagedArray, i, i+1)
Next i
   </code>
			<code lang="C#">IntPtr unmanagedArray = ...;

// One way to set the 10 elements of the C-style unmanagedArray
byte [] newArray = new int[10];
Marshal.Copy(unmanagedArray, newArray, 0, 10);
for (int i = 0; i &lt; newArray.Length; i++)
  newArray[i] = i+1;
Marshal.Copy(newArray, 0, unmanagedArray, 10);

// Another way to set the 10 elements of the C-style unmanagedArray
for (int i = 0; i &lt; 10; i++)
  Marshal.WriteInt32(unmanagedArray, i, i+1);
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.WriteByte"/>
	</doc>
	<doc for="Marshal.WriteInt321">
		<summary>
			<para> Writes a 32-bit signed integer value to unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory of the target object.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before writing.</param>
		<param name="val">The value to write.</param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteInt32"/> enables direct interaction with an unmanaged 32-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.WriteInt322">
		<overload>
			<para> Writes a 32-bit signed integer value to unmanaged memory.
      </para>
		</overload>
		<summary>
			<para> Writes a 32-bit signed integer value to unmanaged memory.
      </para>
		</summary>
		<param name="ptr">The address in unmanaged memory from which to write. </param>
		<param name="val">The value to write. </param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteInt32"/> enables direct interaction with an unmanaged 32-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.WriteInt64">
		<overload>
			<para> Writes a 64-bit signed integer value to unmanaged memory.</para>
		</overload>
		<summary>
			<para>Writes a 64-bit signed integer value to unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory from which to write.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before writing.</param>
		<param name="val">The value to write.</param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteInt64"/> enables direct interaction with an unmanaged 64-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<example>
			<para> The following example compares two ways of interacting with an
      unmanaged C-style Int64 array. The <see cref="System.Runtime.InteropServices.Marshal.WriteInt64"/> method provides direct
      access to the element values of the array, setting its ten elements to the
      values 1 through 10.</para>
			<code lang="VB">Dim unmanagedArray As IntPtr = ...
Dim i As Integer

' One way to set the 10 elements of the C-style unmanagedArray
Dim newArray As Long(9)
Marshal.Copy(unmanagedArray, newArray, 0, 10)
For i = 0 To newArray.Length
  newArray(i) = i+1
Next i
Marshal.Copy(newArray, 0, unmanagedArray, 10)

' Another way to set the 10 elements of the C-style unmanagedArray
For i = 0 To 10
  Marshal.WriteInt64(unmanagedArray, i, i+1)
Next i
   </code>
			<code lang="C#">IntPtr unmanagedArray = ...;

// One way to set the 10 elements of the C-style unmanagedArray
byte [] newArray = new long[10];
Marshal.Copy(unmanagedArray, newArray, 0, 10);
for (int i = 0; i &lt; newArray.Length; i++)
  newArray[i] = i+1;
Marshal.Copy(newArray, 0, unmanagedArray, 10);

// Another way to set the 10 elements of the C-style unmanagedArray
for (int i = 0; i &lt; 10; i++)
  Marshal.WriteInt64(unmanagedArray, i, i+1);
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.WriteByte"/>
	</doc>
	<doc for="Marshal.WriteInt641">
		<summary>
			<para> Writes a 64-bit signed integer value to unmanaged memory.</para>
		</summary>
		<param name="ptr">The base address in unmanaged memory of the target object.</param>
		<param name="ofs">An additional byte offset, added to the <paramref name="ptr"/> parameter before writing.</param>
		<param name="val">The value to write.</param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteInt64"/> enables direct interaction with an unmanaged 64-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.WriteInt642">
		<summary>
			<para> Writes a 64-bit signed integer value to unmanaged memory.
      </para>
		</summary>
		<param name="ptr">The address in unmanaged memory from which to write. </param>
		<param name="val">The value to write. </param>
		<exception cref="System.ArgumentException"><paramref name="ptr "/>is not a recognized format.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.WriteInt64"/> enables direct interaction with an unmanaged 64-bit signed array,
   eliminating the expense of copying an entire unmanaged array (using <see cref="System.Runtime.InteropServices.Marshal.Copy" qualify="true"/>) to a separate managed array before setting its element values.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.Copy"/>
	</doc>
	<doc for="Marshal.ReleaseComObject">
		<summary>
			<para> Decrements the reference count of the supplied runtime
      callable wrapper. </para>
		</summary>
		<param name="o">The COM object to release.</param>
		<returns>
			<para>The new value of the reference count of the runtime callable
      wrapper associated with <paramref name="o"/>. This value is
      typically zero since the runtime callable wrapper keeps just one reference to
      the wrapped COM object regardless of the number of managed clients calling
      it.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="o"/> is not a COM object.</exception>
		<remarks>
			<para> Every time a COM interface pointer enters the common
      language runtime, it is wrapped in an runtime callable wrapper. If you are
      unfamiliar with the features of this wrapper, see <see topic="cpconruntimecallablewrapper"/>.</para>
			<para>This method is used to explicitly control the lifetime of a COM object used 
      from managed code. You should use this method to free the underlying COM object
      that holds references to resources in a timely manner or when objects must be
      freed in a specific order. </para>
			<para> The runtime callable wrapper has a reference count that
      is incremented every time a COM interface pointer is mapped to it. The <see cref="System.Runtime.InteropServices.Marshal.ReleaseComObject"/>
      
      method decrements the reference count of a runtime callable
      wrapper. When the reference count reached zero, the runtime releases all its references
      on the unmanaged COM object, and throws a <see cref="System.NullReferenceException" qualify="true"/> if you attempt to
      use the object further. If the same COM interface is passed more than once from
      unmanaged to managed code, the reference count on the wrapper is incremented
      every time and calling <see cref="System.Runtime.InteropServices.Marshal.ReleaseComObject"/> returns the number of
      remaining references. </para>
			<note type="note">
      To ensure that the runtime
      callable wrapper and the original COM object are released, construct a loop from
      which you call this method until the returned reference count reaches zero.
      
   </note>
			<note type="note">
      This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
      being called from untrusted code; only the immediate caller is required to have
   <see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/>
   permission. If your code can be called from partially trusted code, do not pass
   user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
   validation. For important limitations on using the <see langword="LinkDemand"/>
   member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.NullReferenceException"/>
	</doc>
	<doc for="Marshal.SetComObjectData">
		<summary>
			<para>Sets data referenced by the specified key in the
      specified COM object.</para>
		</summary>
		<param name="obj">The COM object in which to store the data.</param>
		<param name=" key">The key in the internal hash table of the COM object in which to store the data.</param>
		<param name=" data">The data to set.</param>
		<returns>
			<para><see langword="true"/> if the data was set successfully; otherwise,
<see langword="false"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para><paramref name="obj"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para><paramref name="key"/><see langword=""/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><paramref name="obj"/> is not a COM object.</exception>
		<remarks>
			<para>All COM objects wrapped in a runtime callable wrapper have
      an associated hash table, to which <see cref="System.Runtime.InteropServices.Marshal.SetComObjectData"/> adds data. <see cref="System.Runtime.InteropServices.Marshal.GetComObjectData" qualify="true"/> retrieves data from the hash table. You should never have to call either method from your
      code.</para>
			<note type="note">
      This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
      being called from untrusted code; only the immediate caller is required to have
   <see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
   permission. If your code can be called from partially trusted code, do not pass
   user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
   validation. For important limitations on using the <see langword="LinkDemand"/>
   member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetComObjectData"/>
	</doc>
	<doc for="Marshal.ThrowExceptionForHR">
		<overload>
			<para>Throws an exception with a specific
      failure HRESULT value.</para>
		</overload>
		<summary>
			<para>Throws an exception with a specific failure HRESULT value.</para>
		</summary>
		<param name="errorCode">The HRESULT corresponding to the desired exception.</param>
		<remarks>
			<para>This method creates an exception object for the specified failure HRESULT. If
      the HRESULT is 0 or positive (a success code), the method returns without
      creating or throwing an exception.</para>
			<para>Some failure HRESULTs map to well-defined exceptions, while others do not map to a
      defined exception. If the HRESULT maps to a defined exception, <see cref="System.Runtime.InteropServices.Marshal.ThrowExceptionForHR"/> creates an instance of
      the exception and throws it. Otherwise, it creates an instance of <see cref="System.Runtime.InteropServices.COMException" qualify="true"/>,
      initializes the error code field with
      the HRESULT, and throws that exception. When this method is invoked, it attemps
      to retrieve extra information regarding the error by using the unmanaged
   <see langword="GetErrorInfo"/> function.</para>
			<para>For the mapping from each HRESULT to its comparable exception class in the
      .NET Framework, see <see topic="cpconhresultsexceptions"/>. For additional information about
   <see langword="GetErrorInfo"/>, see the MSDN library.</para>
			<note type="note">
      This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
      being called from untrusted code; only the immediate caller is required to have
   <see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/>
   permission. If your code can be called from partially trusted code, do not pass
   user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
   validation. For important limitations on using the <see langword="LinkDemand"/>
   member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.COMException"/>
	</doc>
	<doc for="Marshal.FreeCoTaskMem">
		<summary>
			<para> Frees a block of memory allocated by the unmanaged COM
      task memory allocator with <see cref="System.Runtime.InteropServices.Marshal.AllocCoTaskMem" qualify="true"/>.
      </para>
		</summary>
		<param name="ptr">The address of the memory to be freed. </param>
		<exception cref="System.ArgumentNullException"><paramref name="ptr"/> is <see langword="null"/>.</exception>
		<remarks>
			<para>You can use <see cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/> to free
   any memory allocated by <see cref="System.Runtime.InteropServices.Marshal.AllocCoTaskMem"/>, <see cref="System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem"/>, or any equivalent unmanaged API.
   If the <paramref name="ptr"/> parameter is
<see langword="null"/>, the method does nothing. </para>
			<para><see cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/> exposes the
<see langword="CoTaskMemFree"/> COM API function, which frees all bytes so that you can no 
longer use the memory pointed to by the <paramref name="ptr"/> parameter. For additional
information about <see langword="CoTaskMemFree"/>, see the MSDN library. </para>
			<para>In addition to <see cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/>, the <see cref="System.Runtime.InteropServices.Marshal"/> class provides two other
memory-deallocation methods: <see cref="System.Runtime.InteropServices.Marshal.DestroyStructure" qualify="true"/> and <see cref="System.Runtime.InteropServices.Marshal.FreeHGlobal" qualify="true"/>. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.AllocCoTaskMem"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.ReAllocCoTaskMem"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.DestroyStructure"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.FreeHGlobal"/>
	</doc>
	<doc for="Marshal.FreeBSTR">
		<summary>
			<para>Frees a BSTR using
   <see langword="SysFreeString"/>.</para>
		</summary>
		<param name="ptr">The address of the BSTR to be freed.</param>
		<exception cref="System.ArgumentNullException"><paramref name="ptr"/> is <see langword="null"/>.</exception>
		<remarks>
			<para>Like <see cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem" qualify="true"/> and <see cref="System.Runtime.InteropServices.Marshal.FreeHGlobal" qualify="true"/>, you can use this method to
   deallocate memory. <see cref="System.Runtime.InteropServices.Marshal.FreeBSTR"/> calls
<see langword="SysFreeString"/>, a COM API method, which frees memory allocated 
   by any of the following unmanaged methods: <see langword="SysAllocString"/>,
<see langword="SysAllocStringByteLen"/>, <see langword="SysAllocStringLen"/>, 
<see langword="SysReAllocString"/>, <see langword="SysReAllocStringLen"/>. You can call unmanaged methods such as these with
   platform invoke. For details, see <see topic="cpconconsumingunmanageddllfunctions"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem" qualify="true"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.FreeHGlobal" qualify="true"/>
	</doc>
	<doc for="Marshal.PtrToStringAnsi">
		<overload>
			<para> Allocates a managed <see cref="System.String"/> and copies all or part of an unmanaged ANSI string into
   it.</para>
		</overload>
		<summary>
			<para> Copies all characters up to the first null from an unmanaged ANSI string to a
      managed <see cref="System.String"/>. Widens each ANSI character to Unicode.</para>
		</summary>
		<param name="ptr">The address of the first character of the unmanaged string.</param>
		<returns>
			<para>A managed <see cref="System.String"/> object that holds a copy
   of the unmanaged ANSI string.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="ptr"/> is <see langword="null"/>.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.PtrToStringAnsi"/> is useful
   for custom marshaling or when mixing managed and unmanaged code. Since this method
   creates a copy of the unmanaged string's contents, you must free the original
   string as appropriate. This method provides the
   opposite functionality of <see cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi" qualify="true"/> and <see cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi" qualify="true"/>. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi"/>
	</doc>
	<doc for="Marshal.PtrToStringAnsi1">
		<summary>
			<para> Allocates a managed <see cref="System.String"/>, copies a specified number of characters
   from an unmanaged ANSI
   string into it,
   and widens each ANSI character to Unicode.</para>
		</summary>
		<param name="ptr">The address of the first character of the unmanaged string.</param>
		<param name="len">The byte count of the input string to copy.</param>
		<returns>
			<para>A managed <see cref="System.String"/> that holds a copy of
   the native ANSI string.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="len"/> is less than zero.</exception>
		<exception cref="System.ArgumentNullException"><paramref name="ptr"/> is <see langword="null"/>.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.PtrToStringAnsi"/> is useful
   for custom marshaling or when mixing managed and unmanaged code. Since this method
   creates a copy of the unmanaged string's contents, you must free the original
   string as appropriate. This method provides the opposite
   functionality of <see cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi" qualify="true"/> and
<see cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi" qualify="true"/>. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi"/>
	</doc>
	<doc for="Marshal.PtrToStringUni">
		<overload>
			<para>Allocates a managed <see cref="System.String"/> and copies a specified number of characters from an
   unmanaged Unicode string into it.</para>
		</overload>
		<summary>
			<para> Copies a specified number of characters from a
      Unicode string stored in native heap to a managed <see cref="System.String"/>.</para>
		</summary>
		<param name="ptr">The address of the first character of the unmanaged string.</param>
		<param name="len">The number of Unicode characters to copy.</param>
		<returns>
			<para>A managed string that holds a copy of
      the native string.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="len"/> is less than zero.</exception>
		<exception cref="System.ArgumentNullException"><paramref name="ptr"/> is <see langword="null"/>.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.PtrToStringUni"/> is useful
   for custom marshaling or when mixing managed and unmanaged code. Since this method
   creates a copy of the unmanaged string's contents, you must free the original
   string as appropriate. This method provides the opposite
   functionality of <see cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni" qualify="true"/> and <see cref="System.Runtime.InteropServices.Marshal.StringToHGlobalUni" qualify="true"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi"/>
	</doc>
	<doc for="Marshal.PtrToStringAuto">
		<overload>
			<para>Allocates a managed <see cref="System.String"/> and copies a specified number of characters from an
   unmanaged string into it.</para>
		</overload>
		<summary>
			<para> Copies a specified number of characters
      from a string stored in unmanaged memory to a managed <see cref="System.String"/>.</para>
		</summary>
		<param name="ptr"><para>For Unicode platforms, the address of the first Unicode character.</para>
			<para>-or-</para>
			<para>For ANSI plaforms, the address of the first ANSI character.</para></param>
		<param name="len">The number of characters to copy.</param>
		<returns>
			<para>A managed string that holds a copy of
      the native string.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="len"/> is less than zero.</exception>
		<exception cref="System.ArgumentNullException"><paramref name="ptr"/> is <see langword="null"/>.</exception>
		<remarks>
			<para> On Unicode platforms, this method calls <see cref="System.Runtime.InteropServices.Marshal.PtrToStringUni"/>; on ANSI platforms, it
   calls <see cref="System.Runtime.InteropServices.Marshal.PtrToStringAnsi"/>. No transformations are
   done before these methods are called.</para>
			<para><see cref="System.Runtime.InteropServices.Marshal.PtrToStringAuto"/> is useful for custom marshaling
or when mixing managed and unmanaged code. Since this method creates a copy of
the unmanaged string's contents, you must free the original string as
appropriate. <see cref="System.Runtime.InteropServices.Marshal.PtrToStringAnsi"/> provides the opposite
functionality of <see cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto" qualify="true"/> and
<see cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAuto" qualify="true"/>. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAuto"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.PtrToStringUni"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.PtrToStringAnsi"/>
	</doc>
	<doc for="Marshal.PtrToStringUni1">
		<summary>
			<para> Allocates a managed <see cref="System.String"/> and copies all characters up to the
   first null character from an unmanaged Unicode string into it.</para>
		</summary>
		<param name="ptr">The address of the first character of the unmanaged string.</param>
		<returns>
			<para>A managed string holding a copy of
      the native string.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="ptr"/> is <see langword="null"/>.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.PtrToStringUni"/> is useful for custom
   marshaling or for use when mixing managed and unmanaged code. Since this method
   creates a copy of the unmanaged string's contents, you must free the original
   string as appropriate. This method provides the opposite
   functionality of <see cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemUni" qualify="true"/> and <see cref="System.Runtime.InteropServices.Marshal.StringToHGlobalUni" qualify="true"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAnsi"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi"/>
	</doc>
	<doc for="Marshal.PtrToStringAuto1">
		<summary>
			<para> Allocates a managed <see cref="System.String"/> and copies all characters up to the
   first null character from a string stored in unmanaged memory into it.</para>
		</summary>
		<param name="ptr"><para>For Unicode platforms, the address of the first Unicode character.</para>
			<para>-or-</para>
			<para>For ANSI plaforms, the address of the first ANSI character.</para></param>
		<returns>
			<para> A managed string that holds a copy
      of the unmanaged string.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="ptr"/> is <see langword="null"/>.</exception>
		<remarks>
			<para> If the current platform is Unicode, each ANSI character is widened
      to a Unicode character and this method calls <see cref="System.Runtime.InteropServices.Marshal.PtrToStringUni"/>. Otherwise this method
      calls <see cref="System.Runtime.InteropServices.Marshal.PtrToStringAnsi"/>.</para>
			<para><see cref="System.Runtime.InteropServices.Marshal.PtrToStringAuto"/> is useful for custom marshaling or when mixing
   managed and unmanaged code. Since this method creates a copy of the unmanaged
   string's contents, you must free the original string as appropriate. <see cref="System.Runtime.InteropServices.Marshal.PtrToStringAnsi"/> provides the opposite
   functionality of <see cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto" qualify="true"/> and
<see cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAuto" qualify="true"/>.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToCoTaskMemAuto"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToHGlobalAuto"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.PtrToStringUni"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.PtrToStringAnsi"/>
	</doc>
	<doc for="Marshal.PtrToStringBSTR">
		<summary>
			<para> Allocates a managed <see cref="System.String"/> and copies a BSTR string stored in unmanaged memory into
   it.</para>
		</summary>
		<param name="ptr">The address of the first character of the unmanaged string.</param>
		<returns>
			<para>A managed string that holds a copy of
      the native string.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="ptr"/> is <see langword="null"/>.</exception>
		<remarks>
			<para>Only call this method on strings allocated with the unmanaged
   <see langword="SysAllocString"/> and <see langword="SysAllocStringLen"/> functions. </para>
			<para><see cref="System.Runtime.InteropServices.Marshal.PtrToStringBSTR"/> is useful
   for custom marshaling or when mixing managed and unmanaged code. Since this method
   creates a copy of the unmanaged string's contents, you must free the original
   string as appropriate. This method provides the opposite
   functionality of <see cref="System.Runtime.InteropServices.Marshal.StringToBSTR" qualify="true"/>. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.StringToBSTR"/>
	</doc>
	<doc for="Marshal.BindToMoniker">
		<summary>
			<para>Gets an interface pointer identified by the specified moniker.</para>
		</summary>
		<param name="monikerName">The moniker corresponding to the desired interface pointer.</param>
		<returns>
			<para>An object containing a reference to
      the interface pointer identified by the <paramref name="monikerName"/> parameter. A
      moniker is a name, and in this case, the moniker is defined by an
      interface.</para>
		</returns>
		<exception cref="System.Runtime.InteropServices.COMException">An unrecognized HRESULT was returned by the unmanaged <see langword="BindToMoniker"/> method.</exception>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.Marshal.BindToMoniker" qualify="true"/> exposes
   the <see langword="BindToMoniker"/> COM API method, which produces an
   object that you can cast to any COM interface you require. This method
   provides the same
   functionality as the <see langword="GetObject"/> method in
   Visual Basic 6.0 and Visual Basic .NET. For additional information about the
<see langword="BindToMoniker "/>COM
   method, see the MSDN
   Library.</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<example>
			<para>The following example demonstrates how to use the <see cref="System.Runtime.InteropServices.Marshal.BindToMoniker"/>
method with the SOAP moniker, provided by Microsoft Windows XP, to
seamlessly access an XML Web service from managed code through COM
interop:</para>
			<code lang="VB">Dim translator As Object = Marshal.BindToMoniker( _
  "SOAP:wsdl=http://www.xmethods.net/sd/2001/BabelFishService.wsdl")
</code>
			<code lang="C#">object translator = Marshal.BindToMoniker(
  "SOAP:wsdl=http://www.xmethods.net/sd/2001/BabelFishService.wsdl");
</code>
		</example>
	</doc>
	<doc for="Marshal.QueryInterface">
		<summary>
			<para> Requests a pointer to a specified interface from a COM
      object.
      </para>
		</summary>
		<param name="pUnk">The interface to be queried. </param>
		<param name="iid">A <see cref="System.Guid"/>, passed by reference, that is the interface identifier (IID) of the requested interface. </param>
		<param name="ppv">When this method returns, contains a reference to the returned interface. </param>
		<returns>
			<para>The returned interface.</para>
		</returns>
		<remarks>
			<para>The <see cref="System.Runtime.InteropServices.Marshal.QueryInterface"/> method exposes
   the <see langword="IUnknown::QueryInterface"/> of a COM object,
   which attempts to obtain a specific interface pointer.
   Using <see langword="QueryInterface"/>
   
   on a COM object is the same as performing
   a cast operation in managed code. Calling an object with this method causes the
   reference count to increment on the interface pointer before the pointer is
   returned. Always use <see cref="System.Runtime.InteropServices.Marshal.Release" qualify="true"/> to decrement the
   reference count once you have finished with the pointer. To obtain an <see cref="System.IntPtr"/> value that represents a <see langword="IUnknown"/>
   interface pointer, you can call <see cref="System.Runtime.InteropServices.Marshal.GetComInterfaceForObject" qualify="true"/>,
<see cref="System.Runtime.InteropServices.Marshal.GetIUnknownForObject" qualify="true"/>, or <see cref="System.Runtime.InteropServices.Marshal.GetIDispatchForObject" qualify="true"/>. </para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.AddRef"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.Release"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetComInterfaceForObject"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetIUnknownForObject"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetIDispatchForObject"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetObjectForIUnknown"/>
	</doc>
	<doc for="Marshal.FreeHGlobal">
		<summary>
			<para> Frees memory previously allocated from the unmanaged memory
      of the process with <see cref="System.Runtime.InteropServices.Marshal.AllocHGlobal"/>.
      </para>
		</summary>
		<param name="hglobal">The handle returned by the original matching call to <see cref="System.Runtime.InteropServices.Marshal.AllocHGlobal"/>.</param>
		<remarks>
			<para>You can use <see cref="System.Runtime.InteropServices.Marshal.FreeHGlobal"/> to free any memory from the global
   heap allocated by <see cref="System.Runtime.InteropServices.Marshal.AllocHGlobal"/>, <see cref="System.Runtime.InteropServices.Marshal.ReAllocHGlobal"/>, or any equivalent unmanaged API
   method. If the <paramref name="hglobal"/> parameter is
<see langword="null"/>, the method does nothing. </para>
			<para><see cref="System.Runtime.InteropServices.Marshal.FreeHGlobal"/> exposes the <see langword="GlobalFree"/> function from Kernel32.DLL, which
frees all bytes so that you can no longer use the memory pointed to by
<paramref name="hglobal"/>. For additional information
about <see langword="GlobalFree"/>, see the MSDN Library.</para>
			<para>In addition to <see cref="System.Runtime.InteropServices.Marshal.FreeHGlobal"/>, the <see cref="System.Runtime.InteropServices.Marshal"/> class provides two other memory-deallocation
API methods: <see cref="System.Runtime.InteropServices.Marshal.DestroyStructure"/> and <see cref="System.Runtime.InteropServices.Marshal.FreeCoTaskMem"/> .</para>
			<note type="note">
   This method uses <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> to prevent it from
   being called from untrusted code; only the immediate caller is required to have
<see cref="System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" qualify="true"/> 
permission. If your code can be called from partially trusted code, do not pass
user input to <see cref="System.Runtime.InteropServices.Marshal"/> class methods without
validation. For important limitations on using the <see langword="LinkDemand"/>
member, see <see topic="cpcondemandvslinkdemand"/>.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission"><para>for operating with unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</para></permission>
		<seealso cref="System.Runtime.InteropServices.Marshal.AllocHGlobal"/>
		<seealso cref="System.Runtime.InteropServices.Marshal.ReAllocHGlobal"/>
	</doc>
	<doc for="Marshal.ReleaseThreadCache">
		<summary>
			<para>This member supports the .NET Framework infrastructure
      and is not intended to be used directly from your
      code.</para>
		</summary>
	</doc>
</docs>
