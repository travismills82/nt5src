<docs>
	<doc for="TypeLibTypeFlags.FLicensed">
		<summary>
			<para>The type is licensed.</para>
		</summary>
	</doc>
	<doc for="TypeLibTypeFlags.FPreDeclId">
		<summary>
			<para>The type is predefined. The client application should 
       automatically create a single instance of the object that has this attribute.
       The name of the variable that points to the object is the same as the class name
       of the object.</para>
		</summary>
	</doc>
	<doc for="TypeLibTypeFlags.FHidden">
		<summary>
			<para>The type should not be displayed to browsers.</para>
		</summary>
	</doc>
	<doc for="TypeLibTypeFlags.FControl">
		<summary>
			<para>The type is a control from which other types will be 
       derived, and should not be displayed to users.</para>
		</summary>
	</doc>
	<doc for="TypeLibTypeFlags.FNonExtensible">
		<summary>
			<para>The interface cannot add members at run time.</para>
		</summary>
	</doc>
	<doc for="TypeLibTypeFlags.FRestricted">
		<summary>
			<para>This flag is intended for system-level types or types 
       that type browsers should not display.</para>
		</summary>
	</doc>
	<doc for="TypeLibTypeFlags.FAggregatable">
		<summary>
			<para>The class supports aggregation.</para>
		</summary>
	</doc>
	<doc for="TypeLibTypeFlags.FDispatchable">
		<summary>
			<para>Indicates that the interface derives from 
    <see langword="IDispatch"/>, either directly or indirectly.</para>
		</summary>
	</doc>
	<doc for="TypeLibFuncFlags.FSource">
		<summary>
			<para>The function returns an object that is a source of events.</para>
		</summary>
	</doc>
	<doc for="TypeLibFuncFlags.FBindable">
		<summary>
    The function that supports data binding.
 </summary>
	</doc>
	<doc for="TypeLibFuncFlags.FDisplayBind">
		<summary>
			<para>The function that is displayed to the user as 
       bindable. <see cref="System.Runtime.InteropServices.TypeLibFuncFlags.FBindable"/> must also be set.</para>
		</summary>
	</doc>
	<doc for="TypeLibFuncFlags.FHidden">
		<summary>
			<para>The function should not be displayed to the user, 
       although it exists and is bindable.</para>
		</summary>
	</doc>
	<doc for="TypeLibFuncFlags.FUiDefault">
		<summary>
			<para>The type information member is the default member for 
       display in the user interface.</para>
		</summary>
	</doc>
	<doc for="TypeLibFuncFlags.FNonBrowsable">
		<summary>
			<para>The property appears in an object browser, but not in a 
       properties browser.</para>
		</summary>
	</doc>
	<doc for="TypeLibFuncFlags.FReplaceable">
		<summary>
			<para>Tags the interface as having default behaviors.</para>
		</summary>
	</doc>
	<doc for="TypeLibVarFlags.FReadOnly">
		<summary>
			<para>Assignment to the variable should not be allowed.</para>
		</summary>
	</doc>
	<doc for="TypeLibVarFlags.FSource">
		<summary>
			<para>The variable returns an object that is a source of events.</para>
		</summary>
	</doc>
	<doc for="TypeLibVarFlags.FBindable">
		<summary>
    The variable supports data binding.
 </summary>
	</doc>
	<doc for="TypeLibVarFlags.FHidden">
		<summary>
    The variable should not be displayed in a browser,
    though it exists and is bindable.
 </summary>
	</doc>
	<doc for="TypeLibVarFlags.FRestricted">
		<summary>
    This flag is intended for system-level functions or
    functions that type browsers should not display.
 </summary>
	</doc>
	<doc for="TypeLibVarFlags.FDefaultCollelem">
		<summary>
			<para>Permits an optimization in which the compiler looks for 
       a member named "xyz" on the type "abc". If such a member is found and is
       flagged as an accessor function for an element of the default collection, then a
       call is generated to that member function.</para>
		</summary>
	</doc>
	<doc for="TypeLibVarFlags.FUiDefault">
		<summary>
			<para>The default display in the user interface.</para>
		</summary>
	</doc>
	<doc for="TypeLibVarFlags.FNonBrowsable">
		<summary>
			<para>The variable appears in an object browser, but not in a 
       properties browser.</para>
		</summary>
	</doc>
	<doc for="TypeLibVarFlags.FReplaceable">
		<summary>
			<para>Tags the interface as having default behaviors.</para>
		</summary>
	</doc>
	<doc for="TypeLibVarFlags.FImmediateBind">
		<summary>
    The variable is mapped as individual bindable
    properties.
 </summary>
	</doc>
	<doc for="TypeLibFuncFlags.FDefaultCollelem">
		<summary>
			<para> Permits an optimization in which the compiler
      looks for a member named "xyz" on the type "abc". If such a member is found and is
      flagged as an accessor function for an element of the default collection, then a
      call is generated to that member function.</para>
		</summary>
	</doc>
	<doc for="ComInterfaceType">
		<summary>
			<para>Identifies how to expose an interface to COM.</para>
		</summary>
		<remarks>
			<para>This enumeration works in conjuction with <see cref="System.Runtime.InteropServices.InterfaceTypeAttribute"/>.</para>
		</remarks>
	</doc>
	<doc for="InterfaceTypeAttribute.Value">
		<summary>
			<para>Gets the <see cref="System.Runtime.InteropServices.ComInterfaceType"/> value that describes how the interface should be exposed to COM.</para>
		</summary>
		<value>
   The <see cref="System.Runtime.InteropServices.ComInterfaceType"/> value that describes how the
   interface should be exposed to COM.
</value>
	</doc>
	<doc for="ClassInterfaceAttribute.Value">
		<summary>
			<para>Gets the <see cref="System.Runtime.InteropServices.ClassInterfaceType"/> value that describes which type of interface should be generated for the class.</para>
		</summary>
		<value>
   The <see cref="System.Runtime.InteropServices.ClassInterfaceType"/> value that describes which type
   of interface should be generated for the class.
</value>
	</doc>
	<doc for="LCIDConversionAttribute.Value">
		<summary>
			<para> Gets the position of the LCID argument in the unmanaged
      signature. </para>
		</summary>
		<value>
			<para>The position of the LCID argument in the unmanaged signature, where 0 is the 
      first argument.</para>
		</value>
	</doc>
	<doc for="IDispatchImplAttribute.Value">
		<summary>
			<para>Gets the <see cref="System.Runtime.InteropServices.IDispatchImplType"/> value used by the
   class.</para>
		</summary>
		<value>
			<para>The <see cref="System.Runtime.InteropServices.IDispatchImplType"/> value used by the class.</para>
		</value>
	</doc>
	<doc for="GuidAttribute.Value">
		<summary>
			<para>Gets the <see cref="System.Guid"/> of the class.</para>
		</summary>
		<value>
   The <see cref="System.Guid"/> of the class.
</value>
	</doc>
	<doc for="StructLayoutAttribute.Value">
		<summary>
			<para>Gets the <see cref="System.Runtime.InteropServices.LayoutKind"/> value that specifies how the
   class or structure is arranged.</para>
		</summary>
		<value>
   The <see cref="System.Runtime.InteropServices.LayoutKind"/> value that specifies how the
   class or structure is arranged.
</value>
	</doc>
	<doc for="FieldOffsetAttribute.Value">
		<summary>
			<para>Gets the offset from the beginning of the structure to the beginning of the
      field.</para>
		</summary>
		<value>
   The offset from the beginning of the
   structure to the beginning of the field.
</value>
	</doc>
	<doc for="ComAliasNameAttribute.Value">
		<summary>
			<para>Gets the alias for the field or parameter as found in the type library when it
      was imported.</para>
		</summary>
		<value>
   The alias for the field or parameter
   as found in the type library when it was imported.
</value>
	</doc>
	<doc for="LCIDConversionAttribute.LCIDConversionAttribute">
		<summary>
			<para>Initializes a new instance of 
      the <see langword="LCIDConversionAttribute"/>
      class with the position of the LCID in the unmanaged signature.</para>
		</summary>
		<param name="lcid">Indicates the position of the LCID argument in the unmanaged signature, where 0 is the first argument.</param>
	</doc>
	<doc for="TypeLibTypeAttribute.TypeLibTypeAttribute1">
		<summary>
			<para>Initializes a new instance of the 
   <see langword="TypeLibTypeAttribute"/> class with the
      specified <see cref="System.Runtime.InteropServices.TypeLibTypeFlags"/> value.</para>
		</summary>
		<param name="flags">The <see cref="System.Runtime.InteropServices.TypeLibTypeFlags"/> value for the attributed type as found in the type library it was imported from.</param>
	</doc>
	<doc for="OptionalAttribute.OptionalAttribute">
		<summary>
			<para>Initializes a new instance of 
      the <see langword="OptionalAttribute"/> class with default values.</para>
		</summary>
	</doc>
	<doc for="ComConversionLossAttribute.ComConversionLossAttribute">
		<summary>
			<para>Initializes a new instance of the
   <see langword="ComConversionLossAttribute"/> 
   class.</para>
		</summary>
	</doc>
	<doc for="TypeLibTypeFlags.FReplaceable">
		<summary>
			<para>The object supports 
   <see langword="IConnectionPointWithDefault"/>, and has default behaviors.</para>
		</summary>
	</doc><doc for="ImportedFromTypeLibAttribute.Value">
		<summary>
			<para> Gets the name of the original type library file.</para>
		</summary>
		<value>
			<para> The name of the original type
 library file.</para>
		</value>
	</doc><doc for="PrimaryInteropAssemblyAttribute.MajorVersion">
		<summary>
			<para>Gets the major version number of the type library for
 which this assembly is the primary interop assembly.</para>
		</summary>
		<value>
			<para> The major version number of the type
 library for which this assembly is the primary interop assembly.</para>
		</value>
	</doc><doc for="PrimaryInteropAssemblyAttribute.MinorVersion">
		<summary>
			<para>Gets the minor version number of the type library for
 which this assembly is the primary interop assembly.</para>
		</summary>
		<value>
			<para>The minor version number of the type
 library for which this assembly is the primary interop assembly.</para>
		</value>
	</doc><doc for="ComRegisterFunctionAttribute.ComRegisterFunctionAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.ComRegisterFunctionAttribute"/>
class.</para>
		</summary>
	</doc><doc for="ComUnregisterFunctionAttribute.ComUnregisterFunctionAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.ComUnregisterFunctionAttribute"/>
class.</para>
		</summary>
	</doc><doc for="VarEnum.VT_I2">
		<summary>
			<para>Indicates a <see langword="short"/> integer.</para>
		</summary>
	</doc><doc for="VarEnum.VT_I4">
		<summary>
			<para>Indicates a <see langword="long"/> integer.</para>
		</summary>
	</doc><doc for="VarEnum.VT_R4">
		<summary>
			<para>Indicates a <see langword="float"/> value.</para>
		</summary>
	</doc><doc for="VarEnum.VT_R8">
		<summary>
			<para>Indicates a <see langword="double"/> value.</para>
		</summary>
	</doc><doc for="VarEnum.VT_CY">
		<summary>
			<para>Indicates a currency value.</para>
		</summary>
	</doc><doc for="VarEnum.VT_DISPATCH">
		<summary>
			<para>Indicates an <see langword="IDispatch"/> pointer.</para>
		</summary>
	</doc><doc for="VarEnum.VT_UNKNOWN">
		<summary>
			<para>Indicates an <see langword="IUnknown"/> 
pointer.</para>
		</summary>
	</doc><doc for="VarEnum.VT_DECIMAL">
		<summary>
			<para>Indicates a <see langword="decimal"/> value.</para>
		</summary>
	</doc><doc for="VarEnum.VT_I1">
		<summary>
			<para>Indicates a <see langword="char"/> value.</para>
		</summary>
	</doc><doc for="VarEnum.VT_INT">
		<summary>
			<para>Indicates an integer value.</para>
		</summary>
	</doc><doc for="VarEnum.VT_UINT">
		<summary>
			<para>Indicates an <see langword="unsigned"/> integer value.</para>
		</summary>
	</doc><doc for="VarEnum.VT_VARIANT">
		<summary>
			<para>Indicates a VARIANT <see langword="far"/> pointer.</para>
		</summary>
	</doc><doc for="VarEnum.VT_I8">
		<summary>
			<para>Indicates a 64-bit integer.</para>
		</summary>
	</doc><doc for="VarEnum.VT_UI8">
		<summary>
			<para>Indicates an 64-bit unsigned integer.</para>
		</summary>
	</doc><doc for="VarEnum.VT_HRESULT">
		<summary>
			<para>Indicates an HRESULT.</para>
		</summary>
	</doc><doc for="VarEnum.VT_PTR">
		<summary>
			<para>Indicates a pointer type.</para>
		</summary>
	</doc><doc for="VarEnum.VT_CARRAY">
		<summary>
			<para>Indicates a C style array.</para>
		</summary>
	</doc><doc for="VarEnum.VT_USERDEFINED">
		<summary>
			<para>Indicates a user defined type.</para>
		</summary>
	</doc><doc for="VarEnum.VT_RECORD">
		<summary>
			<para>Indicates a user defined type.</para>
		</summary>
	</doc><doc for="VarEnum.VT_BLOB">
		<summary>
			<para>Indicates length prefixed bytes.</para>
		</summary>
	</doc><doc for="VarEnum.VT_STREAM">
		<summary>
			<para>Indicates that the name of a stream follows.</para>
		</summary>
	</doc><doc for="VarEnum.VT_STORAGE">
		<summary>
			<para> Indicates that the name of a storage follows.</para>
		</summary>
	</doc><doc for="VarEnum.VT_STREAMED_OBJECT">
		<summary>
			<para>Indicates that a stream contains an object.</para>
		</summary>
	</doc><doc for="VarEnum.VT_STORED_OBJECT">
		<summary>
			<para>Indicates that a storage contains an object.</para>
		</summary>
	</doc><doc for="VarEnum.VT_BLOB_OBJECT">
		<summary>
			<para>Indicates that a blob contains an object.</para>
		</summary>
	</doc><doc for="VarEnum.VT_CF">
		<summary>
			<para>Indicates the clipboard format.</para>
		</summary>
	</doc><doc for="VarEnum.VT_CLSID">
		<summary>
			<para>Indicates a class ID.</para>
		</summary>
	</doc><doc for="VarEnum.VT_ARRAY">
		<summary>
			<para>Indicates a <see langword="SAFEARRAY"/> pointer.</para>
		</summary>
	</doc><doc for="VarEnum.VT_BYREF">
		<summary>
			<para>Indicates that a value is a reference.</para>
		</summary>
	</doc><doc for="IDispatchImplType">
		<summary>
			<para>Indicates which <see langword="IDispatch"/> implementation to use for a
   particular class.</para>
		</summary>
		<remarks>
			<para>See <see cref="System.Runtime.InteropServices.IDispatchImplAttribute"/> for 
   more information.</para>
		</remarks>
	</doc><doc for="IDispatchImplType.InternalImpl">
		<summary>
			<para> Specifies that the
   <see langword="IDispatch"/> implemenation is supplied by the runtime.</para>
		</summary>
	</doc><doc for="VarEnum.VT_BOOL">
		<summary>
			<para>Indicates a Boolean value.</para>
		</summary>
	</doc>
	<doc for="OptionalAttribute">
		<summary>
			<para> Indicates that a parameter is optional.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to parameters.</para>
			<para>Optional parameters are not supported by all languages.</para>
		</remarks>
	</doc>
	<doc for="ProgIdAttribute.Value">
		<summary>
			<para>Gets the ProgID of the class.</para>
		</summary>
		<value>
			<para>The ProgID of the class.</para>
		</value>
	</doc>
	<doc for="IDispatchImplAttribute.IDispatchImplAttribute">
		<overload>
			<para>Initializes a new instance of
      the <see langword="IDispatchImplAttribute"/> class.</para>
		</overload>
		<summary>
			<para>Initializes a new instance of the
   <see langword="IDispatchImplAttribute"/> class with specified <see cref="System.Runtime.InteropServices.IDispatchImplType"/> value.</para>
		</summary>
		<param name="implType">Indicates which <see cref="System.Runtime.InteropServices.IDispatchImplType"/> enumeration will be used.</param>
		<remarks>
			<para>For readable code that is less prone to error, always use this 
      constructor.</para>
		</remarks>
	</doc>
	<doc for="UnmanagedType.Error">
		<summary>
			<para>This native type associated with an <see cref="System.Runtime.InteropServices.UnmanagedType.I4"/> or a <see cref="System.Runtime.InteropServices.UnmanagedType.U4"/> causes the parameter to
   be exported as a HRESULT in the exported type library.</para>
		</summary>
	</doc>
	<doc for="UnmanagedType.LPStr">
		<summary>
			<para> A single byte, null-terminated ANSI character 
      string. You can use this member on the <see cref="System.String" qualify="true"/> or <see cref="System.Text.StringBuilder" qualify="true"/> data types
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.IUnknown">
		<summary>
			<para>A COM <see langword="IUnknown"/> 
pointer. You can use this member on the <see cref="System.Object"/> data
type.</para>
		</summary>
	</doc>
	<doc for="UnmanagedType.LPStruct">
		<summary>
			<para> A pointer to a C-style structure that you use to marshal managed formatted classes. Valid for platform
      invoke methods only.
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.LPWStr">
		<summary>
			<para> A 2-byte, null-terminated Unicode character string.
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.SysInt">
		<summary>
			<para> A platform-dependent, signed integer. 4-bytes on 32 bit Windows, 8-bytes on
      64 bit Windows.</para>
		</summary>
	</doc>
	<doc for="UnmanagedType.SysUInt">
		<summary>
			<para>A platform-dependent, unsigned integer. 4-bytes on 32 bit 
      Windows, 8-bytes on 64 bit Windows.</para>
		</summary>
	</doc>
	<doc for="UnmanagedType.VBByRefStr">
		<summary>
			<para>Allows Visual Basic .NET to change a string in unmanaged code, and have the results reflected in managed code. This value
      is only supported for platform invoke.</para>
		</summary>
	</doc>
	<doc for="StructLayoutAttribute.Size">
		<summary>
			<para>Indicates the absolute size of the class or structure.</para>
		</summary>
		<remarks>
			<para>Must be greater or equal to the sum of all members. This 
      field is primarily for compiler writers to specify the total size (in bytes) of
      the class or structure, and is useful for extending memory occupied by a structure for direct, unmanaged access. For example, you can use this field when working with unions
      that are not represented in metadata directly.</para>
		</remarks>
	</doc>
	<doc for="ComInterfaceType.InterfaceIsIDispatch">
		<summary>
			<para> Indicates an interface is exposed to COM as a dispinterface, which enables late binding only.</para>
		</summary>
	</doc>
	<doc for="TypeLibTypeFlags.FAppObject">
		<summary>
			<para>A type description that describes an <see langword="Application"/> object.</para>
		</summary>
	</doc>
	<doc for="TypeLibTypeFlags.FReverseBind">
		<summary>
   Indicates base interfaces should be checked for name
   resolution before checking child interfaces. This is the reverse of the default behavior.
</summary>
	</doc>
	<doc for="TypeLibFuncFlags.FDefaultBind">
		<summary>
			<para>The function that best represents the object. Only one function in a type information can have this attribute.</para>
		</summary>
	</doc>
	<doc for="TypeLibVarFlags.FRequestEdit">
		<summary>
			<para>Indicates that the property supports the COM <see langword="OnRequestEdit"/>
notification.</para>
		</summary>
	</doc>
	<doc for="TypeLibVarFlags.FDefaultBind">
		<summary>
   The variable is the single property that best represents
   the object. Only one variable in a type info can have this value.
   </summary>
	</doc>
	<doc for="VarEnum.VT_EMPTY">
		<summary>
			<para>Indicates that a value was not specified.</para>
		</summary>
	</doc>
	<doc for="UnmanagedType.Struct">
		<summary>
			<para> A VARIANT, which is used to marshal managed formatted classes and value
      types.
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.LPArray">
		<summary>
			<para>A pointer to the first element of a C-style array. When marshaling from
      managed to unmanaged, the length of the array is determined by the length of the
      managed array. When marshaling from unmanaged to managed, the length of the
      array is determined from the <see cref="System.Runtime.InteropServices.MarshalAsAttribute.SizeConst" qualify="true"/> and the <see cref="System.Runtime.InteropServices.MarshalAsAttribute.SizeParamIndex" qualify="true"/> fields, optionally followed by
      the unmanaged type of the elements within the array when it is necessary to
      differentiate among string types.</para>
		</summary>
	</doc>
	<doc for="UnmanagedType.Currency">
		<summary>
			<para>Used on a <see cref="System.Decimal" qualify="true"/> to marshal the decimal value as a COM currency type
   instead of as a <see langword="Decimal"/>.
</para>
		</summary>
	</doc>
	<doc for="InAttribute.InAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.InAttribute"/>
class.</para>
		</summary>
	</doc>
	<doc for="OutAttribute.OutAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.OutAttribute"/>
class.</para>
		</summary>
	</doc>
	<doc for="ComInterfaceType.InterfaceIsIUnknown">
		<summary>
			<para>Indicates an interface is exposed to COM as
      an <see langword="IUnknown"/>-derived interface, which enables only
      early binding.</para>
		</summary>
	</doc>
	<doc for="InterfaceTypeAttribute.InterfaceTypeAttribute">
		<overload>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.InterfaceTypeAttribute"/> class.</para>
		</overload>
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.InterfaceTypeAttribute"/> class
   with the specified <see cref="System.Runtime.InteropServices.ComInterfaceType"/>
   enumeration
   member.</para>
		</summary>
		<param name="interfaceType">One of the <see cref="System.Runtime.InteropServices.ComInterfaceType"/> values that describes how the interface should be exposed to COM clients.</param>
		<remarks>
			<para>For readable code that is less prone to error, always use this
      constructor.</para>
		</remarks>
	</doc>
	<doc for="ClassInterfaceAttribute.ClassInterfaceAttribute">
		<overload>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.ClassInterfaceAttribute"/> class.</para>
		</overload>
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.ClassInterfaceAttribute"/>
class with the specified <see cref="System.Runtime.InteropServices.ClassInterfaceType"/>
enumeration
member.</para>
		</summary>
		<param name="classInterfaceType">One of the <see cref="System.Runtime.InteropServices.ClassInterfaceType"/> values that describes the type of interface that is generated for a class.</param>
		<remarks>
			<para>For readable code that is less prone to error, always use this
      constructor.</para>
		</remarks>
	</doc>
	<doc for="UnmanagedType.Interface">
		<summary>
			<para>A COM interface pointer. The <see cref="System.Guid"/> of the interface is obtained from the class metadata. 
   Use this member to specify the exact interface type or the default interface
   type if you apply it to a class. This member produces <see cref="System.Runtime.InteropServices.UnmanagedType.IUnknown" qualify="true"/> behavior when you apply it to the <see cref="System.Object"/> data
   type.</para>
		</summary>
	</doc>
	<doc for="UnmanagedType.SafeArray">
		<summary>
			<para>A <see langword="SafeArray"/> is a 
   self-describing array that carries the type, rank, and bounds of the associated
   array data. You can use this member with the <see cref="System.Runtime.InteropServices.MarshalAsAttribute.SafeArraySubType" qualify="true"/>
   field to override the default element type.</para>
		</summary>
	</doc>
	<doc for="PrimaryInteropAssemblyAttribute.PrimaryInteropAssemblyAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute"/> class with the major and minor version numbers of
   the type library for which this assembly is the primary interop assembly.</para>
		</summary>
		<param name="major">The major version of the type library for which this assembly is the primary interop assembly.</param>
		<param name=" minor">The minor version of the type library for which this assembly is the primary interop assembly.</param>
		<remarks>
			<para>The <see cref="System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute"/> can appear multiple times if the
   assembly is the primary interop assembly for multiple versions of the same type
   library.</para>
		</remarks>
	</doc>
	<doc for="ComSourceInterfacesAttribute.ComSourceInterfacesAttribute1">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.ComSourceInterfacesAttribute"/> class with the type to use as a source interface.</para>
		</summary>
		<param name="sourceInterface">The <see cref="System.Type"/> of the source interface.</param>
		<remarks>
			<para>Use this constructor to expose a single event source interface to
      COM clients.</para>
		</remarks>
	</doc>
	<doc for="ComSourceInterfacesAttribute.ComSourceInterfacesAttribute2">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.ComSourceInterfacesAttribute"/> class with the types to use as
   source interfaces.</para>
		</summary>
		<param name="sourceInterface1">The <see cref="System.Type"/> of the default source interface.</param>
		<param name=" sourceInterface2">The <see cref="System.Type"/> of a source interface.</param>
		<remarks>
			<para>Use this constructor to expose two event source interfaces to COM
      clients.</para>
		</remarks>
	</doc>
	<doc for="ComSourceInterfacesAttribute.ComSourceInterfacesAttribute3">
		<summary>
			<para>Initializes a new instance of the
   <see langword="ComSourceInterfacesAttribute"/> class with the types to use as
      source interfaces.</para>
		</summary>
		<param name="sourceInterface1">The <see cref="System.Type"/> of the default source interface.</param>
		<param name=" sourceInterface2">The <see cref="System.Type"/> of a source interface.</param>
		<param name=" sourceInterface3">The <see cref="System.Type"/> of a source interface.</param>
		<remarks>
			<para>Use this constructor to expose three event source interfaces to COM
      clients.</para>
		</remarks>
	</doc>
	<doc for="ComSourceInterfacesAttribute.ComSourceInterfacesAttribute4">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.ComSourceInterfacesAttribute"/> class with the types to use as
   source interfaces.</para>
		</summary>
		<param name="sourceInterface1">The <see cref="System.Type"/> of the default source interface.</param>
		<param name=" sourceInterface2">The <see cref="System.Type"/> of a source interface.</param>
		<param name=" sourceInterface3">The <see cref="System.Type"/> of a source interface.</param>
		<param name=" sourceInterface4">The <see cref="System.Type"/> of a source interface.</param>
		<remarks>
			<para>Use this constructor to expose four event source interfaces to COM
      clients.</para>
		</remarks>
	</doc>
	<doc for="UnmanagedType.I1">
		<summary>
			<para> A 1-byte signed integer. You can use this member to
      transform a Boolean value into a 1-byte, C-style <see langword="bool"/>
      (<see langword="true"/> =
      1, <see langword="false"/> =
      0).
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.U1">
		<summary>
			<para> A 1-byte unsigned integer.
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.I2">
		<summary>
			<para> A 2-byte signed integer.
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.U2">
		<summary>
			<para> A 2-byte unsigned integer.
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.I4">
		<summary>
			<para> A 4-byte signed integer.
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.U4">
		<summary>
			<para> A 4-byte unsigned integer.
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.I8">
		<summary>
			<para> An 8-byte signed integer.
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.U8">
		<summary>
			<para> An 8-byte unsigned integer.
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.R4">
		<summary>
			<para> A 4-byte floating point number.
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.R8">
		<summary>
			<para> An 8-byte floating point number.
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.AnsiBStr">
		<summary>
			<para> An ANSI character string that is a length prefixed, single
      byte. You can use this member on the <see cref="System.String"/> data type.
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.TBStr">
		<summary>
			<para> A length-prefixed, platform-dependent
   <see langword="char"/> string. ANSI on Windows 98, Unicode on Windows NT. You rarely
      use this BSTR-like member.</para>
		</summary>
	</doc>
	<doc for="UnmanagedType.VariantBool">
		<summary>
			<para>A 2-byte, OLE-defined VARIANT_BOOL type (<see langword="true"/> = -1,
<see langword="false"/> = 0).</para>
		</summary>
	</doc>
	<doc for="UnmanagedType.AsAny">
		<summary>
			<para>A dynamic type that determines the type of an object at run
      time and marshals the object as that type. Valid for platform invoke
      methods only.
      </para>
		</summary>
	</doc>
	<doc for="MarshalAsAttribute.Value">
		<summary>
			<para>Gets the <see cref="System.Runtime.InteropServices.UnmanagedType"/> value the data
   is to be marshaled as.</para>
		</summary>
		<value>
			<para>The <see cref="System.Runtime.InteropServices.UnmanagedType"/> value the data is to be
   marshaled as.</para>
		</value>
		<remarks>
			<para>This value is used with <see cref="System.Runtime.InteropServices.MarshalAsAttribute"/> to
   indicate how types should be marshaled between managed and unmanaged code.
   In some cases, you can use this field with
   certain <see langword="UnmanagedType"/> enumeration members.
   For <see cref="System.Runtime.InteropServices.UnmanagedType.CustomMarshaler"/> and
<see cref="System.Runtime.InteropServices.UnmanagedType.ByValArray"/>, 
   you must use additional named parameters. </para>
		</remarks>
	</doc>
	<doc for="DllImportAttribute.DllImportAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.DllImportAttribute"/> class
   with the name of the DLL containing the method to import.</para>
		</summary>
		<param name="dllName">The name of the DLL that contains the unmanaged method.</param>
	</doc>
	<doc for="DllImportAttribute.EntryPoint">
		<summary>
			<para>Indicates the name or ordinal of the DLL entry point to
      be
      called.</para>
		</summary>
		<remarks>
			<para>You can specify the entry-point name by supplying a
      string indicating the name of the DLL containing the entry point, or you can
      identify the entry point by its ordinal. Ordinals are prefixed with the # sign,
      for example, #1. If you omit this field, the common language runtime uses the
      name of the .NET method marked with the <see cref="System.Runtime.InteropServices.DllImportAttribute"/>.</para>
			<para>For additional information, see <see topic="cpconidentifyingfunctionsindlls"/>. For examples showing how to use
   the <see cref="System.Runtime.InteropServices.DllImportAttribute.EntryPoint"/> field, see
<see topic="cpconentrypointobjectfield" title="Specifying an Entry Point"/>.</para>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.DllImportAttribute"/>
	</doc>
	<doc for="DllImportAttribute.CharSet">
		<summary>
			<para> Indicates how to marshal string parameters to
      the method and controls name
      mangling.</para>
		</summary>
		<remarks>
			<para> Use this field with a member of the <see cref="System.Runtime.InteropServices.CharSet"/> enumeration to specify the
   marshaling behavior of string parameters and to specify which entry-point name to
   invoke (the exact name given or a name ending with "A" or "W"). The default
   enumeration member for C# and Visual Basic is <see langword="CharSet.Ansi"/>
   and the default enumeration member for C++ is <see langword="CharSet.None"/>,
   which is equivalent to <see langword="CharSet.Ansi"/>. In Visual Basic, you use
   the <see langword="Declare"/> statement to specify
   the <see langword="CharSet"/> field. </para>
			<para>The <see cref="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling"/> field influences the behavior of
the <see langword="CharSet"/>
field in determining which entry-point name to invoke. For
a detailed description and examples of the string marshaling and name matching
behavior associated with the <see langword="CharSet"/> field, see
<see topic="cpconcharsetobjectfield" title="Specifying a Character Set"/>.</para>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling"/>
	</doc>
	<doc for="ClassInterfaceType">
		<summary>
			<para>Identifies the type of class interface that is generated
      for a class.</para>
		</summary>
		<remarks>
			<para>This enumeration is used in conjunction with the <see cref="System.Runtime.InteropServices.ClassInterfaceAttribute"/>.</para>
		</remarks>
		<seealso topic="cpgrftypelibraryexportertlbexpexe"/>
	</doc>
	<doc for="TypeLibFuncFlags">
		<summary>
			<para>Describes the original settings of 
      the <see langword="FUNCFLAGS"/>
      in the COM type library from where this method was imported.</para>
		</summary>
		<remarks>
			<para><see cref="System.Runtime.InteropServices.TypeLibFuncFlags"/> is used with the <see cref="System.Runtime.InteropServices.TypeLibFuncAttribute"/>.
   The flags are retained for reference only. They are not used by the common language
   runtime.</para>
			<para> For more information about 
<see langword="FUNCFLAGS"/>, see the MSDN library.</para>
		</remarks>
	</doc>
	<doc for="VarEnum.VT_UI1">
		<summary>
			<para> Indicates a <see langword="byte"/>.</para>
		</summary>
	</doc>
	<doc for="VarEnum.VT_UI2">
		<summary>
			<para>Indicates an <see langword="unsigned"/>
				<see langword="short"/>.</para>
		</summary>
	</doc>
	<doc for="VarEnum.VT_UI4">
		<summary>
			<para>Indicates an <see langword="unsigned"/>
				<see langword="long"/>.</para>
		</summary>
	</doc>
	<doc for="VarEnum.VT_VOID">
		<summary>
			<para>Indicates a C style <see langword="void"/>.</para>
		</summary>
	</doc>
	<doc for="VarEnum.VT_LPWSTR">
		<summary>
			<para>Indicates a wide string terminated by <see langword="null"/>.</para>
		</summary>
	</doc>
	<doc for="VarEnum.VT_VECTOR">
		<summary>
			<para>Indicates a simple, counted array.</para>
		</summary>
	</doc>
	<doc for="IDispatchImplType.CompatibleImpl">
		<summary>
			<para>Specifies that the <see langword="IDispatch"/> implementation is supplied by passing the
   type information for the object to the COM <see langword="CreateStdDispatch"/> API
   method.</para>
		</summary>
	</doc>
	<doc for="TypeLibTypeFlags">
		<summary>
			<para>Describes the original settings of the <see cref="System.Runtime.InteropServices.TYPEFLAGS"/>
in the COM type library from which the type was imported.</para>
		</summary>
		<remarks>
			<para><see langword="TypeLibTypeFlags"/> is used along with the <see cref="System.Runtime.InteropServices.TypeLibTypeAttribute"/>. The
   flags
   are retained for reference only. They are not used by the common language runtime.</para>
			<para> For more information, see
<see langword="TYPEFLAGS"/> in the MSDN library.</para>
		</remarks>
	</doc>
	<doc for="TypeLibTypeFlags.FCanCreate">
		<summary>
			<para>Instances of the type can be created by
      <see langword="ITypeInfo::CreateInstance"/>.</para>
		</summary>
	</doc>
	<doc for="TypeLibFuncFlags.FRestricted">
		<summary>
			<para>This flag is intended for system-level functions or
      functions that type browsers should not display.</para>
		</summary>
	</doc>
	<doc for="TypeLibFuncFlags.FRequestEdit">
		<summary>
			<para>When set, any call to a method that sets the property
      results first in a call to <see langword="IPropertyNotifySink::OnRequestEdit"/>.</para>
		</summary>
	</doc>
	<doc for="TypeLibFuncFlags.FUsesGetLastError">
		<summary>
			<para>The function supports <see langword="GetLastError"/>.</para>
		</summary>
	</doc>
	<doc for="TypeLibFuncFlags.FImmediateBind">
		<summary>
			<para>The function is mapped as individual bindable properties.</para>
		</summary>
	</doc>
	<doc for="TypeLibVarFlags">
		<summary>
			<para>Describes the original settings of the <see cref="System.Runtime.InteropServices.VARFLAGS"/>
in the COM type library from which the variable was imported.</para>
		</summary>
		<remarks>
			<para><see langword="TypeLibVarFlags"/> is used in conjunction with the <see cref="System.Runtime.InteropServices.TypeLibVarAttribute"/>.
   The flags are retained for reference only. They are not used by the common language
   runtime.</para>
			<para> For more information, see
<see langword="VARFLAGS"/> in the MSDN library.</para>
		</remarks>
	</doc>
	<doc for="TypeLibTypeAttribute.TypeLibTypeAttribute">
		<overload>
			<para>Initializes a new instance of the
   <see langword="TypeLibTypeAttribute"/> class.</para>
		</overload>
		<summary>
			<para>Initializes a new instance of
      the <see langword="TypeLibTypeAttribute"/> class with the
      specified <see cref="System.Runtime.InteropServices.TypeLibTypeFlags" qualify="true"/> value.</para>
		</summary>
		<param name="flags">The <see cref="System.Runtime.InteropServices.TypeLibTypeFlags"/> value for the attributed type as found in the type library it was imported from.</param>
		<seealso cref="System.Runtime.InteropServices.TypeLibTypeFlags" qualify="true"/>
	</doc>
	<doc for="TypeLibTypeAttribute.Value">
		<summary>
			<para>Gets the <see cref="System.Runtime.InteropServices.TypeLibTypeFlags" qualify="true"/> value for this type.</para>
		</summary>
		<value>
			<para>The <see cref="System.Runtime.InteropServices.TypeLibTypeFlags"/> value for this type.</para>
		</value>
		<seealso cref="System.Runtime.InteropServices.TypeLibTypeFlags"/>
	</doc>
	<doc for="TypeLibFuncAttribute.TypeLibFuncAttribute">
		<overload>
			<para>Initializes a new instance of
      the <see langword="TypeLibFuncAttribute"/> class.</para>
		</overload>
		<summary>
			<para>Initializes a new instance of
      the <see langword="TypeLibFuncAttribute"/> class
      with the specified <see cref="System.Runtime.InteropServices.TypeLibFuncFlags" qualify="true"/>
      value.</para>
		</summary>
		<param name="flags">The <see cref="System.Runtime.InteropServices.TypeLibFuncFlags"/> value for the attributed method as found in the type library it was imported from.</param>
		<seealso cref="System.Runtime.InteropServices.TypeLibFuncFlags"/>
	</doc>
	<doc for="TypeLibFuncAttribute.TypeLibFuncAttribute1">
		<summary>
			<para>Initializes a new instance of the
   <see langword="TypeLibFuncAttribute"/> class with the
      specified <see cref="System.Runtime.InteropServices.TypeLibFuncFlags" qualify="true"/> value.</para>
		</summary>
		<param name="flags">The <see cref="System.Runtime.InteropServices.TypeLibFuncFlags"/> value for the attributed method as found in the type library it was imported from.</param>
		<seealso cref="System.Runtime.InteropServices.TypeLibFuncFlags"/>
	</doc>
	<doc for="TypeLibFuncAttribute.Value">
		<summary>
			<para>Gets the <see cref="System.Runtime.InteropServices.TypeLibFuncFlags" qualify="true"/> value for this method.</para>
		</summary>
		<value>
			<para>The <see cref="System.Runtime.InteropServices.TypeLibFuncFlags"/> value for this method.</para>
		</value>
		<seealso cref="System.Runtime.InteropServices.TypeLibFuncFlags"/>
	</doc>
	<doc for="TypeLibVarAttribute.TypeLibVarAttribute">
		<overload>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.TypeLibVarAttribute"/> class.</para>
		</overload>
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.TypeLibVarAttribute"/> class
   with the specified <see cref="System.Runtime.InteropServices.TypeLibVarFlags" qualify="true"/>
   value.</para>
		</summary>
		<param name="flags">The <see cref="System.Runtime.InteropServices.TypeLibVarFlags"/> value for the attributed field as found in the type library it was imported from.</param>
		<seealso cref="System.Runtime.InteropServices.TypeLibVarFlags"/>
	</doc>
	<doc for="TypeLibVarAttribute.TypeLibVarAttribute1">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.TypeLibVarAttribute"/> class with the
   specified <see cref="System.Runtime.InteropServices.TypeLibVarFlags" qualify="true"/> value.</para>
		</summary>
		<param name="flags">The <see cref="System.Runtime.InteropServices.TypeLibVarFlags"/> value for the attributed field as found in the type library it was imported from.</param>
		<seealso cref="System.Runtime.InteropServices.TypeLibVarFlags"/>
	</doc>
	<doc for="TypeLibVarAttribute.Value">
		<summary>
			<para>Gets the <see cref="System.Runtime.InteropServices.TypeLibVarFlags"/> value for this field.</para>
		</summary>
		<value>
			<para>The <see cref="System.Runtime.InteropServices.TypeLibVarFlags"/> value for this field.</para>
		</value>
		<seealso cref="System.Runtime.InteropServices.TypeLibVarFlags"/>
	</doc>
	<doc for="UnmanagedType.IDispatch">
		<summary>
			<para>A COM <see langword="IDispatch"/>
pointer (<see langword="Object"/> in Microsoft Visual Basic
6.0).</para>
		</summary>
	</doc>
	<doc for="MarshalAsAttribute.MarshalAsAttribute">
		<overload>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.MarshalAsAttribute"/> class.</para>
		</overload>
		<summary>
			<para>Initializes a new instance of
      the <see cref="System.Runtime.InteropServices.MarshalAsAttribute"/> class with the
      specified <see cref="System.Runtime.InteropServices.UnmanagedType"/>
      enumeration
      member.</para>
		</summary>
		<param name="unmanagedType">The <see cref="System.Runtime.InteropServices.UnmanagedType"/> value the data is to be marshaled as.</param>
		<remarks>
			<para>For readable code that is less prone to error, always use this
      constructor.</para>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.UnmanagedType"/>
	</doc>
	<doc for="MarshalAsAttribute.SafeArrayUserDefinedSubType">
		<summary>
			<para> Indicates the user-defined element type of the
   <see cref="System.Runtime.InteropServices.UnmanagedType.SafeArray" qualify="true"/>. </para>
		</summary>
		<remarks>
			<para>Initialize this field with your custom type to enable the elements of the
   <see langword="SAFEARRAY"/> to be marshaled successfully.
      
      This field is only needed when the <see cref="System.Runtime.InteropServices.MarshalAsAttribute.SafeArraySubType" qualify="true"/> is either <see cref="System.Runtime.InteropServices.VarEnum.VT_UNKNOWN" qualify="true"/>, <see cref="System.Runtime.InteropServices.VarEnum.VT_DISPATCH" qualify="true"/>, or <see cref="System.Runtime.InteropServices.VarEnum.VT_RECORD" qualify="true"/>. For additional
      information, see <see topic="cpcondefaultmarshalingforarrays"/>.</para>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.UnmanagedType.SafeArray"/>
		<seealso cref="System.Runtime.InteropServices.MarshalAsAttribute.SafeArraySubType"/>
	</doc>
	<doc for="MarshalAsAttribute.ArraySubType">
		<summary>
			<para>Specifies the element type of the unmanaged <see cref="System.Runtime.InteropServices.UnmanagedType.LPArray" qualify="true"/> or <see cref="System.Runtime.InteropServices.UnmanagedType.ByValArray" qualify="true"/>.</para>
		</summary>
		<remarks>
			<para> You can set this parameter to a value from
      the <see cref="System.Runtime.InteropServices.UnmanagedType" qualify="true"/>
      enumeration to specify the type of the array's elements. If a type is not
      specified, the default unmanaged type corresponding to the managed array's element type is used. For example, the <see langword="ArraySubType"/> for a
   <see langword="LPWStr"/> array in COM is <see cref="System.Runtime.InteropServices.UnmanagedType.LPWStr" qualify="true"/>. For additional
      information, see <see topic="cpcondefaultmarshalingforarrays"/>.</para>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.UnmanagedType"/>
	</doc>
	<doc for="MarshalAsAttribute.SizeParamIndex">
		<summary>
			<para>Indicates which parameter contains the count of array
      elements, much like <see langword="size_is"/> in COM, and is zero-based.</para>
		</summary>
		<remarks>
			<para>This field is used when building managed objects that 
      work with COM. <see cref="System.Runtime.InteropServices.MarshalAsAttribute.SizeParamIndex"/> is only valid
      on managed methods that are called from COM clients, where one of the parameters
      is an array. Since the marshaler cannot determine the size of an unmanaged
      array, this information is passed in a separate parameter.</para>
			<para> 
      
      The parameter
      containing the size must be an integer that is passed by value. If you specify
      both the <see cref="System.Runtime.InteropServices.MarshalAsAttribute.SizeParamIndex"/> and <see cref="System.Runtime.InteropServices.MarshalAsAttribute.SizeConst" qualify="true"/>
      with a <see cref="System.Runtime.InteropServices.UnmanagedType.LPArray" qualify="true"/>, the sum of their
      values produces a size total. This field does not have any effect on managed
      code that calls COM objects. For additional information, see <see topic="cpcondefaultmarshalingforarrays"/>.</para>
		</remarks>
		<example>
			<codelink SampleID="System.Runtime.InteropServices.MarshalAsAttribute.SizeParamIndex" SnippetID="1"/>
		</example>
		<seealso cref="System.Runtime.InteropServices.MarshalAsAttribute.SizeConst"/>
		<seealso cref="System.Runtime.InteropServices.UnmanagedType.LPArray"/>
	</doc>
	<doc for="MarshalAsAttribute.SizeConst">
		<summary>
			<para> Indicates the number of elements in the fixed-length array or the number of characters (not bytes) in a string
      to import.</para>
		</summary>
		<remarks>
			<para>This field is required for the <see cref="System.Runtime.InteropServices.UnmanagedType.ByValArray"/> and <see cref="System.Runtime.InteropServices.UnmanagedType.ByValTStr"/> members of the <see cref="System.Runtime.InteropServices.UnmanagedType" qualify="true"/>
enumeration. For additional information, see <see topic="cpcondefaultmarshalingforarrays"/>. </para>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.UnmanagedType"/>
	</doc>
	<doc for="MarshalAsAttribute.MarshalType">
		<summary>
			<para>Specifies the fully qualified name of a custom
      marshaler.</para>
		</summary>
		<remarks>
			<para>You can use either the <see cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalType"/>
or <see cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalTypeRef" qualify="true"/> field specify
a custom marshaler type for the attributed parameter, field, or return type.
The <see cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalType"/> field enables you to
specify a string representing the fully qualified name of a custom marshaler. It
is useful for late-bound references, but is less preferred than <see cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalTypeRef"/> for
specifying a custom marshaler. For additional information about creating and
using custom marshalers, see <see topic="cpconcustommarshaling"/>.</para>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalTypeRef"/>
	</doc>
	<doc for="ComImportAttribute.ComImportAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.ComImportAttribute"/>.</para>
		</summary>
	</doc>
	<doc for="GuidAttribute.GuidAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.GuidAttribute"/> class with the specified 
   GUID.</para>
		</summary>
		<param name="guid">The <see cref="System.Guid"/> to be assigned.</param>
	</doc>
	<doc for="PreserveSigAttribute.PreserveSigAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.PreserveSigAttribute"/>
class.</para>
		</summary>
	</doc>
	<doc for="ComAliasNameAttribute.ComAliasNameAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.ComAliasNameAttribute"/>
class with the alias for the attributed field or parameter.</para>
		</summary>
		<param name="alias">The alias for the field or parameter as found in the type library when it was imported.</param>
	</doc>
	<doc for="ComInterfaceType.InterfaceIsDual">
		<summary>
			<para> Indicates the interface is exposed to COM as a dual 
      interface, which enables both early and late binding. <see cref="System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual"/>
      is the default value.</para>
		</summary>
	</doc>
	<doc for="ClassInterfaceType.AutoDual">
		<summary>
			<para> Indicates that a dual class interface
      is automatically generated for the class and exposed to COM. Type information is produced
      for the class interface and published in the type library. Using
   <see langword="AutoDual"/> is strongly discouraged because of the versioning
      limitations described in <see cref="System.Runtime.InteropServices.ClassInterfaceAttribute"/>.</para>
		</summary>
	</doc>
	<doc for="ImportedFromTypeLibAttribute">
		<summary>
			<para> Indicates that the types defined within an assembly were originally defined in a
      type library.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to assemblies, although the 
   <see topic="cpgrftypelibraryImportertlbimpexe"/> 
   typically applies it for you when it a type library.</para>
			<para> The primary
   use of the attribute is to capture the original source
   of the type information. For example, you can import A.tlb
   as an interop assembly called A.dll and have assembly
   B.dll reference A.dll. When you export B.dll to B.tlb, this attribute
   causes the references in B.tlb that point to A.dll to point instead to
   A.tlb. This should not be confused with the <see cref="System.Runtime.InteropServices.ComImportAttribute"/>, which specifies that an individual type is implemented in
   COM.</para>
		</remarks>
		<example>
			<codelink SampleID="ImprovedInteropSnippets" SnippetID="3"/>
		</example>
		<seealso topic="cpgrftypelibraryImportertlbimpexe"/>
		<seealso cref="System.Runtime.InteropServices.ComImportAttribute"/>
	</doc>
	<doc for="ImportedFromTypeLibAttribute.ImportedFromTypeLibAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.ImportedFromTypeLibAttribute"/>
class with the name of the
original type library
file.</para>
		</summary>
		<param name="tlbFile">The location of the original type library file.</param>
	</doc>
	<doc for="IDispatchImplType.SystemDefinedImpl">
		<summary>
			<para> Specifies that the common language runtime decides which
   <see langword="IDispatch"/>
   implementation to use.</para>
		</summary>
	</doc>
	<doc for="ComConversionLossAttribute">
		<summary>
			<para>Indicates that information was lost about a class or interface when it was imported from
      a type library to an assembly.</para>
		</summary>
		<remarks>
			<para> The <see topic="cpgrftypelibraryImportertlbimpexe"/> applies this attribute to classes or
   interfaces.</para>
			<para> Methods that use <see langword="void"/>
pointer arguments cause this attribute to be applied to the containing
class or interface.</para>
		</remarks>
		<seealso topic="cpgrftypelibraryImportertlbimpexe"/>
	</doc>
	<doc for="TypeLibTypeFlags.FDual">
		<summary>
			<para>The interface supplies both <see langword="IDispatch"/> and V-table
   binding.</para>
		</summary>
	</doc>
	<doc for="TypeLibVarFlags.FDisplayBind">
		<summary>
			<para>The variable is displayed as bindable. <see cref="System.Runtime.InteropServices.TypeLibVarFlags.FBindable"/> must also be set.</para>
		</summary>
	</doc>
	<doc for="VarEnum">
		<summary>
			<para> Indicates how to marshal the array
      elements when an array is marshaled from managed to unmanaged code as a <see cref="System.Runtime.InteropServices.UnmanagedType.SafeArray" qualify="true"/>.</para>
		</summary>
		<remarks>
			<para>Used with <see cref="System.Runtime.InteropServices.MarshalAsAttribute" qualify="true"/> to
   explicitly control the element type of the <see cref="System.Runtime.InteropServices.UnmanagedType.SafeArray"/>.</para>
		</remarks>
		<example>
			<codelink SampleID="ImprovedInteropSnippets" SnippetID="2"/>
		</example>
		<seealso cref="System.Runtime.InteropServices.UnmanagedType.SafeArray"/>
		<seealso cref="System.Runtime.InteropServices.MarshalAsAttribute"/>
	</doc>
	<doc for="UnmanagedType.BStr">
		<summary>
			<para> A Unicode character string that is a
      length-prefixed double byte. You can use this member, which is the default string
      in COM, on the <see cref="System.String"/> data
      type.
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.LPTStr">
		<summary>
			<para> A platform-dependent character string: ANSI on Windows
      98 and Unicode on Windows NT and Windows XP. This value is only supported for platform invoke, and
      not COM interop, because exporting a string of type
   <see langword="LPTStr"/>
   is not supported.</para>
		</summary>
	</doc>
	<doc for="UnmanagedType.ByValArray">
		<summary>
			<para>When <see cref="System.Runtime.InteropServices.MarshalAsAttribute.Value" qualify="true"/> is set to
<see langword="ByValArray"/>, the <see cref="System.Runtime.InteropServices.MarshalAsAttribute.SizeConst"/> must be set
   to indicate the number of elements in the array. The <see cref="System.Runtime.InteropServices.MarshalAsAttribute.ArraySubType"/> field can optionally contain
   the <see cref="System.Runtime.InteropServices.UnmanagedType"/> of the array elements when it is necessary
   to differentiate among string types. You can only use this <see cref="System.Runtime.InteropServices.UnmanagedType"/> on an array
   that appear as fields in a structure.</para>
		</summary>
	</doc>
	<doc for="UnmanagedType.FunctionPtr">
		<summary>
			<para> An integer that can be used as a C-style function
      pointer. You can use this member on a <see cref="System.Delegate"/> data type or a type that inherits from
      a <see cref="System.Delegate"/>.
      </para>
		</summary>
	</doc>
	<doc for="UnmanagedType.CustomMarshaler">
		<summary>
			<para> Specifies the custom marshaler class when used
      with <see cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalType" qualify="true"/> or <see cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalTypeRef" qualify="true"/>.
      The <see cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalCookie" qualify="true"/> field can be
      used to pass additional
      information to
      the custom marshaler.
      You
      can use this member on any reference type.
      </para>
		</summary>
	</doc>
	<doc for="StructLayoutAttribute">
		<summary>
			<para>The <see langword="StructLayoutAttribute"/> class allows the user to control the physical
   layout of the data fields of a class or structure.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to classes or structures.</para>
			<para>Typically, the common language runtime controls the
      physical layout of the data fields of a class or structure in managed memory. If
      the class or structure needs to be arranged a certain way, you can
      use <see cref="System.Runtime.InteropServices.StructLayoutAttribute"/>. Explicit
      control of a class layout is important if the class is to be passed to unmanaged
      code that expects a specific layout. The <see cref="System.Runtime.InteropServices.LayoutKind"/> value
   <see langword="Sequential "/>is used to force the members to be laid out
      sequentially in the order they appear. <see langword="Explicit "/> controls the precise position of each data member. With
   <see langword="Explicit"/>,<see langword=" "/>each member must use the <see cref="System.Runtime.InteropServices.FieldOffsetAttribute"/> to
      indicate the position of that field within the type.</para>
			<para> C#, Visual Basic. NET, and C++ compilers
      apply the <see langword="Sequential"/> layout value to classes and
      structures by default. The <see topic="cpgrfTypeLibraryImporterTlbimpexe"/>
      
      also applies this attribute; it always applies
      the <see langword="Sequential"/> value when
      it imports a type library.</para>
		</remarks>
		<example>
			<para>The following example demonstrates a managed declaration
      of the <c>GetSystemTime</c> function
   and defines <c>MySystemTime</c>
class with <see cref="System.Runtime.InteropServices.LayoutKind.Explicit" qualify="true"/> layout. The <c>GetSystemTime</c> gets
the system time and prints to the console.</para>
			<codelink SampleID="StructLayoutAttribute" SnippetID="1"/>
		</example>
		<seealso topic="cpgrfTypeLibraryImporterTlbimpexe"/>
	</doc>
	<doc for="StructLayoutAttribute.StructLayoutAttribute">
		<overload>
			<para>Initalizes a new instance of the <see cref="System.Runtime.InteropServices.StructLayoutAttribute"/> class.</para>
		</overload>
		<summary>
			<para>Initalizes a new instance of the <see cref="System.Runtime.InteropServices.StructLayoutAttribute"/> class
   with the specified <see cref="System.Runtime.InteropServices.LayoutKind" qualify="true"/>
   enumeration member.</para>
		</summary>
		<param name="layoutKind">One of the <see cref="System.Runtime.InteropServices.LayoutKind"/> values that specifes how the class or structure should be arranged.</param>
		<remarks>
			<para>For readable code that is less prone to error, always use this
      constructor.</para>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.LayoutKind"/>
	</doc>
	<doc for="StructLayoutAttribute.Pack">
		<summary>
			<para>Controls the alignment of data fields of a class or
      structure in memory.</para>
		</summary>
		<remarks>
			<para>This field indicates the packing size that should be
      used when the <see cref="System.Runtime.InteropServices.LayoutKind.Sequential" qualify="true"/> value
      is specified. The value of <see langword="Pack"/> must be 0, 1, 2, 4,
      8, 16, 32, 64, or 128. A value of 0 indicates that the packing alignment is set
      to the default for the current platform.</para>
			<para> The default packing size is 8, except
      for unmanaged structures that typically have a
      default packing size of 4.</para>
		</remarks>
	</doc>
	<doc for="FieldOffsetAttribute.FieldOffsetAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.FieldOffsetAttribute"/>
class with the offset in the structure to the beginning of the field.</para>
		</summary>
		<param name="offset">The offset in bytes from the beginning of the structure to the beginning of the field.</param>
	</doc>
	<doc for="CoClassAttribute">
		<summary>
			<para> Specifies the
      class identifier of a coclass imported from a type library.</para>
		</summary>
		<remarks>
			<para>You can apply this attribute to coclass interfaces, 
      although the <see topic="cpgrfTypeLibraryImporterTlbimpexe"/>
      typically applies it for you when it imports a type
      library.</para>
			<para>When Tlbimp.exe imports a coclass, it produces a managed
      class and an interface to represent the coclass. The coclass interface has the
      same interface identifier (IID) as the default interface of the original
      coclass. The imported coclass interface also retains the name of the
      coclass. Tlbimp.exe appends the original coclass name with "class" to identify
      the imported class.</para>
			<para> You rarely apply this attribute. However, if plan
      to write source code that produces metadata that closely simulates
      metadata produced by Tlbimp.exe, you should create a coclass interface for each
      coclass. Use the name of the original coclass to name the coclass interface and
      derive it from the default interface. In addition to the <see cref="System.Runtime.InteropServices.CoClassAttribute"/>, you
      must also apply the <see cref="System.Runtime.InteropServices.ComImportAttribute" qualify="true"/>
      and <see cref="System.Runtime.InteropServices.GuidAttribute" qualify="true"/> to
      the coclass interface. For additional information about how Tlbimp.exe imports
      interfaces and coclasses from a type library, see <see topic="cpcontlbimptypeconversion"/>.</para>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.ComImportAttribute"/>
		<seealso cref="System.Runtime.InteropServices.GuidAttribute"/>
		<seealso topic="cpgrfTypeLibraryImporterTlbimpexe"/>
	</doc>
	<doc for="ClassInterfaceType.None">
		<summary>
			<para> Indicates that no class interface is generated for the
      class. If no interfaces are implemented explicitly, the class can only provide late
      bound access through the <see langword="IDispatch"/>
      interface. This is the recommended setting for
   <see cref="System.Runtime.InteropServices.ClassInterfaceAttribute"/>.
      Using <see langword="ClassInterfaceType.None"/> is the only way to expose functionality
      through interfaces implemented explicitly by the class.</para>
			<para> The <see topic="cpgrftypelibraryExportertlbexpexe"/>

exposes the first public, COM-visible interface
implemented by the class as the default interface of the coclass. If the class
implements no interfaces, the first public, COM-visible interface implemented by
a base class becomes the default interface (starting with the most recently
derived base class and working backward). Tlbexp.exe exposes
<see langword="_Object"/> as the default interface if neither
the class nor its base classes implement interfaces.</para>
		</summary>
	</doc>
	<doc for="TypeLibFuncAttribute">
		<summary>
			<para>Contains the <see cref="System.Runtime.InteropServices.FUNCFLAGS"/> that
   were originally imported for this method from the COM type library.</para>
		</summary>
		<remarks>
			<para> The <see topic="cpgrftypelibraryImportertlbimpexe"/> applies this attribute to methods.</para>
			<para> This attribute is applied when a type library is imported
   and should never be changed. It is only applied when the method's <see cref="System.Runtime.InteropServices.FUNCFLAGS"/>
   evaluate
   to non zero. The attribute is designed to be used by tools that need
   to know how the original <see cref="System.Runtime.InteropServices.FUNCFLAGS"/>
   were set. The common language runtime does not use this
   attribute.</para>
		</remarks>
		<example>
			<para> The following example demonstrates how to get the <see cref="System.Runtime.InteropServices.TypeLibFuncAttribute"/> value of a method.</para>
			<codelink SampleID="ImprovedInteropSnippets" SnippetID="5"/>
		</example>
		<seealso topic="cpgrftypelibraryImportertlbimpexe"/>
	</doc>
	<doc for="ComVisibleAttribute.ComVisibleAttribute">
		<summary>
			<para>Initializes a new instance of
      the <see langword="ComVisibleAttribute"/> class.</para>
		</summary>
		<param name="visibility"><see langword="true"/> to indicate that the type is visible to COM; otherwise, <see langword="false"/>. The default is <see langword="true"/>.</param>
		<remarks>
			<para>To make types visible to COM, set the
      attribute to <see langword="true"/>. To hide types from COM, set the attribute to
   <see langword="false"/>.</para>
		</remarks>
	</doc>
	<doc for="ComImportAttribute">
		<summary>
			<para>Indicates that the attributed type was previously defined in COM.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to classes or interfaces,
      although the <see topic="cpgrfTypeLibraryImporterTlbimpexe"/>
      typically applies it for you when it imports
      a type
      library.</para>
			<para><see cref="System.Runtime.InteropServices.ComImportAttribute"/>
is
a pseudo-custom attribute that indicates that a type has been defined in a previously
published type library. The common language runtime treats these types
differently when activating, exporting, coercing, and so
on.</para>
			<para>A pseudo-custom attribute indicates that bits of the core metadata of a type need to be set when the
   attribute is present. Unlike a custom attribute that extends the metadata for
   a type and is saved along with the type, a pseudo-custom attribute modifies the
   metadata for the type and is discarded.</para>
		</remarks>
		<example>
			<para>The following example demonstrates how to apply the <see cref="System.Runtime.InteropServices.ComImportAttribute"/> to a managed interface
   declaration. You apply this attribute only when generating an interop assembly
   manually in source code, and want to simulate the metadata produced by
   Tlbimp.exe.</para>
			<codelink SampleID="ImprovedInteropSnippets" SnippetID="2"/>
		</example>
		<seealso topic="cpgrfTypeLibraryImporterTlbimpexe"/>
	</doc>
	<doc for="StructLayoutAttribute.CharSet">
		<summary>
			<para>Indicates how string data fields within the class should
      be marshaled as <see langword="LPWSTR"/> or <see langword="LPSTR"/>
      by default.</para>
		</summary>
		<remarks>
			<para>If the <see langword="CharSet"/> field is set to <see cref="System.Runtime.InteropServices.CharSet.Unicode" qualify="true"/>, all string arguments
   are converted to Unicode characters (<see langword="LPWSTR"/>) before being passed to the unmanaged
   implementation. If the field is set to <see cref="System.Runtime.InteropServices.CharSet.Ansi" qualify="true"/>, the strings are
   converted to ANSI strings (<see langword="LPSTR"/>). If the <see langword="CharSet"/> field is set to
<see cref="System.Runtime.InteropServices.CharSet.Auto" qualify="true"/>, the conversion is platform dependent 
   (Unicode on Windows NT, Windows 2000, Windows XP, and Windows .NET
   Server family; ANSI on Windows 98 and Windows Me).</para>
		</remarks>
	</doc>
	<doc for="DispIdAttribute">
		<summary>
			<para> Specifies the COM dispatch identifier (DISPID) of a method, field, or property.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to methods, fields, or properties.</para>
			<para>This attribute contains the DISPID for the method, field,
      or property it describes. Unique DISPIDs are typically assigned by the common
      language runtime, but you can use this attribute to assign a specific DISPID to a method. When importing a type library, this attribute
      is applied to all methods with assigned DISPIDs. This ensures
      that any managed implementation of the same method retains the same DISPID if exposed to
      COM.</para>
		</remarks>
		<example>
			<para>The following example demonstrates how explicit DISPIDs can be assigned to members of a class.</para>
			<codelink SampleID="Classic DispIdAttribute Example" SnippetID="1"/>
		</example>
	</doc>
	<doc for="DispIdAttribute.DispIdAttribute">
		<summary>
			<para>Initializes a new instance of the
   <see langword="DispIdAttribute"/> class with the specified
      DISPID.</para>
		</summary>
		<param name="dispId">The DISPID for the member.</param>
	</doc>
	<doc for="DispIdAttribute.Value">
		<summary>
			<para>Gets the DISPID for the member.</para>
		</summary>
		<value>
			<para>The DISPID for the member.</para>
		</value>
	</doc>
	<doc for="ClassInterfaceType.AutoDispatch">
		<summary>
			<para>Indicates that the class only supports late binding for
      COM clients. A dispinterface for the class is automatically exposed to COM
      clients on request. The type library produced by the type
   <see topic="cpgrftypelibraryExportertlbexpexe"/>
   
   does not contain type information for the dispinterface in order to
   prevent clients from caching the DISPIDs of the interface. The
   dispinterface does not exhibit the versioning problems
   described in <see cref="System.Runtime.InteropServices.ClassInterfaceAttribute"/> because clients can only late
   bind to the interface.</para>
			<para> This is the default setting for <see cref="System.Runtime.InteropServices.ClassInterfaceAttribute"/>.</para>
		</summary>
	</doc>
	<doc for="ClassInterfaceAttribute">
		<summary>
			<para>Indicates the type of class interface to be generated for a class exposed to COM,
      if an interface is generated at all.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to assemblies or classes.</para>
			<para> This attribute controls whether the
   <see topic="cpgrftypelibraryexportertlbexpexe"/> automatically
      generates a class interface for the attributed class. A class
      interface carries the same name as the class itself, but the name is
      prefixed with an underscore. When exposed, the class interface contains all the
   <see langword="public"/>, non-<see langword="static"/>
   
   members of the managed class, including members inherited from its base class. Managed classes cannot access a
   class interface and have no need to as they can access the
   class members directly. Tlbexp.exe generates a unique interface identifier (IID) for the class interface.</para>
			<para> Class interfaces can be dual or dispatch-only
   interfaces. Optionally, you can suppress the generation of the class interface and provide
   a custom interface instead. You expose or suppress a class interface
   by specifying a <see cref="System.Runtime.InteropServices.ClassInterfaceType" qualify="true"/> enumeration member. When
   you apply <see cref="System.Runtime.InteropServices.ClassInterfaceAttribute"/>
   
   to an assembly, the attribute pertains to all classes in the assembly unless
   the individual classes override the setting with their own attribute.</para>
			<para> Although class interfaces eliminate the task of explicitly defining interfaces
   for each class, their use in production applications is strongly discouraged. Dual class interfaces
   allow clients to bind to a specific interface layout that
   is subject to change as the class evolves. For example, consider a
   managed class that exposes a class interface to COM clients. The first
   version of the class contains methods <c>North</c> and <c>South</c>. An unmanaged client can bind to the
class interface, which provides <c>North</c> as the first method in the class interface and
method <c>South</c> as the
second method. Now consider the next version of the class, which has a
new method, <c>East</c>, inserted
between methods <c>North</c>
and <c>South</c>. Unmanaged clients that try
to bind to the new class through the old class interface end up calling
method <c>East</c> when they
intend to call method <c>South</c>, because the positioning of methods within
the interface has changed. Moreover, any change to the layout of a base
class also affects the layout of the class interface for all derived classes.
Managed clients, which bind directly to classes, do not exhibit the same
versioning problems. For specific guidelines on using a class interface,
see <see topic="cpconintroducingclassinterface"/>. </para>
			<para> The <see topic="cpgrftypelibraryImportertlbimpexe"/> always applies to imported classes
the <see cref="System.Runtime.InteropServices.ClassInterfaceType.None" qualify="true"/>
enumeration member to indicate
that existing COM classes never expose managed interfaces. </para>
		</remarks>
		<example>
			<para> The following example shows how to apply
      the <see cref="System.Runtime.InteropServices.ClassInterfaceAttribute"/> with
      the <see cref="System.Runtime.InteropServices.ClassInterfaceType"/> value <see cref="System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch"/>, which generates an
   <see langword="IDispatch"/> interface for
      <c>MyClass</c>.</para>
			<codelink SampleID="Classic ClassInterfaceAttribute Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Runtime.InteropServices.ClassInterfaceType"/>
		<seealso topic="cpgrftypelibraryexportertlbexpexe"/>
		<seealso topic="cpgrftypelibraryimportertlbimpexe"/>
	</doc>
	<doc for="ComVisibleAttribute.Value">
		<summary>
			<para>Gets a value that indicates whether the COM type is visible.</para>
		</summary>
		<value>
			<para><see langword="true"/>if the type is visible; otherwise, 
<see langword="false"/>. The default value is <see langword="true"/>.</para>
		</value>
	</doc>
	<doc for="LCIDConversionAttribute">
		<summary>
			<para> Indicates that a method's unmanaged signature expects
      a locale identifier (LCID) parameter.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to methods.</para>
			<para> This attribute indicates that the marshaler should expect an LCID to be passed
      after the designated method argument. When calls are made from managed to
      unmanaged code, the marshaler supplies the LCID argument automatically.</para>
		</remarks>
		<example>
			<para>The following example demonstrates different signature translations based on different values
      supplied to <see langword="LCIDConversionAttribute"/>.</para>
			<codelink SampleID="LCIDConversionAttributeSample2" SnippetID="1"/>
		</example>
	</doc>
	<doc for="ProgIdAttribute">
		<summary>
			<para> Allows the user to specify the ProgID of a class.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to classes.</para>
			<para> ProgIDs are automatically generated for a class by
      combining the namespace with the type name. This can produce an invalid ProgID
      however, as ProgIDs are limited to 39 characters and can contain no punctuation
      other than a period. In such case, a ProgID can be manually assigned to the
      class using <see cref="System.Runtime.InteropServices.ProgIdAttribute"/>.</para>
		</remarks>
		<example>
			<para>The following example demonstrates how to apply <see langword="ProgIdAttribute"/> on a class. The
   application then gets all attributes of <c>MyClass</c>, and prints the <see cref="System.Runtime.InteropServices.ProgIdAttribute.Value"/> property of
<see langword="ProgIdAttribute"/>. </para>
			<codelink SampleID="ProgIdAttribute_Value" SnippetID="1"/>
		</example>
	</doc>
	<doc for="ProgIdAttribute.ProgIdAttribute">
		<summary>
			<para>Initializes a new instance of the
   <see langword="ProgIdAttribute"/> with the specified ProgID.</para>
		</summary>
		<param name="progId"> The ProgID to be assigned to the class.</param>
	</doc>
	<doc for="IDispatchImplAttribute">
		<summary>
			<para> Indicates which <see langword="IDispatch"/>
implementation the common language runtime uses when exposing dual interfaces and
dispinterfaces to COM.</para>
		</summary>
		<remarks>
			<para> You can apply
      this attribute to
      classes or
      assemblies.</para>
			<para>This attribute should only be set when an explicit
      implementation is required. When you set the attribute to <see cref="System.Runtime.InteropServices.IDispatchImplType.CompatibleImpl"/>, the <see langword="IDispatch"/> implementation is supplied by passing
      the type information for the object to COM's <see langword="CreateStdDispatch"/>
      API. When you set the attribute to <see cref="System.Runtime.InteropServices.IDispatchImplType.InternalImpl"/>, the <see langword="IDispatch"/> implementation is supplied by the common language
      runtime. Setting the attribute to <see cref="System.Runtime.InteropServices.IDispatchImplType.SystemDefinedImpl"/>
      allows
      the runtime to choose the appropriate implementation. When using the attribute on an assembly,
      the attribute applies to all classes defined within the assembly. When using
      the attribute on an individual class, the attribute applies only to the interfaces
      exposed by that class and overrides any assembly-level setting.</para>
		</remarks>
		<example>
			<para>The following example demonstrates how to
      apply <see cref="System.Runtime.InteropServices.IDispatchImplAttribute"/> to select
      the <see langword="IDispatch"/> implementation supplied by the common language runtime.</para>
			<codelink SampleID="ImprovedInteropSnippets" SnippetID="1"/>
		</example>
		<seealso cref="System.Runtime.InteropServices.IDispatchImplType"/>
	</doc>
	<doc for="IDispatchImplAttribute.IDispatchImplAttribute1">
		<summary>
			<para>Initializes a new instance of
      the <see langword="IDispatchImplAttribute"/>
      class with specified <see cref="System.Runtime.InteropServices.IDispatchImplType"/>
      value.</para>
		</summary>
		<param name="implType">Indicates which <see cref="System.Runtime.InteropServices.IDispatchImplType"/> enumeration will be used.</param>
		<remarks>
			<para>This constructor takes an underlying 16-bit signed integer that
      represents each <see cref="System.Runtime.InteropServices.IDispatchImplType"/> enumeration member. The Type
      Library
      Importer (TlbImp.exe) uses this constructor to avoid generating a typeref to
      the <see langword="IDispatchImplType"/> value that <paramref name="value"/> represents,
      and then builds the signature with that token. </para>
		</remarks>
	</doc>
	<doc for="ComSourceInterfacesAttribute">
		<summary>
			<para> Identifies a list of interfaces that are exposed as COM event sources
      for the attributed class.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to classes.</para>
			<para>You apply this attribute to a managed class to identify
      the event interfaces that the class exposes as COM connection points. An event
      interface contains methods that map to the event members of the class. The class
      event name and the interface method name must be the same. This attribute can
      accommodate up to four source interfaces for a class by passing the type of the
      source interface to the appropriate constructor, which take between one and four
      type arguments. For classes that want to expose more than four source
      interfaces, the string version of the constructor can be used. For additional
      information about exposing .NET events to COM clients, see <see topic="cpconraisingeventshandledbycomsink"/>.</para>
		</remarks>
		<example>
			<para>The following example shows how to apply the <see cref="System.Runtime.InteropServices.ComSourceInterfacesAttribute"/> to connect the event sink
   interface to a class by passing the namespace and event sink interface.</para>
			<codelink SampleID="Classic ComSourceInterfacesAttribute Example" SnippetID="1"/>
		</example>
	</doc>
	<doc for="ComSourceInterfacesAttribute.ComSourceInterfacesAttribute">
		<overload>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.ComSourceInterfacesAttribute"/> class.</para>
		</overload>
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.ComSourceInterfacesAttribute"/> class
   with the name of the event source interface.</para>
		</summary>
		<param name="sourceInterfaces">A <see langword="null"/>-delimited list of fully qualified event source interface names.</param>
		<remarks>
			<para>Use this constructor to expose more than four event source interfaces to COM
      clients.</para>
		</remarks>
	</doc>
	<doc for="ComSourceInterfacesAttribute.Value">
		<summary>
			<para> Gets the fully qualified name of the event source interface.</para>
		</summary>
		<value>
			<para> The fully qualified name of the event source interface.</para>
		</value>
		<remarks>
			<para> If you specify more than one source interface, the value 
      returned is a <see langword="null"/>-delimited list of fully
      qualified event source interface names.</para>
		</remarks>
	</doc>
	<doc for="TypeLibTypeFlags.FOleAutomation">
		<summary>
			<para>The types used in the interface are fully compatible
      with Automation, including vtable binding support.</para>
		</summary>
	</doc>
	<doc for="TypeLibTypeAttribute">
		<summary>
			<para>Contains the <see cref="System.Runtime.InteropServices.TYPEFLAGS"/> that were
   originally imported for this type from the COM type library.</para>
		</summary>
		<remarks>
			<para> The <see topic="cpgrftypelibraryImportertlbimpexe"/> applies this attribute to classes or interfaces.</para>
			<para> This attribute is applied when a type library is imported
   and should never be changed. It is only applied when the method's <see cref="System.Runtime.InteropServices.TYPEFLAGS"/>
   
   evaluate to non-zero. The attribute is designed to be used by tools that need
   to know how the original <see cref="System.Runtime.InteropServices.TYPEFLAGS"/>
   were set. The common language runtime does not use this
   attribute.</para>
		</remarks>
		<example>
			<para> The following example demonstrates how to get the <see cref="System.Runtime.InteropServices.TypeLibTypeAttribute"/> value of a class or
   interface.</para>
			<codelink SampleID="ImprovedInteropSnippets" SnippetID="4"/>
		</example>
		<seealso topic="cpgrftypelibraryImportertlbimpexe"/>
	</doc>
	<doc for="TypeLibVarAttribute">
		<summary>
			<para>Contains the <see cref="System.Runtime.InteropServices.VARFLAGS"/> that
   were originally imported for this field from the COM type library.</para>
		</summary>
		<remarks>
			<para> The <see topic="cpgrftypelibraryImportertlbimpexe"/> applies this attribute to fields.</para>
			<para>This attribute is applied when a type library is imported
   and should never be changed. It is only applied when the method's <see langword="VARFLAGS"/> evaluate to non-zero. The
   attribute is designed to be used by tools that need to know how the
   original <see langword="VARFLAGS"/>
   
   were set. The common language runtime does not use this
   attribute.</para>
		</remarks>
		<example>
			<para>The following example demonstrates how to get the <see cref="System.Runtime.InteropServices.TypeLibVarAttribute"/> value of a field.</para>
			<codelink SampleID="TypeLibVar" SnippetID="1"/>
		</example>
		<seealso topic="cpgrftypelibraryImportertlbimpexe"/>
	</doc>
	<doc for="VarEnum.VT_DATE">
		<summary>
			<para>Indicates a DATE value.</para>
		</summary>
	</doc>
	<doc for="VarEnum.VT_BSTR">
		<summary>
			<para>Indicates a BSTR string.</para>
		</summary>
	</doc>
	<doc for="VarEnum.VT_ERROR">
		<summary>
			<para>Indicates an SCODE.</para>
		</summary>
	</doc>
	<doc for="VarEnum.VT_FILETIME">
		<summary>
			<para>Indicates a FILETIME value.</para>
		</summary>
	</doc>
	<doc for="VarEnum.VT_NULL">
		<summary>
			<para> Indicates a <see langword="null"/> value,
   similar to a null value in SQL.</para>
		</summary>
	</doc>
	<doc for="VarEnum.VT_SAFEARRAY">
		<summary>
			<para>Indicates a SAFEARRAY. Not valid
   in a VARIANT.</para>
		</summary>
	</doc>
	<doc for="VarEnum.VT_LPSTR">
		<summary>
			<para>Indicates a <see langword="null"/> terminated string.</para>
		</summary>
	</doc>
	<doc for="UnmanagedType.Bool">
		<summary>
			<para> A 4-byte Boolean value (<see langword="true "/>!= 0, <see langword="false "/>= 0). This is the
   Win32 BOOL type.
   </para>
		</summary>
	</doc>
	<doc for="MarshalAsAttribute">
		<summary>
			<para> Indicates how to marshal the data between managed and unmanaged code.</para>
		</summary>
		<remarks>
			<para>You can apply this attribute to parameters, fields, or return values.</para>
			<para> This attribute is optional, as each
      data type has a default marshaling behavior. This attribute is only necessary
      when a given type can be marshaled to multiple types. For example, you can marshal a string to unmanaged code as either a <see cref="System.Runtime.InteropServices.UnmanagedType.LPStr"/>, a <see cref="System.Runtime.InteropServices.UnmanagedType.LPWStr"/>, a <see cref="System.Runtime.InteropServices.UnmanagedType.LPTStr"/>, or a <see cref="System.Runtime.InteropServices.UnmanagedType.BStr"/>. By default, the
      common language runtime marshals a
      string parameter as a <see cref="System.Runtime.InteropServices.UnmanagedType.BStr"/> to COM methods.
      You can
      apply the <see cref="System.Runtime.InteropServices.MarshalAsAttribute"/> attribute to an
      individual field or parameter to cause that particular string to be marshaled as
      a <see cref="System.Runtime.InteropServices.UnmanagedType.LPStr"/> instead of a <see cref="System.Runtime.InteropServices.UnmanagedType.BStr"/>. The
   <see topic="cpgrfTypeLibraryExporterTlbexpexe"/>
   passes your marshaling preferences to the common language
   runtime.</para>
			<para> Some parameters
   and return values have different default marshaling behavior when used with COM interop or
   platform invoke. By default, the runtime marshals a string parameter (and fields
   in a value type) as a <see cref="System.Runtime.InteropServices.UnmanagedType.LPStr"/> to a platform
   invoke method or function. For additional information, see <see topic="cpcondefaultmarshalingbehavior"/>.</para>
			<para>In most cases, the attribute simply identifies the format
   of the unmanaged data using the <see cref="System.Runtime.InteropServices.UnmanagedType"/> enumeration, as shown in the
   following C# signature:</para>
			<para><c>void
   MyMethod([MarshalAs(LPStr)] String s);</c></para>
			<para>Some <see cref="System.Runtime.InteropServices.UnmanagedType"/> enumeration members
require
additional information. For example, additional information is needed when
the <see cref="System.Runtime.InteropServices.UnmanagedType"/>
is <see cref="System.Runtime.InteropServices.UnmanagedType.LPArray"/>. For a complete
description of how to use this attribute with arrays, see <see topic="cpcondefaultmarshalingforarrays"/>.</para>
			<para>The <see topic="cpgrfTypeLibraryImporterTlbimpexe"/> also applies this
attribute to parameters, fields, and return values to indicate that the data
type in the input type library is not the default type for the corresponding
managed data type. Tlbimp.exe always applies the <see cref="System.Runtime.InteropServices.MarshalAsAttribute"/> to <see cref="System.String"/>
and <see cref="System.Object"/> types for clarity, regardless of the type specified in the input type
library.</para>
		</remarks>
		<example>
			<para>The following examples show the placement of
      the <see cref="System.Runtime.InteropServices.MarshalAsAttribute"/> in managed source code as
      applied to parameters, field, and return values. </para>
			<code lang="VB">'Applied to a parameter.
  Public Sub M1 (&lt;MarshalAs(UnmanagedType.LPWStr)&gt; msg As String)
'Applied to a field within a class.
  Class MsgText 
    &lt;MarshalAs(UnmanagedType.LPWStr)&gt; Public msg As String
  End Class
'Applied to a a return value.
  Public Function M2() As &lt;MarshalAs(UnmanagedType.LPWStr)&gt; String
   </code>
			<code lang="C#">//Applied to a parameter.
  public void M1 ([MarshalAs(UnmanagedType.LPWStr)]String msg);
//Applied to a field within a class.
  class MsgText {
    [MarshalAs(UnmanagedType.LPWStr)] Public String msg;
  }
//Applied to a return value.
[return: MarshalAs(UnmanagedType.LPWStr)]
public String GetMessage();
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.UnmanagedType"/>
		<seealso topic="cpgrfTypeLibraryExporterTlbexpexe"/>
		<seealso topic="cpgrfTypeLibraryImporterTlbimpexe"/>
	</doc>
	<doc for="MarshalAsAttribute.SafeArraySubType">
		<summary>
			<para>Indicates the element type of the <see cref="System.Runtime.InteropServices.UnmanagedType.SafeArray" qualify="true"/>.</para>
		</summary>
		<remarks>
			<para> You can set this field to a value from
      the <see cref="System.Runtime.InteropServices.VarEnum" qualify="true"/> enumeration to specify the type
      of the safe array's elements. If a type is not specified, the managed element
      type's default type (if passed as a VARIANT) is used. For example, the <see langword="SafeArraySubType"/> for an
      <see langword="int"/> array in COM is <see cref="System.Runtime.InteropServices.VarEnum.VT_I4"/>. For additional
      information, see <see topic="cpcondefaultmarshalingforarrays"/>.</para>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.UnmanagedType.SafeArray"/>
		<seealso cref="System.Runtime.InteropServices.VarEnum"/>
	</doc>
	<doc for="MarshalAsAttribute.MarshalCookie">
		<summary>
			<para> Provides additional information to a custom marshaler.</para>
		</summary>
		<remarks>
			<para>This field is optional when using a custom
      marshaler.</para>
			<para> You can set this field to a string that supplies
      additional information to a custom marshaler. For example, the same marshaler
      can be used to provide a number of wrappers, where the cookie is used to indicate the specific
      wrapper.</para>
		</remarks>
	</doc>
	<doc for="GuidAttribute">
		<summary>
			<para> Supplies an explicit <see cref="System.Guid" qualify="true"/> when an automatic GUID is undesirable.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to assemblies, interfaces,
      classes, enumerations, structures, or delegates, although the
   <see topic="cpgrfTypeLibraryImporterTlbimpexe"/>
   can apply it for you when
   it imports
   a type
   library.</para>
			<para>The string passed to the attribute must be in a format that
   is an acceptable constructor argument for the type <see cref="System.Guid"/>. To avoid conflicts with the type
<see cref="System.Guid"/>, use the long name <see cref="System.Runtime.InteropServices.GuidAttribute"/> explicitly. Only use an 
   explicit GUID when a type must have a specific GUID. If the attribute is
   omitted, a GUID is assigned automatically.
   </para>
		</remarks>
		<example>
			<para>The following example demonstrates how to apply the <see cref="System.Runtime.InteropServices.GuidAttribute"/> to a class that
   is exported to COM with a fixed GUID.</para>
			<codelink SampleID="Classic GuidAttribute Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Guid"/>
		<seealso topic="cpgrfTypeLibraryImporterTlbimpexe"/>
	</doc>
	<doc for="PreserveSigAttribute">
		<summary>
			<para> Indicates that the HRESULT 
      or <see langword="retval"/> signature transformation
      that takes place during COM interop calls should be suppressed.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to methods.</para>
			<para> By default, the
   <see topic="cpgrfTypeLibraryExporterTlbexpexe"/>
   ensures that a call that returns an HRESULT of S_OK is transformed such that the
   [out, retval] parameter is used as the function return value. The S_OK HRESULT
   is discarded. For HRESULTs other than S_OK, the runtime throws an exception and
   discards the [out, retval] parameter. When you apply the <see cref="System.Runtime.InteropServices.PreserveSigAttribute"/>
   
   to
   a managed method signature, the managed and unmanaged signatures of the
   attributed method are identical.</para>
			<para>Preserving the original method signature is necessary if
   the member returns more than one success HRESULT value and you want to detect
   the different values. Since most COM member return an HRESULT, by applying the
<see cref="System.Runtime.InteropServices.PreserveSigAttribute"/>,
   you can retrieve an integer representing the success or failure HRESULT.
   Tlbexp.exe preserves any [out, retavl] parameters as out parameters in the
   managed signature.</para>
			<para>The <see topic="cpgrfTypeLibraryImporterTlbimpexe"/> also applies this attribute; it
applies the attribute to dispinterfaces when it imports a type library.</para>
		</remarks>
		<example>
			<para> The following example shows how Tlbexp.exe converts
      a C# method without <see cref="System.Runtime.InteropServices.PreserveSigAttribute"/>
      when exporting an assembly to
      a COM type library.</para>
			<para>Managed signature:</para>
			<para><c>int DoSomething (long l);</c></para>
			<para> Unmanaged signature:</para>
			<para><c>HRESULT DoSomething ([in] long l, [out, retval] int * i);</c></para>
			<para>When you apply <see cref="System.Runtime.InteropServices.PreserveSigAttribute"/> to
   the same C# method and export the
   assembly, the method conversion differs from the previous example. Notice that Tlbexp.exe removes
   the HRESULT and the [out, retval] parameter modifier.</para>
			<para>Managed signature:</para>
			<para><c>[PreserveSig] int DoSomething (long l);</c></para>
			<para> Unmanaged signature:</para>
			<para><c>int DoSomething ([in] long l);</c></para>
		</example>
		<seealso topic="cpgrfTypeLibraryExporterTlbexpexe"/>
		<seealso topic="cpgrfTypeLibraryImporterTlbimpexe"/>
	</doc>
	<doc for="InAttribute">
		<summary>
			<para> Indicates that data should be marshaled from the caller to the callee, but not back to
      the caller.</para>
		</summary>
		<remarks>
			<para> You can apply this
      attribute to
      parameters.</para>
			<para> 
      The <see cref="System.Runtime.InteropServices.InAttribute"/> is optional. The attribute is
      supported for COM interop and
      platform invoke only. In
      the absence of explicit settings, the interop marshaler assumes
      rules based on the parameter type, whether the parameter is
      passed by reference or by value, and whether the type is blittable or non-blittable. For example, the <see cref="System.Text.StringBuilder"/>
      class is always assumed to be In/Out and an
      array of strings passed by value is assumed to be In.</para>
			<para>You cannot apply the <see cref="System.Runtime.InteropServices.InAttribute"/>
to a parameter modified with the
C#-styled <see langword="out"/> keyword.
To avoid confusing the <see langword="In"/> keyword in Visual Basic with the
<see cref="System.Runtime.InteropServices.InAttribute"/>, minus Attribute, use
the <c>&lt;[In]&gt;</c> form with brackets around the attribute. </para>
			<para>Combining the <see cref="System.Runtime.InteropServices.InAttribute"/> and <see cref="System.Runtime.InteropServices.OutAttribute"/> is
particularly useful when applied to arrays and formatted, non-blittable types.
Callers see the changes a callee makes to these types only when you apply both
attributes. Since these types require copying during marshaling, you can
use <see cref="System.Runtime.InteropServices.InAttribute"/>
and <see cref="System.Runtime.InteropServices.OutAttribute"/>
to reduce unnecessary copies.</para>
			<para>For more information on the effect of <see cref="System.Runtime.InteropServices.InAttribute"/> on marshaling
behavior, see <see topic="cpcondirectionalattributes"/>.</para>
		</remarks>
		<example>
			<para>The following example shows how to apply
      the <see cref="System.Runtime.InteropServices.InAttribute"/> and <see cref="System.Runtime.InteropServices.OutAttribute"/> to a platform invoke
      prototype that passes an array as a parameter. The combination of
      directional attributes allows the caller to see the changes made by
      the callee.</para>
			<codelink SampleID="Interop InOutParameters" SnippetID="1"/>
		</example>
		<seealso cref="System.Runtime.InteropServices.OutAttribute"/>
		<seealso cref="System.Text.StringBuilder"/>
		<seealso topic="cpconblittablenon-blittabletypes"/>
	</doc>
	<doc for="OutAttribute">
		<summary>
			<para> Indicates that data should be
      marshaled from callee back to caller.</para>
		</summary>
		<remarks>
			<para> You can apply this
      attribute to
      parameters.</para>
			<para> 
      The <see cref="System.Runtime.InteropServices.OutAttribute"/> is optional. The attribute is
      supported for COM interop and platform invoke only. In the absence
      of explicit settings, the interop marshaler assumes rules based on the
      parameter type, whether the parameter is passed by reference or by value, and
      whether the type is blittable or non-blittable. For example, the <see cref="System.Text.StringBuilder"/>
      class is always assumed to be In/Out and an
      array of strings passed by value is assumed to be
      In. </para>
			<para> Out-only behavior is never a default marshaling behavior for parameters. You can apply
      the <see cref="System.Runtime.InteropServices.OutAttribute"/> to value and reference types
      passed by reference to change In/Out behavior to Out-only behavior, which is
      equivalent to using the <see langword="out"/> keyword in C#.
      For example, arrays passed by value, marshaled as In-only parameters by
      default, can be changed to Out-only. However, the behavior does not always
      provide expected semantics when the types include all-blittable elements or
      fields because the interop marshaler uses pinning. If you do not care about
      passing data into the callee, Out-only marshaling can provide better performance
      for non-blittable types. </para>
			<para> Combining the <see cref="System.Runtime.InteropServices.InAttribute"/> and <see cref="System.Runtime.InteropServices.OutAttribute"/> is particularly useful when
   applied to arrays and formatted, non-blittable types. Callers see the changes a callee makes to these types only when you apply both attributes.
   Since these types require copying during marshaling, you can
   use <see cref="System.Runtime.InteropServices.InAttribute"/> and <see cref="System.Runtime.InteropServices.OutAttribute"/> to reduce unnecessary copies. </para>
			<para>For more information on the effect of <see cref="System.Runtime.InteropServices.OutAttribute"/>
on marshaling behavior, see <see topic="cpcondirectionalattributes"/>.</para>
		</remarks>
		<example>
			<para>The following example shows how to apply
      the <see cref="System.Runtime.InteropServices.InAttribute"/> and <see cref="System.Runtime.InteropServices.OutAttribute"/> to a platform invoke
      prototype that passes an array as a parameter. The combination of
      directional attributes allows the caller to see the changes made by
      the callee. </para>
			<codelink SampleID="Interop InOutParameters" SnippetID="1"/>
		</example>
		<seealso cref="System.Runtime.InteropServices.InAttribute"/>
		<seealso cref="System.Text.StringBuilder"/>
		<seealso topic="cpconblittablenon-blittabletypes"/>
	</doc>
	<doc for="DllImportAttribute.CallingConvention">
		<summary>
			<para> Indicates the calling convention of an
      entry point.</para>
		</summary>
		<remarks>
			<para> You set this field to one of the <see cref="System.Runtime.InteropServices.CallingConvention"/> enumeration members. The
   default value for the <see cref="System.Runtime.InteropServices.DllImportAttribute.CallingConvention"/> field is <see langword="WinAPI"/>,
   which in turn defaults to <see langword="StdCall"/>
   convention.</para>
			<para>For more information, see Calling Convention in the MSDN library. </para>
		</remarks>
		<example>
			<para>In some cases, Visual Basic developers use
      the <see cref="System.Runtime.InteropServices.DllImportAttribute"/>, instead of the <see langword="Declare"/> statement, to define a DLL function in
      managed code. Setting
      the <see cref="System.Runtime.InteropServices.DllImportAttribute.CallingConvention"/> field is one of
      those cases.</para>
			<code lang="VB">Imports System
Imports Microsoft.VisualBasic
Imports System.Runtime.InteropServices

Public Class LibWrap
' Visual Basic does not support varargs, so all arguments must be 
' explicitly defined. CallingConvention.Cdecl must be used since the stack 
' is cleaned up by the caller. 
' int printf( const char *format [, argument]... )

&lt;DllImport("msvcrt.dll", CallingConvention := CallingConvention.Cdecl)&gt; _
Overloads Shared Function printf ( _
    format As String, i As Integer, d As Double) As Integer
End Function

&lt;DllImport("msvcrt.dll", CallingConvention := CallingConvention.Cdecl)&gt; _
Overloads Shared Function printf ( _
    format As String, i As Integer, s As String) As Integer
End Function
End Class 'LibWrap

Public Class App
    Public Shared Sub Main()
        LibWrap.printf(ControlChars.CrLf + "Print params: %i %f", 99, 
                       99.99)
        LibWrap.printf(ControlChars.CrLf + "Print params: %i %s", 99, _
                       "abcd")
    End Sub 'Main
End Class 'App
   </code>
			<code lang="C#">using System;
using System.Runtime.InteropServices;

public class LibWrap
{
// C# doesn't support varargs so all arguments must be explicitly defined.
// CallingConvention.Cdecl must be used since the stack is 
// cleaned up by the caller.

// int printf( const char *format [, argument]... )

[DllImport("msvcrt.dll", CharSet=CharSet.Ansi, CallingConvention=CallingConvention.Cdecl)]
public static extern int printf(String format, int i, double d); 

[DllImport("msvcrt.dll", CharSet=CharSet.Ansi, CallingConvention=CallingConvention.Cdecl)]
public static extern int printf(String format, int i, String s); 
}

public class App
{
    public static void Main()
    {
        LibWrap.printf("\nPrint params: %i %f", 99, 99.99);
        LibWrap.printf("\nPrint params: %i %s", 99, "abcd");
    }
}
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.CallingConvention"/>
	</doc>
	<doc for="FieldOffsetAttribute">
		<summary>
			<para> Indicates the physical position of fields within the unmanaged representation of a class or structure.</para>
		</summary>
		<remarks>
			<para>You can apply this attribute to
      fields.</para>
			<para> This attribute is used when
   <see cref="System.Runtime.InteropServices.StructLayoutAttribute" qualify="true"/>, with <see cref="System.Runtime.InteropServices.LayoutKind.Explicit" qualify="true"/> passed
      to its constructor, is applied to a class or structure to specify the
      offset of each non-<see langword="static"/>
      or constant member
      within the unmanaged representation of that class or structure. The attribute has no affect on the managed
      layout of the members of the type.</para>
		</remarks>
		<example>
			<para>The following example demonstrates how to apply the <see cref="System.Runtime.InteropServices.FieldOffsetAttribute"/> to members of a class with
   an explicit layout.</para>
			<codelink SampleID="Classic FieldOffsetAttribute Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Runtime.InteropServices.StructLayoutAttribute"/>
		<seealso cref="System.Runtime.InteropServices.LayoutKind"/>
	</doc>
	<doc for="ComAliasNameAttribute">
		<summary>
			<para> Indicates the COM alias for a parameter
      or field type.</para>
		</summary>
		<remarks>
			<para>You can apply this attribute to parameters, fields, properties, or return values.</para>
		</remarks>
		<example>
			<para>In the following type library, OLE_COLOR is an alias for 
      int. During import the arguments of the <c>Color</c>
   accessor are marked with
   the <see cref="System.Runtime.InteropServices.ComAliasNameAttribute"/> to
   indicate that type library refers to them as <c>OLE_COLOR</c>

.</para>
			<codelink SampleID="Classic ComAliasNameAttribute Example" SnippetID="1"/>
			<para>imported as:</para>
			<codelink SampleID="Classic ComAliasNameAttribute Example" SnippetID="2"/>
		</example>
	</doc>
	<doc for="AutomationProxyAttribute">
		<summary>
			<para>Specifies whether the type should be marshaled using the
      Automation marshaler or a custom proxy and stub.</para>
		</summary>
		<remarks>
			<para>You can apply this attribute to assemblies, classes, or
      interfaces.</para>
			<para> When applied
      to a class, it extends to the class interface for that class, if present.</para>
		</remarks>
	</doc>
	<doc for="AutomationProxyAttribute.AutomationProxyAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.AutomationProxyAttribute"/> class.</para>
		</summary>
		<param name="val"><see langword="true"/> if the class should be marshaled using the Automation Marshaler; <see langword="false"/> if a proxy stub marshaler should be used.</param>
	</doc>
	<doc for="AutomationProxyAttribute.Value">
		<summary>
			<para> Gets a value indicating the type of marshaler to use.</para>
		</summary>
		<value>
			<para><see langword="true"/> if
   the class should be marshaled using the Automation Marshaler;
<see langword="false"/> if a proxy stub marshaler should be used.</para>
		</value>
	</doc>
	<doc for="CoClassAttribute.CoClassAttribute">
		<summary>
			<para>Initializes new instance of the <see cref="System.Runtime.InteropServices.CoClassAttribute"/> with the class identifier of the original coclass.</para>
		</summary>
		<param name="coClass">A <see cref="System.Type"/> that contains the class identifier of the original coclass.</param>
	</doc>
	<doc for="CoClassAttribute.CoClass">
		<summary>
			<para>Gets the class identifier of the original coclass.</para>
		</summary>
		<value>
			<para>A <see cref="System.Type"/> containing the class identifier of the original
   coclass.</para>
		</value>
	</doc>
	<doc for="PrimaryInteropAssemblyAttribute">
		<summary>
			<para> Indicates that the attributed assembly is a
      primary interop assembly.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to assemblies, although the
   <see topic="cpgrfTypeLibraryImporterTlbimpexe"/>
   typically applies it for
   you when it imports
   a type library.</para>
			<para> An interop assembly contains metadata that
   describes exiting COM types, which are often already described in a COM type library.
   Tlbimp.exe produces interop assemblies from COM type libraries. Interop
   assemblies typically only contain metadata (no code). Primary interop assemblies
   are provided by the same
   publisher as the type library they describe, and provide the official definitions of the types defined
   with that type library. Primary interop assemblies are always signed
   by their publisher to ensure uniqueness. </para>
			<para> You can generate a primary interop assembly from a
   type library in the following ways:</para>
			<list type="bullet"><item>
					<term>
      
      Run TlbImp.exe with
      the <see langword="/primary"/> option from the command line.</term>
				</item>
				<item>
					<term>
      
      Apply the <see cref="System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute"/> at design
      time.</term>
				</item>
			</list>
			<para> To specify a primary
   interop assembly in managed source code, you must apply the <see cref="System.Runtime.InteropServices.GuidAttribute" qualify="true"/> and <see cref="System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute"/> to
   the assembly at design time.
   The <see cref="System.Runtime.InteropServices.GuidAttribute"/> on the primary interop assembly
   identifies the LIBID of the type library and the <see cref="System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute"/> identifies the version of the
   particular type library for which this assembly is the primary interop assembly.
   The <see cref="System.Runtime.InteropServices.PrimaryInteropAssemblyAttribute"/> can
   appear multiple times if the assembly is the primary interop assembly for
   multiple versions of the same type library. </para>
			<para>When using the types defined in a type library, always
   reference the primary interop assembly for that type library, rather than
   reimporting or redefining the types themselves. For guidelines and procedures on
   how to produce or use primary interop assemblies, see
<see topic="cpconprimaryinteropassemblies"/>. 
   For a detailed description of the type library importing process, see
<see topic="cpcontypelibrarytoassemblyconversionsummary"/>.</para>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.GuidAttribute"/>
		<seealso topic="cpgrfTypeLibraryImporterTlbimpexe"/>
		<seealso topic="cpconprimaryinteropassemblies"/>
	</doc>
	<doc for="ComEventInterfaceAttribute.ComEventInterfaceAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.ComEventInterfaceAttribute"/>
class with the source interface and event provider class.</para>
		</summary>
		<param name="SourceInterface">A <see cref="System.Type"/> that contains the original source interface from the type library. COM uses this interface to call back to the managed class.</param>
		<param name=" EventProvider">A <see cref="System.Type"/> that contains the class that implements the methods of the event interface.</param>
	</doc>
	<doc for="ComEventInterfaceAttribute.SourceInterface">
		<summary>
			<para>Gets the original source interface from the type
      library.</para>
		</summary>
		<value>
			<para> A <see cref="System.Type"/> 
containing the source interface.</para>
		</value>
		<remarks>
			<para>A source interface has at least one event member, and
      typically one for each method of the source interface. COM uses this interface to call back to the managed class.</para>
		</remarks>
	</doc>
	<doc for="ComEventInterfaceAttribute.ThrowOnUnmappableChar">
		<summary>
			<para> Enables or disables the throwing of an exception on an unmappable
      Unicode character that is converted to an ANSI '?' character.</para>
		</summary>
		<remarks>
			<para>If <see langword="false"/>, the <see cref="System.Runtime.InteropServices.BestFitMappingAttribute.ThrowOnUnmappableChar"/> 
field is disabled; otherwise, an exception is thrown each time the
interop marshaler encounters an unmappable character. The default <see langword="false"/>. </para>
		</remarks>
	</doc>
	<doc for="ComCompatibleVersionAttribute.MinorVersion">
		<summary>
			<para>Gets the minor version number of the assembly.</para>
		</summary>
		<value>
			<para>The minor version number of the assembly.</para>
		</value>
	</doc>
	<doc for="ComCompatibleVersionAttribute.BuildNumber">
		<summary>
			<para> Gets the build number of the assembly.</para>
		</summary>
		<value>
			<para>The build number of the assembly.</para>
		</value>
	</doc>
	<doc for="ComCompatibleVersionAttribute.ComCompatibleVersionAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.ComCompatibleVersionAttribute"/> class with the major 
   version, minor version, build, and revision numbers of the assembly.</para>
		</summary>
		<param name="major">The major version number of the assembly.</param>
		<param name=" minor">The minor version number of the assembly.</param>
		<param name=" build">The build number of the assembly.</param>
		<param name=" revision">The revision number of the assembly.</param>
	</doc>
	<doc for="TypeLibVersionAttribute.MajorVersion">
		<summary>
			<para>Gets the major version number of the type library.</para>
		</summary>
		<value>
			<para>The major version number of the type library.</para>
		</value>
	</doc>
	<doc for="TypeLibVersionAttribute.MinorVersion">
		<summary>
			<para>Gets the minor version number of the type library.</para>
		</summary>
		<value>
			<para>The minor version number of the type library.</para>
		</value>
	</doc>
	<doc for="UnmanagedType.ByValTStr">
		<summary>
			<para>Used for in-line, fixed-length character arrays that
      appear within a structure. The character type used with <see cref="System.Runtime.InteropServices.UnmanagedType.ByValTStr"/>
      is determined by the <see cref="System.Runtime.InteropServices.CharSet" qualify="true"/> argument of the <see cref="System.Runtime.InteropServices.StructLayoutAttribute" qualify="true"/>
      applied to the containing
      structure. Always use the <see cref="System.Runtime.InteropServices.MarshalAsAttribute.SizeConst" qualify="true"/> field to indicate the size of the
      array. </para>
			<para>.NET Framework <see cref="System.Runtime.InteropServices.UnmanagedType.ByValTStr"/> types behave like
   C-style, fixed-size strings inside a structure (for example, <c>char s[5]</c>).
The behavior in managed code differs from the Microsoft Visual Basic 6.0
behavior, which is not null
terminated (for example, <c>MyString As String * 5</c>
).</para>
		</summary>
	</doc>
	<doc for="MarshalAsAttribute.MarshalTypeRef">
		<summary>
			<para>Implements <see cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalType" qualify="true"/> as a type.</para>
		</summary>
		<remarks>
			<para>You can use either the <see cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalTypeRef"/>
or <see cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalType"/> field to
specify a custom marshaler type for the attributed parameter, field, or return
type. The <see cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalTypeRef"/>
field allows easier usage of <see cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalType"/> by shortening
the syntax. In the following example, the first line represents syntax
using <see cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalType"/> and the second line represents
syntax using <see cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalTypeRef"/>.</para>
			<c>
				<para>[MarshalAs(UnmanagedType.CustomMarshaler, MarshalType = "Assembly,
      NameSpace.TypeName"] </para>
				<para>[MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef =
      typeof(NameSpace.TypeName)]</para>
			</c>
			<para>You can set a <see cref="System.Type"/> object using <see langword="typeof"/> in
C#, <see langword="GetType"/> in Visual Basic,
or <see langword="__typeof"/> in C++. For additional information
about creating and using custom marshalers, see <see topic="cpconcustommarshaling"/>.</para>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.MarshalAsAttribute.MarshalType"/>
	</doc>
	<doc for="TypeLibVersionAttribute.TypeLibVersionAttribute">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.TypeLibVersionAttribute"/> class with the major and
   minor version numbers of the type library.</para>
		</summary>
		<param name="major">The major version number of the type library.</param>
		<param name=" minor">The minor version number of the type library.</param>
	</doc>
	<doc for="InterfaceTypeAttribute">
		<summary>
			<para>Indicates whether a managed interface is dual,
      dispatch-only, or <see langword="IUnknown"/>-only when exposed to
      COM.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute
      to interfaces.</para>
			<para> By default, the
   <see topic="cpgrftypelibraryExportertlbexpexe"/>
   exposes a managed interface to COM as a dual interface, giving you the flexibility
   of late binding or the performance of early binding. The <see cref="System.Runtime.InteropServices.ComInterfaceType"/> enumeration enables you to
   override the default behavior and specify late binding only or early binding
   only. For example, you can apply <c>InterfaceType (ComInterfaceType.InterfaceIsIDispatch)</c> to an interface to produce metadata to
restrict callers to late binding only. Although interfaces that derive from
the <see langword="IDispatch"/> interface are often dual,
the <see langword="InterfaceIsIDispatch"/>
enumeration member allows only late-bound calls to the interface methods. This
attribute has no effect on the managed view of the interface. For additional
information on how interfaces are exposed to COM, see <see topic="cpcontlbexptypeconversion"/>.</para>
			<para> The <see topic="cpgrftypelibraryImportertlbimpexe"/> also applies this
attribute to imported, nondual interfaces; it applies the appropriate
enumeration member to indicate that the interface is dispatch-only or
<see langword="IUnknown"/>-only.</para>
		</remarks>
		<example>
			<para>The following example shows how <see langword="InterfaceTypeAttribute"/> controls how the
   interface is exposed to COM.</para>
			<codelink SampleID="Classic InterfaceTypeAttribute Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Runtime.InteropServices.ComInterfaceType"/>
		<seealso topic="cpgrftypelibraryExportertlbexpexe"/>
		<seealso topic="cpgrftypelibraryImportertlbimpexe"/>
	</doc>
	<doc for="ComCompatibleVersionAttribute">
		<summary>
			<para>Indicates to a COM client that all classes in the current version of an assembly are compatible with classes in an earlier version of the assembly.</para>
		</summary>
		<remarks>
			<para>You can apply this attribute to assemblies.</para>
			<para>By default, the
   <see topic="cpgrfTypeLibraryExporterTlbexpexe "/>
   
   uses an assembly's version number to calculate class identifiers (CLSIDs). All public, COM-visible classes receive new CLSIDs each time you export a new assembly
   version.</para>
			<para>You can apply the <see cref="System.Runtime.InteropServices.ComCompatibleVersionAttribute.ComCompatibleVersionAttribute"/> attribute to
force all CLSIDs for classes in the current version of an assembly to be the
same as CLSIDs for classes in an earlier version of the assembly. As long as the
CLSIDs remain the same, a legacy COM application can use the later version of a
compatible assembly after you uninstall the original assembly. If you apply
the <see cref="System.Runtime.InteropServices.GuidAttribute" qualify="true"/> to a class to explicitly set its
CLSID, the <see cref="System.Runtime.InteropServices.ComCompatibleAttribute"/> has no effect.</para>
			<para> The properties of this attribute combine to form the four parts of an
   assembly version. Always specify the lowest version that the current assembly is
   backward compatible with so that version is used to calculate all CLSIDs in the
   assembly.</para>
		</remarks>
		<example>
			<para>The
      following example shows how to specify assembly version 1.0.0.0 in an assembly
      with a higher version number. Regardless of the new assembly version, all CLSIDs
      in the assembly are generated using version 1.0.0.0 instead of using the current
      assembly version.</para>
			<code lang="VB">Imports System
Imports System.Runtime.Interop

Assembly: AssemblyVersion ("3.0.0.0")
Assembly: ComCompatibleVersionAttribute(1,0,0,0)

Module MyNamespace
  Public Class MyClass
    ' Insert code.
  End Class
   </code>
			<code lang="C#">using System;
using System.Runtime.InteropServices;

[Assembly: AssemblyVersion ("3.0.0.0")
[Assembly: ComCompatibleVersion(1,0,0,0)]

namespace MyNamespace
{
  class MyClass
  {
    // Insert code.
  }
}
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.GuidAttribute"/>
		<seealso topic="cpgrfTypeLibraryExporterTlbexpexe"/>
	</doc>
	<doc for="ComCompatibleVersionAttribute.MajorVersion">
		<summary>
			<para>Gets the major version number of the assembly.</para>
		</summary>
		<value>
			<para>The major version number of the assembly.</para>
		</value>
	</doc>
	<doc for="ComCompatibleVersionAttribute.RevisionNumber">
		<summary>
			<para>Gets the revision number of the assembly.</para>
		</summary>
		<value>
			<para>The revision number of the assembly.</para>
		</value>
	</doc>
	<doc for="BestFitMappingAttribute.BestFitMappingAttribute">
		<summary>
			<para> Initializes a new instance of the <see cref="System.Runtime.InteropServices.BestFitMappingAttribute"/> class set to the value of
   the <see cref="System.Runtime.InteropServices.BestFitMappingAttribute.BestFitMapping"/>
   property.</para>
		</summary>
		<param name="BestFitMapping"><see langword="true"/> to indicate that best-fit mapping is enabled; otherwise, <see langword="false"/>. The default is <see langword="true"/>. </param>
	</doc>
	<doc for="DllImportAttribute.ExactSpelling">
		<summary>
			<para> Controls whether the <see cref="System.Runtime.InteropServices.DllImportAttribute.CharSet" qualify="true"/> field causes the common language
   runtime to search an unmanaged DLL for entry-point names other
   than the one specified. </para>
		</summary>
		<remarks>
			<para> If <see langword="false"/>, the entry point name appended with the letter A is invoked when the <see cref="System.Runtime.InteropServices.DllImportAttribute.CharSet" qualify="true"/> field is set
   to <see langword="CharSet.Ansi"/>, and the entry-point name appended with the
   letter W is invoked when the <see cref="System.Runtime.InteropServices.DllImportAttribute.CharSet" qualify="true"/> field is set
   to the <see langword="CharSet.Unicode"/>. Typically, managed compilers set
   this field.</para>
The following table shows the relationship between
the <see cref="System.Runtime.InteropServices.DllImportAttribute.CharSet"/> and <see cref="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling"/> fields, based
on default values imposed by the programming language. You can override the
default setting, but do so with caution.
<list type="table">
				<listheader>
					<term>Language</term>
					<description>ANSI</description>
					<description>Unicode</description>
					<description>Auto</description>
				</listheader>
				<item>
					<term> Visual
         Basic</term>
					<description>ExactSpelling:=True</description>
					<description>ExactSpelling:=True</description>
					<description>
						<para>ExactSpelling:=False</para></description>
				</item>
				<item>
					<term> 
            C#</term>
					<description>
						<para>ExactSpelling=false</para></description>
					<description>
						<para>ExactSpelling=false</para></description>
					<description>
						<para>ExactSpelling=false</para></description>
				</item>
				<item>
					<term> 
                     C++</term>
					<description>
						<para>ExactSpelling=false</para></description>
					<description>
						<para>ExactSpelling=false</para></description>
					<description>
						<para>ExactSpelling=false</para></description>
				</item>
			</list>
		</remarks>
		<example>
			<para>In some cases, Visual Basic developers use the <see cref="System.Runtime.InteropServices.DllImportAttribute"/>, instead of
                     using the <see langword="Declare"/> statement, to define a DLL function in
                     managed code. Setting
                     the <see cref="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling"/> field is one of
                     those cases.</para>
			<code lang="VB">Imports System.Runtime.InteropServices

Public Class Win32   
    &lt;DllImport ("user32.dll", ExactSpelling := False)&gt; _
    Public Shared Function MessageBox (ByVal hWnd As Integer, _
        ByVal txt As String, ByVal caption As String, _
        ByVal Typ As Integer) As Integer
    End Function
End Class
                  </code>
			<code lang="C#">using System.Runtime.InteropServices;

public class Win32 {
    [DllImport("user32.dll", CharSet=CharSet.Unicode, 
               ExactSpelling=true)]
    public static extern int MessageBoxW(int hWnd, String text, String 
                                          caption, uint type);
}
                  </code>
			<code lang="C++">using namespace System::Runtime::InteropServices;

typedef void* HWND;
[DllImport("user32", CharSet=CharSet::Ansi, ExactSpelling=true)]
extern "C" int MessageBoxA(HWND hWnd,
                          String* pText,
                          String* pCaption,
                          unsigned int uType);
                  </code>
		</example>
	</doc>
	<doc for="DllImportAttribute.PreserveSig">
		<summary>
			<para> Indicates whether the signature is a direct
      translation of the unmanaged entry point.</para>
		</summary>
		<remarks>
			<para> Most methods called with platform invoke do not
      return HRESULTs, making the HRESULT/[out, retval] conversion pointless. This is why
      the default behavior preserves the signature exactly as defined. This field is
      <see langword="true"/> by default. </para>
			<para> Occasionally, you do want to override
      the default behavior to convert the signature. For example, the definition of a
      method such as <c>HRESULT
      CoCreateInstance(...)</c>
   should set this field to <see langword="false"/>.
   When set to <see langword="false"/>, a call that returns an HRESULT of S_OK is
   transformed such that the [out, retval] parameter is used as the
   function return value. The S_OK HRESULT is discarded. For HRESULTs other than S_OK, the
   runtime throws an exception and discards the [out, retval] parameter. Only methods that
   return an HRESULT can undergo a conversion. </para>
			<para>This field is similar to the <see cref="System.Runtime.InteropServices.PreserveSigAttribute"/>;
however, in contrast to the <see cref="System.Runtime.InteropServices.DllImportAttribute.PreserveSig"/> field,
the default value for the attribute is <see langword="false"/>. </para>
		</remarks>
		<example>
			<para>In some cases, Visual Basic developers use
      the <see cref="System.Runtime.InteropServices.DllImportAttribute"/>, instead of using the <see langword="Declare"/> statement, to define a DLL function in managed code. Setting
      the <see cref="System.Runtime.InteropServices.DllImportAttribute.PreserveSig"/> field is one of those cases.</para>
			<code lang="VB">Imports System.Runtime.InteropServices

Public Class Win32
    &lt;DllImport ("user32.dll", PreserveSig := False)&gt; _
    Public Shared Function MessageBoxA (ByVal hWnd As _
    Integer, ByVal txt As String, ByVal caption As String, _
    ByVal Typ As Integer) As Integer 
    End Function
End Class
      </code>
			<code lang="C#">using System.Runtime.InteropServices;

public class Win32 {
    [DllImport("user32.dll", PreserveSig=false)]
    public static extern int MessageBoxA(int hWnd, String text, String 
       caption, uint type);
}
      </code>
			<code>
[C++]
using namespace System::Runtime::InteropServices;

typedef void* HWND;
[DllImport("user32", PreserveSig=true)]
extern "C" int MessageBoxA(HWND hWnd,
                          String* pText,
                          String* pCaption,
                          unsigned int uType);
      </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.PreserveSigAttribute"/>
	</doc>
	<doc for="DllImportAttribute.SetLastError">
		<summary>
			<para> Indicates whether the callee calls the
   <see langword="SetLastError"/> Win32 API function before returning from the attributed method.</para>
		</summary>
		<remarks>
			<para><see langword="true"/> to 
   indicate that the
   callee will call <see langword="SetLastError"/>; otherwise, <see langword="false"/>. The default is <see langword="false"/>, except in Visual Basic.</para>
			<para> The runtime marshaler calls <see langword="GetLastError"/> and caches
the value returned to prevent it from being overwritten by other API calls. You
can retrieve the error code by calling <see cref="System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>.</para>
		</remarks>
		<example>
			<para>In some cases, Visual Basic developers use the <see cref="System.Runtime.InteropServices.DllImportAttribute"/>, instead of using the <see langword="Declare"/> statement, to
   define a DLL function in managed
   code. Setting
   the <see cref="System.Runtime.InteropServices.DllImportAttribute.SetLastError"/> field is one of those
   cases.</para>
			<code lang="VB">Imports System.Runtime.InteropServices

Public Class Win32
    &lt;DllImport ("user32.dll", SetLastError := False)&gt; _
    Public Shared Function MessageBoxA (ByVal hWnd As Integer, _
        ByVal txt As String, ByVal caption As String, _
        ByVal Typ As Integer) As Integer
    End Function
End Class
</code>
			<code lang="C#">using System.Runtime.InteropServices;

public class Win32 {
    [DllImport("user32.dll", SetLastError=true)]
    public static extern int MessageBoxA(int hWnd, String text, 
                             String caption, uint type);
}
</code>
			<code lang="C++">using namespace System::Runtime::InteropServices;

typedef void* HWND;
[DllImport("user32", SetLastError=true)]
extern "C" int MessageBoxA(HWND hWnd,
                          String* pText,
                          String* pCaption,
                          unsigned int uType);
</code>
		</example>
		<seealso cref="System.Runtime.InteropServices.Marshal.GetLastWin32Error"/>
	</doc>
	<doc for="ComEventInterfaceAttribute">
		<summary>
			<para>Identifies the source interface and the class that implements the methods of
      the event interface that is generated when a coclass is imported from a COM type library.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to interfaces, although the
   <see topic="cpgrfTypeLibraryImporterTlbimpexe"/>
   typically applies it for you when it imports a type
   library.</para>
			<para>When a source interface is imported from a type library,
   any methods it implements are added as events to a generated event interface.
   Tlbimp.exe applies <see cref="System.Runtime.InteropServices.ComEventInterfaceAttribute"/> to
   the event interface to
   identify the managed class that implements the methods of the event interface and implements
   the original source interface. The common language runtime uses this attribute at
   run time to perform the following tasks:</para>
			<list type="bullet"><item>
					<term>
      
      Associate events exposed by the interface to their
      implementation in the event provider class.</term>
				</item>
				<item>
					<term>
      
      Link the events to the original COM source interface.</term>
				</item>
			</list>You rarely apply this attribute. However, if you plan to write source
code that produces metadata that closely simulates metadata produced by
Tlbimp.exe, you should create a event interface for each original source interface. For
a detailed description about how Tlbimp.exe imports events, see <see topic="cpcontlbimpmemberconversion"/>. For instruction about how to expose a COM event to a .NET client, see <see topic="cpconhandlingeventsraisedbycomsource"/>.
</remarks>
		<seealso topic="cpgrfTypeLibraryImporterTlbimpexe"/>
	</doc>
	<doc for="DllImportAttribute.Value">
		<summary>
			<para>Gets the name of the DLL file that contains the entry point.</para>
		</summary>
		<value>
			<para>The name of the DLL file that contains the
      entry point.</para>
		</value>
		<remarks>
			<para> You can provide a full or relative path. If you provide no path, the DLL must be in the current path
      at run time, unless the DLL is loaded by some other means. Be aware, however,
      that using a fully qualified path can introduce inaccuracy if the DLL is
      moved.</para>
		</remarks>
	</doc>
	<doc for="DllImportAttribute.BestFitMapping">
		<summary>
			<para> Enables or disables best-fit mapping behavior when
      converting Unicode characters to ANSI characters.</para>
		</summary>
		<remarks>
			<para>If <see langword="true"/>
, best-fit mapping behavior is enabled; otherwise, best-fit mapping is disabled.
The <see cref="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping"/>
field is <see langword="true"/> by default. Settings for this field
override the any level settings for the <see cref="System.Runtime.InteropServices.BestFitMappingAttribute" qualify="true"/>
attribute. </para>
			<para> The common language runtime converts to ANSI
   characters any managed Unicode characters passed to an unmanaged method executing
   on Windows 98 or Windows Me. Best-fit mapping enables the
<see topic="cpconinteropmarshaling" title="interop marshaler"/> to provide a 
   close-matching character when no exact match exists. For example, the marshaler
   converts the Unicode copyright character to 'c' for unmanaged methods that
   accept ANSI characters. Some characters lack a best-fit representation; these
   characters are called unmappable. Unmappable characters are usually converted to
   the default '?' ANSI
   
   character.</para>
			<note type="caution">
   Certain Unicode characters are
   converted to dangerous characters, such as the backslash '\' character, which
   can inadvertently change a path. By setting the <see cref="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar"/> field to
<see langword="true"/>, you can signal the presence of an unmappable character to 
   the caller by throwing an exception.
</note>
			<note type="caution"> You
cannot change the default values provided by the <see cref="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping"/> and
<see cref="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar"/> fields when 
passing a managed array whose elements are ANSI Chars or LPSTRs to an unmanaged
safe array. Best-fit mapping is always enabled and no exception is thrown. Be aware that this
combination can compromise your security
model.
</note>
		</remarks>
		<example>
			<para>In some cases, Visual Basic developers use
      the <see cref="System.Runtime.InteropServices.DllImportAttribute"/>, instead of the <see langword="Declare"/>
      statement, to define a DLL function in managed code. Setting the <see cref="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping"/> field is one of those cases. The following example shows how to apply the strictest
      character mapping security to a platform invoke method definitions by specifying the ANSI character set,
      disabling best fit mapping behavior, and throwing an exception on unmapped
      Unicode characters. </para>
			<code lang="VB">&lt;DllImport( "My.dll", Charset := Charset.Ansi, _
                      BestfitMapping := False _
                      ThrowOnUnmappableChar := True )&gt;
   </code>
			<code lang="C#">[DllImport( "My.dll", Charset = Charset.Ansi, 
                      BestfitMapping = false
                      ThrowOnUnmappableChar = true )]
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.DllImportAttribute.CharSet"/>
		<seealso cref="System.Runtime.InteropServices.BestFitMappingAttribute"/>
	</doc>
	<doc for="DllImportAttribute.ThrowOnUnmappableChar">
		<summary>
			<para>Enables or disables the throwing of an exception on an unmappable Unicode
      character that is converted to an ANSI '?' character.</para>
		</summary>
		<remarks>
			<para><see langword="true"/> to indicate that an exception is
   thrown each time the interop marshaler converts an unmappable
   character; <see langword="false"/> to indicate
   that the the <see cref="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar"/>
   field is disabled. This field is <see langword="false"/>
   by default. </para>
			<para> The common language runtime converts to ANSI characters any managed
   Unicode characters passed to an unmanaged method executing on Windows 98 or Windows
   Me. Best-fit mapping enables the <see topic="cpconinteropmarshaling" title="interop marshaler"/> to provide a
   close-matching character when no exact match exists. For example, the marshaler
   converts the Unicode copyright character to 'c' for unmanaged methods that
   accept ANSI characters. Some characters lack a best-fit representation; these
   characters are called unmappable. Unmappable characters are usually converted
   to the default '?' ANSI character.</para>
			<note type="caution">
   Certain Unicode characters are converted to dangerous
   characters, such as the backslash '\' character, which can inadvertently change
   a path. By setting the <see cref="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar"/> field to
<see langword="true"/>, you can signal the presence of an 
   unmappable character to the caller by throwing an exception.
</note>
			<note type="caution">
   You cannot change the default values provided by
   the <see cref="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping"/> and <see cref="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar"/> fields when
   passing a managed array whose elements are ANSI Chars or LPSTRs to an unmanaged
   safe array. Best-fit mapping is always enabled and no exception is thrown. Be
   aware that this combination can compromise your security model.
</note>
		</remarks>
		<example>
			<para>In some cases, Visual Basic developers use
      the <see cref="System.Runtime.InteropServices.DllImportAttribute"/>
      to define a DLL function in managed code, instead of using
      the <see langword="Declare"/> statement. Setting the <see cref="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar"/> field is one
      of those cases. The following example shows how to apply the strictest character
      mapping security to a platform invoke method definitions by specifying the ANSI
      character set, disabling best fit mapping behavior, and throwing an exception on
      unmapped Unicode characters. </para>
			<code lang="VB">&lt;DllImport( "My.dll", Charset := Charset.Ansi, _
                      BestfitMapping := False _
                      ThrowOnUnmappableChar := True )&gt;
   </code>
			<code lang="C#">[DllImport( "My.dll", Charset = Charset.Ansi, 
                      BestfitMapping = false
                      ThrowOnUnmappableChar = true )]
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.DllImportAttribute.CharSet"/>
		<seealso cref="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping"/>
	</doc>
	<doc for="BestFitMappingAttribute">
		<summary>
			<para>Controls whether Unicode characters are converted to the closest matching
      ANSI characters.</para>
		</summary>
		<remarks>
			<para>You can apply this attribute to an assembly, interface, class, or structure.</para>
			<para> By default, the common language runtime converts to
      ANSI characters any managed Unicode characters passed to an unmanaged
      method executing on Windows 98 or Windows Me. Best-fit mapping enables the <see topic="cpconinteropmarshaling" title="interop marshaler"/>
      
      to select a
      close-matching character when no exact match exists. For example,
      the marshaler converts the Unicode copyright character to 'c' for
      unmanaged methods that accept ANSI characters. </para>
			<note type="caution">
      Some characters lack a best-fit
      representation; these characters are called unmappable. Unmappable characters
      are usually converted to the default '?' ANSI character. Certain Unicode
      characters are converted to dangerous characters, such as the backslash '\'
      character, which can inadvertently change a path.
      
   </note>
			<para><see cref="System.Runtime.InteropServices.BestFitMappingAttribute"/>
provides two parameters to control aspects of best-fit mapping. You use
the first parameter to toggle best-fit mapping on and off. The default value is
<see langword="true"/>, which enables best-fit mapping on the
assembly, interface, and class levels. An attribute applied to an interface or class
overrides an assembly-level attribute. You can likewise enable or disable
best-fit mapping for platform invoke calls by using the <see cref="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping" qualify="true"/> field. A
value set by
the platform invoke field overrides all levels of
<see cref="System.Runtime.InteropServices.BestFitMappingAttribute"/>. </para>
			<para> You can use the second parameter to control throwing an
   exception on unmappable characters. The default value for the <see cref="System.Runtime.InteropServices.BestFitMappingAttribute.ThrowOnUnmappableChar"/> field is
<see langword="false"/>, which disables throwing an exception each 
   time the runtime encounters a Unicode character that has to be converted to the
   '?' ANSI character. Even if best-fit mapping is <see langword="true"/>, unmappable characters generate an exception
   when the <see cref="System.Runtime.InteropServices.BestFitMappingAttribute.ThrowOnUnmappableChar"/> field is
<see langword="true"/>. 
   To tighten security, you can toggle the first
   parameter to <see langword="false"/> and the second parameter to
<see langword="true"/>. This combination 
   of parameter settings turns best-fit mapping off, but enables the
   exception-throwing mechanism as a safety precaution. </para>
			<note type="caution">
   You cannot change the default values
   provided by <see cref="System.Runtime.InteropServices.BestFitMappingAttribute"/> when
   passing a managed array whose elements are ANSI Chars or LPSTRs to an unmanaged
   safe array. Best-fit mapping is always enabled and no exception can be thrown.
   Be aware that this combination can compromise your security model.
</note>
		</remarks>
		<example>
			<para>The following example shows how to disable best fit
      mapping and to throw an exception on the conversion of Unicode characters to the
      '?' ANSI character. Setting <see cref="System.Runtime.InteropServices.BestFitMappingAttribute"/>
      
      parameters in this manner provides an added measure of
      security.</para>
			<code lang="VB">&lt;BestFitMapping(False, ThrowOnUnmappableChar := True)&gt; _
Interface IMyInterface1
     'Insert code here.
End Interface
   </code>
			<code lang="C#">[BestFitMapping(false, ThrowOnUnmappableChar = true)]
interface IMyInterface1 
{
    //Insert code here.
}
   </code>
		</example>
		<seealso cref="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping"/>
	</doc>
	<doc for="InterfaceTypeAttribute.InterfaceTypeAttribute1">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.InterfaceTypeAttribute"/> class with the specified <see cref="System.Runtime.InteropServices.ComInterfaceType"/>
enumeration member.</para>
		</summary>
		<param name="interfaceType">Describes how the interface should be exposed to COM clients.</param>
		<remarks>
			<para> This constructor takes an underlying 16-bit integer that
      represents each <see cref="System.Runtime.InteropServices.ComInterfaceType"/> enumeration member. The
   <see topic="cpgrftypelibraryimportertlbimpexe"/>
   
   uses this constructor.</para>
		</remarks>
		<seealso topic="cpgrftypelibraryimportertlbimpexe"/>
	</doc>
	<doc for="ClassInterfaceAttribute.ClassInterfaceAttribute1">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.ClassInterfaceAttribute"/> class with the specified
<see cref="System.Runtime.InteropServices.ClassInterfaceType"/>
enumeration value.</para>
		</summary>
		<param name="classInterfaceType">Describes the type of interface that is generated for a class.</param>
		<remarks>
			<para> This constructor takes an underlying 16-bit
      signed integer that represents each <see cref="System.Runtime.InteropServices.ClassInterfaceType"/> enumeration member. The
   <see topic="cpgrftypelibraryImportertlbimpexe"/> 
   uses this constructor. </para>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.ClassInterfaceType"/>
		<seealso topic="cpgrftypelibraryimportertlbimpexe"/>
	</doc>
	<doc for="ComVisibleAttribute">
		<summary>
			<para> Controls accessibility of an individual managed type or member, or of all types within an assembly, to COM.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to assemblies,
      interfaces, classes, structures, delegates, enumerations, fields, methods, or properties.</para>
			<para>The default is <see langword="true"/>, which indicates that the managed type is visible to COM. This attribute is not needed to make public managed assemblies and types visible; they are visible
   to COM by default. Only <see langword="public"/> types can be made visible. The attribute
   cannot be used to make an otherwise <see langword="internal"/> or
<see langword="protected"/> type visible to COM or
   to make members of a nonvisible type visible.</para>
			<para> Setting the
   attribute to <see langword="false "/>on the assembly hides all
<see langword="public"/> types within the assembly. You can 
   selectively make types within the assembly visible by setting the individual
   types to <see langword="true"/>. Setting the attribute to
<see langword="false "/> on a specific type hides that type and its 
   members. However, you cannot make members of a
   type visible if the type is invisible. Setting the attribute
   to <see langword="false"/> on a type prevents that type from being exported
   to a type library; classes are not registered; interfaces are never responsive
   to unmanaged <see langword="QueryInterface"/>
   calls.</para>
			<para> Unless you explicitly set
   a class and its members to <see langword="false"/>, inherited
   classes can expose to COM base class members that are invisible in the
   original class. For example, if you set ClassA to <see langword="false"/>
   and do not apply the attribute to its members, the class and its members are
   invisible to COM. However, if you derive ClassB from ClassA and export ClassB to COM, ClassA
   members become visible base class members of ClassB.</para>
			<para> For a detailed description of the export process, see <see topic="cpconassemblytotypelibraryconversionsummary"/>.</para>
		</remarks>
		<example>
			<para> The following example shows how you can control the visibility
      to COM of a class so that its members are invisible. By setting
   <see langword="ComVisibleAttribute"/> to <see langword="false"/> on <c>MyClass</c>, and <see langword="false"/> on <c>MyMethod</c> and <c>MyProperty</c>, you can avoid inadvertently exposing the members to
   COM through inheritance.</para>
			<codelink SampleID="Classic ComVisibleAttribute Example" SnippetID="1"/>
		</example>
		<seealso topic="cpgrfTypeLibraryExporterTlbExpexe"/>
		<seealso topic="cpconassemblytotypelibraryconversionsummary"/>
	</doc>
	<doc for="UnmanagedType">
		<summary>
			<para> Identifies how to marshal parameters or fields to unmanaged
      code.
      </para>
		</summary>
		<remarks>
			<para>This enumeration is used by <see cref="System.Runtime.InteropServices.MarshalAsAttribute" qualify="true"/> to specify
   nondefault values for <see cref="System.Array"/>, <see cref="System.Boolean"/>, and <see cref="System.String"/> data types or to
   make the default behavior explicit. You can also use the enumeration members to
   specify simple value types (I1, I2, I4, I8, R4, R8, U2, U4, and U8), unmanaged
   types that are unavailable in the .NET Framework, and various miscellaneous
   types. Some members represent types to be use with platform invoke
   methods only.</para>
		</remarks>
		<example>
			<para>The following code fragment demonstrates how to declare in managed 
      source code an unmanaged interface implemented by a COM component.
      The <see cref="System.Runtime.InteropServices.ComImportAttribute" qualify="true"/> prevents the <c>IMyStorage</c> interface from being
   exported back for use by COM. (COM clients should use the existing COM component
   directly.) In this example, <see cref="System.Runtime.InteropServices.MarshalAsAttribute"/>
   specifies serveral <see cref="System.Runtime.InteropServices.UnmanagedType"/>
   members, which represent the types used by the original
   COM interface.</para>
			<codelink SampleID="ImprovedInteropSnippets" SnippetID="2"/>
		</example>
		<seealso cref="System.Runtime.InteropServices.MarshalAsAttribute"/>
		<seealso cref="System.Runtime.InteropServices.ComImportAttribute"/>
	</doc>
	<doc for="ComEventInterfaceAttribute.BestFitMapping">
		<summary>
			<para> Gets the best-fit mapping behavior when
      converting Unicode characters to ANSI characters.</para>
		</summary>
		<value>
			<para><see langword="true"/> if best-fit mapping is
   enabled; otherwise, <see langword="false"/>. The default is
<see langword="true"/>.</para>
		</value>
		<remarks>
			<para>If best-fit mapping is <see langword="false"/>
and <see cref="System.Runtime.InteropServices.BestFitMappingAttribute.ThrowOnUnmappableChar"/> is
<see langword="true"/>, all Unicode characters that require conversion to ANSI 
format will generate an exception when passed to unmanaged code. Some characters
are unmappable, even when best-fit mapping is <see langword="true"/>
. Some characters lack a
best-fit representation; these characters are called unmappable. Unmappable characters are usually
converted to the default '?' ANSI character. </para>
			<note type="caution">
   Certain Unicode characters are
   converted to dangerous characters, such as the backslash '\' character, which
   can inadvertently change a path.
</note>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.BestFitMappingAttribute.ThrowOnUnmappableChar"/>
	</doc>
	<doc for="MarshalAsAttribute.MarshalAsAttribute1">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Runtime.InteropServices.MarshalAsAttribute"/> class with the
   specified <see cref="System.Runtime.InteropServices.UnmanagedType"/> value.</para>
		</summary>
		<param name="unmanagedType">The <see cref="System.Runtime.InteropServices.UnmanagedType"/> value the data is to be marshaled as.</param>
		<remarks>
			<para> This constructor takes an underlying 16-bit signed integer that represents
      each <see cref="System.Runtime.InteropServices.UnmanagedType"/> enumeration member. The
   <see topic="cpgrfTypeLibraryImporterTlbimpexe"/> 
   uses this
   constructor.</para>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.UnmanagedType"/>
		<seealso topic="cpgrfTypeLibraryImporterTlbimpexe"/>
	</doc>
	<doc for="DllImportAttribute">
		<summary>
			<para> Indicates that the attributed method is exposed by an unmanaged dynamic-link library (DLL) as a static entry point.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to methods.</para>
			<para>The <see cref="System.Runtime.InteropServices.DllImportAttribute"/> attribute provides the information needed to call a function
   exported from an unmanaged DLL. As a minimum requirement, you must supply the name of
   the DLL containing the entry point.</para>
			<para> 
   You apply this attribute directly to
   C# and C++ method definitions; however, the Visual Basic compiler emits this
   attribute when you use the <see langword="Declare"/>
   statement. For complex method definitions that include
<see cref="System.Runtime.InteropServices.DllImportAttribute.BestFitMapping"/>, 
<see cref="System.Runtime.InteropServices.DllImportAttribute.CallingConvention"/>, 
<see cref="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling"/>,
<see cref="System.Runtime.InteropServices.DllImportAttribute.PreserveSig"/>, 
<see cref="System.Runtime.InteropServices.DllImportAttribute.SetLastError"/>, or 
<see cref="System.Runtime.InteropServices.DllImportAttribute.ThrowOnUnmappableChar"/> fields, you 
   apply this attribute directly to Visual Basic method definitions. </para>
			<note type="note">
   JScript
   .NET does not support this
   attribute. You can use C# or Visual Basic wrapper classes to
   access unmanaged API methods from JScript .NET programs.
   
</note>
			<para> For additional information about using the platform
   invoke service to access functions in unmanaged DLLs, see <see topic="cpconconsumingunmanageddllfunctions"/>.</para>
		</remarks>
		<example>
			<para>The following example shows how to apply the <see cref="System.Runtime.InteropServices.DllImportAttribute"/> to a method.</para>
			<codelink SampleID="Classic DllImportAttribute Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Runtime.InteropServices.DllImportAttribute.SetLastError"/>
		<seealso cref="System.Runtime.InteropServices.DllImportAttribute.ExactSpelling"/>
		<seealso cref="System.Runtime.InteropServices.DllImportAttribute.PreserveSig"/>
		<seealso cref="System.Runtime.InteropServices.DllImportAttribute.CallingConvention"/>
	</doc>
	<doc for="StructLayoutAttribute.StructLayoutAttribute1">
		<summary>
			<para>Initalizes a new instance of the <see cref="System.Runtime.InteropServices.StructLayoutAttribute"/> class with the
   specified <see cref="System.Runtime.InteropServices.LayoutKind" qualify="true"/>
   enumeration member.</para>
		</summary>
		<param name="layoutKind">One of the <see cref="System.Runtime.InteropServices.LayoutKind"/> values that specifes how the class or structure should be arranged.</param>
		<remarks>
			<para>This constructor takes an underlying 16-bit integer that represents
      each <see cref="System.Runtime.InteropServices.LayoutKind"/>
      enumeration member. The <see topic="cpgrfTypeLibraryImporterTlbimpexe"/> uses this
      constructor.</para>
		</remarks>
		<seealso cref="System.Runtime.InteropServices.LayoutKind" qualify="true"/>
		<seealso topic="cpgrfTypeLibraryImporterTlbimpexe"/>
	</doc>
	<doc for="ComEventInterfaceAttribute.EventProvider">
		<summary>
			<para>Gets the class that implements the methods of the event
      interface.</para>
		</summary>
		<value>
			<para>A <see cref="System.Type"/> that contains the class that implements the
   methods of the event interface.</para>
		</value>
		<remarks>
			<para> This value is set to the type of the event
      provider class generated by the <see topic="cpgrfTypeLibraryImporterTlbimpexe"/>. Tlbimp.exe appends the source
      interface name with EventProvider. For example,
      IMyInterface becomes IMyInterfaceEventProvider.</para>
		</remarks>
	</doc>
	<doc for="ComRegisterFunctionAttribute">
		<summary>
			<para> Specifies the method to call when you register an assembly for use from COM;
      this allows for the execution of user-written code during the registration process.</para>
		</summary>
		<remarks>
			<para> You can apply this attribute to methods.</para>
			<para><see cref="System.Runtime.InteropServices.ComRegisterFunctionAttribute"/> enables you
   to add abritrary registration code to accommodate the requirements of COM clients.
   For example, you can update the registry using registration functions from
   the <see cref="Microsoft.Win32"/>
   namespace. If you provide a registration method, you must also apply
<see cref="System.Runtime.InteropServices.ComUnregisterFunctionAttribute" qualify="true"/> to an unregistration 
   method, which reverses the operations done in the registration method.</para>
			<para> The common language runtime calls the method with this
   attribute when its containing assembly is registered (directly or indirectly)
   with the <see topic="cpgrfassemblyregistrationtoolregasmexe"/>
   or through the <see cref="System.Runtime.InteropServices.RegistrationServices.RegisterAssembly" qualify="true"/> API method.
   Methods with this attribute can have any visibility (public, private, and so
   on), but must be <see langword="static"/> and must take a single <see cref="System.Type"/>
   
   parameter for the type to register.</para>
		</remarks>
		<example>
			<para>The following example demonstrates how to
      apply <see cref="System.Runtime.InteropServices.ComRegisterFunctionAttribute"/> and <see cref="System.Runtime.InteropServices.ComUnregisterFunctionAttribute"/> to methods with the appropriate
      signature.</para>
			<codelink SampleID="Classic ComRegisterFunctionAttribute Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Runtime.InteropServices.ComUnregisterFunctionAttribute"/>
		<seealso topic="cpgrfassemblyregistrationtoolregasmexe"/>
		<seealso cref="System.Runtime.InteropServices.RegistrationServices.RegisterAssembly"/>
	</doc>
	<doc for="ComUnregisterFunctionAttribute">
		<summary>
			<para>Specifies the method to call when you unregister an assembly
      for use from COM; this allows for the execution of user-written code during the
      unregistration process.</para>
		</summary>
		<remarks>
			<para> You can apply this
      attribute to
      methods.</para>
			<para><see cref="System.Runtime.InteropServices.ComUnregisterFunctionAttribute"/> enables you to add code that reverses the
   operations performed by a registration method. If you apply
   the <see cref="System.Runtime.InteropServices.ComRegisterFunctionAttribute"/> to
   provide a registration method, you must also provide an unregistration method to reverse
   the operations done in the registration method. You can have only one
   unregistration method for a class.</para>
			<para> The common language runtime calls the method with this
   attribute when its containing assembly is unregistered (directly or indirectly)
   with the <see topic="cpgrfassemblyregistrationtoolregasmexe"/>
   or through the <see cref="System.Runtime.InteropServices.RegistrationServices.UnregisterAssembly" qualify="true"/> API method.
   Methods with this attribute can have any visibility
   (public, private, and so on), but must be <see langword="static"/> and must take a single <see cref="System.Type"/> parameter for the <see cref="System.Type"/>
   
   to unregister. </para>
		</remarks>
		<example>
			<para>The following example demonstrates applying <see cref="System.Runtime.InteropServices.ComRegisterFunctionAttribute"/>
and <see cref="System.Runtime.InteropServices.ComUnregisterFunctionAttribute"/> to methods with the
appropriate signature.</para>
			<codelink SampleID="Classic ComRegisterFunctionAttribute Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Runtime.InteropServices.ComRegisterFunctionAttribute"/>
		<seealso topic="cpgrfassemblyregistrationtoolregasmexe"/>
		<seealso cref="System.Runtime.InteropServices.RegistrationServices.UnregisterAssembly" qualify="true"/>
	</doc>
	<doc for="TypeLibVersionAttribute">
		<summary>
			<para><SPAN>Specifies
      the version number of an exported type library.</SPAN>
			</para>
		</summary>
		<remarks>
			<para>You can apply this attribute to assemblies.</para>
			<para>By default, the <see topic="cpgrfTypeLibraryExporterTlbexpexe "/> generates a type library version
   from the first two numbers of an assembly version. For example, Tlb.exe exports
   assembly version 1.2.5000.0 as a type library version 1.2, eliminating the build
   and revision numbers of the assembly. If this behavior is undesirable, you can
   control the generation of the type library number explicitly by applying
   the <see cref="System.Runtime.InteropServices.TypeLibVersionAttribute"/>.</para>
			<para>It is useful to control the generation of a type library version explicitly when
   two assembly versions produce the same type library version. For example, assembly
   version 1.2.0.0 and assembly version 1.2.500.0 both produce a type
   library version of 1.2, which can cause problems when you uninstall one of the
   assemblies. To differentiate the type library versions, you can force the
   second assembly (version 1.2.500.0) to produce a type library version of
   1.25.</para>
		</remarks>
		<example>
			<para>The following example shows how to apply
      the <see cref="System.Runtime.InteropServices.TypelibVersionAttribute"/> to
      explicitly set the type library version to 1.25. </para>
			<code lang="VB">Imports System
Imports System.Runtime.Interop

&lt;Assembly: AssemblyVersion ("1.2.500.0")&gt;
&lt;Assembly: TypeLibVersionAttribute(1,25)&gt;

Module MyNamespace
  Public Class c
    ' Insert code.
  End Class
   </code>
			<code lang="C#">using System;
using System.Runtime.InteropServices;

[Assembly: AssemblyVersion ("1.2.500.0")&gt;
[Assembly: TypeLibVersion(1,25)]

namespace MyNamespace
{
  class MyClass
  {
    // Insert code.
  }
}
   </code>
		</example>
		<seealso topic="cpgrfTypeLibraryExporterTlbexpexe "/>
	</doc>
</docs>
