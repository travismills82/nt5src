<docs>
	<doc for="Assembly.GlobalAssemblyCache">
		<summary>
			<para>Gets a value indicating whether the assembly was 
      loaded from the global assembly cache.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the assembly was loaded from the global assembly 
   cache; otherwise, <see langword="false"/>.</para>
		</value>
	</doc><doc for="Assembly.ModuleResolve">
		<summary>
			<para>Occurs when the common language runtime class loader
      cannot resolve a reference to an internal module of an assembly through normal means.</para>
		</summary>
		<remarks>
			<para>This event gives the callback a chance to find and load the module itself and
      return it.</para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">to create and manipulate an application domain. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" qualify="true"/>.</permission>
	</doc><doc for="Assembly.EscapedCodeBase">
		<summary>
			<para> Gets the URI, including escape characters, that 
      represents the codebase. </para>
		</summary>
		<value>
			<para> A URI with escape characters. </para>
		</value>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to the path. Associated enumeration: <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/>. </permission>
	</doc><doc for="Assembly.EntryPoint">
		<summary>
			<para> Gets the entry point of this
      assembly.</para>
		</summary>
		<value>
			<para>A <see cref="System.Reflection.MethodInfo"/> object
   that represents the entry point of this assembly. If no entry point is found
   (for example, the assembly is a DLL), <see langword="null"/> is returned.</para>
		</value>
	</doc><doc for="Assembly.CreateQualifiedName">
		<summary>
			<para>Creates the name of a type qualified by the display name of its
      assembly.</para>
		</summary>
		<param name="assemblyName">The display name of an assembly.</param>
		<param name="typeName">The full name of a type.</param>
		<returns>
			<para>A <see langword="String"/> that is the full name of the type qualified by the display name of the
   assembly.</para>
		</returns>
		<remarks>
			<para>The format of the returned string is:</para>
			<para>&lt;FullTypeName&gt;,
      &lt;AssemblyDisplayName&gt;</para>
			<para>See <see cref="System.Reflection.AssemblyName"/> for a
   description of the format of the display name of an assembly.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetExportedTypes">
		<summary>
			<para>Gets the
      exported types defined in this assembly.</para>
		</summary>
		<returns>
			<para>An array of type <see langword="Type"/> containing the exported
   types defined in this assembly.</para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetSatelliteAssembly">
		<overload>
			<para>Gets the satellite assembly.</para>
		</overload>
		<summary>
			<para>Gets the
      satellite assembly for the specified culture.</para>
		</summary>
		<param name="culture">The specified culture.</param>
		<returns>
			<para>The
      specified satellite assembly.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/> .</exception>
		<exception cref="System.IO.FileNotFoundException">The assembly cannot be found.</exception>
		<exception cref="System.IO.FileLoadException">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo"/> did not match the one specified.</exception>
		<remarks>
			<para>Satellite assemblies contain localized resources, as distinct from main
      application assemblies, which contain non-localizable executable code and
      resources for a single culture that serve as the default or neutral culture.</para>
			<para>Call this method to use your current assembly version.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetSatelliteAssembly1">
		<summary>
			<para>Gets the specified version of the satellite assembly for
      the specified culture.</para>
		</summary>
		<param name="culture">The specified culture.</param>
		<param name=" version">The version of the satellite assembly.</param>
		<returns>
			<para>The specified satellite assembly.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/> .</exception>
		<exception cref="System.IO.FileLoadException">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo"/> or the version did not match the one specified.</exception>
		<exception cref="System.IO.FileNotFoundException">The assembly cannot be found.</exception>
		<remarks>
			<para>Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</para>
			<para>Call <see topic="frlrfSystemReflectionAssemblyClassGetSatelliteAssemblyTopic1" title="GetSatelliteAssembly(CultureInfo)"/>
to use your current assembly version.</para>
			<para>If <paramref name="version"/> is <see langword="null"/>, the current assembly version is
used if both the resource and main assemblies are signed.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetObjectData">
		<summary>
			<para>Gets serialization information with all of the data needed to reinstantiate this assembly.</para>
		</summary>
		<param name="info">The object to be populated with serialization information.</param>
		<param name=" context">The destination context of the serialization.</param>
		<exception cref="System.ArgumentNullException"><paramref name="info "/>is <see langword="null"/>.</exception>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetCustomAttributes">
		<overload>
			<para> Gets the
      custom attributes for this assembly.</para>
		</overload>
		<summary>
			<para>Gets all the
      custom attributes for this assembly.</para>
		</summary>
		<param name="inherit">This argument is ignored for objects of type <see cref="System.Reflection.Assembly"/> . </param>
		<returns>
			<para>An array of type <see langword="Object"/>
containing the custom attributes for this assembly.</para>
		</returns>
		<remarks>
			<para>This method implements the corresponding <see cref="System.Reflection.ICustomAttributeProvider"/> interface method.
   Therefore, the <paramref name="inherit "/>
   parameter must be specified even though it is ignored.</para>
			<para> A pseudo-attribute indicates bits of the
   core metadata that must be set when the attribute is present. Unlike a
   custom attribute that extends the metadata for a type and is saved along with
   the type, a pseudo-attribute modifies the metadata for the type and
   then is discarded. Some of the resulting bits cannot be accessed
   using existing reflection APIs.</para>
			<para>The following table summarizes the different pseudo-attributes and the
   accessors for the bits that are available in reflection.</para>
			<list type="table">
				<listheader>
					<term>Pseudo-Attribute</term>
					<description>Metadata Bits</description>
					<description>Reflection Accessor</description>
				</listheader>
				<item>
					<term> DllImportAttribute</term>
					<description>
						<para>CorPInvokeMap </para>
						<para>DLL name</para></description>
					<description>
						<para>No accessor for PInvokeMap for ordinary
               method/global method attributes.</para>
						<para>No accessor for DLL name.</para></description>
				</item>
				<item>
					<term> GuidAttribute</term>
					<description>Stored as a real custom attribute.</description>
					<description>Accessed as a real custom attribute.</description>
				</item>
				<item>
					<term> ComImportAttribute</term>
					<description>CorTypeAttr.tdImport</description>
					<description>Type.Attributes.Import</description>
				</item>
				<item>
					<term> SerializableAttribute</term>
					<description>CorTypeAttr.tdSerializable</description>
					<description>Type.Attributes.Serializable</description>
				</item>
				<item>
					<term> NonSerializedAttribute</term>
					<description>CorFieldAttr.fdNotSerialized</description>
					<description>FieldInfo.Attributes.NotSerialized</description>
				</item>
				<item>
					<term> MethodImplAttribute</term>
					<description>CorMethodImpl</description>
					<description>
						<para>MethodInfo.GetMethodImplementationFlags()</para>
						<para>ConstructorInfo.GetMethodImplementationFlags()</para></description>
				</item>
				<item>
					<term> MarshalAsAttribute</term>
					<description>Various bits.</description>
					<description>No accessor.</description>
				</item>
				<item>
					<term> PreserveSigAttribute</term>
					<description>CorMethodImpl.miOLE</description>
					<description>
						<para>MethodInfo.GetMethodImplementationFlags().OLE</para>
						<para>ConstructorInfo.GetMethodImplementationFlags().OLE</para></description>
				</item>
				<item>
					<term> InAttribute</term>
					<description>CorParamAttr.pdIn</description>
					<description>ParameterInfo.Attributes.In</description>
				</item>
				<item>
					<term> OutAttribute</term>
					<description>CorParamAttr.pdOut</description>
					<description>ParameterInfo.Attributes.Out</description>
				</item>
				<item>
					<term> StructLayoutAttribute</term>
					<description>
						<para>CorTypeAttr.tdLayoutSequential</para>
						<para>CorTypeAttr.tdExplicitLayout</para>
						<para>CorTypeAttr.tdAnsiClass</para>
						<para>CorTypeAttr.tdUnicodeClass</para>
						<para>CorTypeAttr.tdAutoClass</para>
						<para>Class packing.</para></description>
					<description>
						<para>Type.Attributes.LayoutSequential</para>
						<para>Type.Attributes.ExplicitLayout</para>
						<para>Type.Attributes.AnsiClass</para>
						<para>Type.Attributes.UnicodeClass</para>
						<para>Type.Attributes.AutoClass</para>
						<para>No accessor.</para></description>
				</item>
				<item>
					<term> FieldOffsetAttribute</term>
					<description>Field offset.</description>
					<description>No accessor.</description>
				</item>
				<item>
					<term> AssemblyLoadAttribute</term>
					<description>CorAssemblyFlags</description>
					<description> No accessor or
                           enumerator.</description>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetLoadedModules">
		<overload>
			<para>Gets all the loaded modules that are part of this assembly.</para>
		</overload>
		<summary>
			<para>Gets all the
      loaded modules that are part of this assembly.</para>
		</summary>
		<returns>
			<para>An array of
      modules.</para>
		</returns>
		<remarks>
			<para>A type can be retrieved from a specific module using
   <see cref="System.Reflection.Module.GetType" qualify="true"/>. Calling <see langword="Module.GetType "/>on the module containing
      the manifest will not initiate a search of the entire assembly. To retrieve a
      type from an assembly, regardless of which module it is in, you must call
   <see cref="System.Reflection.Assembly.GetType" qualify="true"/>
   .</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetLoadedModules2">
		<summary>
			<para>Gets all the loaded modules that are part of this
      assembly, specifying whether to include resource modules.</para>
		</summary>
		<param name="getResourceModules"><see langword="true"/> to include resource modules; otherwise, <see langword="false"/>.</param>
		<returns>
			<para>An array of modules.</para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetModules2">
		<summary>
			<para>Gets all the modules that are part of this assembly, specifying whether to
      include resource modules.</para>
		</summary>
		<param name="getResourceModules"><see langword="true"/> to include resource modules; otherwise, <see langword="false"/>.</param>
		<returns>
			<para>An array of modules.</para>
		</returns>
		<remarks>
			<note type="note">
      Modules
      must be emitted with file name extensions.
      
   </note>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetFiles">
		<overload>
			<para>Gets the files in the file table of an assembly manifest. </para>
		</overload>
		<summary>
			<para> Gets the files in the file table of an assembly manifest.
      </para>
		</summary>
		<returns>
			<para> An array of <see cref="System.IO.FileStream"/> objects.
   </para>
		</returns>
		<remarks>
			<para>This method only works on public resources. </para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetFiles2">
		<summary>
			<para>Gets the files in the file table of an assembly
      manifest, specifying whether to include resource modules.</para>
		</summary>
		<param name="getResourceModules"><see langword="true"/> to include resource modules; otherwise, <see langword="false"/>.</param>
		<returns>
			<para>An array of <see cref="System.IO.FileStream"/> objects.</para>
		</returns>
		<remarks>
			<para>This method only works on public resources. </para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetManifestResourceNames">
		<summary>
			<para>Returns the
      names of all the resources in this assembly.</para>
		</summary>
		<returns>
			<para>An array of type <see langword="String"/> containing the names of
   all the resources.</para>
		</returns>
		<remarks>
			<para>This method works on both public and private resources.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetEntryAssembly">
		<summary>
			<para>Gets the process executable in the default application
      domain. In other application domains, this is the first executable that was
      executed by <see cref="System.AppDomain.ExecuteAssembly" qualify="true"/>
      .</para>
		</summary>
		<returns>
			<para>The <see langword="Assembly"/> that is the process executable in the
   default application domain, or the first executable that was executed by <see cref="System.AppDomain.ExecuteAssembly" qualify="true"/> .</para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetReferencedAssemblies">
		<summary>
			<para>Gets the <see cref="System.Reflection.AssemblyName"/>
objects for all the assemblies referenced by this assembly.</para>
		</summary>
		<returns>
			<para>An array of type <see cref="System.Reflection.AssemblyName"/> containing all the assemblies referenced by this assembly.</para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.ToString">
		<summary>
			<para>Returns the full name of the assembly, also known as the display name.</para>
		</summary>
		<returns>
			<para>The full name of the assembly, or the class name if the full name of the
      assembly cannot be determined.</para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.LoadModule">
		<overload>
			<para>Loads the module internal to this assembly.</para>
		</overload>
		<summary>
			<para>Loads the module, internal to this assembly, with
      a Common Object File Format (COFF)-based image containing an emitted module, or a resource file.</para>
		</summary>
		<param name="moduleName">Name of the module. Must correspond to a file name in this assembly's manifest.</param>
		<param name="rawModule">A byte array that is a COFF-based image containing an emitted module, or a resource. </param>
		<returns>
			<para>The
      loaded Module.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="moduleName"/> or <paramref name="rawModule"/> is <see langword="null"/> .</exception>
		<exception cref="System.ArgumentException"><paramref name="moduleName"/> does not match a file entry in this assembly's manifest.</exception>
		<exception cref="System.BadImageFormatException"><paramref name="rawModule"/> is not a valid module. </exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to provide evidence. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.LoadModule1">
		<summary>
			<para>Loads the module, internal to this assembly, with
      a Common Object File Format (COFF)-based image containing an emitted module, or a resource file.
      The raw bytes representing the symbols for the module are also loaded.</para>
		</summary>
		<param name="moduleName">Name of the module. Must correspond to a file name in this assembly's manifest.</param>
		<param name="rawModule">A byte array that is a COFF-based image containing an emitted module, or a resource. </param>
		<param name="rawSymbolStore">A byte array containing the raw bytes representing the symbols for the module. Must be <see langword="null"/> if this is a resource file.</param>
		<returns>
			<para>The
      loaded module.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="moduleName"/> or <paramref name="rawModule"/> is <see langword="null"/> .</exception>
		<exception cref="System.ArgumentException"><paramref name="moduleName"/> does not match a file entry in this assembly's manifest.</exception>
		<exception cref="System.BadImageFormatException"><paramref name="rawModule"/> is not a valid module. </exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to provide evidence. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetName">
		<overload>
			<para> Gets an <see cref="System.Reflection.AssemblyName"/>
for this assembly.</para>
		</overload>
		<summary>
			<para>Gets an <see cref="System.Reflection.AssemblyName"/>
for this assembly.</para>
		</summary>
		<returns>
			<para>An <see cref="System.Reflection.AssemblyName"/> for
   this assembly.</para>
		</returns>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to the path of the assembly. Associated enumeration: <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/></permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetName1">
		<summary>
			<para>Gets an <see cref="System.Reflection.AssemblyName"/>
for this
assembly, setting the codebase as specified by <paramref name="copiedName"/>
.</para>
		</summary>
		<param name="copiedName"><see langword="true"/> to set the <see cref="System.Reflection.Assembly.CodeBase"/> to the location of the assembly after it was shadow copied; <see langword="false"/> to set <see cref="System.Reflection.Assembly.CodeBase"/> to the original location.</param>
		<returns>
			<para>An <see cref="System.Reflection.AssemblyName"/> for
   this assembly.</para>
		</returns>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to the path of the assembly. Associated enumeration: <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/></permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetFile">
		<summary>
			<para>Gets a <see cref="System.IO.FileStream"/> for the
   specified file in the file table of the manifest of this assembly.</para>
		</summary>
		<param name="name">The name of the specified file.</param>
		<returns>
			<para>A <see cref="System.IO.FileStream"/> for the specified
   file, or <see langword="null "/>
   if the file is not found.</para>
		</returns>
		<exception cref="System.IO.FileLoadException">A file that was found could not be loaded.</exception>
		<exception cref="System.ArgumentNullException">The <paramref name="name"/> parameter is <see langword="null"/>.</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<exception cref="System.ArgumentException">The <paramref name="name"/> parameter is the empty string (""). </exception>
		<remarks>
			<para> This method works on both public and private resources.
   <paramref name="name"/>
   should not include the path to the file.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to the path and for reading the specified file. Associated enumerations: <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/> and <see cref="System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true"/></permission>
	</doc>
	<doc for="Assembly.GetManifestResourceInfo">
		<summary>
			<para>Returns information about how the given resource has been persisted.</para>
		</summary>
		<param name="resourceName">The name of the resource.</param>
		<returns>
			<para><see cref="System.Reflection.ManifestResourceInfo"/> populated with information about
   the resource's topology, or <see langword="null"/>
   if the resource is not found.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="resourceName"/> is <see langword="null"/> .</exception>
		<exception cref="System.ArgumentException">The <paramref name="resourceName"/> parameter is the empty string ("").</exception>
		<remarks>
			<para>This method works on both public and private resources.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.CreateInstance">
		<overload>
			<para>Locates a type from this assembly and creates an instance of it
      using the system activator. </para>
		</overload>
		<summary>
			<para>Locates the specified type from this assembly and creates an instance of it using the
      system activator, using case-sensitive search. </para>
		</summary>
		<param name="typeName">The <see cref="System.Type.FullName" qualify="true"/> of the type to locate.</param>
		<returns>
			<para>An instance of <see cref="System.Object"/> representing the type, with culture, 
   arguments, binder, and activation attributes set to <see langword="null"/>, and <see cref="System.Reflection.BindingFlags"/> set to Public or Instance,
   or <see langword="null"/> if <paramref name="typeName"/> is not found.</para>
		</returns>
		<exception cref="System.ArgumentException"><para><paramref name="typeName"/> is the empty string ("") or "\0anything"</para>
			<para>-or-</para>
			<para>The length of <paramref name="typeName"/> exceeds 1024 characters.</para></exception>
		<exception cref="System.ArgumentNullException"><paramref name="typeName"/> is <see langword="null"/>.</exception>
		<exception cref="System.MissingMethodException">No matching constructor was found.</exception>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.CreateInstance1">
		<summary>
			<para>Locates the specified type from this assembly and creates an instance of it using
      the system activator, with optional case-sensitive search.</para>
		</summary>
		<param name="typeName">The <see cref="System.Type.FullName" qualify="true"/> of the type to locate.</param>
		<param name=" ignoreCase"><see langword="true"/> to ignore the case of the type name; otherwise, <see langword="false"/> .</param>
		<returns>
			<para>An instance of <see cref="System.Object"/> representing the type,
   with culture, arguments, binder, and activation attributes set to <see langword="null"/>, and <see cref="System.Reflection.BindingFlags"/> set to Public or Instance, or <see langword="null"/> if
<paramref name="typeName"/> is not
   found.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="typeName"/> is the empty string ("") or "\0anything" <para>-or-</para>
			<para>The length of <paramref name="typeName"/> exceeds 1024 characters.</para></exception>
		<exception cref="System.MissingMethodException">No matching constructor was found.</exception>
		<exception cref="System.ArgumentNullException"><paramref name="typeName"/> is <see langword="null"/>.</exception>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetCustomAttributes1">
		<summary>
			<para> Gets the custom attributes for this assembly as specified by type.</para>
		</summary>
		<param name="attributeType">The <see cref="System.Type"/> for which the custom attributes are to be returned.</param>
		<param name="inherit">This argument is ignored for objects of type <see cref="System.Reflection.Assembly"/> . </param>
		<returns>
			<para>An array of type <see langword="Object"/> containing the
   custom attributes for this assembly as specified by
<paramref name="attributeType"/>
.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="attributeType"/> is <see langword="null"/> .</exception>
		<exception cref="System.ArgumentException"><paramref name="attributeType"/> is not a runtime type.</exception>
		<remarks>
			<para>This method implements the corresponding <see cref="System.Reflection.ICustomAttributeProvider"/> interface method. Therefore, the <paramref name="inherit "/>parameter must be specified even though it is ignored.</para>
			<para>A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present. Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded. Some of the resulting bits cannot be accessed using existing reflection APIs.</para>
			<para>The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</para>
			<list type="table">
				<listheader>
					<term>Pseudo-Attribute</term>
					<description>Metadata Bits</description>
					<description>Reflection Accessor</description>
				</listheader>
				<item>
					<term> DllImportAttribute</term>
					<description><para>CorPInvokeMap </para>
						<para>DLL name</para></description>
					<description><para>No accessor for PInvokeMap for ordinary method/global method attributes.</para>
						<para>No accessor for DLL name.</para></description>
				</item>
				<item>
					<term> GuidAttribute</term>
					<description>Stored as a real custom attribute.</description>
					<description>Accessed as a real custom attribute.</description>
				</item>
				<item>
					<term> ComImportAttribute</term>
					<description>CorTypeAttr.tdImport</description>
					<description>Type.Attributes.Import</description>
				</item>
				<item>
					<term> SerializableAttribute</term>
					<description>CorTypeAttr.tdSerializable</description>
					<description>Type.Attributes.Serializable</description>
				</item>
				<item>
					<term> NonSerializedAttribute</term>
					<description>CorFieldAttr.fdNotSerialized</description>
					<description>FieldInfo.Attributes.NotSerialized</description>
				</item>
				<item>
					<term> MethodImplAttribute</term>
					<description>CorMethodImpl</description>
					<description><para>MethodInfo.GetMethodImplementationFlags()</para>
						<para>ConstructorInfo.GetMethodImplementationFlags()</para></description>
				</item>
				<item>
					<term> MarshalAsAttribute</term>
					<description>Various bits.</description>
					<description>No accessor.</description>
				</item>
				<item>
					<term> PreserveSigAttribute</term>
					<description>CorMethodImpl.miOLE</description>
					<description><para>MethodInfo.GetMethodImplementationFlags().OLE</para>
						<para>ConstructorInfo.GetMethodImplementationFlags().OLE</para></description>
				</item>
				<item>
					<term> InAttribute</term>
					<description>CorParamAttr.pdIn</description>
					<description>ParameterInfo.Attributes.In</description>
				</item>
				<item>
					<term> OutAttribute</term>
					<description>CorParamAttr.pdOut</description>
					<description>ParameterInfo.Attributes.Out</description>
				</item>
				<item>
					<term> StructLayoutAttribute</term>
					<description><para>CorTypeAttr.tdLayoutSequential</para>
						<para>CorTypeAttr.tdExplicitLayout</para>
						<para>CorTypeAttr.tdAnsiClass</para>
						<para>CorTypeAttr.tdUnicodeClass</para>
						<para>CorTypeAttr.tdAutoClass</para>
						<para>Class packing.</para></description>
					<description><para>Type.Attributes.LayoutSequential</para>
						<para>Type.Attributes.ExplicitLayout</para>
						<para>Type.Attributes.AnsiClass</para>
						<para>Type.Attributes.UnicodeClass</para>
						<para>Type.Attributes.AutoClass</para>
						<para>No accessor.</para></description>
				</item>
				<item>
					<term> FieldOffsetAttribute</term>
					<description>Field offset.</description>
					<description>No accessor.</description>
				</item>
				<item>
					<term> AssemblyLoadAttribute</term>
					<description>CorAssemblyFlags</description>
					<description>No accessor or enumerator.</description>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetManifestResourceStream">
		<overload>
			<para>Loads the specified
      manifest resource from this assembly.</para>
		</overload>
		<summary>
			<para>Loads the specified
      manifest resource, scoped by the namespace of the specified type, from this
      assembly.</para>
		</summary>
		<param name="type">The type whose namespace is used to scope the manifest resource name.</param>
		<param name="name">The name of the manifest resource being requested.</param>
		<returns>
			<para>A <see cref="System.IO.Stream"/> representing
   this
   manifest resource.</para>
		</returns>
		<exception cref="System.ArgumentNullException">The <paramref name="name"/> parameter is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException">The <paramref name="name"/> parameter is the empty string ("").</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para> This
      method works on both public and private resources.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>If the full name of <paramref name="type"/> is "MyNameSpace.MyClasses" and <paramref name="name"/> is
   "Net", <see langword="GetManifestResourceStream"/> will search for a resource
   named MyNameSpace.Net.</para>
		</example>
		<seealso topic="cpconassemblymanifest"/>
	</doc>
	<doc for="Assembly.GetManifestResourceStream1">
		<summary>
			<para>Loads the specified
      manifest resource from this assembly.</para>
		</summary>
		<param name="name">The name of the manifest resource being requested.</param>
		<returns>
			<para>A <see cref="System.IO.Stream"/> representing
   this
   manifest resource.</para>
		</returns>
		<exception cref="System.ArgumentNullException">The <paramref name="name"/> parameter is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException">The <paramref name="name"/> parameter is the empty string ("").</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para> This
      method works on both public and private resources.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<seealso topic="cpconassemblymanifest"/>
	</doc>
	<doc for="Assembly.GetType">
		<overload>
			<para> Gets the <see cref="System.Type"/>
object that represents the specified type.</para>
		</overload>
		<summary>
			<para>Gets the <see cref="System.Type"/> object with the specified name in the
   assembly instance.</para>
		</summary>
		<param name="name">The full name of the type.</param>
		<returns>
			<para>A
   <see cref="System.Type"/> object that 
      represents the specified class, or <see langword="null"/>
      if the class is not found.</para>
		</returns>
		<exception cref="System.ArgumentException"><para><paramref name="name"/> is invalid.</para>
			<para>-or-</para>
			<para>The length of <paramref name="name"/> exceeds 1024 characters.</para></exception>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>Unlike <see cref="System.Type.GetType" qualify="true"/>, which requires a string that includes both the
   type name and the assembly name, this method requires only the type name because
   only the assembly on which you are calling <see langword="GetType"/>
   is used.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting methods that are not public. Associated enumerations: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/> , <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
	</doc>
	<doc for="Assembly.GetType1">
		<summary>
			<para>Gets
      the <see cref="System.Type"/> object with the specified
      name in the assembly instance and optionally throws an exception.</para>
		</summary>
		<param name="name">The full name of the type.</param>
		<param name="throwOnError"><see langword="true"/> to throw an exception if the type is not found; otherwise, <see langword="null"/> .</param>
		<returns>
			<para>A
   <see cref="System.Type"/>
   object that represents the specified class.</para>
		</returns>
		<exception cref="System.Reflection.ReflectionTypeLoadException">The type is not in the assembly instance you are calling the method on.</exception>
		<exception cref="System.ArgumentException"><para><paramref name="name"/> is invalid.</para><para>-or-</para><para>The length of <paramref name="name"/> exceeds 1024 characters.</para></exception>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>Unlike <see cref="System.Type.GetType" qualify="true"/>, which requires a string that includes both the type name and the assembly name, this method requires only the type name because only the assembly on which you are calling <see langword="GetType"/> is used.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting methods that are not public. Associated enumerations: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/> , <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
	</doc>
	<doc for="Assembly.GetType2">
		<summary>
			<para>Gets
      the <see cref="System.Type"/> object with the specified name
      in the assembly instance, with the options of ignoring the case,
      and throwing an exception.</para>
		</summary>
		<param name="name">The full name of the type.</param>
		<param name="throwOnError"><see langword="true"/> to throw an exception if the type is not found; otherwise, <see langword="null"/> .</param>
		<param name="ignoreCase"><see langword="true"/> to ignore the case of the type name; otherwise, <see langword="false"/> .</param>
		<returns>
			<para>A
   <see cref="System.Type"/>
   object that represents the specified class.</para>
		</returns>
		<exception cref="System.Reflection.ReflectionTypeLoadException">The type is not in the assembly instance you are calling the method on.</exception>
		<exception cref="System.ArgumentException"><para><paramref name="name"/> is invalid.</para><para>-or-</para><para>The length of <paramref name="name"/> exceeds 1024 characters.</para></exception>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>Unlike <see cref="System.Type.GetType" qualify="true"/>, which requires a string that includes both the type name and the assembly name, this method requires only the type name because only the assembly on which you are calling <see langword="GetType"/> is used.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting methods that are not public. Associated enumerations: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/> , <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
	</doc>
	<doc for="Assembly.IsDefined">
		<summary>
			<para>Indicates whether a custom attribute identified by the specified <see cref="System.Type"/>
is defined.</para>
		</summary>
		<param name="attributeType">The <see cref="System.Type"/> of the custom attribute to be checked for this assembly.</param>
		<param name=" inherit">This argument is ignored for objects of this type.</param>
		<returns>
			<para><see langword="true "/>if a custom attribute
   identified by the specified <see cref="System.Type"/> is defined; otherwise, <see langword="false"/>
   .</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="attributeType"/> is <see langword="null"/> .</exception>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.GetModule">
		<summary>
			<para>Gets the
      specified module in this assembly.</para>
		</summary>
		<param name="name">The name of the module being requested.</param>
		<returns>
			<para>The module being 
      requested, or <see langword="null"/> if the module is not
      found.</para>
		</returns>
		<exception cref="System.ArgumentNullException">The <paramref name="name"/> parameter is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException">The <paramref name="name"/> parameter is the empty string ("").</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>This method works on file names.</para>
			<para>Classes in the <see langword="Reflection.Emit "/> namespace emit the scope name for a dynamic
   module. The scope name can be determined by the <see cref="System.Reflection.Module.ScopeName" qualify="true"/> property. Pass the kind of module you want to
<see langword="Assembly.GetModule"/>. For example, if you want the module that
   contains the assembly manifest, pass the scope name of the module to
<see langword="GetModule"/>. Otherwise, pass the file name of the module.
   Assemblies loaded by one of the <see langword="Load"/> methods that have a byte[]
   parameter have only one module, and that is the manifest module. Always seek
   these modules using the scope name.</para>
			<para>A type can be retrieved from a specific module using <see cref="System.Reflection.Module.GetType" qualify="true"/>. Calling <see langword="Module.GetType "/>on the module containing the manifest will not initiate a search of the
entire assembly. To retrieve a type from an assembly, regardless of which module
it is in, you must call <see cref="System.Reflection.Assembly.GetType" qualify="true"/> .</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.LoadFile">
		<overload>
			<para>Loads the contents of an assembly file.</para>
		</overload>
		<summary>
			<para>Loads the contents of an assembly file on the specified path.</para>
		</summary>
		<param name="path">The path of the file to load.</param>
		<returns>
			<para>The loaded assembly.</para>
		</returns>
		<exception cref="System.ArgumentNullException">The <paramref name="path"/> parameter is <see langword="null"/>.</exception>
		<exception cref="System.IO.FileNotFoundException">The <paramref name="path"/> parameter is the empty string ("") or does not exist.</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true"/>, <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.LoadFile2">
		<summary>
			<para>Loads an assembly given its path, loading the assembly 
      into the domain of the caller using the supplied evidence.</para>
		</summary>
		<param name="path">The path of the assembly file.</param>
		<param name=" securityEvidence">Evidence for loading the assembly.</param>
		<returns>
			<para>The loaded assembly.</para>
		</returns>
		<exception cref="System.ArgumentNullException">The <paramref name="path"/> parameter is <see langword="null"/>.</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<exception cref="System.IO.FileNotFoundException">The <paramref name="path"/> parameter is the empty string ("") or does not exist.</exception>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true"/>, <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.CreateInstance2">
		<summary>
			<para>Locates the specified type from this assembly and creates
      an instance of it using the system activator, with optional case-sensitive search and having the
      specified culture, arguments, and binding and activation attributes.</para>
		</summary>
		<param name="typeName">The <see cref="System.Type.FullName" qualify="true"/> of the type to locate.</param>
		<param name="ignoreCase"><see langword="true"/> to ignore the case of the type name; otherwise, <see langword="false"/> .</param>
		<param name=" bindingAttr">A bitmask that affects the way in which the search is conducted. The value is a combination of bit flags from <see cref="System.Reflection.BindingFlags"/>. </param>
		<param name=" binder">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo"/> objects via reflection. If <paramref name="binder"/> is <see langword="null"/> , the default binder is used.</param>
		<param name=" args">An array of type <see langword="Object"/> containing the arguments to be passed to the constructor. This array of arguments must match in number, order, and type the parameters of the constructor to be invoked. If the default constructor is desired, <paramref name="args"/> must be an empty array or <see langword="null"/> . </param>
		<param name=" culture">An instance of <see langword="CultureInfo"/> used to govern the coercion of types. If this is <see langword="null"/>, the <see langword="CultureInfo"/> for the current thread is used. (This is necessary to convert a <see langword="String"/> that represents 1000 to a <see langword="Double"/> value, for example, since 1000 is represented differently by different cultures.)</param>
		<param name=" activationAttributes"><para>An array of type <see langword="Object"/> containing one or more activation attributes that can participate in the activation. An example of an activation attribute is:</para>
			<para>URLAttribute(http://hostname/appname/objectURI)</para></param>
		<returns>
			<para>An instance of <see langword="Object"/> representing the type and matching the
   specified criteria, or <see langword="null"/> if <paramref name="typeName"/> is not found.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="typeName"/> is the empty string ("") or "\0anything" <para>-or-</para>
			<para>The length of <paramref name="typeName"/> exceeds 1024 characters.</para></exception>
		<exception cref="System.ArgumentNullException"><paramref name="typeName"/> is <see langword="null"/>.</exception>
		<exception cref="System.MissingMethodException">No matching constructor was found.</exception>
		<exception cref="System.NotSupportedException">A non-empty activation attributes array is passed to a type that does not inherit from <see cref="System.MarshalByRefObject"/>.</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to create an instance of a delegate. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.Evidence">
		<summary>
			<para>Gets the
      evidence for this assembly. </para>
		</summary>
		<value>
			<para>An <see langword="Evidence"/>
object for this assembly.</para>
		</value>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>Evidence is the set of information that constitutes input to security policy
      decisions, such as what permissions can be granted to code. </para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
		<seealso cref="System.Security.Policy.Evidence"/>
	</doc>
	<doc for="Assembly.LoadFrom1">
		<summary>
			<para>Loads an assembly given its file
      name or path and supplying security evidence.</para>
		</summary>
		<param name="assemblyFile">The name or path of the file that contains the manifest of the assembly.</param>
		<param name="securityEvidence">Evidence for loading the assembly.</param>
		<returns>
			<para>The loaded assembly.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="assemblyFile"/> is <see langword="null"/>.</exception>
		<exception cref="System.IO.FileNotFoundException"><paramref name="assemblyFile "/>is not found, or the module you are trying to load does not specify a filename extension.</exception>
		<exception cref="System.BadImageFormatException"><paramref name="assemblyFile"/> is not a valid assembly. </exception>
		<exception cref="System.Security.SecurityException">A codebase that does not start with "file://" was specified without the required <see langword="WebPermission"/>.</exception>
		<exception cref="System.IO.PathTooLongException">An assembly or module was loaded twice with two different evidences, or the assembly name is longer than MAX_PATH characters.</exception>
		<exception cref="System.ArgumentException">The <paramref name="assemblyFile"/> parameter is the empty string ("").</exception>
		<remarks>
			<para>The <paramref name="assemblyFile"/> parameter must refer to a URI without escape
   characters. This method supplies escape
   characters for all invalid characters in the URI.</para>
			<para><paramref name="assemblyFile"/> is relative to the current
directory, and the assembly is loaded into the domain of the caller.</para>
			<para>The <see cref="System.Reflection.Assembly.LoadFrom"/> methods use a load context that records the
assembly name and the assembly instance information for the set of assemblies
that is the transitive closure of the assemblies loaded by the application using
<see cref="System.Reflection.Assembly.LoadFrom"/>. The <see cref="System.Reflection.Assembly.LoadFrom"/> load context applies 
to assemblies that are loaded using their locations.</para>
			<para>Whether certain permissions are granted or not granted to an assembly is
   based on evidence. The rules for assembly and security evidence merging are as
   follows: </para>
			<list type="bullet"><item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.LoadFrom"/> method with no <see cref="System.Security.Policy.Evidence"/> parameter, the assembly is loaded with
      the evidence that the loader supplies.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.LoadFrom"/> method with an <see cref="System.Security.Policy.Evidence"/> parameter, pieces of
      evidence are merged. Pieces of evidence supplied as an argument to the <see cref="System.Reflection.Assembly.LoadFrom"/> method supersede pieces of
      evidence supplied by the loader.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.LoadFrom"/> method with a <see langword="Byte[]"/> parameter to load a common object file
      format (COFF) image, evidence is combined. <see langword="Zone"/>,
   <see langword="Url"/> and <see langword="Site"/> are inherited from the calling 
      assembly, and <see langword="Hash"/> and <see langword="StrongName"/> are taken from the COFF assembly.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.LoadFrom"/> method with
      a <see langword="Byte[]"/> parameter and <see cref="System.Security.Policy.Evidence"/> to load a common object
      file format (COFF) image, only the supplied evidence is used. Evidence of
      the calling assembly and evidence of the COFF image is ignored.</term>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.FileIOPermission">for reading a URI that begins with "file://". Associated enumeration: <see cref="System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true"/></permission>
		<permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file://".</permission>
		<seealso cref="System.Security.Policy.Evidence"/>
	</doc>
	<doc for="Assembly.LoadFrom2">
		<summary>
			<para>Loads an assembly given its file name or path, security
      evidence hash value, and hash algorithm.</para>
		</summary>
		<param name="assemblyFile">The name or path of the file that contains the manifest of the assembly.</param>
		<param name="securityEvidence">Evidence for loading the assembly.</param>
		<param name=" hashValue">The value of the computed hash code.</param>
		<param name=" hashAlgorithm">The hash algorithm used for hashing files and for generating the strong name.</param>
		<returns>
			<para>The loaded assembly.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="assemblyFile"/> is <see langword="null"/>.</exception>
		<exception cref="System.IO.FileNotFoundException"><paramref name="assemblyFile "/>is not found, or the module you are trying to load does not specify a filename extension.</exception>
		<exception cref="System.BadImageFormatException"><paramref name="assemblyFile"/> is not a valid assembly. </exception>
		<exception cref="System.Security.SecurityException">A codebase that does not start with "file://" was specified without the required <see langword="WebPermission"/>.</exception>
		<exception cref="System.IO.PathTooLongException">An assembly or module was loaded twice with two different evidences, or the assembly name is longer than MAX_PATH characters.</exception>
		<exception cref="System.ArgumentException">The <paramref name="assemblyFile"/> parameter is the empty string ("").</exception>
		<remarks>
			<para>The <paramref name="assemblyFile"/> parameter must refer to a URI without escape characters. This method
   supplies escape characters for all invalid characters in the URI.</para>
			<para><paramref name="assemblyFile"/> is relative to the current directory, and the assembly is
loaded into the domain of the caller.</para>
			<para>The <see cref="System.Reflection.Assembly.LoadFrom"/> methods use a load context that records the
assembly name and the assembly instance information for the set of assemblies
that is the transitive closure of the assemblies loaded by the application using
<see cref="System.Reflection.Assembly.LoadFrom"/>. The <see cref="System.Reflection.Assembly.LoadFrom"/> load context applies 
to assemblies that are loaded using their locations.</para>
			<para>Whether certain permissions are granted or not granted to an assembly is
   based on evidence. The rules for assembly and security evidence merging are as
   follows: </para>
			<list type="bullet"><item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.LoadFrom"/> method with no <see cref="System.Security.Policy.Evidence"/> parameter, the assembly is loaded with
      the evidence that the loader supplies.</term>
				</item>
				<item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.LoadFrom"/> method with an <see cref="System.Security.Policy.Evidence"/> parameter, pieces of
      evidence are merged. Pieces of evidence supplied as an argument to the <see cref="System.Reflection.Assembly.LoadFrom"/> method supersede pieces of
      evidence supplied by the loader.</term>
				</item>
				<item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.LoadFrom"/> method with a <see langword="Byte[]"/> parameter to load a common object file
      format (COFF) image, evidence is combined. <see langword="Zone"/>,
   <see langword="Url"/> and <see langword="Site"/> are inherited from the calling 
      assembly, and <see langword="Hash"/> and <see langword="StrongName"/> are taken from the COFF assembly.</term>
				</item>
				<item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.LoadFrom"/> method with
      a <see langword="Byte[]"/> parameter and <see cref="System.Security.Policy.Evidence"/> to load a common
      object file format (COFF) image, only the supplied evidence is used. Evidence
      of the calling assembly and evidence of the COFF image is ignored.</term>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.FileIOPermission">for reading a URI that begins with "file://". Associated enumeration: <see cref="System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true"/></permission>
		<permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file://".</permission>
	</doc>
	<doc for="Assembly.Load">
		<overload>
			<para>Loads an assembly.</para>
		</overload>
		<summary>
			<para> Loads an assembly given
      the long form of its name.</para>
		</summary>
		<param name="assemblyString">The long form of the assembly name.</param>
		<returns>
			<para>The
      loaded assembly.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="assemblyString"/> is <see langword="null"/>.</exception>
		<exception cref="System.IO.FileNotFoundException"><paramref name="assemblyString"/> is not found.</exception>
		<exception cref="System.BadImageFormatException"><paramref name="assemblyFile"/> is not a valid assembly. </exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>The <see cref="System.Reflection.Assembly.Load"/> methods use the default load context, which records
   the assembly name and assembly instance information for the set of assemblies
   that is the transitive closure of the assemblies referenced by a managed
   application. The default load context applies to assemblies that are
   loaded with a <see langword="Load"/> method and that use a fully
   qualified assembly reference.</para>
			<para>Whether certain permissions are granted or not granted to an assembly is
   based on evidence. The rules for assembly and security evidence merging are as
   follows: </para>
			<list type="bullet"><item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with no <see cref="System.Security.Policy.Evidence"/> parameter, the assembly is loaded with
      the evidence that the loader supplies.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with an <see cref="System.Security.Policy.Evidence"/> parameter, pieces of
      evidence are merged. Pieces of evidence supplied as an argument to the <see cref="System.Reflection.Assembly.Load"/> method supersede pieces of
      evidence supplied by the loader.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with a <see langword="Byte[]"/> parameter to load a common object file
      format (COFF) image, evidence is combined. <see langword="Zone"/>,
   <see langword="Url"/> and <see langword="Site"/> are inherited from the calling 
      assembly, and <see langword="Hash"/> and <see langword="StrongName"/> are taken from the COFF assembly.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with
      a <see langword="Byte[]"/> parameter and <see cref="System.Security.Policy.Evidence"/> to load a common object
      file format (COFF) image, only the supplied evidence is used. Evidence of
      the calling assembly and evidence of the COFF image is ignored.</term>
				</item>
			</list>
			<para>Reflecting on Managed Extensions for C++ executable files might throw a <see cref="System.BadImageFormatException"/>. This is most
likely caused by C++ compiler stripping the relocation addresses or the .Reloc
section from your executable file. To preserve the .reloc address for your C++
executable file, specify <see langword="/fixed:no"/> when you are
linking.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true"/>, <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/>.</permission>
		<permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file://".</permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
		<example>
			<para> The
      following example loads an assembly given its fully qualified name, and
      lists all the types contained in the specified assembly. For this code example to run, you must provide
      the fully qualified assembly name. For information about how to obtain the fully
      qualified assembly name, see <see topic="cpconassemblynames"/>.</para>
			<codelink SampleID="assembly.load1" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.AssemblyName"/>
		<seealso cref="System.Reflection.Assembly.LoadFrom"/>
	</doc>
	<doc for="Assembly.Load1">
		<summary>
			<para> Loads an assembly given its display name, loading the
      assembly into the domain of the caller using the supplied evidence.</para>
		</summary>
		<param name="assemblyString">The display name of the assembly.</param>
		<param name="assemblySecurity">Evidence for loading the assembly.</param>
		<returns>
			<para>The
      loaded assembly.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="assemblyString"/> is <see langword="null"/>.</exception>
		<exception cref="System.IO.FileNotFoundException"><paramref name="assemblyString"/> is not found.</exception>
		<exception cref="System.BadImageFormatException"><paramref name="assemblyFile"/> is not a valid assembly. </exception>
		<exception cref="System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>The <see cref="System.Reflection.Assembly.Load"/> methods use the default load context, which records
   the assembly name and assembly instance information for the set of assemblies
   that is the transitive closure of the assemblies referenced by a managed
   application. The default load context applies to assemblies that are
   loaded with a <see cref="System.Reflection.Assembly.Load"/> method and that use a fully
   qualified assembly reference.</para>
			<para>Whether certain permissions are granted or not granted to an assembly is
   based on evidence. The rules for assembly and security evidence merging are as
   follows: </para>
			<list type="bullet"><item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with no <see cref="System.Security.Policy.Evidence"/> parameter, the assembly is loaded with
      the evidence that the loader supplies.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with an <see cref="System.Security.Policy.Evidence"/> parameter, pieces of evidence are merged. Pieces of
      evidence supplied as an argument to the <see cref="System.Reflection.Assembly.Load"/> method supersede pieces of
      evidence supplied by the loader.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with a <see langword="Byte[]"/> parameter to load a common object file
      format (COFF) image, evidence is combined. <see langword="Zone"/>,
   <see langword="Url"/> and <see langword="Site"/> are inherited from the calling 
      assembly, and <see langword="Hash"/> and <see langword="StrongName"/> are taken from the COFF assembly.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with
      a <see langword="Byte[]"/> parameter and <see cref="System.Security.Policy.Evidence"/> to load a common object
      file format (COFF) image, only the supplied evidence is used. Evidence of
      the calling assembly and evidence of the COFF image is ignored.</term>
				</item>
			</list>
			<para>Reflecting on Managed Extensions for C++ executable files might throw a <see cref="System.BadImageFormatException"/>. This is most
likely caused by C++ compiler stripping the relocation addresses or the .Reloc
section from your executable file. To preserve the .reloc address for your C++
executable file, specify <see langword="/fixed:no"/>
when you are linking.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true"/>, <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/>.</permission>
		<permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file://".</permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
		<seealso cref="System.Security.Policy.Evidence"/>
	</doc>
	<doc for="Assembly.Load2">
		<summary>
			<para>Loads
      an assembly given its <see cref="System.Reflection.AssemblyName"/> .</para>
		</summary>
		<param name="assemblyRef">The <see cref="System.Reflection.AssemblyName"/> object that describes the assembly to be loaded.</param>
		<returns>
			<para>The loaded assembly.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="assemblyRef"/> is <see langword="null"/>.</exception>
		<exception cref="System.IO.FileNotFoundException"><paramref name="assemblyRef"/> is not found.</exception>
		<exception cref="System.BadImageFormatException"><paramref name="assemblyFile"/> is not a valid assembly. </exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>The <see cref="System.Reflection.Assembly.Load"/> methods use the default load context, which records the assembly name and assembly instance information for the set of assemblies that is the transitive closure of the assemblies referenced by a managed application. The default load context applies to assemblies that are loaded with a <see langword="Load"/> method and that use a fully qualified assembly reference.</para>
			<para>Whether certain permissions are granted or not granted to an assembly is based on evidence. The rules for assembly and security evidence merging are as follows: </para>
			<list type="bullet"><item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with no <see cref="System.Security.Policy.Evidence"/> parameter, the assembly is loaded with
      the evidence that the loader supplies.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with an <see cref="System.Security.Policy.Evidence"/> parameter, pieces of
      evidence are merged. Pieces of evidence supplied as an argument to the <see cref="System.Reflection.Assembly.Load"/> method supersede pieces of
      evidence supplied by the loader.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with a <see langword="Byte[]"/> parameter to load a common object file
      format (COFF) image, evidence is combined. <see langword="Zone"/>,
   <see langword="Url"/> and <see langword="Site"/> are inherited from the calling 
      assembly, and <see langword="Hash"/> and <see langword="StrongName"/> are taken from the COFF assembly.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with
      a <see langword="Byte[]"/> parameter and <see cref="System.Security.Policy.Evidence"/> to load a common object
      file format (COFF) image, only the supplied evidence is used. Evidence of
      the calling assembly and evidence of the COFF image is ignored.</term>
				</item>
			</list>
			<para>Reflecting on Managed Extensions for C++ executable files might throw a <see cref="System.BadImageFormatException"/>. This is most likely caused by C++ compiler stripping the relocation addresses or the .Reloc section from your executable file. To preserve the .reloc address for your C++ executable file, specify <see langword="/fixed:no"/> when you are linking.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true"/>, <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/>.</permission>
		<permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file://".</permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
		<seealso cref="System.Reflection.AssemblyName"/>
	</doc>
	<doc for="Assembly.Load4">
		<summary>
			<para>Loads the assembly with
      a Common Object File Format (COFF)-based image containing an emitted assembly. The
      assembly is loaded into the domain of the caller.</para>
		</summary>
		<param name="rawAssembly">An array of type <see langword="byte"/> that is a COFF-based image containing an emitted assembly.</param>
		<returns>
			<para>The
      loaded
      assembly.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="rawAssembly"/> is <see langword="null"/> .</exception>
		<exception cref="System.BadImageFormatException"><paramref name="rawAssembly"/> is not a valid assembly. </exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>The <see cref="System.Reflection.Assembly.Load"/> methods use the default load context, which records the assembly name and assembly instance information for the set of assemblies that is the transitive closure of the assemblies referenced by a managed application. The default load context applies to assemblies that are loaded with a <see langword="Load"/> method and that use a fully qualified assembly reference.</para>
			<para>Whether certain permissions are granted or not granted to an assembly is based on evidence. The rules for assembly and security evidence merging are as follows: </para>
			<list type="bullet"><item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with no <see cref="System.Security.Policy.Evidence"/> parameter, the assembly is loaded with
      the evidence that the loader supplies.</term>
				</item>
				<item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with an <see cref="System.Security.Policy.Evidence"/> parameter, pieces of
      evidence are merged. Pieces of evidence supplied as an argument to the <see cref="System.Reflection.Assembly.Load"/> method supersede pieces of
      evidence supplied by the loader.</term>
				</item>
				<item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with a <see langword="Byte[]"/> parameter to load a common object file
      format (COFF) image, evidence is combined. <see langword="Zone"/>,
   <see langword="Url"/> and <see langword="Site"/> are inherited from the calling 
      assembly, and <see langword="Hash"/> and <see langword="StrongName"/> are taken from the COFF assembly.</term>
				</item>
				<item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with
      a <see langword="Byte[]"/> parameter and <see cref="System.Security.Policy.Evidence"/> to load a common object
      file format (COFF) image, only the supplied evidence is used. Evidence of
      the calling assembly and evidence of the COFF image is ignored.</term>
				</item>
			</list>
			<para>Reflecting on Managed Extensions for C++ executable files might throw a <see cref="System.BadImageFormatException"/>. This is most likely caused by C++ compiler stripping the relocation addresses or the .Reloc section from your executable file. To preserve the .reloc address for your C++ executable file, specify <see langword="/fixed:no"/> when you are linking.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true"/>, <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/>.</permission>
		<permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file://".</permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
		<seealso cref="System.Reflection.AssemblyName"/>
	</doc>
	<doc for="Assembly.Load5">
		<summary>
			<para> Loads the assembly with a Common Object
      File Format (COFF)-based image containing an emitted assembly.</para>
		</summary>
		<param name="rawAssembly">An array of type <see langword="byte"/> that is a COFF-based image containing an emitted assembly.</param>
		<param name="rawSymbolStore">An array of type <see langword="byte"/> containing the raw bytes representing the symbols for the assembly.</param>
		<returns>
			<para>The
      loaded assembly.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="rawAssembly"/> is <see langword="null"/> .</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<exception cref="System.BadImageFormatException"><paramref name="assemblyFile"/> is not a valid assembly. </exception>
		<remarks>
			<para>The assembly is loaded into the domain of the caller, and
      the raw bytes
      representing the symbols for the assembly are also loaded.</para>
			<para>The <see cref="System.Reflection.Assembly.Load"/> methods use the default load context, which records
   the assembly name and assembly instance information for the set of assemblies
   that is the transitive closure of the assemblies referenced by a managed
   application. The default load context applies to assemblies that are
   loaded with a <see langword="Load"/> method and that use a fully
   qualified assembly reference.</para>
			<para>Whether certain permissions are granted or not granted to an assembly is
   based on evidence. The rules for assembly and security evidence merging are as
   follows: </para>
			<list type="bullet"><item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with no <see cref="System.Security.Policy.Evidence"/> parameter, the assembly is loaded with
      the evidence that the loader supplies.</term>
				</item>
				<item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with an <see cref="System.Security.Policy.Evidence"/> parameter, pieces of
      evidence are merged. Pieces of evidence supplied as an argument to the <see cref="System.Reflection.Assembly.Load"/> method supersede pieces of
      evidence supplied by the loader.</term>
				</item>
				<item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with a <see langword="Byte[]"/> parameter to load a common object file
      format (COFF) image, evidence is combined. <see langword="Zone"/>,
   <see langword="Url"/> and <see langword="Site"/> are inherited from the calling 
      assembly, and <see langword="Hash"/> and <see langword="StrongName"/> are taken from the COFF assembly.</term>
				</item>
				<item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with
      a <see langword="Byte[]"/> parameter and <see cref="System.Security.Policy.Evidence"/> to load a common object
      file format (COFF) image, only the supplied evidence is used. Evidence of
      the calling assembly and evidence of the COFF image is ignored.</term>
				</item>
			</list>
			<para>Reflecting on Managed Extensions for C++ executable files might throw a
<see cref="System.BadImageFormatException"/>. This is most likely caused by C++ compiler stripping 
   the relocation addresses or the .Reloc section from your executable file. To
   preserve the .reloc address for your C++ executable file, specify
<see langword="/fixed:no"/> when you are linking.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true"/>, <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/>.</permission>
		<permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file://".</permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.Load6">
		<summary>
			<para>Loads the assembly with a Common Object File Format
      (COFF)-based image containing an emitted assembly.</para>
		</summary>
		<param name="rawAssembly">An array of type <see langword="byte"/> that is a COFF-based image containing an emitted assembly. </param>
		<param name="rawSymbolStore">An array of type <see langword="byte"/> containing the raw bytes representing the symbols for the assembly. </param>
		<param name="securityEvidence">Evidence for loading the assembly.</param>
		<returns>
			<para>The
      loaded assembly.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="rawAssembly"/> is <see langword="null"/> .</exception>
		<exception cref="System.BadImageFormatException"><paramref name="assemblyFile"/> is not a valid assembly. </exception>
		<exception cref="System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>The assembly is loaded into the domain of the caller
      using the supplied evidence. The raw bytes
      representing the symbols for the assembly are also loaded.</para>
			<para>The <see cref="System.Reflection.Assembly.Load"/> methods use the default load context, which records
   the assembly name and assembly instance information for the set of assemblies
   that is the transitive closure of the assemblies referenced by a managed
   application. The default load context applies to assemblies that are loaded with
   a <see langword="Load"/> method and that use a fully qualified assembly
   reference.</para>
			<para>Whether certain permissions are granted or not granted to an assembly is
   based on evidence. The rules for assembly and security evidence merging are as
   follows: </para>
			<list type="bullet"><item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with no <see cref="System.Security.Policy.Evidence"/> parameter, the assembly is loaded with
      the evidence that the loader supplies.</term>
				</item>
				<item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with an <see cref="System.Security.Policy.Evidence"/> parameter, pieces of
      evidence are merged. Pieces of evidence supplied as an argument to the <see cref="System.Reflection.Assembly.Load"/> method supersede pieces of
      evidence supplied by the loader.</term>
				</item>
				<item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with a <see langword="Byte[]"/> parameter to load a common object file
      format (COFF) image, evidence is combined. <see langword="Zone"/>,
   <see langword="Url"/> and <see langword="Site"/> are inherited from the calling 
      assembly, and <see langword="Hash"/> and <see langword="StrongName"/> are taken from the COFF assembly.</term>
				</item>
				<item>
					<term>
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with
      a <see langword="Byte[]"/> parameter and <see cref="System.Security.Policy.Evidence"/> to load a common object
      file format (COFF) image, only the supplied evidence is used. Evidence of
      the calling assembly and evidence of the COFF image is ignored.</term>
				</item>
			</list>
			<para>Reflecting on Managed Extensions for C++ executable files might throw a
<see cref="System.BadImageFormatException"/>. This is most likely caused by C++ compiler stripping 
   the relocation addresses or the .Reloc section from your executable file. To
   preserve the .reloc address for your C++ executable file, specify
<see langword="/fixed:no"/> when you are 
   linking.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true"/>, <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/>.</permission>
		<permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file://".</permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
	</doc>
	<doc for="Assembly.LoadWithPartialName">
		<overload>
			<para>Loads an assembly from the application directory or from
      the global assembly cache using a partial name.</para>
		</overload>
		<summary>
			<para>Loads an assembly from the application directory or from
      the global assembly cache using a partial name.</para>
		</summary>
		<param name="partialName">The partial name of the assembly.</param>
		<returns>
			<para>The loaded assembly. If <paramref name="partialName"/> is not found, this
   method returns <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<exception cref="System.NullReferenceException">The <paramref name="partialName"/> parameter is <see langword="null"/>.</exception>
		<remarks>
			<para>Applications that load assemblies with this method will be impacted by
      upgrades of those assemblies. Therefore, do not use this method unless
      necessary, and even then, consider redesigning the application to use <see cref="System.Reflection.Assembly.Load"/>
      or <see cref="System.Reflection.Assembly.LoadFrom"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true"/>, <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/>.</permission>
		<permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file://".</permission>
		<permission cref="System.Security.Permissions.SecurityPermission">for calling unmanaged code and to load an assembly with evidence. Associated enumerations: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/> , <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
		<seealso cref="System.Reflection.Assembly.Load"/>
		<seealso cref="System.Reflection.Assembly.LoadFrom"/>
	</doc>
	<doc for="Assembly.LoadWithPartialName1">
		<summary>
			<para>Loads an assembly from the application directory or from
      the global assembly cache using a partial name. The assembly is loaded into the domain of the caller using the
      supplied evidence.</para>
		</summary>
		<param name="partialName">The partial name of the assembly.</param>
		<param name="securityEvidence"><see cref="System.Security.Policy.Evidence"/>for loading the assembly.</param>
		<returns>
			<para>The loaded assembly. If <paramref name="partialName"/> is not found, this method returns <see langword="null"/>.</para>
		</returns>
		<exception cref="System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<exception cref="System.NullReferenceException">The <paramref name="partialName"/> parameter is <see langword="null"/>.</exception>
		<remarks>
			<para>Evidence is the set of information that constitutes input to security policy
      decisions, such as what permissions can be granted to code.</para>
			<para>Applications that load assemblies with this method will be impacted
      by upgrades of those assemblies. Therefore, do not use this method unless
      necessary, and even then, consider redesigning the application to use <see cref="System.Reflection.Assembly.Load"/>
      or <see cref="System.Reflection.Assembly.LoadFrom"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true"/>, <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/>.</permission>
		<permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file://".</permission>
		<permission cref="System.Security.Permissions.SecurityPermission">for calling unmanaged code and to load an assembly with evidence. Associated enumerations: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>, <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
		<seealso cref="System.Reflection.Assembly.Load"/>
		<seealso cref="System.Reflection.Assembly.LoadFrom"/>
	</doc>
	<doc for="Assembly.Load3">
		<summary>
			<para> Loads an assembly given its <see cref="System.Reflection.AssemblyName"/> . The
   assembly is loaded into the domain of the caller using the supplied evidence.</para>
		</summary>
		<param name="assemblyRef">The <see cref="System.Reflection.AssemblyName"/> object that describes the assembly to be loaded.</param>
		<param name="assemblySecurity">Evidence for loading the assembly.</param>
		<returns>
			<para>The
      loaded assembly.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="assemblyRef"/> is <see langword="null"/>.</exception>
		<exception cref="System.IO.FileNotFoundException"><paramref name="assemblyRef"/> is not found.</exception>
		<exception cref="System.BadImageFormatException"><paramref name="assemblyFile"/> is not a valid assembly. </exception>
		<exception cref="System.IO.FileLoadException">An assembly or module was loaded twice with two different evidences.</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>The <see cref="System.Reflection.Assembly.Load"/> methods use the default load context, which records the assembly name and assembly instance information for the set of assemblies that is the transitive closure of the assemblies referenced by a managed application. The default load context applies to assemblies that are loaded with a <see langword="Load"/> method and that use a fully qualified assembly reference.</para>
			<para>Whether certain permissions are granted or not granted to an assembly is based on evidence. The rules for assembly and security evidence merging are as follows: </para>
			<list type="bullet"><item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with no <see cref="System.Security.Policy.Evidence"/> parameter, the assembly is loaded with
      the evidence that the loader supplies.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with an <see cref="System.Security.Policy.Evidence"/> parameter, pieces of
      evidence are merged. Pieces of evidence supplied as an argument to the <see cref="System.Reflection.Assembly.Load"/> method supersede pieces of
      evidence supplied by the loader.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with a <see langword="Byte[]"/> parameter to load a common object file
      format (COFF) image, evidence is combined. <see langword="Zone"/>,
   <see langword="Url"/> and <see langword="Site"/> are inherited from the calling
      assembly, and <see langword="Hash"/> and <see langword="StrongName"/> are taken from the COFF assembly.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.Load"/> method with
      a <see langword="Byte[]"/> parameter and <see cref="System.Security.Policy.Evidence"/> to load a common object
      file format (COFF) image, only the supplied evidence is used. Evidence of
      the calling assembly and evidence of the COFF image is ignored.</term>
				</item>
			</list>
			<para>Reflecting on Managed Extensions for C++ executable files might throw a <see cref="System.BadImageFormatException"/>. This is most likely caused by C++ compiler stripping the relocation addresses or the .Reloc section from your executable file. To preserve the .reloc address for your C++ executable file, specify <see langword="/fixed:no"/> when you are linking.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to read from a file or directory, and for access to the information in the path itself. Associated enumerations: <see cref="System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true"/>, <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/>.</permission>
		<permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file://".</permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to load an assembly with evidence. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>.</permission>
		<seealso cref="System.Security.Policy.Evidence"/>
	</doc>
	<doc for="ModuleResolveEventHandler">
		<summary>
			<para>Represents the method that will handle the <see cref="System.Reflection.Assembly.ModuleResolve"/>
event of an <see cref="System.Reflection.Assembly"/>.</para>
		</summary>
		<param name="sender">The assembly that was the source of the event.</param>
		<param name="e">The arguments supplied by the object describing the event.</param>
		<remarks>
			<para>When you create an <see cref="System.Reflection.Assembly"/> delegate, you identify the
   method that will handle the event. To associate the event with your event
   handler, add an instance of the delegate to the event. The event handler is
   called whenever the event occurs, unless you remove the delegate. For more
   information about event handler delegates, see <see topic="cpconEventsDelegates"/>
   .</para>
			<para>If the common language runtime class loader cannot resolve a reference to an
   internal module of an assembly through normal means, the event is raised to give
   the callback a chance to find or load the module itself and return it.</para>
			<para>Each derived class of <see cref="System.Delegate"/> and <see cref="System.MulticastDelegate"/> has a constructor and an
<see langword="Invoke"/>
method. See the Managed Extensions for C++ code example given in the
description for the <see cref="System.Delegate"/>.</para>
		</remarks>
		<example>
			<para> The following example demonstrates the sequence 
      of execution in which an event handler is called. In this example, Server1 is an external module
      of the MySample class.</para>
			<para> Compile and run
      this example as follows.</para>
			<list type="number"><item>
					<term>
         Compile Server1.</term>
				</item>
				<item>
					<term>
         Compile MySample.</term>
				</item>
				<item>
					<term>
         Run MySample.
         Note that the module file Server1.netmodule must be in a subfolder
         named "subfolder" for this to work.</term>
				</item>
			</list>
			<para> 
   Compile Server1 as follows:</para>
			<para><c>csc 
   /out:subfolder\Server1.netmodule /t:module Server1.cs</c></para>
			<code lang="C#">using System;
using System.Reflection;
public class Server1 : MarshalByRefObject 
{
    public int trivial()
    {
        Console.WriteLine ("server1.trivial");
        return 1;
    }
}
</code>
			<para> 
   Compile MySample as follows:</para>
			<para><c>csc /out:MySample.exe /t:exe 
   /addmodule:subfolder\Server1.netmodule MySample.cs</c></para>
			<code lang="C#">using System;
using System.IO;
using System.Reflection;

class MySample
{
    public static int Main(String[] args)
    {
        Assembly asm1 = Assembly.GetExecutingAssembly();
        asm1.ModuleResolve += new ModuleResolveEventHandler (evModuleResolve);
        Console.WriteLine("Calling MySample.Test");
        Test();
        return 0;
    }

    private static Module evModuleResolve(object sender, ResolveEventArgs e)
    {
        Console.WriteLine("MySample.evModuleResolve");
        FileStream fs = File.Open(".\\subfolder\\server1.netmodule", FileMode.Open);
        byte [] rgFileBytes = new byte [1];
        long len = fs.Length;
        rgFileBytes = new byte[len];
        fs.Read(rgFileBytes, 0, (int)len);

        Assembly a = Assembly.GetExecutingAssembly();
        Module m = a.LoadModule("server1.netmodule", rgFileBytes);
        
        return m;
    }

    private static void Test()
    {
        Console.WriteLine("Instantiating Server1");
        Server1 s = new Server1();
        Console.WriteLine("Calling Server1.trivial");
        s.trivial();
    }    
}
</code>
		</example>
	</doc>
	<doc for="Assembly.CodeBase">
		<summary>
			<para>Gets the location of the assembly as specified originally, for example, in an
   <see cref="System.Reflection.AssemblyName"/> object. </para>
		</summary>
		<value>
			<para>The location of the assembly as specified originally. </para>
		</value>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>To get the absolute path to the loaded manifest-containing file, use the
   <see cref="System.Reflection.Assembly.Location" qualify="true"/> property instead.</para>
			<para>If the assembly was loaded as a byte array, this property returns the location of the
      caller of the <see cref="System.Reflection.Assembly.Load"/> method, not the assembly.</para>
		</remarks>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to the path. Associated enumeration: <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/>. </permission>
		<example>
			<para>The following example shows an expression that uses the
   <see langword="CodeBase "/>property.</para>
			<codelink SampleID="System.Reflection.Assembly" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Assembly.FullName">
		<summary>
			<para>Gets the display name of the assembly. </para>
		</summary>
		<value>
			<para>The display name of the assembly.</para>
		</value>
		<remarks>
			<para>See <see cref="System.Reflection.AssemblyName"/> for a
   description of the format of the display name of an assembly.</para>
		</remarks>
		<example>
			<para>The following example retrieves the full name of an assembly.</para>
			<codelink SampleID="System.Reflection.Assembly" SnippetID="2"/>
		</example>
		<seealso topic="cpconSpecifyingFullyQualifiedTypeNames"/>
	</doc>
	<doc for="Assembly.GetAssembly">
		<summary>
			<para>Gets the assembly in
      which the specified class is defined.</para>
		</summary>
		<param name="type">A <see cref="System.Type"/> object representing a class in the assembly that will be returned.</param>
		<returns>
			<para>The assembly in which the specified class
      is defined.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="type"/> is <see langword="null"/> .</exception>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example retrieves the assembly of a specified class.</para>
			<codelink SampleID="System.Reflection.Assembly" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Assembly.GetTypes">
		<summary>
			<para>Gets
      the types defined in this assembly.</para>
		</summary>
		<returns>
			<para>An array of type
   <see cref="System.Type"/> containing
      objects for all the types defined in this assembly.</para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting methods that are not public. Associated enumerations: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/> , <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example displays the types in the 
      specified assembly. </para>
			<codelink SampleID="System.Reflection.Assembly" SnippetID="11"/>
		</example>
	</doc>
	<doc for="Assembly.LoadFrom">
		<overload>
			<para>Loads an assembly.</para>
		</overload>
		<summary>
			<para>Loads an assembly given
      its file name or path.</para>
		</summary>
		<param name="assemblyFile">The name or path of the file that contains the manifest of the assembly.</param>
		<returns>
			<para>The loaded assembly.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="assemblyFile"/> is <see langword="null"/>.</exception>
		<exception cref="System.IO.FileNotFoundException"><paramref name="assemblyFile "/>is not found, or the module you are trying to load does not specify a filename extension.</exception>
		<exception cref="System.BadImageFormatException"><paramref name="assemblyFile"/> is not a valid assembly. </exception>
		<exception cref="System.Security.SecurityException">A codebase that does not start with "file://" was specified without the required WebPermission.</exception>
		<exception cref="System.IO.PathTooLongException">An assembly or module was loaded twice with two different evidences, or the assembly name is longer than MAX_PATH characters.</exception>
		<exception cref="System.ArgumentException">The <paramref name="assemblyFile"/> parameter is the empty string ("").</exception>
		<remarks>
			<para>The <paramref name="assemblyFile"/> parameter must refer to a URI without escape
   characters. This method supplies escape characters for all invalid characters in
   the URI.</para>
			<para><paramref name="assemblyFile"/> is relative to the current
directory, and the assembly
is loaded into the domain of the caller.</para>
			<para>The <see cref="System.Reflection.Assembly.LoadFrom"/> methods use a load context
that records the assembly name and the assembly instance information for the set
of assemblies that is the transitive closure of the assemblies loaded by the
application using <see cref="System.Reflection.Assembly.LoadFrom"/>. The <see cref="System.Reflection.Assembly.LoadFrom"/> load context applies to assemblies that
are loaded using their locations.</para>
			<para>Whether certain permissions are granted or not granted to an assembly is
   based on evidence. The rules for assembly and security evidence merging are as
   follows: </para>
			<list type="bullet"><item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.LoadFrom"/> method with no <see cref="System.Security.Policy.Evidence"/> parameter, the assembly is loaded with
      the evidence that the loader supplies.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.LoadFrom"/> method with an <see cref="System.Security.Policy.Evidence"/> parameter, pieces of
      evidence are merged. Pieces of evidence supplied as an argument to the <see cref="System.Reflection.Assembly.LoadFrom"/> method supersede pieces of
      evidence supplied by the loader.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.LoadFrom"/> method with a <see langword="Byte[]"/> parameter to load a common object file
      format (COFF) image, evidence is combined. <see langword="Zone"/>,
   <see langword="Url"/> and <see langword="Site"/> are inherited from the calling
      assembly, and <see langword="Hash"/> and <see langword="StrongName"/> are taken from the COFF assembly.</term>
				</item>
				<item>
					<term>
      
      When you use a <see cref="System.Reflection.Assembly.LoadFrom"/> method with
      a <see langword="Byte[]"/> parameter and <see cref="System.Security.Policy.Evidence"/> to load a common object
      file format (COFF) image, only the supplied evidence is used. Evidence of
      the calling assembly and evidence of the COFF image is ignored.</term>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.FileIOPermission">for reading a URI that begins with "file://". Associated enumeration: <see cref="System.Security.Permissions.FileIOPermissionAccess.Read" qualify="true"/></permission>
		<permission cref="T:System.Net.WebPermission">for reading a URI that does not begin with "file://".</permission>
		<example>
			<para>The following example loads an assembly given its file name or path.</para>
			<codelink SampleID="System.Reflection.Assembly" SnippetID="11"/>
		</example>
	</doc>
	<doc for="Assembly.GetModules">
		<overload>
			<para>Gets all the modules that are part of this assembly.</para>
		</overload>
		<summary>
			<para>Gets all the
      modules that are part of this assembly.</para>
		</summary>
		<returns>
			<para>An array of
      modules.</para>
		</returns>
		<exception cref="System.IO.FileNotFoundException">The module to be loaded does not specify a file name extension.</exception>
		<remarks>
			<para>A type can be retrieved from a specific module using <see cref="System.Reflection.Module.GetType" qualify="true"/>. Calling <see langword="Module.GetType "/>on the module containing the manifest will not initiate a search of the
   entire assembly. To retrieve a type from an assembly, regardless of which module
   it is in, you must call <see cref="System.Reflection.Assembly.GetType" qualify="true"/> .</para>
			<note type="note">
   
   Modules must
   be emitted with file name
   extensions.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para> The following example displays the name of the module in
      the returned array that contains the assembly manifest.</para>
			<codelink SampleID="Classic Assembly.GetModules Example" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Assembly.GetExecutingAssembly">
		<summary>
			<para> Gets the <see cref="System.Reflection.Assembly"/>
that the current code is running from.</para>
		</summary>
		<returns>
			<para> The assembly that the
      current code is running from.
      </para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example gets the assembly of the currently running code.</para>
			<codelink SampleID="System.Reflection.Assembly" SnippetID="5"/>
		</example>
	</doc>
	<doc for="Assembly.GetCallingAssembly">
		<summary>
			<para> Returns the <see cref="System.Reflection.Assembly"/> of the method that invoked the currently executing method.</para>
		</summary>
		<returns>
			<para> The <see langword="Assembly"/>
object of the method that invoked the currently executing
method.</para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example gets the calling assembly of the current method.</para>
			<codelink SampleID="System.Reflection.Assembly" SnippetID="4"/>
		</example>
	</doc>
	<doc for="Assembly.Location">
		<summary>
			<para>Gets the location, in codebase format, of the loaded
      file that contains the manifest if not shadow-copied.</para>
		</summary>
		<value>
			<para>The location of the loaded file that contains the manifest.
      If the loaded file was shadow-copied, the <see langword="Location"/> is that of the file before being
      shadow-copied. If the assembly is loaded from a byte array, such as when using
      the <see topic="frlrfSystemReflectionAssemblyClassLoadTopic2" title="Load(Byte[])"/> method,
   <see langword="Location"/>
   is an empty string ("").</para>
		</value>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<permission cref="System.Security.Permissions.FileIOPermission">for access to the path. Associated enumeration: <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/>. </permission>
		<example>
			<para>The following example displays the location of the loaded file that contains 
      the manifest.</para>
			<codelink SampleID="System.Reflection.Assembly" SnippetID="3"/>
		</example>
	</doc>
	<doc for="Assembly.ImageRuntimeVersion">
		<summary>
			<para>Gets the version of the common language runtime
      (CLR) saved in the file containing the manifest.</para>
		</summary>
		<value>
			<para>A string representing the CLR version.</para>
		</value>
		<remarks>
			<para>Some .NET Framework version 1.0 common language runtime DLLs have
      incorrect versions such as v1.x86ret and "retail."</para>
		</remarks>
	</doc>
	<doc for="Assembly">
		<summary>
			<para>Defines an <see cref="System.Reflection.Assembly"/>
, which is a reusable, versionable, and self-describing building block
of a common language runtime application.</para>
		</summary>
		<threadsafe>
			<para>This type is safe for multithreaded operations.</para>
		</threadsafe>
		<remarks>
			<para>Assemblies provide the infrastructure that allows the runtime to
      fully understand the contents of an application and to enforce the versioning
      and dependency rules defined by the application. These concepts are crucial for
      solving the versioning problem and for simplifying the deployment
      of runtime applications.</para>
		</remarks>
		<example>
			<codelink SampleID="loadinvoke" SnippetID="1"/>
			<codelink SampleID="myassembly" SnippetID="1"/>
		</example>
	</doc>
</docs>
