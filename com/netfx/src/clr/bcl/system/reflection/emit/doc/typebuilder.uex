<docs>
	<doc for="PackingSize.Unspecified">
		<summary>
    The packing size is not specified.
 </summary>
	</doc>
	<doc for="PackingSize.Size1">
		<summary>
			<para>
       The packing size is 1 byte.
    </para>
		</summary>
	</doc>
	<doc for="PackingSize.Size2">
		<summary>
			<para>
       The packing size is 2 bytes.
    </para>
		</summary>
	</doc>
	<doc for="PackingSize.Size4">
		<summary>
    The packing size is 4 bytes.
 </summary>
	</doc>
	<doc for="PackingSize.Size8">
		<summary>
    The packing size is 8 bytes.
 </summary>
	</doc>
	<doc for="PackingSize.Size16">
		<summary>
    The packing size is 16 bytes.
 </summary>
	</doc>
	<doc for="TypeBuilder.UnspecifiedTypeSize">
		<summary>
			<para>
       Represents that total size for the type is not specified.
    </para>
		</summary>
	</doc>
	<doc for="TypeBuilder.Size">
		<summary>
			<para>
       Retrieves the total size of a type.
    </para>
		</summary>
		<value>
			<para>
       Read-only. Retrieves this typeâ€™s total size.
    </para>
		</value>
	</doc>
	<doc for="TypeBuilder.PackingSize">
		<summary>
			<para>
       Retrieves the packing size of this type.
    </para>
		</summary>
		<value>
			<para>
       Read-only. Retrieves the packing size of this type.
    </para>
		</value>
	</doc>
	<doc for="TypeBuilder.ReflectedType">
		<summary>
    Returns the type that was used to obtain
    this type.
 </summary>
		<value>
    Read-only. The type that was used to
    obtain this type.
 </value>
	</doc>
	<doc for="TypeBuilder.VerifyTypeAttributes">
		<summary>
			<para>
       Returns the type token of this type.
    </para>
		</summary>
		<value>
			<para>
       Read-only. Returns the TypeToken of this
       type.
    </para>
		</value>
	</doc>
	<doc for="TypeBuilder.Module">
		<summary>
			<para> Retrieves
      the dynamic module that contains this type definition.
      </para>
		</summary>
		<value>
			<para> Read-only.
      Retrieves the dynamic module that contains this type definition.
      </para>
		</value>
	</doc><doc for="TypeBuilder.Assembly">
		<summary>
			<para>Retrieves the dynamic assembly that contains this type definition.</para>
		</summary>
		<value>
			<para>Read-only. Retrieves the dynamic assembly that contains this type definition. </para>
		</value>
	</doc><doc for="TypeBuilder.ToString">
		<summary>
			<para>Returns the name of the type excluding the
      namespace.</para>
		</summary>
		<returns>
			<para>Read-only. The name of the type
      excluding the namespace.</para>
		</returns>
	</doc><doc for="TypeBuilder.BaseType">
		<summary>
			<para> Retrieves
      the base type of this type.
      </para>
		</summary>
		<value>
			<para> Read-only.
      Retrieves the base type of this type.
      </para>
		</value>
	</doc><doc for="TypeBuilder.DeclaringType">
		<summary>
			<para> Returns the type that
      declared
      this type.
      </para>
		</summary>
		<value>
			<para> Read-only. The type that
      declared
      this type.
      </para>
		</value>
	</doc><doc for="TypeBuilder.Name">
		<summary>
			<para> Retrieves the name of this type.
      </para>
		</summary>
		<value>
			<para> Read-only. Retrieves the <see cref="System.String"/> name of
   this type.
   </para>
		</value>
	</doc><doc for="TypeBuilder.SetParent">
		<summary>
			<para> Sets the parent of this
   <see langword="Type"/>.
      </para>
		</summary>
		<param name="parent">The parent type. </param>
		<exception cref="System.ArgumentNullException"><paramref name="parent "/>is <see langword="null"/>. </exception>
		<exception cref="System.InvalidOperationException">if the type was previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>.</exception>
	</doc><doc for="TypeBuilder.TypeToken">
		<summary>
			<para> Returns the type token of this type.
      </para>
		</summary>
		<value>
			<para> Read-only. Returns the <see langword="TypeToken "/> of this
   type.
   </para>
		</value>
	</doc><doc for="TypeBuilder.Namespace">
		<summary>
			<para> Retrieves the namespace where this <see langword="TypeBuilder "/> 
is defined.
</para>
		</summary>
		<value>
			<para> Read-only. Retrieves the namespace where this 
   <see langword="TypeBuilder "/> 
   is defined.
   </para>
		</value>
	</doc><doc for="TypeBuilder.GetInterfaces">
		<summary>
			<para> Returns an array of all the interfaces implemented on this
      a class and its base classes.
      </para>
		</summary>
		<returns>
			<para> Returns an array of <see cref="System.Type"/> objects
   representing the implemented interfaces. If none are defined, an empty array is
   returned.
   </para>
		</returns>
	</doc><doc for="TypeBuilder.GetEvents">
		<summary>
			<para> Returns the events for the public events declared or inherited by
      this type.
      </para>
		</summary>
		<returns>
			<para> Returns an array of <see cref="System.Reflection.EventInfo"/> objects representing the
   public events declared or inherited by this type. An empty array is returned if
   there are no public events.
   </para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
	</doc><doc for="TypeBuilder.GetPropertyImpl">
		<summary>
			<para> Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the property to get.</param>
		<param name="bindingAttr"><para>A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para><para>-or-</para><para>Zero, to conduct a case-sensitive search for public properties.</para></param>
		<param name="binder"><para>A <see cref="System.Reflection.Binder"/> object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</para><para>-or-</para><para><see langword="null"/>, to use the <see cref="System.Type.DefaultBinder"/>.</para></param>
		<param name="returnType">The return type of the property.</param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the indexed property to get.</para><para>-or-</para><para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</para></param>
		<param name="modifiers">An array of <see cref="System.Reflection.ParameterModifier"/> objects representing the attributes associated with the corresponding element in the <paramref name="types"/> array.</param>
		<returns>
			<para>A <see cref="System.Reflection.PropertyInfo"/> object representing the property that matches the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
	</doc><doc for="TypeBuilder.GetInterfaceMap">
		<summary>
			<para>Returns an interface mapping for the
      requested interface.</para>
		</summary>
		<param name="interfaceType">The <see cref="System.Type"/> of the interface for which the mapping is to be retrieved. </param>
		<returns>
			<para>Returns the requested interface
      mapping.</para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
	</doc><doc for="TypeBuilder.IsCOMObjectImpl">
		<summary>
			<para> Checks if this type imports a COM type.
      </para>
		</summary>
		<returns>
			<para> Returns <see langword="true"/> if
   this type imports a COM type;
   otherwise, <see langword="false"/> .
   </para>
		</returns>
	</doc><doc for="TypeBuilder.IsDefined">
		<summary>
			<para> Set a custom attribute using a custom attribute builder.
      </para>
		</summary>
		<param name="attributeType">The <see langword="Type"/> object to which the custom attributes are applied.</param>
		<param name="inherit">Specifies whether to search this member's inheritance chain to find the attributes.</param>
		<returns>
			<para><see langword="true"/> if one or more instance of <paramref name="attributeType"/> is defined on this member; otherwise <see langword="false"/>.</para>
		</returns>
		<exception cref="System.NotSupportedException"> This method is not currently supported for incomplete types. Retrieve the type using <see cref="System.Type.GetType"/> and call <see cref="System.Reflection.MemberInfo.IsDefined"/> on the returned <see cref="System.Type"/>.</exception>
	</doc><doc for="TypeBuilder.GUID">
		<summary>
			<para> Retrieves
      the GUID of this type.
      </para>
		</summary>
		<value>
			<para> Read-only.
      Retrieves the GUID of this type
      </para>
		</value>
		<exception cref="System.NotSupportedException">This method is not currently supported for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/>
or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type.</para>
		</remarks>
	</doc><doc for="TypeBuilder.GetMethodImpl">
		<summary>
			<para> Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the method to get.</param>
		<param name="bindingAttr"><para>A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para><para>-or-</para><para>Zero, to conduct a case-sensitive search for public methods.</para></param>
		<param name="binder"><para>A <see cref="System.Reflection.Binder"/> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para><para>-or-</para><para><see langword="null"/>, to use the <see cref="System.Type.DefaultBinder"/>.</para></param>
		<param name="callConvention">The <see cref="System.Reflection.CallingConventions"/> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the method to get.</para><para>-or-</para><para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</para></param>
		<param name="modifiers">An array of <see cref="System.Reflection.ParameterModifier"/> objects representing the attributes associated with the corresponding element in the <paramref name="types"/> array.</param>
		<returns>
			<para>A <see cref="System.Reflection.MethodInfo"/> object representing the method that matches the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
	</doc><doc for="TypeBuilder.GetCustomAttributes">
		<overload>
			<para> Returns the custom attributes defined for this
      type.
      </para>
		</overload>
		<summary>
			<para> Returns all the custom attributes defined for this type.
      </para>
		</summary>
		<param name="inherit">Specifies whether to search this member's inheritance chain to find the attributes.</param>
		<returns>
			<para> Returns an array of objects representing all the custom
      attributes of this
      type.
      </para>
		</returns>
		<exception cref="System.NotSupportedException"> This method is not currently supported for incomplete types. Retrieve the type using <see cref="System.Type.GetType"/> and call <see cref="System.Reflection.MemberInfo.GetCustomAttributes"/> on the returned <see cref="System.Type"/>.</exception>
	</doc><doc for="TypeBuilder.SetCustomAttribute1">
		<summary>
			<para>Set a custom attribute using a custom attribute builder. </para>
		</summary>
		<param name="customBuilder">An instance of a helper class to define the custom attribute. </param>
		<exception cref="System.ArgumentNullException"><paramref name="con "/>is <see langword="null"/>. </exception>
		<permission cref="System.Security.Permissions.ReflectionPermission">SecurityAction.Demand, ReflectionEmit</permission>
	</doc><doc for="TypeBuilder.GetCustomAttributes1">
		<summary>
			<para> Checks if the specified custom attribute type is defined.
      </para>
		</summary>
		<param name="attributeType">The <see cref="System.Type"/> object to which the custom attributes are applied.</param>
		<param name="inherit">Specifies whether to search this member's inheritance chain to find the attributes.</param>
		<returns>
			<para><see langword="true"/> if one or more instance of <paramref name="attributeType"/> is defined on this member; otherwise, <see langword="false"/>.</para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not currently supported for incomplete types. Retrieve the type using <see cref="System.Type.GetType"/> and call <see cref="System.Reflection.MemberInfo.GetCustomAttributes"/> on the returned <see cref="System.Type"/>.</exception>
	</doc><doc for="TypeBuilder.DefineEvent">
		<summary>
			<para> Adds
      a new event to the class, with the given name, attributes and event
      type.
      </para>
		</summary>
		<param name="name">The name of the event. <paramref name="name"/> cannot contain embedded nulls. </param>
		<param name="attributes">The attributes of the event. </param>
		<param name="eventtype">The type of the event. </param>
		<returns>
			<para> The defined event.
      </para>
		</returns>
		<exception cref="System.ArgumentException">The length of <paramref name="name"/> is zero.</exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/>is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="eventtype"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.InvalidOperationException">The type was previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/></exception>
	</doc><doc for="TypeBuilder.DefineField">
		<summary>
			<para> Adds a new field to the class, with the given name, attributes and field
      type.
      </para>
		</summary>
		<param name="fieldName">The name of the field. <paramref name="fieldName "/>cannot contain embedded nulls. </param>
		<param name="type">The type of the field </param>
		<param name="attributes">The attributes of the field. </param>
		<returns>
			<para> The defined field.
      </para>
		</returns>
		<exception cref="System.ArgumentException"><para>The length of <paramref name="fieldName"/> is zero.</para>
			<para>-or-</para>
			<para>
				<paramref name="type"/> is System.Void.</para>
			<para>-or-</para>
			<para>A total size was specified for the parent class of this field.</para></exception>
		<exception cref="System.ArgumentNullException"><paramref name="fieldName "/>is <see langword="null"/>.</exception>
		<exception cref="System.InvalidOperationException">The type was previously created using <see langword="CreateType"/><see cref="System.Reflection.Emit.TypeBuilder"/> .</exception>
	</doc><doc for="TypeBuilder.InvokeMember">
		<summary>
			<para> Invokes the specified member. The method that is to be invoked
      must be accessible and provide the most specific match with the specified
      argument list, under the contraints of the specified binder and invocation
      attributes.
      </para>
		</summary>
		<param name="name">The name of the member to invoke. This can be a constructor, method, property, or field. A suitable invocation attribute must be specified. Note that it is possible to invoke the default member of a class by passing an empty string as the name of the member. </param>
		<param name="invokeAttr">The invocation attribute. This must be a bit flag from <see langword="BindingFlags"/> . </param>
		<param name="binder">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo"/> objects using reflection. If binder is <see langword="null"/>, the default binder is used. See <see cref="System.Reflection.Binder"/> . </param>
		<param name="target">The object on which to invoke the specified member. If the member is static, this parameter is ignored. </param>
		<param name="args">An argument list. This is an array of Objects that contains the number, order, and type of the parameters of the member to be invoked. If there are no parameters this should be null. </param>
		<param name="modifiers"> An array of the same length as args with elements that represent the attributes associated with the arguments of the member to be invoked. A parameter has attributes associated with it in the metadata. They are used by various interoperability services. See the metadata specs for more details. </param>
		<param name="culture">An instance of <see langword="CultureInfo"/> used to govern the coercion of types. If this is null, the <see langword="CultureInfo"/> for the current thread is used. (Note that this is necessary to, for example, convert a String that represents 1000 to a Double value, since 1000 is represented differently by different cultures.) </param>
		<param name="namedParameters">Each parameter in the <paramref name="namedParameters"/> array gets the value in the corresponding element in the <paramref name="args"/> array. If the length of <paramref name="args"/> is greater than the length of <paramref name="namedParameters"/> , the remaining argument values are passed in order. </param>
		<returns>
			<para> Returns the return value of the invoked member.
      </para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not currently supported for incomplete types. </exception>
		<remarks>
			<para> A method will be invoked if the number of parameters in
      the method declaration equals the number of arguments in the specified argument
      list, and the type of each argument can be converted by the binder
      to the type of the parameter.
      </para>
			<para> The binder will find all of the matching methods. These 
      methods are found based on the type of binding requested
      (BindingFlags.InvokeMethod, BindingFlags.GetProperties, and so on.). The set of
      methods is filtered by the name, number of arguments, and a set of search
      modifiers defined in the binder. After the method is selected, it will be
      invoked. Accessibility is checked at that point. The search can control
      which set of methods are searched based upon the accessibility attribute
      associated with the method. The <see langword="IBinder.BindToMethod"/>
      
      
      
      method is responsible
      for selecting the method to be invoked. The default binder selects the most
      specific match.
      </para>
			<note type="note">
      Access restrictions
      are ignored for fully-trusted code. That is, private constructors, methods,
      fields, and properties can be accessed and invoked using Reflection whenever the code is
      fully-trusted.
      
   </note>
   This
   method is not currently supported. You can retrieve the type using
<see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/>
and use reflection on the retrieved type.
</remarks>
	</doc><doc for="TypeBuilder.TypeHandle">
		<summary>
			<para> Not supported in dynamic modules.
      </para>
		</summary>
		<value>
			<para> Read-only.
      </para>
		</value>
		<exception cref="System.NotSupportedException">Not supported in dynamic modules. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type.</para>
		</remarks>
	</doc><doc for="TypeBuilder.FullName">
		<summary>
			<para> 
      Retrieves the full path of this type.
      </para>
		</summary>
		<value>
			<para> 
      Read-only. Retrieves the full path of this type.
      </para>
		</value>
		<remarks>
			<para> The returned format is "enclosingTypeFullName+nestedTypeName" for nested types
      and "typeName" for non-nested types.
      </para>
		</remarks>
	</doc><doc for="TypeBuilder.GetConstructors">
		<summary>
			<para> Returns an array of <see cref="System.Reflection.ConstructorInfo"/> objects representing
   the public and non-public constructors defined for this class, as specified.
   </para>
		</summary>
		<param name="bindingAttr">This must be a bit flag from <see cref="System.Reflection.BindingFlags"/> as in <see langword="InvokeMethod"/>, <see langword="NonPublic"/> , and so on. </param>
		<returns>
			<para> Returns an array of <see cref="System.Reflection.ConstructorInfo"/> objects representing
   the specified constructors defined for this class. If no constructors are
   defined, an empty array is returned.
   </para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission"><see langword="TypeInformation"/> required for non-public members. </permission>
	</doc><doc for="TypeBuilder.GetMethods">
		<summary>
			<para> Returns all the public and non-public methods declared or
      inherited by this type, as specified.
      </para>
		</summary>
		<param name="bindingAttr">This must be a bit flag from <see cref="System.Reflection.BindingFlags"/> as in <see langword="InvokeMethod"/>, <see langword="NonPublic"/> , and so on. </param>
		<returns>
			<para> Returns an array of <see cref="System.Reflection.MethodInfo"/> objects representing the
   public and non-public methods defined on this type if <paramref name="nonPublic"/> is used; otherwise, only the public methods are returned.
   </para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission"><see langword="TypeInformation"/>required for non-public members </permission>
	</doc><doc for="TypeBuilder.GetField">
		<summary>
			<para> Returns the field specified by the given name.
      </para>
		</summary>
		<param name="name">The name of the field to get. </param>
		<param name="bindingAttr">This must be a bit flag from <see cref="System.Reflection.BindingFlags"/> as in <see langword="InvokeMethod"/>, <see langword="NonPublic"/> , and so on. </param>
		<returns>
			<para> Returns the <see cref="System.Reflection.FieldInfo"/> object representing the
   field declared or inherited by this type with the specified name and public or
   non-public modifier. If there are no matches then <see langword="null"/>
   is returned.
   </para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission"><see langword="TypeInformation"/>required for non-public members. </permission>
	</doc><doc for="TypeBuilder.GetFields">
		<summary>
			<para> Returns the public and non-public fields that are
      declared by this type.
      </para>
		</summary>
		<param name="bindingAttr">This must be a bit flag from <see cref="System.Reflection.BindingFlags"/> : <see langword="InvokeMethod"/>, <see langword="NonPublic"/> , and so on. </param>
		<returns>
			<para> Returns an array of <see cref="System.Reflection.FieldInfo"/> objects representing the
   public and non-public fields declared or inherited by this type. An empty array
   is returned if there are no fields, as specified.
   </para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission"><see langword="TypeInformation"/>required for non-public members </permission>
	</doc><doc for="TypeBuilder.GetEvent">
		<summary>
			<para> Returns the event with the specified name.
      </para>
		</summary>
		<param name="name">The name of the event to get. </param>
		<param name="bindingAttr">This invocation attribute. This must be a bit flag from <see cref="System.Reflection.BindingFlags"/> : <see langword="InvokeMethod"/>, <see langword="NonPublic"/> , and so on. </param>
		<returns>
			<para> Returns an <see cref="System.Reflection.EventInfo"/> object representing
   the event declared or inherited by this type with the specified name. If there
   are no matches, then an empty array is returned.
   </para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
	</doc><doc for="TypeBuilder.GetProperties">
		<summary>
			<para> Returns all the public and non-public properties declared or
      inherited by this type, as specified.
      </para>
		</summary>
		<param name="bindingAttr">This invocation attribute. This must be a bit flag from <see cref="System.Reflection.BindingFlags"/> : <see langword="InvokeMethod"/>, <see langword="NonPublic"/> , and so on. </param>
		<returns>
			<para> Returns an array of <see langword="PropertyInfo"/> objects representing the
   public and non-public properties defined on this type if <paramref name="nonPublic"/> is
   used; otherwise, only the public properties are returned.
   </para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
	</doc><doc for="TypeBuilder.GetNestedTypes">
		<summary>
			<para> Returns the public and non-public nested
      types that are declared or inherited by this type.
      </para>
		</summary>
		<param name="bindingAttr">This must be a bit flag from <see cref="System.Reflection.BindingFlags"/>, as in <see langword="InvokeMethod"/>, <see langword="NonPublic"/> , and so on. </param>
		<returns>
			<para>An array of <see cref="System.Type"/> objects representing all the types nested within the current <see cref="System.Type"/> that match the specified binding constraints.</para>
			<para>An empty array of type <see cref="System.Type"/>, if no types are nested within the current <see cref="System.Type"/>, or if none of the
nested types match the binding constraints.</para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
			<para>If this type is complete, for example, if <see langword="CreateType"/> has been
called on this type, but there are nested types that are not complete, then
<see langword="GetNestedTypes"/> will only return those nested types for which 
<see langword="CreateType"/> has been called.</para>
		</remarks>
	</doc><doc for="TypeBuilder.GetNestedType">
		<summary>
			<para> Returns the public and non-public nested types that are
      declared by this type.
      </para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the nested type to get.</param>
		<param name="bindingAttr"><para>A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para><para>-or-</para><para>Zero, to conduct a case-sensitive search for public methods.</para></param>
		<returns>
			<para>A <see cref="System.Type"/> object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
			<para>If this type is complete, for example, if <see langword="CreateType"/> has been
called on this type, but there are nested types that are not complete, then
<see langword="GetNestedTypes"/> will only return those nested types for which 
<see langword="CreateType"/> has been called.</para>
		</remarks>
	</doc><doc for="TypeBuilder.GetMember">
		<summary>
			<para> Returns all the public and non-public members declared or
      inherited by this type, as specified.
      </para>
		</summary>
		<param name=" name">The name of the member. </param>
		<param name=" type">The type of the member to return.</param>
		<param name="bindingAttr">This must be a bit flag from <see cref="System.Reflection.BindingFlags"/>, as in <see langword="InvokeMethod"/>, <see langword="NonPublic"/> , and so on. </param>
		<returns>
			<para> Returns an array of <see cref="System.Reflection.MemberInfo"/> objects representing the
   public and non-public members defined on this type if <paramref name="nonPublic"/> is used; otherwise, only the public members are returned.
   </para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
	</doc><doc for="TypeBuilder.GetEvents1">
		<summary>
			<para> Returns the public and non-public events that are declared by this type.
      </para>
		</summary>
		<param name="bindingAttr">This must be a bit flag from <see cref="System.Reflection.BindingFlags"/>, as in <see langword="InvokeMethod"/>, <see langword="NonPublic"/> , and so on. </param>
		<returns>
			<para> Returns an array of <see cref="System.Reflection.EventInfo"/> objects representing the public and non-public events declared or inherited by this type. An empty array is returned if there are no events, as specified.
   </para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission"><see langword="TypeInformation"/>required for non-public members </permission>
	</doc><doc for="TypeBuilder.GetMembers">
		<summary>
			<para> Returns the members for the public and non-public members
      declared or inherited by this type.
      </para>
		</summary>
		<param name="bindingAttr">This must be a bit flag from <see cref="System.Reflection.BindingFlags"/>, such as <see langword="InvokeMethod"/>, <see langword="NonPublic"/> , and so on. </param>
		<returns>
			<para> Returns an array of <see cref="System.Reflection.MemberInfo"/> objects representing the
   public and non-public members declared or inherited by this type. An empty
   array is returned if there are no matching members.
   </para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission"><see langword="TypeInformation"/>required for non-public members </permission>
	</doc><doc for="TypeBuilder.IsArrayImpl">
		<summary>
			<para> Always returns <see langword="false"/> .
   </para>
		</summary>
		<returns>
			<para> Returns <see langword="false"/> .
   </para>
		</returns>
	</doc><doc for="TypeBuilder.IsByRefImpl">
		<summary>
			<para>Always returns <see langword="false "/> .</para>
		</summary>
		<returns>
			<para>Always <see langword="false"/>.</para>
		</returns>
	</doc><doc for="TypeBuilder.IsPointerImpl">
		<summary>
			<para>Always returns <see langword="false "/> .</para>
		</summary>
		<returns>
			<para>Always <see langword="false"/>.</para>
		</returns>
	</doc><doc for="TypeBuilder.IsPrimitiveImpl">
		<summary>
			<para> Always returns <see langword="false"/> .
   </para>
		</summary>
		<returns>
			<para> Returns <see langword="false"/> .
   </para>
		</returns>
	</doc><doc for="TypeBuilder.IsSubclassOf">
		<summary>
			<para>Checks if this type is a derived class of the given type
   <paramref name="c"/> .</para>
		</summary>
		<param name="c">A <see cref="System.Type"/> that is to be checked</param>
		<returns>
			<para>Read-only. Returns <see langword="true"/> if this type is
   the same as the type <paramref name="c"/>, or is a subtype of type <paramref name="c"/> ; otherwise,
<see langword="false"/> 
.</para>
		</returns>
	</doc><doc for="TypeBuilder.UnderlyingSystemType">
		<summary>
			<para>Returns the underlying system type for this
   <see langword="TypeBuilder"/> .</para>
		</summary>
		<value>
			<para>Read-only. Returns the underlying
      system type.</para>
		</value>
		<exception cref="System.InvalidOperationException">This type is an enum but there is no underlying system type.</exception>
	</doc><doc for="TypeBuilder.HasElementTypeImpl">
		<summary>
			<para> Calling this method always throws <see cref="System.NotSupportedException"/>.
   </para>
		</summary>
		<returns>
			<para>This method is not supported. No value is returned.</para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not supported. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
	</doc><doc for="TypeBuilder.GetElementType">
		<summary>
			<para> Calling this method always throws <see cref="System.NotSupportedException"/> .
   </para>
		</summary>
		<returns>
			<para>This method is not supported. No value is returned.</para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not supported. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
	</doc><doc for="TypeBuilder.IsAssignableFrom">
		<summary>
			<para>Determines whether an instance of the 
      current <see cref="System.Type"/> can be assigned from an instance of the specified
   <see langword="Type"/>.</para>
		</summary>
		<param name="c">The <see langword="Type"/> to compare with the current <see langword="Type"/>.</param>
		<returns>
			<para><see langword="true"/> if the <paramref name="c"/> parameter and the 
   current <see cref="System.Type"/> represent the same type, or if the current
<see langword="Type"/> is in the inheritance hierarchy of <paramref name="c"/>, or if the 
   current <see langword="Type"/> is an interface that <paramref name="c"/> supports.
<see langword="false"/> if none of these conditions are the case, or if 
<paramref name="c"/> is a null reference (<see langword="Nothing"/> in Visual Basic). </para>
		</returns>
		<remarks>
			<para>This method can be overridden by a derived class. </para>
		</remarks>
	</doc><doc for="TypeBuilder.CreateType">
		<summary>
			<para> Creates a <see cref="System.Type"/> object for the
   class. After defining fields and methods on the class, <see langword="CreateType "/>is called in order to load its <see langword="Type "/>
   object.
   </para>
		</summary>
		<returns>
			<para> Returns the new <see cref="System.Type"/> object for this
   class.
   </para>
		</returns>
		<exception cref="System.InvalidOperationException"><para> This type has been previously created.</para>
			<para>-or-</para>
			<para> The enclosing type has not been created.</para>
			<para>-or-</para>
			<para> This type is non-abstract and contains an abstract method.</para>
			<para>-or-</para>
			<para> This type is abstract and has a method with a method body.</para>
			<para>-or-</para>
			<para> This type is not an abstract class or an interface and has a method without a method body.</para></exception>
		<exception cref="System.NotSupportedException"><para>If the type contains invalid Microsoft Intermediate Language (MSIL) code.</para>
			<para>-or-</para>
			<para>The branch target is specified using a 1-byte offset but the target is at a distance greater than 127 bytes from the branch.</para></exception>
		<remarks>
			<para>If this type is a nested type, the <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/> must be called on the nesting
   (enclosing) type before calling the method on this type.</para>
			<para>If the nesting type contains a field that is a value
   type defined as a nested type (for example, a field that is an enum defined as a
   nested type), calling <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/> on the nesting type will
   generate a <see cref="System.AppDomain.TypeResolve"/> event. This is because
   the loader cannot determine the size of the nesting type until the nested type has
   been completed. The caller should define a handler for the <see cref="System.AppDomain.TypeResolve"/>
   event to complete the definition of the nested type by calling
<see cref="System.Reflection.Emit.TypeBuilder.CreateType"/> 
on the nested type's <see cref="System.Reflection.Emit.TypeBuilder"/>. The following example shows how
to define the event
handler.</para>
			<codelink SampleID="System.Reflection.Emit.TypeBuilder.CreateType Example" SnippetID="1"/>
		</remarks>
	</doc>
	<doc for="TypeBuilder.DefineNestedType">
		<overload>
			<para>Defines a nested type.</para>
		</overload>
		<summary>
			<para> Defines a nested type given its name.
      </para>
		</summary>
		<param name="name">The full path of the type. <paramref name="name"/> cannot contain embedded nulls. </param>
		<returns>
			<para> The defined nested type.
      </para>
		</returns>
		<exception cref="System.ArgumentException">Length of <paramref name="name"/> is zero.</exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para> A null interface is specified in the <paramref name="interfaces "/>array.</para></exception>
		<exception cref="System.InvalidOperationException">The type was previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>.</exception>
		<remarks>
			<para>The nested type needs to be complete before you can reflect on it using <see cref="System.Type.GetMembers"/>, <see cref="System.Type.GetNestedType"/>, or
<see cref="System.Type.GetNestedTypes"/> 
.</para>
			<para>See the description of <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>
for the order in which nested types
and nesting types should be completed. </para>
		</remarks>
	</doc><doc for="TypeBuilder.DefineNestedType1">
		<summary>
			<para> Defines a nested type given its name, attributes, the
      type that it extends, and the interfaces
      that
      it implements.
      </para>
		</summary>
		<param name="name">The full path of the type. <paramref name="name"/> cannot contain embedded nulls. </param>
		<param name="attr">The attributes of the type. </param>
		<param name="parent">The type that the nested type extends. </param>
		<param name="interfaces">The interfaces that the nested type implements. </param>
		<returns>
			<para> The defined nested type.
      </para>
		</returns>
		<exception cref="System.ArgumentException"><para> The nested attribute is not specified.</para>
			<para>-or-</para>
			<para> This type is sealed.</para>
			<para>-or-</para>
			<para> This type is an array.</para>
			<para>-or-</para>
			<para> This type is an interface but the nested type is not an interface.</para>
			<para>-or-</para>
			<para> The length of <paramref name="name"/> is zero.</para></exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/> or a null interface is specified in the <paramref name="interfaces "/>array.</para></exception>
		<exception cref="System.InvalidOperationException">The type was previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>.</exception>
		<remarks>
			<para>The nested type needs to be complete before you can reflect on it using <see cref="System.Type.GetMembers"/>, <see cref="System.Type.GetNestedType"/>, or
<see cref="System.Type.GetNestedTypes"/> 
.</para>
			<para>See the description of <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>
for the order in which nested types
and nesting types should be completed. </para>
		</remarks>
	</doc><doc for="TypeBuilder.DefineNestedType2">
		<summary>
			<para> Defines a nested type
      given its name, attributes, and the type
      that
      it extends.
      </para>
		</summary>
		<param name="name">The full path of the type. <paramref name="name"/> cannot contain embedded nulls. </param>
		<param name="attr">The attributes of the type. </param>
		<param name="parent">The type that the nested type extends. </param>
		<returns>
			<para> The defined nested type.
      </para>
		</returns>
		<exception cref="System.ArgumentException"><para> The nested attribute is not specified.</para>
			<para>-or-</para>
			<para> This type is sealed.</para>
			<para>-or-</para>
			<para> This type is an array.</para>
			<para>-or-</para>
			<para> This type is an interface but the nested type is not an interface.</para>
			<para>-or-</para>
			<para> The length of <paramref name="name"/> is zero.</para></exception>
		<exception cref="System.ArgumentNullException"><para><paramref name="name"/> is <see langword="null"/>.</para>
			<para><see langword="-"/>or-</para>
			<para> A null interface is specified in the <paramref name="interfaces "/>array.</para></exception>
		<exception cref="System.InvalidOperationException">The type was previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>.</exception>
		<remarks>
			<para>The nested type needs to be complete before you can reflect on it using <see cref="System.Type.GetMembers"/>, <see cref="System.Type.GetNestedType"/>, or
<see cref="System.Type.GetNestedTypes"/>.</para>
			<para>See the description of <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>
for the order in which nested types
and nesting types should be completed. </para>
		</remarks>
	</doc><doc for="TypeBuilder.DefineNestedType3">
		<summary>
			<para> Defines a nested type given its
      name
      and attributes.
      </para>
		</summary>
		<param name="name">The full path of the type. <paramref name="name"/> cannot contain embedded nulls. </param>
		<param name="attr">The attributes of the type. </param>
		<returns>
			<para> The defined nested type.
      </para>
		</returns>
		<exception cref="System.ArgumentException"><para> The nested attribute is not specified.</para>
			<para>-or-</para>
			<para> This type is sealed.</para>
			<para>-or-</para>
			<para> This type is an array.</para>
			<para>-or-</para>
			<para> This type is an interface but the nested type is not an interface.</para>
			<para>-or-</para>
			<para> The length of <paramref name="name"/> is zero.</para></exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para>
			<para><see langword="-"/>or-</para>
			<para> A null interface is specified in the <paramref name="interfaces "/>array.</para></exception>
		<exception cref="System.InvalidOperationException">The type was previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>.</exception>
		<remarks>
			<para>The nested type needs to be complete before you can reflect on it using <see cref="System.Type.GetMembers"/>, <see cref="System.Type.GetNestedType"/>, or
<see cref="System.Type.GetNestedTypes"/> 
.</para>
			<para>See the description of <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>
for the order in which nested types
and nesting types should be completed. </para>
		</remarks>
	</doc><doc for="TypeBuilder.DefineNestedType4">
		<summary>
			<para> Defines a nested type given its
      name, attributes, the total
      size of the type, and the type
      that
      it extends.
      </para>
		</summary>
		<param name="name">The full path of the type. <paramref name="name"/> cannot contain embedded nulls. </param>
		<param name="attr">The attributes of the type. </param>
		<param name="parent">The type that the nested type extends. </param>
		<param name=" typeSize">The total size of the type. </param>
		<returns>
			<para> The defined nested type.
      </para>
		</returns>
		<exception cref="System.ArgumentException"><para> The nested attribute is not specified.</para>
			<para>-or-</para>
			<para> This type is sealed.</para>
			<para>-or-</para>
			<para> This type is an array.</para>
			<para>-or-</para>
			<para> This type is an interface but the nested type is not an interface.</para>
			<para>-or-</para>
			<para> The length of <paramref name="name"/> is zero.</para></exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para>
			<para><see langword="-"/>or-</para>
			<para> A null interface is specified in the <paramref name="interfaces "/>array.</para></exception>
		<exception cref="System.InvalidOperationException">if the type was previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>.</exception>
		<remarks>
			<para>The nested type needs to be complete before you can reflect on it using <see cref="System.Type.GetMembers"/>, <see cref="System.Type.GetNestedType"/>, or
<see cref="System.Type.GetNestedTypes"/> 
.</para>
			<para>See the description of <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>
for the order in which nested types
and nesting types should be completed. </para>
		</remarks>
	</doc><doc for="TypeBuilder.DefineNestedType5">
		<summary>
			<para> Defines a nested type given its
      name, attributes, the total
      size of the type, and the type
      that
      it extends.
      </para>
		</summary>
		<param name="name">The full path of the type. <paramref name="name"/> cannot contain embedded nulls. </param>
		<param name="attr">The attributes of the type. </param>
		<param name="parent">The type that the nested type extends. </param>
		<param name="packSize">The packing size of the type. </param>
		<returns>
			<para> The defined nested type.
      </para>
		</returns>
		<exception cref="System.ArgumentException"><para> The nested attribute is not specified.</para>
			<para>-or-</para>
			<para> This type is sealed.</para>
			<para>-or-</para>
			<para> This type is an array.</para>
			<para>-or-</para>
			<para> This type is an interface but the nested type is not an interface.</para>
			<para>-or-</para>
			<para> The length of <paramref name="name"/> is zero.</para></exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para>
			<para><see langword="-"/>or-</para>
			<para> A null interface is specified in the <paramref name="interfaces "/>array.</para></exception>
		<exception cref="System.InvalidOperationException">The type was previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>.</exception>
		<remarks>
			<para>The nested type needs to be complete before you can reflect on it using <see cref="System.Type.GetMembers"/>, <see cref="System.Type.GetNestedType"/>, or
<see cref="System.Type.GetNestedTypes"/> 
.</para>
			<para>See the description of <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>
for the order in which nested types
and nesting types should be completed. </para>
		</remarks>
	</doc><doc for="TypeBuilder.GetInterface">
		<summary>
			<para> Returns the interface implemented (directly or indirectly) by
      this class with the fully-qualified name matching the given interface name.
      </para>
		</summary>
		<param name="name">The name of the interface. </param>
		<param name="ignoreCase">If <see langword="true"/>, the search is case-insensitive. If <see langword="false"/> , the search is case-sensitive. </param>
		<returns>
			<para> Returns a <see cref="System.Type"/> object representing the
   implemented interface. Returns null if no interface matching name is found.
   </para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete types. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
	</doc>
	<doc for="TypeBuilder.SetCustomAttribute">
		<overload>
			<para>Sets a custom attribute.</para>
		</overload>
		<summary>
			<para>Sets a custom attribute using a specified custom attribute blob. </para>
		</summary>
		<param name="con">The constructor for the custom attribute. </param>
		<param name="binaryAttribute">A byte blob representing the attributes. </param>
		<exception cref="System.ArgumentNullException"><paramref name="con "/>or <paramref name="binaryAttribute "/>is <see langword="null"/>. </exception>
		<remarks>
			<para>See the metadata specification in the ECMA Partition
      II documentation for details on how to format <paramref name="binaryAttribute"/>. The Partition II documentation is included
      with the .NET Framework SDK installation, and can be found in the %\Microsoft.NET\FrameworkSDK\Tool Developers
      Guide\docs directory.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">SecurityAction.Demand, ReflectionEmit</permission>
	</doc>
	<doc for="TypeBuilder.AddDeclarativeSecurity">
		<summary>
			<para> Adds
      declarative security to this type.
      </para>
		</summary>
		<param name="action">The security action to be taken such as Demand, Assert, and so on. </param>
		<param name="pset">The set of permissions the action applies to. </param>
		<exception cref="System.ArgumentOutOfRangeException">The <paramref name="action"/> is invalid (<see langword="RequestMinimum"/>, <see langword="RequestOptional"/>, and <see langword="RequestRefuse"/> are invalid).</exception>
		<exception cref="System.InvalidOperationException"><para> The containing type has been created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>. </para>
			<para>-or-</para>
			<para> The permission set <paramref name="pset"/> contains an action that was added earlier by <see langword="AddDeclarativeSecurity"/> .</para></exception>
		<exception cref="System.ArgumentNullException"><paramref name="pset"/> is <see langword="null"/> .</exception>
		<remarks>
			<para><see langword="AddDeclarativeSecurity "/>may be called several times with each call specifying
   a security action (such as Demand, Assert, or Deny) and a set
   of permissions that apply to the action.
   </para>
		</remarks>
		<example>
			<para>The following code sample demonstrates the use of 
   <see langword="AddDeclarativeSecurity"/> to add a 'demand' security action to a 
      dynamic type.</para>
			<codelink SampleID="TypeBuilder_AddDeclarativeSecurity" SnippetID="1"/>
		</example>
	</doc>
	<doc for="TypeBuilder.AddInterfaceImplementation">
		<summary>
			<para> Adds an interface that this type
      implements.
      </para>
		</summary>
		<param name="interfaceType">The interface that this type implements. </param>
		<exception cref="System.ArgumentNullException"><paramref name="interfaceType "/>is <see langword="null"/>.</exception>
		<exception cref="System.InvalidOperationException">The type was previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>.</exception>
		<example>
			<para>The following code sample demonstrates the implementation of an interface on 
      a dynamically created type using
   <see langword="AddInterfaceImplementation"/>.</para>
			<codelink SampleID="TypeBuilder_Sample_4" SnippetID="3"/>
		</example>
	</doc>
	<doc for="TypeBuilder.AssemblyQualifiedName">
		<summary>
			<para> Returns the full name of this type qualified by the display
      name
      of
      the assembly.
      </para>
		</summary>
		<value>
			<para> Read-only. The full name of this type qualified by the
      display name
      of
      the assembly.
      </para>
		</value>
		<remarks>
			<para> The format of the returned string is:
      </para>
			<para> &lt;FullTypeName&gt;, &lt;AssemblyDisplayName&gt;
      </para>
			<para> See <see cref="System.Reflection.AssemblyName"/> for a description of the format of the display name of an assembly.
   </para>
		</remarks>
		<example>
		</example>
	</doc>
	<doc for="TypeBuilder.DefineConstructor">
		<summary>
			<para> Adds a new constructor to the class, with the given attributes and
      signature.
      </para>
		</summary>
		<param name="attributes">The attributes of the constructor. </param>
		<param name="callingConvention">The calling convention of the constructor. </param>
		<param name="parameterTypes">The types of the parameters of the constructor. </param>
		<returns>
			<para> The defined constructor.
      </para>
		</returns>
		<exception cref="System.InvalidOperationException">The type was previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>.</exception>
		<example>
			<para>The following code sample demonstrates the use of 
   <see langword="DefineConstructor"/> to set a constructor's particular signature 
      and attributes on a dynamic type and return a corresponding <see cref="System.Reflection.Emit.ConstructorBuilder"/> for IL population.</para>
			<codelink SampleID="TypeBuilder_Sample_4" SnippetID="2"/>
		</example>
	</doc>
	<doc for="TypeBuilder.DefineDefaultConstructor">
		<summary>
			<para> Defines the default constructor. The constructor
      defined here will simply call the default constructor of the parent.
      </para>
		</summary>
		<param name="attributes">A <see langword="MethodAttributes"/> object representing the attributes to be applied to the constructor. </param>
		<returns>
			<para>Returns the constructor.</para>
		</returns>
		<exception cref="System.NotSupportedException">The parent class does not have a default constructor </exception>
		<remarks>
			<para> Since the default constructor is automatically defined, it is
      only necessary to call this method if the attributes on the default constructor
      should be set to something other than MethodBase.Constructor.
      This method is provided here to make it easier to set the attributes.
      </para>
		</remarks>
		<example>
			<para>The following code sample demonstrates the use of 
   <see langword="DefineConstructor"/> to set a constructor's particular signature 
      and attributes on a dynamic type and return a corresponding <see cref="System.Reflection.Emit.ConstructorBuilder"/> for IL population.</para>
			<codelink SampleID="TypeBuilder_Sample_4" SnippetID="2"/>
		</example>
	</doc>
	<doc for="TypeBuilder.DefineMethod">
		<overload>
			<para>Defines a method.</para>
		</overload>
		<summary>
			<para> Adds a new method to the class, with the given name and method
      signature.
      </para>
		</summary>
		<param name="name">The name of the method. <paramref name="name"/> cannot contain embedded nulls. </param>
		<param name="attributes">The attributes of the method. </param>
		<param name="returnType">The return type of the method. </param>
		<param name="parameterTypes">The types of the parameters of the method. </param>
		<returns>
			<para>The defined method.</para>
		</returns>
		<exception cref="System.ArgumentException"><para>The length of <paramref name="name"/> is zero.</para><para>-or-</para><para> The type of the parent of this method is an interface and this method is not virtual.</para></exception>
		<exception cref="System.ArgumentNullException"><paramref name="name "/>is <see langword="null"/>.</exception>
		<exception cref="System.InvalidOperationException">The type was previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/></exception>
		<example>
			<para>The following code sample demonstrates the use of 
   <see langword="DefineMethod"/> to set a constructor's particular signature and 
      attributes on a dynamic type and return a corresponding <see cref="System.Reflection.Emit.MethodBuilder"/> for IL population.</para>
			<codelink SampleID="TypeBuilder_DefineNestedType1" SnippetID="2"/>
		</example>
	</doc>
	<doc for="TypeBuilder.DefineMethod1">
		<summary>
			<para> Adds a new method to the class, with the given name and method
      signature.
      </para>
		</summary>
		<param name="name">The name of the method. <paramref name="name"/> cannot contain embedded nulls. </param>
		<param name="attributes">The attributes of the method. </param>
		<param name=" callingConvention">The calling convention of the method. </param>
		<param name="returnType">The return type of the method. </param>
		<param name="parameterTypes">The types of the parameters of the method. </param>
		<returns>
			<para> The defined method.
      </para>
		</returns>
		<exception cref="System.ArgumentException"><para>The length of <paramref name="name"/> is zero.</para>
			<para>-or-</para>
			<para> The type of the parent of this method is an interface and this method is not virtual.</para></exception>
		<exception cref="System.ArgumentNullException"><paramref name="name "/>is <see langword="null"/>.</exception>
		<exception cref="System.InvalidOperationException">The type was previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/></exception>
		<example>
			<para>The following code sample demonstrates 
      the use of <see langword="DefineMethod"/> to set a constructor's particular
      signature and attributes on a dynamic type and return a corresponding <see cref="System.Reflection.Emit.MethodBuilder"/> for IL population.</para>
			<codelink SampleID="TypeBuilder_DefineNestedType1" SnippetID="2"/>
		</example>
	</doc>
	<doc for="TypeBuilder.DefinePInvokeMethod">
		<overload>
			<para> Defines a <see langword="PInvoke "/> method.
   </para>
		</overload>
		<summary>
			<para> Defines a <see langword="PInvoke "/>method given its name,
   the name of the DLL in which the method is defined, the attributes of the
   method, the calling convention of the method, the return type of the method, the
   types of the parameters of the method, and the <see langword="PInvoke "/>
   
   flags.
   </para>
		</summary>
		<param name="name">The name of the <see langword="PInvoke"/> method. <paramref name="name"/> cannot contain embedded nulls. </param>
		<param name=" dllName">The name of the DLL in which the <see langword="PInvoke"/> method is defined. </param>
		<param name=" attributes">The attributes of the method. </param>
		<param name=" callingConvention">The method's calling convention. </param>
		<param name=" returnType">The method's return type. </param>
		<param name=" parameterTypes">The types of the method's parameters.</param>
		<param name=" nativeCallConv">The native calling convention. </param>
		<param name=" nativeCharSet">The method's native character set. </param>
		<returns>
			<para> The defined <see langword="PInvoke"/> method.
   </para>
		</returns>
		<exception cref="System.ArgumentException"><para> The method is not static. </para>
			<para>-or-</para>
			<para> The parent type is an interface.</para>
			<para>-or-</para>
			<para> The method is abstract.</para>
			<para>-or-</para>
			<para> The method was previously defined.</para>
			<para>-or-</para>
			<para> The length of <paramref name="name"/> or <paramref name="dllName"/> is zero. </para></exception>
		<exception cref="System.ArgumentNullException"><para><paramref name="name "/>or <paramref name="dllName "/>is <see langword="null"/>.</para></exception>
		<exception cref="System.InvalidOperationException">The containing type has been previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>.</exception>
		<remarks>
			<para>Some DLL import attributes (see the description of
      System.Runtime.InteropServices.DllImportAttribute) cannot be specified as
      arguments to this method. Such attributes should be set by emitting a custom
      attribute for the method. For example, the DLL import attribute
   <see langword="PreserveSig "/>
   
   is set by emitting
   a custom attribute.</para>
		</remarks>
		<example>
			<para>The following code sample demonstrates how to create a PInvoke call to a 
      specific external method signature inside a dynamic type using
   <see langword="DefinePInvokeMethod"/>.</para>
			<codelink SampleID="ModuleBuilder_DefinePInvokeMethod1" SnippetID="1"/>
		</example>
	</doc>
	<doc for="TypeBuilder.DefinePInvokeMethod1">
		<summary>
			<para> Defines a <see langword="PInvoke "/>method given its name,
   the name of the DLL in which the method is defined, the attributes of the
   method, the calling convention of the method, the return type of the method, the
   types of the parameters of the method, and the <see langword="PInvoke "/>
   
   flags.
   </para>
		</summary>
		<param name="name">The name of the <see langword="PInvoke"/> method. <paramref name="name"/> cannot contain embedded nulls. </param>
		<param name=" dllName">The name of the DLL in which the PInvoke method is defined. </param>
		<param name=" entryName">The name of the entry point in the DLL. </param>
		<param name=" attributes">The attributes of the method. </param>
		<param name=" callingConvention">The method's calling convention. </param>
		<param name=" returnType">The method's return type. </param>
		<param name=" parameterTypes">The types of the method's parameters. </param>
		<param name=" nativeCallConv">The native calling convention. </param>
		<param name=" nativeCharSet">The method's native character set.</param>
		<returns>
			<para> The defined PInvoke method.
      </para>
		</returns>
		<exception cref="System.ArgumentException"><para> The method is not static. </para><para>-or-</para><para> The parent type is an interface.</para><para>-or-</para><para> The method is abstract.</para><para>-or-</para><para> The method was previously defined.</para><para>-or-</para><para> The length of <paramref name="name"/>,
				<paramref name="dllName, "/>or <paramref name="entryName"/> is zero. </para></exception>
		<exception cref="System.ArgumentNullException"><paramref name="name, dllName"/>, or <paramref name="entryName"/> is <see langword="null"/>.</exception>
		<exception cref="System.InvalidOperationException">The containing type has been previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>.</exception>
		<remarks>
			<para>Some DLL import attributes (see the description of
      System.Runtime.InteropServices.DllImportAttribute) cannot be specified as
      arguments to this method. Such attributes should be set by emitting a custom
      attribute for the method. For example, the DLL import attribute
   <see langword="PreserveSig "/> is set by emitting a custom attribute.</para>
		</remarks>
		<example>
			<para>The following code sample demonstrates how to create a PInvoke call to a 
      specific external method signature inside a dynamic type using
   <see langword="DefinePInvokeMethod"/>.</para>
			<codelink SampleID="ModuleBuilder_DefinePInvokeMethod2" SnippetID="1"/>
		</example>
	</doc>
	<doc for="TypeBuilder.DefineMethodOverride">
		<summary>
			<para> Specifies a given method body that implements a given
      method declaration.
      </para>
		</summary>
		<param name="methodInfoBody">The method body to be used. This should be a <see langword="MethodBuilder"/> object. </param>
		<param name="methodInfoDeclaration">The method whose declaration is to be used. </param>
		<exception cref="System.ArgumentException"><paramref name="methodInfoBody"/> does not belong to this class.</exception>
		<exception cref="System.ArgumentNullException"><paramref name="methodInfoBody"/> or <paramref name="methodInfoDeclaration"/>is <see langword="null"/>.</exception>
		<exception cref="System.InvalidOperationException"><para> The type was previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>. </para>
			<para>-or-</para>
			<para> The method <paramref name="methodInfoBody"/>'s declaring type is not this type.</para></exception>
		<remarks>
			<para><see langword="DefineMethodOverride "/>defines a method impl. A
   method impl is a token point to an implementation and a token pointing to a declaration
   that the body will implement. The body must be defined on the type the
   method impl is defined and the body must be virtual. The declaration can be made
   to a method defined on an interface implemented by the type, a method on a derived
   class or a method defined in the type. If the declaration is on an interface
   only, the slot defined for the interface is altered. If the declaration is made to
   a method on a base type then the slot for the method is overridden and
   any duplicates for the overridden method are also replaced. The method
   overridden cannot be the actual method declared. If the method is on the same type then
   the slot is replaced and any duplicates for the replaced methods are overridden.
   </para>
		</remarks>
		<example>
		</example>
	</doc>
	<doc for="TypeBuilder.DefineProperty">
		<summary>
			<para> Adds a new property to the class, with the given name and property
      signature.
      </para>
		</summary>
		<param name="name">The name of the property. <paramref name="name"/> cannot contain embedded nulls. </param>
		<param name="attributes">The attributes of the property. </param>
		<param name="returnType">The return type of the property. </param>
		<param name="parameterTypes">The types of the parameters of the property. </param>
		<returns>
			<para> The defined property.
      </para>
		</returns>
		<exception cref="System.ArgumentException">The length of <paramref name="name"/> is zero.</exception>
		<exception cref="System.ArgumentNullException"><para><paramref name="name "/>is <see langword="null"/></para>
			<para>-or-</para>
			<para>if any of the elements of the <paramref name="parameterTypes"/> array is <see langword="null"/></para></exception>
		<exception cref="System.InvalidOperationException">The type was previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/></exception>
		<example>
			<para>The following code sample demonstrates how to define a dynamic property and 
      obtain a <see cref="System.Reflection.Emit.PropertyBuilder"/> for specification. Note that a
   <see langword="PropertyBuilder"/> must also have a corresponding <see cref="System.Reflection.Emit.MethodBuilder"/>, which will house the IL logic for the 
      property.</para>
			<codelink SampleID="System.Reflection.Emit.PropertyBuilder Example" SnippetID="1"/>
		</example>
	</doc>
	<doc for="TypeBuilder.DefineTypeInitializer">
		<summary>
			<para> Defines the initializer for this type.
      </para>
		</summary>
		<returns>
			<para> Returns a type initializer.
      </para>
		</returns>
		<exception cref="System.InvalidOperationException">The containing type has been previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>.</exception>
		<remarks>
			<para>The initializer created is always public.</para>
		</remarks>
		<example>
			<para>The following code sample demonstrates how to create an 
      initialization constructor using
   <see langword="DefineTypeInitializer"/>.</para>
			<codelink SampleID="TypeBuilder_Properties1" SnippetID="3"/>
		</example>
	</doc>
	<doc for="TypeBuilder.GetConstructorImpl">
		<summary>
			<para> Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</para>
		</summary>
		<param name="bindingAttr"><para>A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para><para>-or-</para><para>Zero, to conduct a case-sensitive search for public methods.</para></param>
		<param name="binder"><para>A <see cref="System.Reflection.Binder"/> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para><para>-or-</para><para><see langword="null"/>, to use the <see cref="System.Type.DefaultBinder"/>.</para></param>
		<param name="callConvention">The <see cref="System.Reflection.CallingConventions"/> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the constructor to get.</para><para>-or-</para><para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</para></param>
		<param name="modifiers">An array of <see cref="System.Reflection.ParameterModifier"/> objects representing the attributes associated with the corresponding element in the <paramref name="types"/> array.</param>
		<returns>
			<para>A <see cref="System.Reflection.ConstructorInfo"/> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.NotSupportedException">This method is not implemented for incomplete type. </exception>
		<remarks>
			<para> Retrieve the type using <see cref="System.Type.GetType"/> or <see cref="System.Reflection.Assembly.GetType"/> and use reflection on the retrieved type. </para>
		</remarks>
	</doc>
	<doc for="TypeBuilder.GetAttributeFlagsImpl">
		<summary>
			<para> Returns the implementation attribute flags.
      </para>
		</summary>
		<returns>
			<para> Returns the implementation attribute flags.
      </para>
		</returns>
		<example>
		</example>
	</doc>
	<doc for="TypeBuilder.DefineInitializedData">
		<summary>
			<para> Defines initialized data field in the .sdata section of
      the portable executable (PE) file.
      </para>
		</summary>
		<param name="name">The name used to refer to the data. <paramref name="name"/> cannot contain embedded nulls. </param>
		<param name=" data">The blob of data. </param>
		<param name=" attributes">The attributes for the field. </param>
		<returns>
			<para> A field to reference the data.
      </para>
		</returns>
		<exception cref="System.ArgumentException"><para> Length of <paramref name="name"/> is zero.</para>
			<para>-or-</para>
			<para>The size of the data is less than or equal to zero or greater than or equal to 0x3f0000.</para></exception>
		<exception cref="System.ArgumentNullException"><paramref name="name "/>or <paramref name="data"/>is <see langword="null"/>.</exception>
		<exception cref="System.InvalidOperationException"><see cref="System.Reflection.Emit.TypeBuilder.CreateType"/> has been previously called. </exception>
		<remarks>
			<para>The field that you create with this method will be <see langword="static"/>, 
   even if you do not include <see langword="FieldAttributes.Static"/> in the
<paramref name="attributes"/> parameter.</para>
		</remarks>
	</doc>
	<doc for="TypeBuilder.DefineUninitializedData">
		<summary>
			<para> Defines uninitialized data field in the .sdata section of
      the portable executable (PE) file.
      </para>
		</summary>
		<param name="name">The name used to refer to the data. <paramref name="name"/> cannot contain embedded nulls. </param>
		<param name="size">The size of the data field. </param>
		<param name="attributes">The attributes for the field. </param>
		<returns>
			<para> A field to reference the data.
      </para>
		</returns>
		<exception cref="System.ArgumentException"><para> Length of <paramref name="name"/> is zero.</para>
			<para>-or-</para>
			<para><paramref name="size"/> is less than or equal to zero or greater than or equal to 0x003f0000.</para></exception>
		<exception cref="System.ArgumentNullException"><paramref name="name "/>is <see langword="null"/>.</exception>
		<exception cref="System.InvalidOperationException">The type was previously created using <see cref="System.Reflection.Emit.TypeBuilder.CreateType"/>.</exception>
		<remarks>
			<para>The field that you create with this method will be <see langword="static"/>, 
   even if you do not include <see langword="FieldAttributes.Static"/> in the
<paramref name="attributes"/> parameter.</para>
		</remarks>
		<example>
			<para>The following code sample demonstrates the use of
   <see langword="DefineUninitializedData"/> to create an uninitialized data field
      in a dynamic type:</para>
			<codelink SampleID="TypeBuilder_DefineUninitializedData" SnippetID="1"/>
		</example>
	</doc>
	<doc for="TypeBuilder">
		<summary>
			<para> Defines and
      
      creates new instances of classes
      during runtime.</para>
		</summary>
		<threadsafe>
			<para>Reflection Emit is thread-safe when using assemblies that were created with
      the <see cref="System.AppDomain.DefineDynamicAssembly" qualify="true"/> method with the Boolean parameter
   <paramref name="isSynchronized"/> set to <see langword="true"/>.</para>
		</threadsafe>
		<remarks>
			<para><see langword="TypeBuilder "/>is the root class used to control the creation
   of dynamic classes in the runtime. <see langword="TypeBuilder "/> provides a
   set of routines that are used to define classes, add methods and fields, and
   create the class inside the runtime. A new <see langword="TypeBuilder "/>can be
   created from a dynamic module.</para>
			<para>To retrieve a <see cref="System.Type"/> object for an incomplete type, use 
<see cref="System.Reflection.Emit.ModuleBuilder.GetType" qualify="true"/> with a string representing the type name, such
as "MyType" or "MyType[]".</para>
		</remarks>
		<example>
			<para>The following code sample demonstrates how to build a dynamic type using
   <see langword="TypeBuilder"/>.</para>
			<codelink SampleID="System.Reflection.Emit ILGenerator Example" SnippetID="1"/>
		</example>
	</doc>
	<doc for="PackingSize">
		<summary>
			<para> Specifies one of two factors that determine the memory 
      alignment of fields when
      a type is marshaled.</para>
		</summary>
		<remarks>
			<para>Packing size affects the alignment of fields in structures and classes whose 
      organization is <see cref="System.Runtime.InteropServices.LayoutKind.Sequential" qualify="true"/>. The packing size is one of two
      factors that determine the offset of a field when the structure or class is
      marshaled; the other factor is the effective size of the field. To determine the
      offset of a field:</para>
			<list type="number"><item>
					<term>Compute the minimum value for the offset by adding the size of the 
         preceding field to the offset of the preceding field.</term>
				</item>
				<item>
					<term>Compute the natural packing size for the field: If the field is a simple 
         data type, use the size. If the field is an array, use the size of an array
         element. If the field is itself a structure, compare the packing size of that
         structure to the size of the largest field in that structure, and use the
         smaller of the two values.</term>
				</item>
				<item>
					<term>Compute the effective packing size by comparing the packing size to the 
         natural packing size of the field, computed in step 2. Use the smaller of the
         two numbers.</term>
				</item>
				<item>
					<term>Compute the offset. The offset is the first memory location that is equal 
         to or larger than the minimum, and a multiple of the effective packing size
         computed in step 3.</term>
				</item>
			</list>
			<note type="note">
   Once offsets have been computed
   for all the fields in the class or structure, padding is added so that the
   overall size is a multiple of the packing size.
</note>
			<para>For example, in a class containing a <see langword="byte"/> and a 
<see langword="long"/>, using packing size <see langword="Size1"/>, the offset of 
the <see langword="byte"/> field is zero (0) and the offset of
the <see langword="long"/> field is one (1). If the packing size is
<see langword="Size4"/>, the <see langword="long"/> field has offset four 
(4). In a class containing two <see langword="short"/> fields, using any
packing size, the offset of the second <see langword="short"/> field is two
(2).</para>
			<note type="note">
   Changing the packing size can
   affect performance if it causes fields to be aligned on offsets that are not
   multiples of their size.
</note>
		</remarks>
	</doc>
</docs>
