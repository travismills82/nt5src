<docs>
	<doc for="OpCodes.OpCodes">
		<summary>
			<para>
       The IL instruction opcodes supported by the
       runtime. The IL Instruction Specification describes each
       Opcode.
    </para>
		</summary>
		<seealso topic="IL Instruction Set       Specification"/>
	</doc>
	<doc for="OpCodes.Prefix7">
		<summary>
			<para>This is a reserved instruction.</para>
		</summary>
		<remarks>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term></term>
					<description>prefix7</description>
					<description></description>
				</item>
			</list>
			<para> This instruction is reserved and currently unused. 
      Emitting this instruction will generate an error.</para>
		</remarks>
	</doc><doc for="OpCodes.Prefix6">
		<summary>
			<para>This is a reserved instruction.</para>
		</summary>
		<remarks>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term></term>
					<description>prefix6</description>
					<description></description>
				</item>
			</list>
			<para> This instruction is reserved and currently unused. 
      Emitting this instruction will generate an error.</para>
		</remarks>
	</doc><doc for="OpCodes.Prefix5">
		<summary>
			<para>This is a reserved instruction.</para>
		</summary>
		<remarks>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term></term>
					<description>prefix5</description>
					<description></description>
				</item>
			</list>
			<para>This instruction is reserved and currently unused. 
      Emitting this instruction will generate an error.</para>
		</remarks>
	</doc><doc for="OpCodes.Prefix4">
		<summary>
			<para>This is a reserved instruction.</para>
		</summary>
		<remarks>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term></term>
					<description>prefix4</description>
					<description></description>
				</item>
			</list>
			<para>This instruction is reserved and currently unused. 
      Emitting this instruction will generate an error.</para>
		</remarks>
	</doc><doc for="OpCodes.Prefix3">
		<summary>
			<para>This is a reserved instruction.</para>
		</summary>
		<remarks>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term></term>
					<description>prefix3</description>
					<description></description>
				</item>
			</list>
			<para> This instruction is reserved and currently unused. 
      Emitting this instruction will generate an error.</para>
		</remarks>
	</doc><doc for="OpCodes.Prefix2">
		<summary>
			<para>This is a reserved instruction.</para>
		</summary>
		<remarks>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term></term>
					<description>prefix2</description>
					<description></description>
				</item>
			</list>
			<para> This instruction is reserved and currently unused. 
      Emitting this instruction will generate an error.</para>
		</remarks>
	</doc><doc for="OpCodes.Prefix1">
		<summary>
			<para>This is a reserved instruction.</para>
		</summary>
		<remarks>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term></term>
					<description>prefix1</description>
					<description></description>
				</item>
			</list>
			<para> This instruction is reserved and currently unused. 
      Emitting this instruction will generate an error.</para>
		</remarks>
	</doc><doc for="OpCodes.Prefixref">
		<summary>
			<para>This is a reserved instruction.</para>
		</summary>
		<remarks>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term></term>
					<description>prefixref</description>
					<description></description>
				</item>
			</list>
			<para> This instruction is reserved and currently unused. 
      Emitting this instruction will generate an error.</para>
		</remarks>
	</doc><doc for="OpCodes.Arglist">
		<summary>
			<para>Returns an unmanaged pointer to the argument list of the current method.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's
      hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along
      with a brief reference summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE 00</term>
					<description>arglist</description>
					<description>Returns an argument list handle for the
            current method.</description>
				</item>
			</list>
			<para>No evaluation stack behaviors are performed by this operation.</para>
			<para>The <see langword="arglist"/>
instruction returns an opaque handle (an unmanaged pointer, of type
<see langword="natural int"/> 
) that represents the argument list of the current
method. This handle is valid only during the lifetime of the current method. You can,
however, pass the handle to other methods as long as the current method is
on the thread of control. You can only execute the <see langword="arglist"/>
instruction within a method
that takes a variable number of arguments.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="arglist"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.And">
		<summary>
			<para> Computes the bitwise AND of two values
      and pushes the result onto the evalution stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Instruction</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 5F</term>
					<description>and</description>
					<description> Determines the bitwise AND of
            two integer values.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value1"/> and <paramref name="value2"/> are popped from the stack; the bitwise AND of 
         the two values is computed.</term>
				</item>
				<item>
					<term>
         
         The result is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="and"/> instruction computes the bitwise AND of the top 
two values on the stack and leaves the result on the stack. </para>
			<para><see langword="And"/> is an integer-specific operation.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="and"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Div_Un">
		<summary>
			<para>Divides two unsigned integer values and pushes the result
      (<see langword="int32"/>) onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 5C</term>
					<description>div.un</description>
					<description>Divides two values, unsigned, returning a
            quotient.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term><paramref name="value1"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term><paramref name="value2"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term><paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; <paramref name="value1"/> 
is divided by <paramref name="value2"/>.</term>
				</item>
				<item>
					<term>The result is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="div.un"/> instruction computes <paramref name="value1"/> divided by
<paramref name="value2"/>, both taken as unsigned integers, and pushes the <paramref name="result"/> 
on the stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="div.un"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Cpobj">
		<summary>
			<para> Copies the value type located at the address of an object
      (type <see langword="&amp;"/>,<see langword="*"/> or
   <see langword="natural int"/>) to the address of the destination object (type
   <see langword="&amp;"/>,<see langword="*"/> or <see langword="natural int"/>).</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 70
            &lt;<see langword="T"/>&gt;</term>
					<description>cpobj<paramref name=" classTok"/></description>
					<description>Copies a value type from a source object to
         a destination object.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      The destination object reference is pushed onto the
      stack.</term>
				</item>
				<item>
					<term>
      The source object reference is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      The two object references are popped from the stack; the value type at the
      address of the source object is copied to the address of the destination
      object.</term>
				</item>
			</list>
			<para> The behavior of <see langword="cpobj "/>is unspecified if the source and destination object references are not
pointers to instances of the
class represented by the class token <paramref name="classTok"/> (a
<see langword="typeref"/> or <see langword="typedef"/>), or if <paramref name="classTok"/> 
does not represent a value type.</para>
			<para><see cref="System.NullReferenceException"/>may be thrown if an invalid address is detected. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="cpobj"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Type)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Dup">
		<summary>
			<para>Copies the current topmost value on the evaluation stack, and then pushes
      the copy onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 25</term>
					<description>dup</description>
					<description>Duplicates the value on the top of the
            stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped off of 
         the stack for duplication.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is pushed back onto 
         the stack.</term>
				</item>
				<item>
					<term>
         
         A duplicate value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="dup"/> instruction duplicates the top 
element of the stack, and leaves two identical values atop it.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="dup"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Jmp">
		<summary>
			<para>Exits current method and jumps to specified method.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 27
            &lt;<see langword="T"/>&gt;</term>
					<description>jmp<paramref name=" method"/></description>
					<description>Exit
         current method and jump to specified method.</description>
				</item>
			</list>
			<para>There are no stack transition behaviors for this instruction.</para>
			<para>The <see langword="jmp"/> (jump) instruction transfers control to the method specified by
<paramref name="method"/>, which is a metadata token for a method reference. The 
current arguments are transferred to the destination method.</para>
			<para>The evaluation stack must be empty when this instruction is executed. The
   calling convention, number and type of arguments at the destination address must
   match that of the current method. </para>
			<para>The <see langword="jmp"/> instruction cannot be used to transferred control
out of a <see langword="try"/>, <see langword="filter"/>, <see langword="catch"/>,
or <see langword="finally"/> block.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="jmp"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, MethodInfo)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldarg_0">
		<summary>
			<para>Loads the argument at index 0 onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 02</term>
					<description>ldarg.0</description>
					<description>Load
            argument 0 onto stack</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>The argument value at index 0 is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldarg.0"/> instruction is an efficient
encoding for loading the argument value at index 0.</para>
			<para>The <see langword="ldarg.0"/> instruction pushes the argument indexed at 0
onto the evaluation stack. The <see langword="ldarg.0"/> instruction can be used to load a
value type or a primitive value onto the stack by copying it from an incoming
argument. The type of the argument value is the same as the type of the
argument, as specified by the current method's signature.</para>
			<para>Arguments that hold an integer value smaller than 4 bytes long are expanded
   to type <see langword="int32"/> when they are loaded onto the stack.
   Floating-point values are expanded to their native size (type
<see langword="F"/>). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldarg.0"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldarg_1">
		<summary>
			<para>Loads the argument at index 1 onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 03</term>
					<description>ldarg.1</description>
					<description>Load
            argument 1 onto stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>The argument value at index 1 is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldarg.1"/> instruction is an efficient encoding for loading
the argument value at index 1.</para>
			<para>The <see langword="ldarg.1"/>
instruction pushes the argument indexed at 1
onto the evaluation stack. The <see langword="ldarg.1"/> instruction can be used to load a
value type or a primitive value onto the stack by copying it from an incoming
argument. The type of the argument value is the same as the type of the
argument, as specified by the current method's signature.</para>
			<para>Arguments that hold an integer value smaller than 4 bytes long are expanded
   to type <see langword="int32"/> when they are loaded onto the stack.
   Floating-point values are expanded to their native size (type
<see langword="F"/>). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldarg.1"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldarg_2">
		<summary>
			<para>Loads the argument at index 2 onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 04</term>
					<description>ldarg.2</description>
					<description> Load argument 2 onto stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>The argument value at index 2 is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldarg.2"/> instruction is an efficient encoding for loading
the argument value at index 2.</para>
			<para>The <see langword="ldarg.2"/>
instruction pushes the argument indexed at 2
onto the evaluation stack. The <see langword="ldarg.2"/> instruction can be used to load a
value type or a primitive value onto the stack by copying it from an incoming
argument. The type of the argument value is the same as the type of the
argument, as specified by the current method's signature.</para>
			<para>Arguments that hold an integer value smaller than 4 bytes long are expanded
   to type <see langword="int32"/> when they are loaded onto the stack.
   Floating-point values are expanded to their native size (type
<see langword="F"/>). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldarg.2"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldarg_3">
		<summary>
			<para>Loads the argument at index 3 onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 05</term>
					<description>ldarg.3</description>
					<description> Load argument 3 onto stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>The argument value at index 3 is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldarg.3"/> instruction is an efficient encoding for loading
the argument value at index 3.</para>
			<para>The <see langword="ldarg.3"/>
instruction pushes the argument indexed at 3
onto the evaluation stack. The <see langword="ldarg.3"/> instruction can be used to load a
value type or a primitive value onto the stack by copying it from an incoming
argument. The type of the argument value is the same as the type of the
argument, as specified by the current method's signature.</para>
			<para>Arguments that hold an integer value smaller than 4 bytes long are expanded
   to type <see langword="int32"/> when they are loaded onto the stack.
   Floating-point values are expanded to their native size (type
<see langword="F"/>). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldarg.3"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldarg">
		<summary>
			<para>Loads an argument (referenced by a specified index 
      value) onto the stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            09 &lt;<see langword="unsigned int16"/>&gt;</term>
					<description>ldarg<paramref name=" index"/></description>
					<description>Load
         argument at <paramref name="index"/> onto stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      The argument value at <paramref name="index"/> is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldarg"/> instruction pushes the argument indexed at
<paramref name="index"/>, where arguments are indexed from 0 onwards, onto the 
evaluation stack. The <see langword="ldarg"/> instruction can be used to load a value type
or a primitive value onto the stack by copying it from an incoming argument. The
type of the argument value is the same as the type of the argument, as specified
by the current method's signature.</para>
			<para>For procedures that take a variable-length argument list, the
<see langword="ldarg"/> instruction can be used only for the initial fixed 
   arguments, not those in the variable part of the signature (see the <see cref="System.Reflection.Emit.OpCodes.Arglist"/> instruction for more details). </para>
			<para>Arguments that hold an integer value smaller than 4 bytes long are expanded
   to type <see langword="int32"/> when they are loaded onto the stack.
   Floating-point values are expanded to their native size (type
<see langword="F"/>). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldarg"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, short)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldarg_S">
		<summary>
			<para>Loads the argument (referenced by a specified short form index)
      onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 0E &lt;<see langword="unsigned int8"/>&gt;</term>
					<description>ldarg.s<paramref name=" index"/></description>
					<description>Load argument at <paramref name="index"/> onto stack,
   short form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      The argument value at <paramref name="index"/> is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldarg.s"/> instruction is an efficient encoding for loading
arguments indexed from 4 through 255.</para>
			<para>The <see langword="ldarg.s"/> instruction pushes the argument indexed at
<paramref name="index"/>, where arguments are indexed from 0 onwards, onto the 
evaluation stack. The <see langword="ldarg.s"/> instruction can be used to load a
value type or a primitive value onto the stack by copying it from an incoming
argument. The type of the argument value is the same as the type of the
argument, as specified by the current method's signature.</para>
			<para>For procedures that take a variable-length argument list, the
<see langword="ldarg.s"/> instruction can be used only for the initial fixed 
   arguments, not those in the variable part of the signature (see the <see cref="System.Reflection.Emit.OpCodes.Arglist"/> instruction for more details). </para>
			<para>Arguments that hold an integer value smaller than 4 bytes long are expanded
   to type <see langword="int32"/> when they are loaded onto the stack.
   Floating-point values are expanded to their native size (type
<see langword="F"/>). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldarg.s"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, byte)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldc_I4_M1">
		<summary>
			<para>Pushes the integer value of -1 onto the evaluation stack
      as an <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 15</term>
					<description>ldc.i4.m1</description>
					<description>Pushes -1 onto the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The value -1 is pushed onto the stack.</term>
				</item>
			</list>
			<para>This is a special short encoding for the push of the integer value 0. All
   special short encodings push 4 byte integers on the stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldc.i4.m1"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldc_I4_0">
		<summary>
			<para>Pushes the integer value of 0 onto the evaluation
      stack as an <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 16</term>
					<description>ldc.i4.0</description>
					<description>Pushes 0 onto the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The value 0 is pushed onto the stack.</term>
				</item>
			</list>
			<para> This is a special short encoding for the
   push of the integer value 0. All special short encodings push 4 byte integers on
   the stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldc.i4.0"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldc_I4_1">
		<summary>
			<para> Pushes the integer value of 1 onto the evaluation stack
      as an <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 17</term>
					<description>ldc.i4.1</description>
					<description>Pushes 1 onto the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The value 1 is pushed onto the stack.</term>
				</item>
			</list>
			<para>This is a special short encoding for the push of the integer value 0. All
   special short encodings push 4 byte integers on the stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldc.i4.1"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldc_I4_2">
		<summary>
			<para> Pushes the integer value of 2 onto the evaluation stack
      as an <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 18</term>
					<description>ldc.i4.2</description>
					<description>Pushes 2 onto the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The value 2 is pushed onto the stack.</term>
				</item>
			</list>
			<para>This is a special short encoding for the push of the integer value 0. All
   special short encodings push 4 byte integers on the stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldc.i4.2"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldc_I4_3">
		<summary>
			<para> Pushes the integer value of 3 onto the evaluation stack
      as an <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 19</term>
					<description>ldc.i4.3</description>
					<description>Pushes 3 onto the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The value 3 is pushed onto the stack.</term>
				</item>
			</list>
			<para>This is a special short encoding for the push of the integer value 0. All
   special short encodings push 4 byte integers on the stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldc.i4.3"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldc_I4_4">
		<summary>
			<para> Pushes the integer value of 4 onto the evaluation stack
      as an <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 1A</term>
					<description>ldc.i4.4</description>
					<description>Pushes 4 onto the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The value 4 is pushed onto the stack.</term>
				</item>
			</list>
			<para>This is a special short encoding for the push of the integer value 0. All
   special short encodings push 4 byte integers on the stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldc.i4.4"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldc_I4_5">
		<summary>
			<para> Pushes the integer value of 5 onto the evaluation stack
      as an <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 1B</term>
					<description>ldc.i4.5</description>
					<description>Pushes 5 onto the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The value 5 is pushed onto the stack.</term>
				</item>
			</list>
			<para>This is a special short encoding for the push of the integer value 0. All
   special short encodings push 4 byte integers on the stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldc.i4.5"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldc_I4_6">
		<summary>
			<para> Pushes the integer value of 6 onto the evaluation stack
      as an <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 1C</term>
					<description>ldc.i4.6</description>
					<description>Pushes 6 onto the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The value 6 is pushed onto the stack.</term>
				</item>
			</list>
			<para>This is a special short encoding for the push of the integer value 0. All
   special short encodings push 4 byte integers on the stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldc.i4.6"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldc_I4_7">
		<summary>
			<para> Pushes the integer value of 7 onto the evaluation stack
      as an <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 1D</term>
					<description>ldc.i4.7</description>
					<description>Pushes 7 onto the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The value 7 is pushed onto the stack.</term>
				</item>
			</list>
			<para>This is a special short encoding for the push of the integer value 0. All
   special short encodings push 4 byte integers on the stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldc.i4.7"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldc_I4_8">
		<summary>
			<para> Pushes the integer value of 8 onto the evaluation stack
      as an <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 1E</term>
					<description>ldc.i4.8</description>
					<description>Pushes 8 onto the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The value 8 is pushed onto the stack.</term>
				</item>
			</list>
			<para>This is a special short encoding for the push of the integer value 0. All
   special short encodings push 4 byte integers on the stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldc.i4.8"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldc_I4_S">
		<summary>
			<para>Pushes the supplied <see langword="int8"/> value onto the evaluation stack as an
<see langword="int32"/>, short form.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 1F
            &lt;<see langword="int8"/>&gt;</term>
					<description>ldc.i4.s <paramref name="num"/></description>
					<description>Pushes <paramref name="num"/> onto the stack as <see langword="int32"/>,
      short form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      The value <paramref name="num"/> is pushed onto the stack.</term>
				</item>
			</list>
			<para><see langword="ldc.i4.s"/> is a more
efficient encoding for pushing the
integers from -127 to 128 onto the evaluation stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldc.i4.s"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, byte)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldc_I4">
		<summary>
			<para>Pushes a supplied value of
      type <see langword="int32"/> onto the evaluation stack as an
   <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 20
            &lt;<see langword="int32"/>
            
            &gt;</term>
					<description>ldc.i4 <paramref name="num"/></description>
					<description>Pushes the value <paramref name="num"/> onto the
      stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The value <paramref name="num"/> is pushed onto the stack.</term>
				</item>
			</list>
			<para>Note that there are special short (and hence more 
   efficient) encodings for the integers -128 through 127, and especially short
   encodings for -1 through 8. All short encodings push 4 byte integers on the
   stack. Longer encodings are used for 8 byte integers and 4 and 8 byte
   floating-point numbers, as well as 4-byte values that do not fit in the short
   forms. There are three ways to push an 8 byte integer constant onto the stack</para>
			<para>1. Use the <see cref="System.Reflection.Emit.OpCodes.Ldc_I8"/> instruction for constants that must be
expressed in more than 32 bits.</para>
			<para>2. Use the <see cref="System.Reflection.Emit.OpCodes.Ldc_I4"/> instruction followed by 
a <see cref="System.Reflection.Emit.OpCodes.Conv_I8"/> for
constants that require 9 to 32 bits.</para>
			<para>3. Use a short form instruction followed by a <see cref="System.Reflection.Emit.OpCodes.Conv_I8"/> 
for constants that can be expressed in 8 or fewer bits.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldc.i4"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, int)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldc_I8">
		<summary>
			<para>Pushes a supplied value of type <see langword="int64"/> onto the evaluation stack as an
<see langword="int64"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 21
            &lt;<see langword="int64"/>&gt;</term>
					<description>ldc.i8 <paramref name="num"/></description>
					<description>Pushes <paramref name="num"/> onto the stack 
      as <see langword="int64"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The value <paramref name="num"/> is pushed onto the stack.</term>
				</item>
			</list>
			<para>This encoding pushes an <see langword="int64"/> value onto
the stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldc.i8"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, long)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldc_R4">
		<summary>
			<para>Pushes a supplied value of type <see langword="float32"/> onto the
   evaluation stack as type <see langword="F"/> (float).</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 22
            &lt;<see langword="float32"/>&gt;</term>
					<description>ldc.r4 <paramref name="num"/></description>
					<description>Pushes <paramref name="num"/> onto the stack 
      as <see langword="F"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The value <paramref name="num"/> is pushed onto the stack.</term>
				</item>
			</list>
			<para>This encoding pushes a <see langword="float32"/> value
onto the stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldc.r4"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, single)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldc_R8">
		<summary>
			<para>Pushes a supplied value of type <see langword="float64 "/> onto the
   evaluation stack as type <see langword="F"/> (float).</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 23
            &lt;<see langword="float64"/>&gt;</term>
					<description>ldc.r8 <paramref name="num"/></description>
					<description>Pushes <paramref name="num"/> onto the stack 
      as <see langword="F"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The value <paramref name="num"/> is pushed onto the stack.</term>
				</item>
			</list>
			<para>This encoding pushes a <see langword="float64"/> value
onto the stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldc.r8"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, double)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldlen">
		<summary>
			<para>Pushes the number of elements of a
      zero-based, one-dimensional array onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 8E</term>
					<description>ldlen</description>
					<description>Pushes the length (of type <see langword="natural unsigned int"/>) of an array on the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      An object reference to an array is pushed onto the
      stack.</term>
				</item>
				<item>
					<term>
      The array reference <paramref name=""/>is popped
      from the stack and the length is computed.</term>
				</item>
				<item>
					<term>
      The length is pushed onto the stack.</term>
				</item>
			</list>
			<para>Arrays are objects and hence represented by a value of type
<see langword="O"/>. The length is 
   returned as a <see langword="natural unsigned int"/>
   .</para>
			<para><see cref="System.NullReferenceException"/> is thrown if the array
reference is a null reference. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldlen"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldftn">
		<summary>
			<para>Pushes an unmanaged pointer (type
   <see langword="natural int"/>) to the native code implementing a
      specific method onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            06 &lt;<see langword="T"/>&gt;</term>
					<description>ldftn<paramref name=" method"/></description>
					<description>Pushes a pointer to a method referenced by
      <paramref name="method"/> on the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      The unmanaged pointer to a specific method is pushed onto the stack.</term>
				</item>
			</list>
			<para>The specific method (<paramref name="method"/>) can be called using
the <see cref="System.Reflection.Emit.OpCodes.Calli"/>
instruction if it references a managed method (or a stub that transitions from
managed to unmanaged code).</para>
			<para>The value returned points to native code using the
   calling convention specified by the <paramref name="method "/>metadata token. Thus, a method pointer can be easily passed to unmanaged
   native code (specifically, as a callback routine). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldftn"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, MethodInfo)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldloc_0">
		<summary>
			<para>Loads the local variable at index 0 onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 06</term>
					<description>ldloc.0</description>
					<description>Loads the local variable at index 0 onto the
            evaluation stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The local variable value at the index 0 is pushed onto the 
         stack.</term>
				</item>
			</list>
			<para><see langword="ldloc.0"/> is an especially efficient
encoding for <see cref="System.Reflection.Emit.OpCodes.Ldloc"/>, allowing access to the local variable
at index 0.</para>
			<para> The type of the value is the same as the type of the local
   variable, which is specified in the method header. Local variables that are
   smaller than 4 bytes long are expanded to type <see langword="int32"/> when they
   are loaded onto the stack. Floating-point values are expanded to their native
   size (type <see langword="F"/>). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldloc.0"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldloc_1">
		<summary>
			<para>Loads the local variable at index 1 onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 07</term>
					<description>ldloc.1</description>
					<description> Loads the local variable at index 1 onto the
            evaluation stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The local variable value at the index 1 is pushed onto the 
         stack.</term>
				</item>
			</list>
			<para><see langword="ldloc.1"/> is an especially efficient encoding for <see cref="System.Reflection.Emit.OpCodes.Ldloc"/>, allowing access to the local
variable at index 1.</para>
			<para> The type of the value is the same as the type of the local
   variable, which is specified in the method header. Local variables that are
   smaller than 4 bytes long are expanded to type <see langword="int32"/> when they
   are loaded onto the stack. Floating-point values are expanded to their native
   size (type <see langword="F"/>). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldloc.1"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldloc_2">
		<summary>
			<para>Loads the local variable at index 2 onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 08</term>
					<description>ldloc.2</description>
					<description>Loads the local variable at index 2 onto the
            evaluation stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         The local variable value at the index 2 is pushed onto the
         stack.</term>
				</item>
			</list>
			<para><see langword="ldloc.2"/> is an especially efficient encoding for <see cref="System.Reflection.Emit.OpCodes.Ldloc"/>, allowing access to the local
variable at index 2.</para>
			<para> The type of the value is the same as the type of the local
   variable, which is specified in the method header. Local variables that are
   smaller than 4 bytes long are expanded to type <see langword="int32"/> when they
   are loaded onto the stack. Floating-point values are expanded to their native
   size (type <see langword="F"/>). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldloc.2"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldloc_3">
		<summary>
			<para>Loads the local variable at index 3 onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 09</term>
					<description>ldloc.3</description>
					<description>Loads the local variable at index 3 onto the
            evaluation stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The local variable value at the index 3 is pushed onto the 
         stack.</term>
				</item>
			</list>
			<para><see langword="ldloc.3"/> is an especially efficient encoding for <see cref="System.Reflection.Emit.OpCodes.Ldloc"/>, allowing access to the local
variable at index 3.</para>
			<para> The type of the value is the same as the type of the local
   variable, which is specified in the method header. Local variables that are
   smaller than 4 bytes long are expanded to type <see langword="int32"/> when they
   are loaded onto the stack. Floating-point values are expanded to their native
   size (type <see langword="F"/>). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldloc.3"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldloca">
		<summary>
			<para>Loads the address of the local variable at a specific
      index onto the evaluation
      stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            OD &lt;<see langword="unsigned int16"/>&gt;</term>
					<description>ldloca<paramref name=" index"/></description>
					<description>Loads the address of the local variable at
      <paramref name="index"/> onto the evaluation stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The address stored in the local variable at the specified index is pushed 
      onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldloca"/>
instruction pushes the address of the
local variable number at the passed index onto the stack, where local variables
are numbered 0 onwards. The value pushed on the stack is already aligned
correctly for use with instructions like <see cref="System.Reflection.Emit.OpCodes.Ldind_I"/> and <see cref="System.Reflection.Emit.OpCodes.Stind_I"/>. The result is a
transient pointer (type <see langword="*"/>
).</para>
			<para> The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldloca"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, short)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldloca_S">
		<summary>
			<para>Loads the address of the local variable at a specific
      index onto the evaluation
      stack, short form.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 12
            &lt;<see langword="unsigned int8"/>&gt;</term>
					<description>ldloca.s <paramref name="index"/></description>
					<description>Loads the address of the local variable at
      <paramref name="index"/> onto the evaluation stack, short
         form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      The address stored in the local variable at the specified index is pushed
      onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldloca.s"/> instruction pushes the address of the local
variable number at the passed index onto the stack, where local variables are
numbered 0 onwards. The value pushed on the stack is already aligned correctly
for use with instructions like <see cref="System.Reflection.Emit.OpCodes.Ldind_I"/> and <see cref="System.Reflection.Emit.OpCodes.Stind_I"/>. The result is a transient
pointer (type <see langword="*"/> ).</para>
			<para>The <see langword="ldloca.s"/> instruction provides an efficient encoding
for use with the local variables 0 through 255.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldloca.s"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, byte)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Pop">
		<summary>
			<para>Removes the value currently on top of the evaluation
      stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 26</term>
					<description>pop</description>
					<description>Pops the top value from the
            stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The top value is popped from the stack.</term>
				</item>
			</list>
			<para>The <see langword="pop"/> instruction removes the top 
element from the stack.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="pop"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Mul">
		<summary>
			<para> Multiplies two values and pushes the result on the
      evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 5A</term>
					<description>mul</description>
					<description>Multiplies two values on the
            stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term><paramref name="value1"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term><paramref name="value2"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term><paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; <paramref name="value1"/> 
is multiplied by <paramref name="value2"/>.</term>
				</item>
				<item>
					<term>The result is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="mul"/> instruction multiplies <paramref name="value1"/> by
<paramref name="value2"/> and pushes 
the result<paramref name=" "/>on the stack. Integer operations silently truncate
the upper bits on overflow.</para>
			<para>See <see cref="System.Reflection.Emit.OpCodes.Mul_Ovf"/> for an
integer-specific multiply operation with overflow
handling. </para>
			<para>For floating-point types, 0 * infinity = NaN. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="mul"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Or">
		<summary>
			<para>Compute the bitwise complement of the two integer values
      on top of the stack and pushes the result onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 60</term>
					<description>or</description>
					<description>Computes the bitwise OR of two integer values, returns an
            integer.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term><paramref name="value2"/> and <paramref name="value1"/> are popped from the 
      stack and their bitwise OR computed.</term>
				</item>
				<item>
					<term>
      The result is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="or"/> instruction 
computes the bitwise OR of two values atop the stack, pushing the result onto the stack.</para>
			<para><see langword="Or"/> is an integer-specific operation.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="or"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Not">
		<summary>
			<para>Computes the bitwise complement of the integer value on top of the stack and
      pushes the result onto the evaluation stack as the same type.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 66</term>
					<description>not</description>
					<description>Computes the bitwise complement of a value.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
         stack and its bitwise complement computed.</term>
				</item>
				<item>
					<term>
         
         The result is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="not"/> instruction 
computes the bitwise complement of an integer value and pushes the result onto
the stack. The return type is the
same as the operand type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="not"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldstr">
		<summary>
			<para> Pushes
      a new object reference to a string literal stored in the metadata.
   </para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 72
            &lt;<see langword="T"/>&gt;</term>
					<description>ldstr <paramref name="mdToken"/></description>
					<description>Pushes a string object for the metadata string
         token <paramref name="mdToken"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      An object reference to a string is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldstr"/>
instruction pushes an object reference (type <see langword="O"/>) to a new string object representing the
specific string literal stored in the metadata. The <see langword="ldstr"/> instruction allocates the requisite amount of
memory and performs any format conversion required to convert the string literal
from the form used in the file to the string format required at runtime.</para>
			<para>The Common Language Infrastructure (CLI) guarantees that the result of two <see langword="ldstr"/> instructions
referring to two metadata tokens that have the same sequence of characters
return precisely the same string object (a process known as "string interning"). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldstr"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, string)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Mul_Ovf_Un">
		<summary>
			<para>Multiplies two unsigned integer values, performs an overflow check, and pushes
   the result onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> D9</term>
					<description>mul.ovf.un</description>
					<description>Multiplies two unsigned values on the stack with an overflow
            check.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term><paramref name="value1"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term><paramref name="value2"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term><paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; <paramref name="value1"/> 
is multiplied by <paramref name="value2"/>, with an overflow check.</term>
				</item>
				<item>
					<term>The result is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="mul.ovf.un"/> instruction multiplies unsigned integer <paramref name="value1"/> by unsigned integer <paramref name="value2"/> and pushes the result<paramref name=" "/>on the stack. An exception is thrown if
the result will not fit in the result type. </para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be
represented in the result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="mul.ovf.un"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Starg_S">
		<summary>
			<para>Stores the value on top of the evaluation stack in the
      argument slot at a specified index, short
      form.
			</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 10
            &lt;<see langword="unsigned int8"/>&gt;</term>
					<description>starg.s <paramref name="num"/></description>
					<description>Pops
         the top value from the stack and stores it in argument slot
      <paramref name="num"/>, short form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>The value currently on top of the stack is popped and placed in argument 
      slot <paramref name="num"/>.</term>
				</item>
			</list>
			<para>The <see langword="starg.s"/> instruction pops a value
from the stack and places it in argument slot <paramref name="num"/>.
The type of the value must match the type of the argument, as specified in the
current method's signature.</para>
			<para>The <see langword="starg.s"/> instruction provides an efficient encoding for
use with the first 256 arguments. </para>
			<para>For procedures that take a variable argument list, the
<see langword="starg.s"/> instruction can be used only for the initial fixed 
   arguments, not those in the variable part of the signature. </para>
			<para>Performing a store into arguments that hold an integer value smaller than 4 bytes long
   truncates the value as it moves from the stack to the argument. Floating-point
   values are rounded from their native size (type <see langword="F"/>) to the size
   associated with the argument. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="starg.s"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, byte)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Shl">
		<summary>
			<para>Shifts an integer value to the left (in zeroes) by
      a specified number of bits, pushing the result onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 62</term>
					<description>shl</description>
					<description>Shifts an integer to the left (shifting in
            zeros).</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>The amount of bits to be shifted is pushed onto the stack.</term>
				</item>
				<item>
					<term>The number of bits to be shifted and the value are popped from the stack; 
         the value is shifted left by the specified number of bits.</term>
				</item>
				<item>
					<term>The result is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="shl"/> instruction
shifts the value (type<see langword="int32"/>,
<see langword="int64"/> or <see langword="natural int"/>) left by the specified number of bits. The number of bits is 
a value of type
<see langword="int32"/>, <see langword="int64"/> or <see langword="natural int"/>. The return value is unspecified if the number of bits to be 
shifted is greater than or equal to the width (in bits) of the supplied
value.</para>
			<para><see langword="Shl"/> inserts a zero bit in the lowest position on each
shift.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="shl"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Shr">
		<summary>
			<para>Shifts an integer value (in sign) to the right by a
      specified number of bits, pushing the result onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 63</term>
					<description>shr</description>
					<description>Shifts an integer to the right (shifting in
            sign).</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         The amount of bits to be shifted is pushed onto the
         stack.</term>
				</item>
				<item>
					<term>
         The number of bits to be shifted and the value are
         popped from the stack; the value is shifted right by the specified number of
         bits.</term>
				</item>
				<item>
					<term>
         The result is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="shr.un"/> instruction shifts the value
(type <see langword="int32"/>, <see langword="int64"/> or <see langword="natural int"/>) right by the specified number of bits. The number of bits is a
value of type <see langword="int32"/>, <see langword="int64"/> or <see langword="natural int"/>.
The return value is unspecified if the number of bits to be shifted is greater
than or equal to the width (in bits) of the supplied value. </para>
			<para><see langword="Shr"/> replicates the high order bit on
each shift, preserving the sign of the original value in the <paramref name="result"/>. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="shr"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Shr_Un">
		<summary>
			<para>Shifts an unsigned integer value (in zeroes) to the right
      by a specified number of bits, pushing the result onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 64</term>
					<description>shr.un</description>
					<description>Shifts an integer to the right (shifting in
            zeroes).</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         The amount of bits to be shifted is pushed onto the
         stack.</term>
				</item>
				<item>
					<term>
         The number of bits to be shifted and the value are
         popped from the stack; the value is shifted right by the specified number of
         bits.</term>
				</item>
				<item>
					<term>
         The result is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="shr.un"/> instruction shifts the value
(type <see langword="int32"/>, <see langword="int64"/> or <see langword="natural int"/>) right by the specified number of bits. The number of bits is a
value of type <see langword="int32"/>, <see langword="int64"/> or <see langword="natural int"/>. The return value is unspecified if the number of bits to be
shifted is greater than or equal to the width (in bits) of the supplied value. </para>
			<para><see langword="Shr.un"/> inserts a
zero bit in the highest position on each shift.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="shr.un"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Refanyval">
		<summary>
			<para>Retrieves the address (type <see langword="&amp;"/>) embedded in a typed reference.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> C2
            &lt;<see langword="T"/>
            &gt;</term>
					<description>refanyval <paramref name="type"/></description>
					<description>Pushes the address stored in a typed
         reference.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>A value type reference is pushed onto the stack.</term>
				</item>
				<item>
					<term>The typed reference is popped from the stack and the corresponding address 
      retrieved.</term>
				</item>
				<item>
					<term>The address is pushed onto the stack.</term>
				</item>
			</list>
			<para>A typed reference contains a type token and
   an address to an object
   instance.</para>
			<para>The <see langword="refanyval"/> instruction retrieves the
address embedded in the a typed reference. The type embedded in the typed
reference supplied on the stack must match the type specified by <paramref name="type"/>
(a metadata token,
either a <see langword="typedef"/> or a <see langword="typeref"/>). See the
<see cref="System.Reflection.Emit.OpCodes.Mkrefany"/>instruction for related 
content.</para>
			<para><see cref="System.InvalidCastException"/> is thrown if <paramref name="type"/> is not identical to the type stored in the type
reference (in this case, <paramref name="type"/>
is the class supplied to
the <see cref="System.Reflection.Emit.OpCodes.Mkrefany"/>
instruction that constructed said typed reference). </para>
			<para><see cref="System.TypeLoadException"/>is thrown if <paramref name="type"/> cannot be found. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="refanyval"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Type)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Starg">
		<summary>
			<para>Stores the value on top of the evaluation stack in the 
      argument slot at a specified index.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE OB
            &lt;<see langword="unsigned int16"/>
            
            &gt;</term>
					<description>starg<paramref name=" num"/></description>
					<description>Pops
         the top value from the stack and stores it in argument slot
      <paramref name="num. "/></description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      The value currently on top of the stack is popped and placed in argument
      slot <paramref name="num"/>.</term>
				</item>
			</list>
			<para>The <see langword="starg"/>
instruction pops a value from the stack and places it in argument slot <paramref name="num"/>. The type of the value must match the type of the
argument, as specified in the current method's signature.</para>
			<para>For procedures that take a variable argument list, the <see langword="starg"/>
instruction can be used only for the initial fixed arguments, not those in the
variable part of the signature. </para>
			<para>Performing a store into arguments that hold an integer value smaller
   than 4 bytes long truncates the value as it moves from the stack to the
   argument. Floating-point values are rounded from their native size (type
<see langword="F"/> 
) to the size associated
with the argument.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="starg"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, short)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Rethrow">
		<summary>
			<para>Rethrows the current exception.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            1A</term>
					<description>rethrow</description>
					<description>Rethrows the current
            exception</description>
				</item>
			</list>
			<para>No stack transition behavior is defined for this instruction.</para>
			<para>The <paramref name="rethrow"/> instruction is only permitted
   within the body of a <see langword="catch"/> handler. It throws the same
   exception that was caught by this handler.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="rethrow"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Sizeof">
		<summary>
			<para>Pushes the size, in bytes, of a supplied value
      type onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            1C &lt;<see langword="T"/>&gt;</term>
					<description>sizeof<paramref name=" valType"/></description>
					<description>Push the size, in bytes, of a value type as an
      <see langword="unsigned int32"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      The size (in bytes) of the supplied value type (<paramref name="valType"/>) is pushed
      onto the stack.</term>
				</item>
			</list>
			<para><paramref name="ValType"/> must be a metadata token (a
<see langword="typeref"/> or <see langword="typedef"/>) that specifies a value type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="sizeof"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Type)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Refanytype">
		<summary>
			<para>Retrieves the type token embedded in a typed
      reference.
			</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            1D</term>
					<description>refanytype</description>
					<description>Pushes the type token stored in a typed
            reference.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>A value type reference is pushed onto the stack.</term>
				</item>
				<item>
					<term>The typed reference is popped from the stack and its corresponding type 
         token retrieved.</term>
				</item>
				<item>
					<term>The type token is pushed onto the stack.</term>
				</item>
			</list>
			<para>A typed reference contains a type token and
   an address to an object instance.</para>
			<para>The <see langword="refanytype"/>
instruction retrieves the type token embedded in the typed reference.
See the <see cref="System.Reflection.Emit.OpCodes.Mkrefany"/> instruction for information on
creating typed references.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="refanytype"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stloc_0">
		<summary>
			<para>Pops the current value from the top of the evaluation
      stack and stores it in a the local variable list at index 0.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 0A</term>
					<description>stloc.0</description>
					<description>Pops a value from the stack into local variable
            0.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         A value is popped off of the stack and placed in the local variable
         indexed by 0.</term>
				</item>
			</list>
			<para>The <see langword="stloc.0"/> 
instruction pops the top value off the evalution stack and moves it into the
local variable indexed by 0. The type of the value must match the type of the
local variable as specified in the current method's local signature.</para>
			<para><see langword="stloc.0"/> is an especially efficient encoding for storing
values in local variable 0.</para>
			<para>Storing into locals that hold an integer value smaller than 4 bytes long
   truncates the value as it moves from the stack to the local variable.
   Floating-point values are rounded from their native size (type
<see langword="F"/>) to the size associated with the argument.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stloc.0"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stloc_1">
		<summary>
			<para>Pops the current value from the top of the evaluation
      stack and stores it in a the local variable list at index 1.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 0B</term>
					<description>stloc.1</description>
					<description>Pops a value from the stack into local variable
            1.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>A value is popped off of the stack and placed in the local variable 
         indexed by 1.</term>
				</item>
			</list>
			<para>The <see langword="stloc.1"/>
instruction pops the top value off the evalution stack and moves it into the
local variable indexed by 1. The type of the value must match the type of the local variable as specified in the
current method's local signature.</para>
			<para><see langword="stloc.1"/> is an especially efficient encoding for storing
values in local variable 1.</para>
			<para>Storing into locals that hold an integer value smaller than 4 bytes long
   truncates the value as it moves from the stack to the local variable.
   Floating-point values are rounded from their native size (type
<see langword="F"/>) to the size associated with the argument.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stloc.1"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stloc_2">
		<summary>
			<para>Pops the current value from the top of the evaluation
      stack and stores it in a the local variable list at index 2.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 0C</term>
					<description>stloc.2</description>
					<description>Pops a value from the stack into local variable
            2</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         A value is popped off of the stack and placed in the local variable
         indexed by 2.</term>
				</item>
			</list>
			<para>The <see langword="stloc.2"/>
instruction pops the top value off the evalution stack and moves it into the
local variable indexed by 2. The type of the value must match the type of the local variable as specified in the
current method's local signature.</para>
			<para><see langword="stloc.2"/> is an especially efficient encoding for storing
values in local variable 2.</para>
			<para>Storing into locals that hold an integer value smaller than 4 bytes long
   truncates the value as it moves from the stack to the local variable.
   Floating-point values are rounded from their native size (type
<see langword="F"/>) to the size associated with the argument.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stloc.2"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stloc_3">
		<summary>
			<para>Pops the current value from the top of the evaluation
      stack and stores it in a the local variable list at index 3.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 0D</term>
					<description>stloc.3</description>
					<description>Pops a value from the stack into local variable
            3</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>A value is popped off of the stack and placed in the local variable 
         indexed by 3.</term>
				</item>
			</list>
			<para>The <see langword="stloc.3"/>
instruction pops the top value off the evalution stack and moves it into the
local variable indexed by 3. The type of the value must match the type of the local variable as specified in the
current method's local signature.</para>
			<para><see langword="stloc.3"/> is an especially efficient encoding for storing
values in local variable 3.</para>
			<para>Storing into locals that hold an integer value smaller than 4 bytes long
   truncates the value as it moves from the stack to the local variable.
   Floating-point values are rounded from their native size (type
<see langword="F"/>) to the size associated with the argument.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stloc.3"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Xor">
		<summary>
			<para>Computes the bitwise XOR of the top two values on the evaluation
      stack, pushing the result onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 61</term>
					<description>xor</description>
					<description>Computes the bitwise XOR of two integer values and returns
            an integer.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term><paramref name="value1"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term><paramref name="value2"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term><paramref name="value2"/> and <paramref name="value1"/> are popped from the stack and their 
   bitwise XOR computed.</term>
				</item>
				<item>
					<term><paramref name="value2"/> and <paramref name="value1"/> are popped from the stack and their 
   bitwise XOR computed.</term>
				</item>
			</list>
			<para>The <see langword="xor"/> 
instruction computes the bitwise XOR of the top two values on the stack and
leaves the result on the stack.</para>
			<para><see langword="Xor"/> is an integer-specific operation.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="xor"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Unbox">
		<summary>
			<para>Converts the boxed representation of a value type to its unboxed form.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 79
            &lt;<see langword="T"/>&gt;</term>
					<description>unbox <paramref name="valType"/></description>
					<description>Extracts the value type data from <paramref name="obj"/>, its
      boxed representation.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      An object reference is pushed onto the stack.</term>
				</item>
				<item>
					<term>The object reference is popped from the stack and unboxed to a value type 
      pointer.</term>
				</item>
				<item>
					<term>The value type pointer is pushed onto the stack.</term>
				</item>
			</list>
			<para>A value type has two separate representations within
   the the Common Language Infrastructre (CLI):</para>
			<list type="bullet"><item>
					<term>
      
      A 'raw' form used when a value type is embedded
      within another object.</term>
				</item>
				<item>
					<term>
      
      A 'boxed' form, where the data in the value type is wrapped (boxed) into
      an object so it can exist as an independent entity.</term>
				</item>
			</list>
			<para>The <see langword="unbox"/>
instruction converts the object reference (type
<see langword="O"/>), the boxed representation of a value type, 
to a value type pointer (a managed pointer, type <see langword="&amp;"/>), its unboxed form. The supplied value
type (<paramref name="valType"/>) is a metadata token indicating the type of value
type contained within the boxed object. </para>
			<para>Unlike <see cref="System.Reflection.Emit.OpCodes.Box"/>, which is required to make a copy of a
value type for use in the object, <see langword="unbox "/>is not required to copy
the value type from the object. Typically it simply computes the address of the
value type that is already present inside of the boxed object. </para>
			<para><see cref="System.InvalidCastException"/> is thrown if the
object is not boxed
as <paramref name="valType"/>. </para>
			<para><see cref="System.NullReferenceException"/> is thrown if the object
reference is a null reference. </para>
			<para><see cref="System.TypeLoadException"/> is thrown if the value type <paramref name="valType"/>
cannot be found. This is typically detected when Microsoft Internediate Language (MSIL) instructions are converted to native code, rather
than at runtime. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="unbox"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Type)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Throw">
		<summary>
			<para>Throws the exception object
      currently on the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 7A</term>
					<description>throw</description>
					<description>Throws an exception.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         An object reference (to an exception) is pushed onto
         the stack.</term>
				</item>
				<item>
					<term>
         The object reference is popped from the stack and the exception
         thrown.</term>
				</item>
			</list>
			<para>The <see langword="throw"/> instruction throws the exception object (type
<see langword="O"/>) currently on the stack.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if the object
reference is a null reference.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="throw"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Add">
		<summary>
			<para> Adds two values and pushes the result onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:
      </para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 58</term>
					<description>add</description>
					<description>Adds two numeric values, returning a new
            numeric value.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, 
      is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; <paramref name="value1"/> 
      is added to <paramref name="value2"/>.</term>
				</item>
				<item>
					<term>
      
      The result is pushed onto the stack.</term>
				</item>
			</list>
			<para>Overflow is not detected for integer operations (for
   proper overflow handling, see <see cref="System.Reflection.Emit.OpCodes.Add_Ovf"/>
   
   ).</para>
			<para>Integer addition wraps, rather than saturates. For
   example, assuming 8-bit integers where<paramref name=" value1"/> is set to 255 and
<paramref name="value2"/> is set to 1, the wrapped result is 0 rather than 256. </para>
			<para>Floating-point overflow returns <see langword="+inf"/>
(<see langword="PositiveInfinity"/>) or <see langword="-inf"/>
(<see langword="NegativeInfinity"/>
). </para>
			<para>The acceptable operand types and their corresponding result
   data type are listed in the table below. If there is no entry for a particular
   type combination (for example, <see langword="int32"/> and
<see langword="float"/>; <see langword="int32"/> and <see langword="int64"/> 
), it is an
invalid Microsoft Intermediate Language (MSIL) and generates an error.</para>
			<list type="table">
				<listheader>
					<term>operand</term>
					<description>value1 type</description>
					<description>value2 type</description>
					<description>result type</description>
				</listheader>
				<item>
					<term> add</term>
					<description><see langword="int32"/></description>
					<description><see langword="int32"/></description>
					<description><see langword="int32"/></description>
				</item>
				<item>
					<term> add</term>
					<description><see langword="int32"/></description>
					<description><see langword="natural int"/>
					</description>
					<description><see langword="natural int"/>
					</description>
				</item>
				<item>
					<term> add</term>
					<description><see langword="int32"/></description>
					<description><see langword="&amp;"/></description>
					<description><see langword="&amp;"/></description>
				</item>
				<item>
					<term> add</term>
					<description><see langword="int32"/></description>
					<description><see langword="*"/></description>
					<description><see langword="*"/></description>
				</item>
				<item>
					<term> add</term>
					<description><see langword="int64"/></description>
					<description><see langword="int64"/></description>
					<description><see langword="int64"/></description>
				</item>
				<item>
					<term> add</term>
					<description><see langword="natural int"/>
					</description>
					<description><see langword="int32"/></description>
					<description><see langword="natural int"/>
					</description>
				</item>
				<item>
					<term> add</term>
					<description><see langword="natural int"/>
					</description>
					<description><see langword="natural int"/>
					</description>
					<description><see langword="natural int"/>
					</description>
				</item>
				<item>
					<term> add</term>
					<description><see langword="natural int"/>
					</description>
					<description><see langword="&amp;"/></description>
					<description><see langword="&amp;"/></description>
				</item>
				<item>
					<term> add</term>
					<description><see langword="natural int"/>
					</description>
					<description><see langword="*"/></description>
					<description><see langword="*"/></description>
				</item>
				<item>
					<term> add</term>
					<description><see langword="F"/></description>
					<description><see langword="F"/></description>
					<description><see langword="F"/></description>
				</item>
				<item>
					<term> add</term>
					<description><see langword="&amp;"/></description>
					<description><see langword="int32"/></description>
					<description><see langword="&amp;"/></description>
				</item>
				<item>
					<term> add</term>
					<description><see langword="&amp;"/></description>
					<description><see langword="natural int "/>
					</description>
					<description><see langword="&amp;"/></description>
				</item>
				<item>
					<term> add</term>
					<description><see langword="*"/></description>
					<description><see langword="int32"/></description>
					<description><see langword="*"/></description>
				</item>
				<item>
					<term> add</term>
					<description><see langword="*"/></description>
					<description><see langword="natural int"/>
					</description>
					<description><see langword="*"/></description>
				</item>
			</list>
			<para> The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can use the <see langword="add"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Beq_S">
		<summary>
			<para>Transfers control to a target instruction (short form) if
      two values are equal.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 2E &lt;<see langword="int8"/>&gt;</term>
					<description>beq.s <paramref name="target"/></description>
					<description>Branch to the target instruction at offset
   <paramref name="target"/> if equal, short
      form </description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if 
   <paramref name="value1"/> is equal to <paramref name="value2"/>, the branch operation is 
      performed.</term>
				</item>
			</list>
			<para>The <see langword="beq.s"/>
instruction transfers control to to the specified target instruction if <paramref name="value1"/> is equal to <paramref name="value2"/>.
The effect is the same as performing a <see langword="ceq"/>
instruction followed by a <see langword="brtrue"/> branch to
the specific target instruction. The target instruction is represented as a 1-byte signed
offset from the beginning of the instruction following the current instruction. </para>
			<para>The acceptable operand types are encapsulated below:</para>
			<para>If the target instruction has one or more prefix codes,
   control can only be transferred to the first of these prefixes. </para>
			<para>Control transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this 
instruction (such transfers are severely restricted and must use
the <see cref="System.Reflection.Emit.OpCodes.Leave"/> instruction instead).</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="beq.s"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Beq">
		<summary>
			<para>Transfers control to a target instruction if two values
      are equal.</para>
		</summary>
		<remarks>
			<para>The following table lists the
      instruction's hexadecimal and Microsoft Intermediate Language (MSIL) assembly
      format, along with a brief reference summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 3B &lt;<see langword="int32"/>&gt;</term>
					<description>beq <paramref name="target"/></description>
					<description>Branch to the target instruction at offset
   <paramref name="target"/> if the two values are equal. </description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from 
      the stack; if <paramref name="value1"/> is equal to <paramref name="value2"/>, the branch
      operation is performed.</term>
				</item>
			</list>
			<para>The <see langword="beq"/>
instruction transfers control to the specified target instruction if
<paramref name="value1"/> is equal to <paramref name="value2"/>. 
The effect is the same as
performing a <see langword="ceq"/>
instruction followed by a <see langword="brtrue"/> branch to the specific target
instruction.
The target instruction is represented as a 4-byte signed offset from the
beginning of the instruction following the current instruction. </para>
			<para>The acceptable operand types are encapsulated below:</para>
			<para> If the target instruction has one or more prefix codes, control can
   only be transferred to the first of these prefixes. </para>
			<para>Control transfers into and out of <see langword="try"/>,
<see langword="catch"/>, <see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this 
instruction (such transfers are severely restricted and must use
the <see cref="System.Reflection.Emit.OpCodes.Leave"/>
instruction instead).</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="beq"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Add_Ovf">
		<summary>
			<para> Adds
      two
      integers, performs an overflow check, and
      pushes the result onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> D6</term>
					<description>add.ovf</description>
					<description>Adds two signed integer values with an overflow
            check.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the
   stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; <paramref name="value1"/> is added to <paramref name="value2 "/>with a check for overflow.</term>
				</item>
				<item>
					<term>
      The result is pushed onto the stack.</term>
				</item>
			</list>
			<para><see cref="System.OverflowException"/> is thrown if the result is
not represented in the result type.</para>
			<para>You can perform this operation on signed integers. For floating-point values,
   use <see cref="System.Reflection.Emit.OpCodes.Add"/>.</para>
			<para> The acceptable operand types and their corresponding result
   data type are listed in the table below. If there is no entry for a particular
   type combination (for example, <see langword="int32"/> and
<see langword="float"/>; <see langword="int32"/> and <see langword="int64"/> 
), it is an invalid Microsoft Intermediate
Language (MSIL) instruction and generates an error.</para>
			<list type="table">
				<listheader>
					<term>operand</term>
					<description>value1 type</description>
					<description>value2 type</description>
					<description>result type</description>
				</listheader>
				<item>
					<term>add</term>
					<description><see langword="int32"/></description>
					<description><see langword="int32"/></description>
					<description><see langword="int32"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="int32"/></description>
					<description><see langword="natural int"/></description>
					<description><see langword="natural int"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="int32"/></description>
					<description><see langword="&amp;"/></description>
					<description><see langword="&amp;"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="int32"/></description>
					<description><see langword="*"/></description>
					<description><see langword="*"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="int64"/></description>
					<description><see langword="int64"/></description>
					<description><see langword="int64"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="natural int"/></description>
					<description><see langword="int32"/></description>
					<description><see langword="natural int"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="natural int"/></description>
					<description><see langword="natural int"/></description>
					<description><see langword="natural int"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="natural int"/></description>
					<description><see langword="&amp;"/></description>
					<description><see langword="&amp;"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="natural int"/></description>
					<description><see langword="*"/></description>
					<description><see langword="*"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="F"/></description>
					<description><see langword="F"/></description>
					<description><see langword="F"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="&amp;"/></description>
					<description><see langword="int32"/></description>
					<description><see langword="&amp;"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="&amp;"/></description>
					<description><see langword="natural int "/></description>
					<description><see langword="&amp;"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="*"/></description>
					<description><see langword="int32"/></description>
					<description><see langword="*"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="*"/></description>
					<description><see langword="natural int"/></description>
					<description><see langword="*"/></description>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="add.ovf"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Add_Ovf_Un">
		<summary>
			<para>Adds two unsigned integer values, performs an
   overflow check, and pushes the result onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> D7</term>
					<description>add.ovf.un</description>
					<description>Adds two unsigned integer values with an overflow
            check.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the
   stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; <paramref name="value1"/> is
   added to <paramref name="value2"/>
   with a check for overflow.</term>
				</item>
				<item>
					<term>
      The result is pushed onto the stack.</term>
				</item>
			</list>
			<para><see cref="System.OverflowException"/> is
thrown if the result is not represented in the result type.</para>
			<para>You can perform this operation on signed integers. For
   floating-point values, use <see cref="System.Reflection.Emit.OpCodes.Add"/>.</para>
			<para>The acceptable operand types and their corresponding result data type are listed
   in the table below. If there is no entry for a particular type combination
   (for example, <see langword="int32"/> and <see langword="float"/>;
<see langword="int32"/> and <see langword="int64"/>), it is an invalid Microsoft 
   Intermediate Language (MSIL) instruction and generates an error.</para>
			<list type="table">
				<listheader>
					<term>operand</term>
					<description>value1 type</description>
					<description>value2 type</description>
					<description>result type</description>
				</listheader>
				<item>
					<term>add</term>
					<description><see langword="int32"/></description>
					<description><see langword="int32"/></description>
					<description><see langword="int32"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="int32"/></description>
					<description><see langword="natural int"/></description>
					<description><see langword="natural int"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="int32"/></description>
					<description><see langword="&amp;"/></description>
					<description><see langword="&amp;"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="int32"/></description>
					<description><see langword="*"/></description>
					<description><see langword="*"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="int64"/></description>
					<description><see langword="int64"/></description>
					<description><see langword="int64"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="natural int"/></description>
					<description><see langword="int32"/></description>
					<description><see langword="natural int"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="natural int"/></description>
					<description><see langword="natural int"/></description>
					<description><see langword="natural int"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="natural int"/></description>
					<description><see langword="&amp;"/></description>
					<description><see langword="&amp;"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="natural int"/></description>
					<description><see langword="*"/></description>
					<description><see langword="*"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="F"/></description>
					<description><see langword="F"/></description>
					<description><see langword="F"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="&amp;"/></description>
					<description><see langword="int32"/></description>
					<description><see langword="&amp;"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="&amp;"/></description>
					<description><see langword="natural int "/></description>
					<description><see langword="&amp;"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="*"/></description>
					<description><see langword="int32"/></description>
					<description><see langword="*"/></description>
				</item>
				<item>
					<term>add</term>
					<description><see langword="*"/></description>
					<description><see langword="natural int"/></description>
					<description><see langword="*"/></description>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="add.ovf.un"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Localloc">
		<summary>
			<para>Allocates a certain number of bytes from the local dynamic memory pool and pushes the address
      (a transient pointer, type <see langword="*"/>) of the first allocated byte onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            0F</term>
					<description>localloc</description>
					<description>Allocate space from the local
            heap.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         The number of bytes to be allocated is pushed onto
         the stack.</term>
				</item>
				<item>
					<term>
         The number of bytes is popped from the stack; an
         amount of memory corresponding to the size is allocated from the local heap.</term>
				</item>
				<item>
					<term>
         A pointer to the first byte of the allocated memory is pushed onto the
         stack.</term>
				</item>
			</list>
			<para>The <see langword="localloc"/> instruction allocates
<paramref name="size"/> (type <see langword="natural unsigned int"/>) bytes from the local dynamic 
memory pool and returns the address (a transient
pointer, type <see langword="*"/>) of the first allocated byte. The block of memory
returned is initialized to 0 only if the initialize flag on the method is
<see langword="true"/> 
. When the current method executes a <see cref="System.Reflection.Emit.OpCodes.Ret"/> ,
the local memory pool
is made available for reuse.</para>
			<para>The resulting address is aligned so that any primitive data type can be stored there
   using the <see langword="stind"/> instructions (such as <see cref="System.Reflection.Emit.OpCodes.Stind_I4"/> ) and loaded using the
<see langword="ldind"/> instructions (such as <see cref="System.Reflection.Emit.OpCodes.Ldind_I4"/> ). </para>
			<para>The <see langword="localloc"/> instruction cannot occur
within a <see langword="filter"/>, <see langword="catch"/>,
<see langword="finally"/>, or <see langword="fault"/> 
block.</para>
			<para><see cref="System.StackOverflowException"/> is thrown if there is insufficient memory to service
the request. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="localloc"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Br_S">
		<summary>
			<para>Unconditionally transfers control to a target
      instruction (short form).</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 2B
            &lt;<see langword="int8"/>&gt;</term>
					<description>br.s <paramref name="target"/></description>
					<description>Branches to a target instruction at the specified offset, short
         form.</description>
				</item>
			</list>
			<para>No evaluation stack behaviors are performed by this
   operation.</para>
			<para>The <see langword="br.s"/> instruction unconditionally
transfers control to a target instruction. The target instruction is represented as a 1-byte signed
offset from the beginning of the instruction following the current instruction. </para>
			<para>Control can only be transferred to the first of these prefixes if the target
   instruction has one or more prefix codes. Control transfers into and out of
<see langword="try"/>, <see langword="catch"/>, <see langword="filter"/>, and 
<see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="br.s"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Brfalse_S">
		<summary>
			<para> Transfers control to a target instruction if <paramref name="value"/> is <see langword="false"/>, a null reference, or zero.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 2C &lt;<see langword="int8"/>&gt;</term>
					<description>
						<para>brfalse.s <paramref name="target"/></para>
						<para>brnull.s <paramref name="target"/></para>
						<para>brzero.s<paramref name=" target"/></para></description>
					<description>Branches to a target instruction at the specified 
   offset if <see langword="false"/>, short form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack by a previous operation.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the stack; if <paramref name="value"/> is
   <see langword="false"/>, branch to<paramref name=" target"/>.</term>
				</item>
			</list>
			<para>The <see langword="brfalse.s"/> instruction (and its aliases
<see langword="brnull"/> and <see langword="brzero"/>) transfers control to the 
specified target instruction if <paramref name="value"/> (of type
<see langword="int32"/>, <see langword="int64"/>, object reference 
<see langword="O"/>, managed pointer <see langword="&amp;"/>, transient pointer 
<see langword="*"/>, <see langword="natural int"/>) is zero 
(<see langword="false"/>). If <paramref name="value"/> is non-zero (<see langword="true"/>)
execution continues at the next instruction.</para>
			<para>The target instruction is represented as a 1-byte signed offset from the
   beginning of the instruction following the current instruction.</para>
			<para>Control can only be transferred to the first of these prefixes if the target
   instruction has one or more prefix codes. Control transfers into and out of
<see langword="try"/>, <see langword="catch"/>, <see langword="filter"/>, and 
<see langword="finally"/> blocks cannot be performed by this 
   instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="brfalse.s"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Bge_S">
		<summary>
			<para>Transfers control to a target instruction (short form)
      if the first value is greater than or equal to the second value.
      </para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's
      hexadecimal and Microsoft Intermediate Language (MSIL) assembly format, along
      with a brief reference summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 2F
         <see langword="&lt;int8&gt;"/></term>
					<description>bge.s <paramref name="target"/></description>
					<description> Branch to the target instruction at the 
         specified offset if the first value is greater than or equal to the second
         value, short form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>, the
      branch operation is performed.</term>
				</item>
			</list>
			<para>The <see langword="bge.s"/>
instruction transfers control to the specified target instruction if <paramref name="value1"/> is greater than or equal to
<paramref name="value2"/>. The effect is identical to performing a 
<see langword="clt.un "/>instruction followed by a 
<see langword="brfalse"/> branch to the specific target instruction. The
target instruction is
represented as a 1-byte signed offset from the beginning of the instruction
following the current instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed 
   by this instruction. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="bge.s"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Bgt_S">
		<summary>
			<para>Transfers control to a target instruction (short form)
      if the first value is greater than the second value.
      </para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 30
            &lt;<see langword="int8"/>&gt;</term>
					<description>bgt.s <paramref name="target"/></description>
					<description>Branch to the target instruction at the specified 
         offset if the first value is greater than the second
         value, short form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is greater than <paramref name="value2"/>, the branch operation is
      performed.</term>
				</item>
			</list>
			<para>The <see langword="bgt.s"/>
instruction transfers control to the specified target instruction if
<paramref name="value1"/> is greater than <paramref name="value2"/>. The effect is identical 
to performing a <see langword="cgt"/> instruction followed by a
<see langword="brtrue"/> branch to the specific target instruction. The 
target instruction is represented as a 1-byte signed offset from the beginning
of the instruction following the current instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="bgt.s"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ble_S">
		<summary>
			<para>Transfers control to a target instruction (short form) if the first
      value is less than or equal to the second value.
      </para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 31 <see langword="&lt;int8&gt;"/></term>
					<description>ble.s <paramref name="target"/></description>
					<description> Branch to the target instruction at the 
      specified offset if the first value is less than or equal to the
      second value, short form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is less than or equal to <paramref name="value2"/>, the branch
      operation is performed.</term>
				</item>
			</list>
			<para>The <see langword="ble.s"/>
instruction transfers control to the specified target instruction if
<paramref name="value1"/> is less than or equal to <paramref name="value2"/>. The effect is identical 
to performing a <see langword="cgt"/> instruction (<see langword="cgt.un"/> for floats) instruction followed by a
<see langword="brfalse"/> branch to the specific target instruction. 
The target instruction is represented as a
1-byte signed offset from the beginning of the instruction following the current instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ble.s"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Blt_S">
		<summary>
			<para>Transfers control to a target instruction (short form)
      if the first value is less than the second value.
      </para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 32 &lt;<see langword="int8"/>&gt;</term>
					<description>blt.s <paramref name="target"/></description>
					<description>Branch to the target instruction at the specified 
      offset if the first value is less than the second value,
      short form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is less than <paramref name="value2"/>, the branch operation is performed.</term>
				</item>
			</list>
			<para>The <see langword="blt.s"/>
instruction transfers control to the specified target instruction if
<paramref name="value1"/> is less than <paramref name="value2"/>. The effect is identical 
to performing a <see langword="clt"/> instruction followed by a
<see langword="brtrue"/> branch to the specific target instruction. The
target instruction is represented as a 1-byte
signed offset from the beginning of the instruction following the current
instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="blt.s"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Bne_Un_S">
		<summary>
			<para>Transfers control to a target instruction (short form)
      when two unsigned integer
      values or unordered float values are not equal.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 33 &lt;<see langword="int8"/>&gt;</term>
					<description>bne.un.s <paramref name="target"/></description>
					<description>Branch to the target instruction at the specified 
      offset if two unsigned integer values are not equal (unsigned
      values), short form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is not equal to <paramref name="value2"/>, the branch operation is
      performed.</term>
				</item>
			</list>
			<para>The <see langword="bne.un"/> instruction transfers
control to the specified target instruction if <paramref name="value1"/> is not equal to
<paramref name="value2"/>, when compared using unsigned integer or unordered float values. 
The effect is identical to performing a <see langword="ceq.un"/> instruction followed by a
<see langword="brfalse"/> branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the
beginning of the instruction following the current instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="bne.un.s"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Bge_Un_S">
		<summary>
			<para>Transfers control to a target instruction (short form)
      if if the the first value is greather than the second value, when comparing unsigned integer values or unordered
      float values.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 34
            &lt;<see langword="int8"/>&gt;</term>
					<description>bge.un.s <paramref name="target"/></description>
					<description> Branch to the target instruction at the 
         specified offset if the first value is greater than or equal to the second
         value (unsigned values), short form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>, the branch operation
      is performed.</term>
				</item>
			</list>
			<para>The <see langword="bge.un.s"/>
instruction transfers control to the specified target instruction
if <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>, when compared using
unsigned integer or unordered float values. The effect is identical to
performing a <see langword="clt"/> instruction followed by a
<see langword="brfalse"/> branch to the specific target instruction. 
The target instruction is represented as a 1-byte signed
offset from the beginning of the instruction following the current
instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="bge.un.s"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Bgt_Un_S">
		<summary>
			<para>Transfers control to a target instruction (short form)
      if the first value is greater than the second value, when comparing unsigned
      integer values or unordered float values.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 35
            &lt;<see langword="int8"/>&gt;</term>
					<description>bgt.un.s <paramref name="target"/></description>
					<description> Branch to the target instruction at the 
         specified offset if the first value is greater than the second value
         (unsigned values), short form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is greater than <paramref name="value2"/>, the branch operation is
      performed.</term>
				</item>
			</list>
			<para>The <see langword="bgt.un.s"/>
instruction transfers control to the specified target instruction
if <paramref name="value1"/> is greater than <paramref name="value2"/>, when compared using
unsigned integer or unordered float values. The effect is identical to
performing a <see langword="cgt.un"/> instruction followed by a
<see langword="brtrue"/> branch to the specific target instruction. The 
target instruction is represented as a 1-byte signed offset from the beginning
of the instruction following the current instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="bgt.un.s"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ble_Un_S">
		<summary>
			<para>Transfers control to a target instruction (short form) if the first
      value is less than or equal to the second value, when comparing unsigned integer values or unordered float values.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 36 <see langword="&lt;int8&gt;"/></term>
					<description>ble.un.s <paramref name="target"/></description>
					<description> Branch to the target instruction at the 
      specified offset if the first value is less than or equal to
      the second value (unsigned values), short form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is less than or equal to <paramref name="value2"/>, the branch
      operation is performed.</term>
				</item>
			</list>
			<para>The <see langword="ble.un.s"/>
instruction transfers control to the specified target instruction
if <paramref name="value1"/> is less than or equal to <paramref name="value2"/>, when compared using
unsigned integer or unordered float values. The effect is identical to
performing a <see langword="cgt.un"/> instruction (<see langword="cgt"/> for floats) followed by a
<see langword="brfalse"/> branch to the specific target instruction. The
target instruction is represented as a
1-byte signed offset from the beginning of the instruction following the current
instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ble.un.s"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Blt_Un_S">
		<summary>
			<para>Transfers control to a target instruction (short form)
      if the first value is less than the second value, when
      comparing unsigned integer values or unordered float values.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 37 &lt;<see langword="int8"/>&gt;</term>
					<description>blt.un.s <paramref name="target"/></description>
					<description>Branch to the target instruction at the specified 
      offset if the first value is less than the second value (unsigned
      values), short form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is less than <paramref name="value2"/>, the branch operation is performed.</term>
				</item>
			</list>
			<para>The <see langword="blt.un"/> instruction transfers control to the specified
target instruction if <paramref name="value1"/> is less than <paramref name="value2"/>, when compared
using unsigned integer or unordered float values. The effect is identical to
performing a <see langword="clt.un"/>
instruction followed by a <see langword="brtrue"/> branch to the specific target
instruction. The target instruction is
represented as a 4-byte signed offset from the beginning of the instruction
following the current instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="blt.un.s"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Br">
		<summary>
			<para>Unconditionally transfers control to a target
      instruction.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 38
            &lt;<see langword="int32"/>&gt;</term>
					<description>br<paramref name=" target"/></description>
					<description>Branches to a target instruction at the specified offset.</description>
				</item>
			</list>
			<para>No evaluation stack behaviors are performed by this operation.</para>
			<para>The <see langword="br"/> instruction
unconditionally transfers control to a target instruction. The target
instruction is represented as a 4-byte signed
offset from the beginning of the instruction following the current instruction.</para>
			<para>Control can only be transferred to the first of these prefixes if the target
   instruction has one or more prefix codes. Control transfers into and out of
<see langword="try"/>, <see langword="catch"/>, <see langword="filter"/>, and 
<see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="br"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Bge">
		<summary>
			<para> Transfers control to a target instruction if the
      first value is greater than or equal to the second value.
      </para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 3C
         <see langword="&lt;int32&gt;"/></term>
					<description>bge<paramref name=" target"/></description>
					<description>Branch to the target instruction at the specified 
         offset if the first value is greater
         than or equal to the second value.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from
      the stack; if <paramref name="value1"/> is greater than or equal
      to <paramref name="value2"/>, the branch operation is performed.</term>
				</item>
			</list>
			<para>The <see langword="bge"/>
instruction transfers control to the specified target instruction if <paramref name="value1"/> is greater than or equal to
<paramref name="value2"/>. The effect is identical to performing a 
<see langword="clt.un "/>instruction followed by a 
<see langword="brfalse"/> branch to the specific target instruction. The target instruction is represented as a 
4-byte signed offset from the beginning of the instruction following the current
instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed 
   by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="bge"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Bgt">
		<summary>
			<para>Transfers control to a target instruction if the
      first value is greater than the second value.
      </para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 3D
            &lt;<see langword="int32"/>&gt;</term>
					<description>bgt<paramref name=" target"/></description>
					<description>Branch to the target instruction at the specified 
         offset if the first value is greater than the second value.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is greater than <paramref name="value2"/>, the branch
      operation is performed.</term>
				</item>
			</list>
			<para>The <see langword="bgt"/>
instruction transfers control to the specified target instruction if
<paramref name="value1"/> is greater than <paramref name="value2"/>. The effect is identical 
to performing a <see langword="cgt"/> instruction followed by a
<see langword="brtrue"/> branch to the specific target instruction. 
The target instruction is represented as a 4-byte signed offset from the
beginning of the instruction following the current instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="bgt"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ble">
		<summary>
			<para>Transfers control to a target instruction if the first value is less
      than or equal to the second value.
      </para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 3E <see langword="&lt;int32&gt;"/></term>
					<description>ble<paramref name=" target"/></description>
					<description> Branch to the target instruction at the 
      specified offset if the first value is less than or equal to
      the second value.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is less than or equal to <paramref name="value2"/>, the branch
      operation is performed.</term>
				</item>
			</list>
			<para>The <see langword="ble"/>
instruction transfers control to the specified target instruction if
<paramref name="value1"/> is less than or equal to <paramref name="value2"/>. The effect is identical 
to performing a <see langword="cgt"/> instruction (<see langword="cgt.un"/> for floats) followed by a
<see langword="brfalse"/> branch to the specific target instruction. The 
target instruction is represented as a 4-byte signed offset from the beginning
of the instruction following the current instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ble"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Blt">
		<summary>
			<para>Transfers control to a target instruction if the first
      value is less than the second value.
      </para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 3F &lt;<see langword="int32"/>&gt;</term>
					<description>blt<paramref name=" target"/></description>
					<description>Branch to the target instruction at the specified 
      offset if the first value is less than the second
      value.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is less than <paramref name="value2"/>, the branch operation is performed.</term>
				</item>
			</list>
			<para>The <see langword="blt"/>
instruction transfers control to the specified target instruction if
<paramref name="value1"/> is less than or equal to <paramref name="value2"/>. The effect is identical 
to performing a <see langword="clt"/> instruction followed by a
<see langword="brtrue"/> branch to the specific target instruction. The
target instruction is represented as a 4-byte
signed offset from the beginning of the instruction following the current
instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="blt"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Bne_Un">
		<summary>
			<para>Transfers control to a target instruction
      when two unsigned integer
      values or unordered float values are not equal.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 40 &lt;<see langword="int32"/> &gt;</term>
					<description>bne.un <paramref name="target"/></description>
					<description>Branch to the target instruction at the specified 
      offset if two unsigned integer values are not
      equal (unsigned values).</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is not equal to <paramref name="value2"/>, the branch operation is
      performed.</term>
				</item>
			</list>
			<para>The <see langword="bne.un"/>
instruction transfers control to the specified target instruction if
<paramref name="value1"/> is not equal to <paramref name="value2"/>, when compared using unsigned integer 
or unordered float values. The effect is identical to performing a
<see langword="ceq.un"/> instruction followed by a 
<see langword="brfalse"/> branch to the specific target instruction. The target instruction is represented as a 4-byte signed offset from the
beginning of the instruction following the current instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="bne.un"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Bge_Un">
		<summary>
			<para>Transfers control to a target instruction if the the
      first value is greather than the second value,
      when comparing unsigned integer values or unordered float values.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 41<see langword=" &lt;int32&gt;"/></term>
					<description>bge.un <paramref name="target"/></description>
					<description> Branch to the target instruction at the 
      specified offset if the first value is greater than or equal to the second
      value (unsigned values). </description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is greater than or equal to <paramref name="value2"/>, the
      branch operation is performed.</term>
				</item>
			</list>
			<para>The <see langword="bge.un"/>
instruction transfers control to the specified target instruction if
<paramref name="value1"/> is greater than or equal to <paramref name="value2"/>, 
when compared using unsigned integer or unordered float values. The effect is identical
to performing a <see langword="clt"/> instruction followed by a
<see langword="brfalse"/> branch to the specific target instruction. The 
target instruction is represented as a 4-byte signed offset from the beginning
of the instruction following the current instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="bge.un"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Bgt_Un">
		<summary>
			<para>Transfers control to a target instruction if the first
      value is greater than the second value, when comparing unsigned integer
      values or unordered float values.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 42
            &lt;<see langword="int32"/>
            &gt;</term>
					<description>bgt.un <paramref name="target"/></description>
					<description>Branch to the target instruction at the specified 
         offset if the first value is greater than the second value
         (unsigned values).</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is greater than <paramref name="value2"/>, the branch operation is
      performed.</term>
				</item>
			</list>
			<para>The <see langword="bgt.un"/>
instruction transfers control to the specified target instruction if
<paramref name="value1"/> is greater than <paramref name="value2"/>, when compared using 
unsigned integer or unordered float values. The effect is identical to
performing a <see langword="cgt.un"/> instruction followed by a
<see langword="brtrue"/> branch to the specific target instruction. 
The 
target instruction is represented as a 4-byte signed offset from the beginning
of the instruction following the current instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="bgt.un"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ble_Un">
		<summary>
			<para>Transfers control to a target instruction if the first value is less
      than or equal to the second value, when
      comparing unsigned integer values or unordered float values.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 43<see langword=" &lt;int32&gt;"/></term>
					<description>ble.un <paramref name="target"/></description>
					<description> Branch to the target instruction at the 
      specified offset if the first value is less than or equal
      to the second value (unsigned values).</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is less than or equal to <paramref name="value2"/>, the branch
      operation is performed.</term>
				</item>
			</list>
			<para>The <see langword="ble.un"/>
instruction transfers control to the specified target instruction if
<paramref name="value1"/> is less than or equal to <paramref name="value2"/>, when compared using 
unsigned integer or unordered float values. The effect is identical to
performing a <see langword="cgt.un"/> instruction (<see langword="cgt"/> for floats) followed by a
<see langword="brfalse"/> branch to the specific target instruction. 
The
target instruction is represented as a 4-byte signed offset from the beginning
of the instruction following the current instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ble.un"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Blt_Un">
		<summary>
			<para>Transfers control to a target instruction if the first
      value is less than the second value, when comparing
      unsigned integer values or unordered float values.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 44 &lt;<see langword="int32"/> &gt;</term>
					<description>blt.un <paramref name="target"/></description>
					<description>Branch to the target instruction at the specified 
      offset if the first value is less than the second
      value (unsigned values).</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; if
   <paramref name="value1"/> is less than <paramref name="value2"/>, the branch operation is performed.</term>
				</item>
			</list>
			<para>The <see langword="blt.un"/>
instruction transfers control to the specified target instruction if
<paramref name="value1"/> is less than <paramref name="value2"/>, when compared using 
unsigned integer or unordered float values. The effect is identical to
performing a <see langword="clt.un"/>
instruction followed by a <see langword="brtrue"/> branch to the specific target
instruction. The target instruction is represented as a 4-byte
signed offset from the beginning of the instruction following the current
instruction.</para>
			<para>Control can only be transferred to the first of these
   prefixes if the target instruction has one or more prefix codes. Control
   transfers into and out of <see langword="try"/>, <see langword="catch"/>,
<see langword="filter"/>, and <see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="blt.un"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Box">
		<summary>
			<para>Converts a value type to an object
      reference (type <see langword="O"/>).</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 8C
            &lt;<see langword="T"/>&gt;</term>
					<description>box<paramref name=" valTypeToken"/></description>
					<description>Convert a value type (of the type
         specified in <paramref name="valTypeToken"/>) to a true object
         reference.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      A value type is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      The value type is popped from the stack; the
   <see langword="box"/> operation is performed.</term>
				</item>
				<item>
					<term>
      An object reference to the resulting "boxed"
      value type is pushed onto the stack.</term>
				</item>
			</list>
			<para>A value type has two separate representations within the Common Language
   Infrastructure (CLI):</para>
			<list type="bullet"><item>
					<term>
      
      A 'raw' form used when a value type is embedded
      within another object or on the stack.</term>
				</item>
				<item>
					<term>
      
      A 'boxed' form, where the data in the value type is wrapped (boxed) into
      an object so it can exist as an independent entity.</term>
				</item>
			</list>
			<para>The <see langword="box"/>
instruction converts the 'raw' (unboxed) value type into an object reference (type
<see langword="O"/>). This is accomplished 
by creating a new object and copying the data from the value type into the newly allocated
object. <paramref name="valTypeToken"/> is a
metadata token indicating the type of the value type on the stack.</para>
			<para><see cref="System.OutOfMemoryException"/>is thrown if there is
insufficient memory to satisfy the request.</para>
			<para><see cref="System.TypeLoadException"/>is thrown if the 
class cannot be
found. This is typically detected when Microsoft Intermediate Language (MSIL) is converted to native code,
rather than at runtime.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="box"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Type)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Brfalse">
		<summary>
			<para> Transfers control to a target instruction if <paramref name="value"/> is <see langword="false"/>, a 
   null reference (<see langword="Nothing"/> in Visual Basic), or zero.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 39
            &lt;<see langword="int32"/>
            
            &gt;</term>
					<description>
						<para>brfalse
            <paramref name="target"/></para>
						<para>brnull <paramref name="target"/></para>
						<para>brzero<paramref name=" target"/></para></description>
					<description>Branches to a target instruction at the specified 
         offset if
      <see langword="false"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack by a previous operation.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the stack; if
   <paramref name="value"/> is <see langword="false"/>, branch to<paramref name=" target"/> .</term>
				</item>
			</list>
			<para>The <see langword="brfalse"/> instruction (and its
aliases <see langword="brnull"/> and <see langword="brzero"/>) transfers control to the specified target instruction if <paramref name="value"/> (of type <see langword="int32"/>,
<see langword="int64"/>, object reference <see langword="O"/>, managed pointer 
<see langword="&amp;"/>, transient pointer <see langword="*"/>, <see langword="natural int"/>) is zero (<see langword="false"/>). If <paramref name="value"/> is non-zero (<see langword="true"/>) execution continues at the next 
instruction.</para>
			<para>The target instruction is represented as a 4-byte signed offset from the beginning of the instruction following the
   current instruction.</para>
			<para>Control can only be transferred to the first of these prefixes if the target
   instruction has one or more prefix codes. Control transfers into and out of
<see langword="try"/>, <see langword="catch"/>, <see langword="filter"/>, and 
<see langword="finally"/> blocks cannot be performed by 
   this instruction.</para>
			<para> The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="brfalse"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Brtrue_S">
		<summary>
			<para>Transfers control to a target instruction (short
      form) if <paramref name="value"/> is <see langword="true"/> , not null, or non-zero.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 2D &lt;<see langword="int8"/>&gt;</term>
					<description>
						<para>brtrue.s<paramref name=" target"/></para>
						<para>brinst.s<paramref name="
         target"/></para></description>
					<description>Branch to a target instruction at the specified 
         offset if non-zero (<see langword="true"/> ), short
         form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack by a previous operation.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the stack; if <paramref name="value"/> is
   <see langword="true"/>, branch to<paramref name=" target"/>.</term>
				</item>
			</list>
			<para>The <see langword="brtrue.s"/> instruction transfers control to the specified
target instruction if <paramref name="value"/> (type <see langword="natural int"/>) is
nonzero (<see langword="true"/>). If <paramref name="value"/> is zero
(<see langword="false"/>) execution continues at the next
instruction.</para>
			<para>If <paramref name="value"/> is an object reference (type <see langword="O"/>) then
<see langword="brinst"/> (an alias for <see langword="brtrue"/>) transfers control if it 
represents an instance of an object (for example, if it is not the null object reference;
see <see cref="System.Reflection.Emit.OpCodes.Ldnull"/>). </para>
			<para>The target instruction is represented as a 1-byte signed offset from the
   beginning of the instruction following the current instruction.</para>
			<para> Control can only be transferred to the first of these prefixes if the
   target instruction has one or more prefix codes. Control transfers into and out
   of <see langword="try"/>, <see langword="catch"/>, <see langword="filter"/>, and
<see langword="finally"/> blocks cannot be performed by this 
   instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="brtrue.s"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Brtrue">
		<summary>
			<para> Transfers control to a target instruction if
   <paramref name="value"/> is <see langword="true"/> , not null, or non-zero.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 3A
            &lt;<see langword="int32"/>&gt;</term>
					<description>
						<para>brtrue<paramref name="
               target"/></para>
						<para>brinst<paramref name=" target"/></para></description>
					<description>Branch to a target instruction at the specified 
            offset if non-zero
            (<see langword="true"/>).</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
         stack by a previous operation.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the stack; if
      <paramref name="value"/> is <see langword="true"/>, branch to<paramref name=" target"/> .</term>
				</item>
			</list>
			<para>The <see langword="brtrue"/>
instruction transfers control to the specified target instruction if <paramref name="value"/> (type <see langword="natural int"/>) is nonzero (<see langword="true"/>). If <paramref name="value"/> is zero (<see langword="false"/>) execution continues at the next
instruction.</para>
			<para> If <paramref name="value"/> is an object reference (type
<see langword="O"/>) then <see langword="brinst"/> (an alias for <see langword="brtrue"/>) transfers control if it represents 
an instance of an object (for example, if it is not the null object reference;
see <see cref="System.Reflection.Emit.OpCodes.Ldnull"/>). </para>
			<para>The target instruction is
   represented as a 4-byte signed offset from the beginning of the instruction following the current
   instruction.</para>
			<para>Control can only be transferred to the first of these prefixes if the target
   instruction has one or more prefix codes. Control transfers into and out of
<see langword="try"/>, <see langword="catch"/>, <see langword="filter"/>, and 
<see langword="finally"/> blocks cannot be performed by this instruction.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="brtrue"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Break">
		<summary>
			<para>Signals the Common Language Infrastructure (CLI) to inform the debugger that a break
      point has been tripped.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 01</term>
					<description>break</description>
					<description>inform a debugger that a breakpoint has been
            reached.</description>
				</item>
			</list>
			<para>No evaluation stack behaviors are performed by this operation.</para>
			<para>The <see langword="break"/> instruction is for debugging
   support. It signals the CLI to inform the debugger that a break point has been
   tripped. It has no other effect on the interpreter state.</para>
			<para>The <see langword="break"/>
instruction
has the smallest possible instruction size enabling code patching with a break point and generating minimal disturbance to the surrounding code.</para>
			<para>The <see langword="break"/> 
instruction can trap to a
debugger, do nothing, or raise a security exception. The exact behavior is implementation-defined.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="break"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Calli">
		<summary>
			<para>Calls the method indicated on the evaluation stack (as a
      pointer to an entry point) with arguments described by a calling
      convention.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 29
            &lt;<see langword="T"/>&gt;</term>
					<description>calli<paramref name=" callSiteDescr"/></description>
					<description>Calls the method
         pointed to with arguments described by the calling
         convention.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      
      Method arguments <paramref name="arg1"/> through <paramref name="argN"/> are pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      The method entry pointer is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      Method arguments <paramref name="arg1"/> through <paramref name="argN"/> and the method entry pointer are
      popped from the stack; the call to the method is performed. When complete, a
      return value is generated by the callee method and sent to the caller.</term>
				</item>
				<item>
					<term>
      
      The
      return value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="calli"/> 
instruction calls the method entry pointer with the arguments <paramref name="arg1
"/> through <paramref name=" argN"/>. The types of
these arguments are described by the specific calling convention
(<paramref name="callSiteDesc"/>). The <see langword="calli"/> instruction may be
immediately preceded by a <see langword="tail"/> prefix (<see cref="System.Reflection.Emit.OpCodes.Tailcall"/>) to specify that the current method
state should be released before transferring control. If the call would transfer
control to a method of higher trust than the origin method the stack frame will
not be released; instead, the execution will continue silently as if the
<see langword="tail"/>
had not been supplied.</para>
			<para>The method entry pointer is assumed to be a specific pointer to
   native code (of the target machine) that can be legitimately called with the
   arguments described by the calling convention (a metadata token for a stand-alone
   signature). Such a pointer can be created using the <see cref="System.Reflection.Emit.OpCodes.Ldftn"/> or <see cref="System.Reflection.Emit.OpCodes.Ldvirtftn"/>
   instructions, or passed in
   from native code. </para>
			<para> The calling
   convention is not checked dynamically, so code that uses a
<see langword="calli"/> 
instruction does not work correctly if
the destination does not actually use the specified calling convention.</para>
			<para> The arguments are placed on the stack in left-to-right
   order. That is, the first argument
   is computed and placed on the stack, then the second argument, then the third,
   until all necessary arguments are atop the stack in descending
   order. The argument-building code sequence for an instance or virtual method must push
   that instance reference (which must not be a null reference) before any of the user-visible
   arguments. </para>
			<para><see cref="System.Security.SecurityException"/> may be thrown if
the system security does not grant
the caller access to the called method. The security check can occur when the Microsoft
Intermediate Language (MSIL) instructions are converted to native code rather than at runtime. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.EmitCalli"/> methods can be used to
perform a <see langword="calli "/>instruction on the stack. Note that
<see langword="calli "/>should be called through the below methods rather than 
using the <see cref="System.Reflection.Emit.ILGenerator.Emit"/> class to place the instruction directly
on the stack.</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.EmitCalli(Opcode, CallingConventions,
      Type, Type[], Type[]) for calls using a managed calling convention.</term>
				</item>
				<item>
					<term>
      
      ILGenerator.EmitCalli(Opcode, CallingConvention, Type, Type[]) for calls
      using an unmanaged calling convention.</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Callvirt">
		<summary>
			<para>Calls a late-bound method on an object, pushing the
      return value onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 6F
            &lt;<see langword="T"/>&gt;</term>
					<description>callvirt<paramref name=" method "/></description>
					<description>Calls a specific method associated with <paramref name="obj"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      
      An object reference <paramref name="obj"/>
      is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      Method arguments <paramref name="arg1"/> through <paramref name="argN"/> are pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      Method arguments <paramref name="arg1"/> through <paramref name="argN"/>
      and the object reference <paramref name="obj"/> are popped from the stack; the method
      call is performed with these arguments and control is transferred to the
      method in <paramref name="obj"/> referred to by the method metadata token. When
      complete, a return value is generated by the callee method and sent to the
      caller.</term>
				</item>
				<item>
					<term>
      
      The
      
      return value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="callvirt"/> instruction calls a
late-bound method on an object. That is, the method is chosen based on the
runtime type of <paramref name="obj"/> rather than
the compile-time class visible in the method pointer. <see langword="Callvirt"/> can be used to call
both virtual and instance methods. The <see langword="callvirt"/> instruction may be immediately preceded
by a <see langword="tail"/> (<see cref="System.Reflection.Emit.OpCodes.Tailcall"/>)
prefix to specify that the current stack frame should be released before
transferring control. If the call would transfer control to a method of higher
trust than the original method the stack frame will not be released.</para>
			<para>The method metadata token provides the name, class and 
   signature of the method to call. The class associated with
<paramref name="obj"/> is the class of which it is an instance. 
   If the class defines a non-static method that matches the indicated method
   name and signature, this method is called. Otherwise all classes in the base
   class chain of this class are checked in order. It is an error if no method is found.</para>
			<para><see langword="Callvirt"/> pops the object and the associated
arguments off the evaluation stack before calling the method. If the method has
a return value, it is pushed on the stack upon method completion. On the callee
side, the <paramref name="obj"/> parameter is accessed as argument 0, <paramref name="arg1"/> as argument
1, and so on. </para>
			<para>The arguments are placed on the stack in left-to-right
   order. That is, the first argument is computed and placed on the stack,
   then the second argument, then the third, until all necessary arguments are atop the stack
   in descending order. The instance reference <paramref name="obj"/> (always required for
<see langword="callvirt"/>) must be pushed before any of the 
   user-visible arguments. The signature (carried in the metadata
   token) need not contain an entry in the parameter list for the this
   pointer. </para>
			<para>Note that a virtual method can also be called using
   the <see cref="System.Reflection.Emit.OpCodes.Call"/> instruction. </para>
			<para><see cref="System.MissingMethodException"/> is thrown if a non-static 
method with the indicated name and signature could not be found in the
class associated with <paramref name="obj"/>
or any of its base classes. This is typically
detected when Microsoft Intermediate Language (MSIL) instructions are converted to native code, rather than at
runtime.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if obj is null. </para>
			<para><see cref="System.Security.SecurityException"/> is thrown if system security does not grant the caller
access to the called method. The security check may occur when the CIL is
converted to native code rather than at runtime.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="callvirt"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, MethodInfo)</term>
				</item>
				<item>
					<term>
      
      ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Castclass">
		<summary>
			<para>Attempts to cast an object passed by reference to
      the specified class.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 74
            &lt;<see langword="T"/>&gt;</term>
					<description>castclass<paramref name=" class"/></description>
					<description>Casts an object to a new object of type <paramref name="class"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      An object reference is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      The object reference is popped from the stack;
      the referenced object is cast as the specified <paramref name="class"/>.</term>
				</item>
				<item>
					<term>
      If successful, a new object reference is pushed onto
      the stack.</term>
				</item>
			</list>
			<para>The <see langword="castclass"/>
instruction attempts to cast the object reference (type <see langword="O"/>) atop the stack to a specified class. The new
class is specified
by a metadata token indicating the desired class. If the class of the object
on the top of the stack does not implement the new class (assuming the
new class is an interface) and is not a derived class of
the new class then an <see cref="System.InvalidCastException"/> is thrown. If the
object reference is a null
reference, <see langword="castclass"/>
succeeds and returns the new object as a null reference.</para>
			<para><see cref="System.InvalidCastException"/> is thrown if obj cannot be cast to
class.</para>
			<para><see cref="System.TypeLoadException"/> is thrown if class cannot be
found. This is typically detected when a Microsoft
Intermediate Language (MSIL)instruction is converted to native code rather than at runtime.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="castclass"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Type)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ceq">
		<summary>
			<para>Compares two values. If they are equal, the integer value 1 <see langword="(int32"/>) is pushed
   onto the evaluation stack; otherwise 0 (<see langword="int32"/>) is pushed onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            01</term>
					<description>ceq</description>
					<description>Pushes
            1 if <paramref name="value1"/> equals <paramref name="value2"/>; else
            pushes 0.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; <paramref name="value1"/>
      is added to <paramref name="value2"/>.</term>
				</item>
				<item>
					<term>
      
      The result is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ceq "/>instruction compares
<paramref name="value1"/> and <paramref name="value2"/>. If <paramref name="value1"/> is equal to 
<paramref name="value2"/>, then 1 (of type <see langword="int32"/>) is pushed on the stack. 
Otherwise 0 (of type <see langword="int32"/>)
is pushed on the stack.</para>
			<para>For floating-point number, <see langword="ceq"/> will return 0 if the numbers
are unordered (either or both are NaN). The infinite values are equal to
themselves. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ceq"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Cgt">
		<summary>
			<para>Compares two values. If the first value is greater than
      the second, the integer value 1
   <see langword="(int32"/>) is pushed onto the evaluation stack; otherwise 0
      (<see langword="int32"/>) is pushed onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            02</term>
					<description>cgt</description>
					<description>Pushes 1 if <paramref name="value1"/> is greater 
         than <paramref name="value2"/>; else
         pushes 0.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack;
   <see langword="cgt"/> tests if <paramref name="value1"/> is greater than <paramref name="value2"/>.</term>
				</item>
				<item>
					<term>
      
      If <paramref name="value1"/> is greater than <paramref name="value2"/>, 1 is
      pushed onto the stack;
      otherwise 0 is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="cgt"/> instruction compares <paramref name="value1"/> and
<paramref name="value2"/>. If <paramref name="value1"/> is strictly greater than <paramref name="value2"/>, then an <see langword="int32"/> value of 1 is 
pushed on the stack. Otherwise, an <see langword="int32"/> value of 0 is pushed on the stack.</para>
			<list type="bullet"><item>
					<term>For floating-point numbers, <see langword="cgt"/> returns 0 if the numbers 
   are unordered (that is, if one or both of the arguments are NaN).</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="cgt"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Cgt_Un">
		<summary>
			<para>Compares two unsigned or unordered values. If the first
      value is greater than the second, the integer value 1 <see langword="(int32"/>)
      is pushed onto the evaluation stack; otherwise 0 (<see langword="int32"/>) is pushed onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE 03</term>
					<description>cgt.un</description>
					<description>Pushes 1 if <paramref name="value1 "/>is 
         greater than <paramref name="value2"/>; else pushes 0 (unsigned
         values).</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack;
   <see langword="cgt.un"/> tests if <paramref name="value1"/> is greater than
   <paramref name="value2"/>.</term>
				</item>
				<item>
					<term>
      
      If <paramref name="value1"/> is greater than <paramref name="value2"/>, 1 is pushed onto the
      stack; otherwise 0 is pushed onto the stack.</term>
				</item>
			</list>
			<para> An <see langword="int32"/> value of 1 is pushed on the stack if any of the
following is <see langword="true"/>
:</para>
For floating-point numbers, <paramref name="value1"/> is not ordered with respect to
<paramref name="value2"/>.
			<para> 
   For integer values, <paramref name="value1"/> is strictly greater than
<paramref name="value2"/> when considered as unsigned numbers. </para>
			<para>Otherwise an <see langword="int32"/> value of 0 is pushed on the stack. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="cgt.un"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Clt">
		<summary>
			<para>Compares two values. If the first value is less than
      the second, the integer value 1 <see langword="(int32"/>) is pushed onto the
      evaluation stack; otherwise 0 (<see langword="int32"/>) is pushed onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE 04</term>
					<description>clt</description>
					<description>Pushes 1 if <paramref name="value1 "/>is less than 
      <paramref name="value2"/>;
      else pushes 0.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order,
   is: <paramref name="value1"/> is pushed onto the stack. </para>
			<list type="number"><item>
					<term>
						<paramref name="value2"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from
      the stack; <see langword="clt"/> tests if <paramref name="value1"/> is less than
   <paramref name="value2"/>.</term>
				</item>
				<item>
					<term>
      
      If <paramref name="value1"/> is less than <paramref name="value2"/>, 1 is
      pushed onto the stack;
      
      otherwise 0 is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="clt"/> instruction compares <paramref name="value1"/> and
<paramref name="value2"/>. If <paramref name="value1"/> is strictly less than <paramref name="value2"/>, then an <see langword="int32"/> 
value of 1 is pushed on the stack. Otherwise, an <see langword="int32"/> value of 0 is pushed on the stack.</para>
			<list type="bullet"><item>
					<term>For floating-point numbers, <see langword="clt"/> returns 0 if the numbers 
   are unordered (that is, if one or both of the arguments are NaN).</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="clt"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Clt_Un">
		<summary>
			<para>Compares the unsigned or unordered values <paramref name="value1"/> and
<paramref name="value2"/>. If <paramref name="value1 "/>is less than <paramref name="value2"/>, 
then the integer value 1
<see langword="(int32"/>) is pushed onto the evaluation stack; otherwise 0 
(<see langword="int32"/>) is
pushed onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE 03</term>
					<description>clt.un</description>
					<description>Pushes 1 if <paramref name="value1 "/>is less than 
      <paramref name="value2"/>; else pushes 0 (unsigned values).</description>
				</item>
			</list>
			<para>The stack transitional behavior,
   in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term><paramref name="value2"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack;
   <see langword="clt.un"/> tests if <paramref name="value1"/> is less than <paramref name="value2"/>.</term>
				</item>
				<item>
					<term>
      
      If <paramref name="value1"/> is less than <paramref name="value2"/>, 1 is pushed onto the stack;
      otherwise 0 is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="clt.un"/>
instruction compares <paramref name="value1"/> and <paramref name="value2"/>. An <see langword="int32"/>
value of 1 is pushed on the stack if any of the following is true:</para>
			<list type="bullet"><item>
					<term>
						<paramref name="value1"/> is strictly less than <paramref name="value2"/>
   (as for <see langword="clt"/>).</term>
				</item>
				<item>
					<term>
      
      For floating-point numbers, <paramref name="value1"/> is not ordered with respect to
   <paramref name="value2"/>.</term>
				</item>
				<item>
					<term>
      
      For integer values, <paramref name="value1"/> is strictly less than <paramref name="value2"/>
      when considered as unsigned numbers.</term>
				</item>
			</list>
			<para>Otherwise, an <see langword="int32"/> value of 0 is pushed on the stack. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="clt.un"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_I1">
		<summary>
			<para>Converts the value on top of the evaluation stack to
   <see langword="int8"/>, then extends (pads) it to
   <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 67</term>
					<description>conv.i1</description>
					<description>Convert to <see langword="int8"/>, pushing
      <see langword="int32"/> on stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.i1 "/>opcode converts the <paramref name="value"/> on top
of the stack to the type specified in the opcode, and leave that converted value
on the top of the stack. Integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.i"/> or<see langword=" conv.u"/> is used, in which 
case the result is also <see langword="natural int"/>). Floating-point values are
converted to the <see langword="F"/> type. </para>
			<para>Conversion from floating-point numbers to integer values truncates the number
   toward zero. When converting from an <see langword="float64"/> to an
<see langword="float32"/>, precision can be lost. If <paramref name="value"/> is too large to 
   fit in a <see langword="float32 (F)"/>, positive infinity (if
<paramref name="value"/> is positive) or negative infinity (if <paramref name="value"/> 
is negative) is returned. If overflow occurs converting one integer type
to another, the high order bits are truncated. If the result is smaller
than an <see langword="int32"/>, the value is sign-extended to fill the slot. </para>
			<para>If overflow occurs converting a floating-point type to an integer the value
   returned is unspecified. </para>
			<para>No exceptions are ever thrown when using this field. See <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I1"/> and <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un"/> for equivalent instructions that
will throw an exception when the result type can not properly represent the
result value. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can use
the <see langword="conv.i1"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_I2">
		<summary>
			<para>Converts the value on top of the evaluation stack to
   <see langword="int16"/>, then extends (pads) it to
   <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 68</term>
					<description>conv.i2</description>
					<description>Convert to <see langword=" int16"/>, pushing <see langword="int32"/> on stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.i2 "/>opcode converts the <paramref name="value"/> on top
of the stack to the type specified in the opcode, and leave that converted value
on the top of the stack. Integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.i"/> or<see langword=" conv.u"/> is used, in which case 
the result is also <see langword="natural int"/>). Floating-point values are
converted to the <see langword="F"/> type. </para>
			<para>Conversion from floating-point numbers to integer values 
   truncates the number toward zero. When converting from an
<see langword="float64"/> to an <see langword="float32"/>, precision can be 
   lost. If <paramref name="value"/> is too large to fit in a <see langword="float32 (F)"/>,
   positive infinity (if <paramref name="value"/> is positive) or negative infinity (if
<paramref name="value"/> is negative) is returned. If overflow occurs converting one integer 
   type to another, the high order bits are truncated. If the result is
   smaller than an <see langword="int32"/>, the value is sign-extended to fill the slot. </para>
			<para>If overflow occurs converting a floating-point type to an integer the value
   returned is unspecified. </para>
			<para>No exceptions are ever thrown when using this field. See <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I2"/> and <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un"/> for equivalent instructions that
will throw an exception when the result type can not properly represent the
result value. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.i2"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_I4">
		<summary>
			<para>Converts the value on top of the evaluation stack to
   <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 69</term>
					<description>conv.i4</description>
					<description>Convert to <see langword=" int32"/>,
         pushing <see langword=" int32"/> on stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.i4 "/>opcode converts the <paramref name="value"/> on top
of the stack to the type specified in the opcode, and leave that converted value
on the top of the stack. Integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.i"/> or<see langword=" conv.u"/> is used, in which case 
the result is also <see langword="natural int"/>). Floating-point values are
converted to the <see langword="F"/> type. </para>
			<para>Conversion from floating-point numbers to integer values 
   truncates the number toward zero. When converting from an
<see langword="float64"/> to an <see langword="float32"/>, precision can be 
   lost. If <paramref name="value"/> is too large to fit in a <see langword="float32 (F)"/>,
   positive infinity (if <paramref name="value"/> is positive) or negative infinity (if
<paramref name="value"/> is negative) is returned. If overflow occurs converting one integer 
   type to another, the high order bits are truncated. If the result is
   smaller than an <see langword="int32"/>, the value is sign-extended to fill the slot. </para>
			<para>If overflow occurs converting a floating-point type to an integer the value
   returned is unspecified. </para>
			<para>No exceptions are ever thrown when using this field. See <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I4"/> and <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un"/> for equivalent instructions that
will throw an exception when the result type can not properly represent the
result value. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="conv.i4"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_I8">
		<summary>
			<para>Converts the value on top of the evaluation stack to
   <see langword=" int64"/>. </para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 6A</term>
					<description>conv.i8</description>
					<description>Convert to <see langword="int64"/>,
         pushing <see langword=" int64"/> on stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.i8 "/>opcode converts the <paramref name="value"/> on top
of the stack to the type specified in the opcode, and leave that converted value
on the top of the stack. Integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.i"/> or<see langword=" conv.u"/> is used, in which case 
the result is also <see langword="natural int"/>). Floating-point values are
converted to the <see langword="F"/> type. </para>
			<para>Conversion from floating-point numbers to integer values 
   truncates the number toward zero. When converting from an
<see langword="float64"/> to an <see langword="float32"/>, precision can be 
   lost. If <paramref name="value"/> is too large to fit in a <see langword="float32 (F)"/>,
   positive infinity (if <paramref name="value"/> is positive) or negative infinity (if
<paramref name="value"/> is negative) is returned. If overflow occurs converting one integer 
   type to another, the high order bits are truncated. If the result is
   smaller than an <see langword="int32"/>, the value is sign-extended to fill the slot. </para>
			<para>If overflow occurs converting a floating-point type to an integer the value
   returned is unspecified. </para>
			<para>No exceptions are ever thrown when using this field. See <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I8"/> and <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un"/> for equivalent instructions that
will throw an exception when the result type can not properly represent the
result value. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.i8"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_R4">
		<summary>
			<para>Converts the value on top of the evaluation stack to
   <see langword="float32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 6B</term>
					<description>conv.r4</description>
					<description>Convert to <see langword="float32"/>, pushing
      <see langword="F"/> on stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.r4 "/>opcode converts the <paramref name="value"/> on top
of the stack to the type specified in the opcode, and leave that converted value
on the top of the stack. Integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.i"/> or<see langword=" conv.u"/> is used, in which case 
the result is also <see langword="natural int"/> ). Floating-point values are
converted to the <see langword="F"/> type. </para>
			<para>Conversion from floating-point numbers to integer values 
   truncates the number toward zero. When converting from an
<see langword="float64"/> to an <see langword="float32"/>, precision can be 
   lost. If <paramref name="value"/> is too large to fit in a <see langword="float32 (F)"/>,
   positive infinity (if <paramref name="value"/> is positive) or negative infinity (if
<paramref name="value"/> is negative) is returned. If overflow occurs converting one integer 
   type to another, the high order bits are truncated. If the result is
   smaller than an <see langword="int32"/> , the value is sign-extended to fill the slot. </para>
			<para>If overflow occurs converting a floating-point type to an integer the value
   returned is unspecified. </para>
			<para>No exceptions are ever thrown when using this field. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.r4"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_R8">
		<summary>
			<para>Converts the value on top of the evaluation stack to
   <see langword="float64"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 6C</term>
					<description>conv.r8</description>
					<description>Convert to <see langword="float64"/>, pushing
      <see langword="F"/> on stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.r8 "/>opcode converts the <paramref name="value"/> on top
of the stack to the type specified in the opcode, and leave that converted value
on the top of the stack. Integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.i"/> or<see langword=" conv.u"/> is used, in which case 
the result is also <see langword="natural int"/>). Floating-point values are
converted to the <see langword="F"/> type. </para>
			<para>Conversion from floating-point numbers to integer values 
   truncates the number toward zero. When converting from an
<see langword="float64"/> to an <see langword="float32"/>, precision can be 
   lost. If <paramref name="value"/> is too large to fit in a <see langword="float32 (F)"/>,
   positive infinity (if <paramref name="value"/> is positive) or negative infinity (if
<paramref name="value"/> is negative) is returned. If overflow occurs converting one integer 
   type to another, the high order bits are truncated. If the result is
   smaller than an <see langword="int32"/> , the value is sign-extended to fill the slot. </para>
			<para>If overflow occurs converting a floating-point type to an integer the value
   returned is unspecified. </para>
			<para>No exceptions are ever thrown when using this field. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.r8"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_U4">
		<summary>
			<para>Converts the value on top of the evaluation stack to
   <see langword="unsigned int32"/>, and extends it to <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 6D</term>
					<description>conv.u4</description>
					<description>Convert to <see langword="unsigned"/>
						<see langword="int32"/>, pushing
   <see langword="int32"/> on stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.u4 "/>opcode converts the <paramref name="value"/> on top
of the stack to the type specified in the opcode, and leave that converted value
on the top of the stack. Integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.i"/> or<see langword=" conv.u"/> is used, in which case 
the result is also <see langword="natural int"/>). Floating-point values are
converted to the <see langword="F"/> type. </para>
			<para>Conversion from floating-point numbers to integer values 
   truncates the number toward zero. When converting from an
<see langword="float64"/> to an <see langword="float32"/>, precision can be 
   lost. If <paramref name="value"/> is too large to fit in a <see langword="float32 (F)"/>,
   positive infinity (if <paramref name="value"/> is positive) or negative infinity (if
<paramref name="value"/> is negative) is returned. If overflow occurs converting one integer 
   type to another, the high order bits are truncated. If the result is
   smaller than an <see langword="int32"/>, the value is sign-extended to fill the slot. </para>
			<para>If overflow occurs converting a floating-point type to an integer the value
   returned is unspecified. </para>
			<para>No exceptions are ever thrown when using this field. See <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I4"/> and <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un"/> for equivalent instructions that
will throw an exception when the result type can not properly represent the
result value. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.u4"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_U8">
		<summary>
			<para>Converts the value on top of the evaluation stack to
   <see langword="unsigned"/>
				<see langword="int64"/>, and extends it to <see langword="int64"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 6E</term>
					<description>conv.u8</description>
					<description>Convert to <see langword="int64"/>, pushing
      <see langword="int64"/> on stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.u8 "/>opcode converts the <paramref name="value"/> on top
of the stack to the type specified in the opcode, and leave that converted value
on the top of the stack. Integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.i"/> or<see langword=" conv.u"/> is used, in which case 
the result is also <see langword="natural int"/>). Floating-point values are
converted to the <see langword="F"/> type. </para>
			<para>Conversion from floating-point numbers to integer values 
   truncates the number toward zero. When converting from an
<see langword="float64"/> to an <see langword="float32"/>, precision can be 
   lost. If <paramref name="value"/> is too large to fit in a <see langword="float32 (F)"/>,
   positive infinity (if <paramref name="value"/> is positive) or negative infinity (if
<paramref name="value"/> is negative) is returned. If overflow occurs converting one integer 
   type to another, the high order bits are truncated. If the result is
   smaller than an <see langword="int32"/>, the value is sign-extended to fill the slot. </para>
			<para>If overflow occurs converting a floating-point type to an integer the value
   returned is unspecified. </para>
			<para>No exceptions are ever thrown when using this field. See <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I8"/> and <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un"/> for equivalent instructions that
will throw an exception when the result type can not properly represent the
result value. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.u8"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_R_Un">
		<summary>
			<para>Converts the unsigned integer value on top of the evaluation stack
      to <see langword="float32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 76</term>
					<description>conv.r.un</description>
					<description>Convert unsigned integer to floating-point, pushing
         <see langword="F"/> on stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
         stack and the conversion operation is attempted.</term>
				</item>
				<item>
					<term>
         
         If the conversion is successful, the resulting value is pushed onto the
         stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.r.un "/>opcode converts the <paramref name="value"/> on top
of the stack to the type specified in the opcode, and leave that converted value
on the top of the stack. Integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.i"/> or<see langword=" conv.u"/> is used, in which case 
the result is also <see langword="natural int"/>). Floating-point values are
converted to the <see langword="F"/> type. </para>
			<para>Conversion from floating-point numbers to integer values 
   truncates the number toward zero. When converting from an
<see langword="float64"/> to an <see langword="float32"/>, precision can be 
   lost. If <paramref name="value"/> is too large to fit in a <see langword="float32 (F)"/>,
   positive infinity (if <paramref name="value"/> is positive) or negative infinity (if
<paramref name="value"/> is negative) is returned. If overflow occurs converting one integer 
   type to another, the high order bits are truncated. If the result is
   smaller than an <see langword="int32"/> , the value is sign-extended to fill the slot. </para>
			<para>If overflow occurs converting a floating-point type to
   an integer the <paramref name="result"/>
   returned is unspecified. The <see langword="conv.r.un"/> operation takes an integer off the
   stack, interprets it as unsigned, and replaces it with a floating-point number
   to represent the integer: either a <see langword="float32"/>, if this is wide enough
   to represent the integer without loss of precision, or else a
<see langword="float64"/> 
.</para>
			<para>No exceptions are ever thrown when using this field. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.r.un"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_I1_Un">
		<summary>
			<para>Converts the unsigned value on top of the evaluation stack to
      signed <see langword="int8"/> and extends it to <see langword="int32"/>,
      throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 82</term>
					<description>conv.ovf.i1.un</description>
					<description>Converts an unsigned value to
            an <see langword="int8"/> (on the stack as <see langword="int32"/>) and
            throw an exception on overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
         stack and the conversion operation is attempted. If overflow occurs, an
         exception is thrown.</term>
				</item>
				<item>
					<term>
         
         If the conversion is successful, the resulting value is pushed onto the
         stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.i1.un"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/>or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.i1.un"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_I2_Un">
		<summary>
			<para>Converts the unsigned value on top of the evaluation stack to
      signed <see langword="int16"/> and extends it to <see langword="int32"/>,
      throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 83</term>
					<description>conv.ovf.i2.un</description>
					<description>Converts an unsigned value to
            an <see langword="int16"/> (on the stack as <see langword="int32"/>) and
            throw an exception on overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
         stack and the conversion operation is attempted. If overflow occurs, an
         exception is thrown.</term>
				</item>
				<item>
					<term>
         
         If the conversion is successful, the resulting value is pushed onto the
         stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.i2.un"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.i2.un"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_I4_Un">
		<summary>
			<para>Converts the unsigned value on top of the evaluation stack to signed
   <see langword="int32"/>, throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 84</term>
					<description>conv.ovf.i4.un</description>
					<description>Converts an unsigned value to
            an <see langword="int32"/> (on the stack as <see langword="int32"/>) and
            throw an exception on overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
         stack and the conversion operation is attempted. If overflow occurs, an
         exception is thrown.</term>
				</item>
				<item>
					<term>
         
         If the conversion is successful, the resulting value is pushed onto the
         stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.i4.un"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.i4.un"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_I8_Un">
		<summary>
			<para>Converts the unsigned value on top of the evaluation stack to signed
   <see langword="int64"/>, throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 85</term>
					<description>conv.ovf.i8.un</description>
					<description>Converts an unsigned value to
            an <see langword="int64"/> (on the stack as <see langword="int64"/>) and
            throw an exception on overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
         stack and the conversion operation is attempted. If overflow occurs, an
         exception is thrown.</term>
				</item>
				<item>
					<term>
         
         If the conversion is successful, the resulting value is pushed onto the
         stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.i8.un"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.i8.un"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_U1_Un">
		<summary>
			<para>Converts the unsigned value on top of the evaluation
      stack to <see langword="unsigned"/>
				<see langword="int8"/> and extends it to <see langword="int32"/>,
      throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 86</term>
					<description>conv.ovf.u1.un</description>
					<description>Converts an unsigned value to an
         <see langword="unsigned int8"/> (on the stack as <see langword="int32"/>) and
            throw an exception on overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
         stack and the conversion operation is attempted. If overflow occurs, an
         exception is thrown.</term>
				</item>
				<item>
					<term>
         
         If the conversion is successful, the resulting value is pushed onto the
         stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.u1.un"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.u1.un"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_U2_Un">
		<summary>
			<para>Converts the unsigned value on top of the evaluation
      stack to <see langword="unsigned int16"/> and extends it to <see langword="int32"/>,
      throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 87</term>
					<description>conv.ovf.u2.un</description>
					<description>Converts an unsigned value to an
         <see langword="unsigned "/>
						<see langword="int16"/> (on the stack as <see langword="int32"/>) and
         throw an exception on overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted. If overflow occurs, an
      exception is thrown.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.u2.un"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.u2.un"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_U4_Un">
		<summary>
			<para>Converts the unsigned value on top of the evaluation
      stack to <see langword="unsigned int32"/>, throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 88</term>
					<description>conv.ovf.u4.un</description>
					<description>Converts an unsigned value to an
         <see langword="unsigned int32 "/> (on the stack as <see langword="int32"/>) and
            throw an exception on overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
         stack and the conversion operation is attempted. If overflow occurs, an
         exception is thrown.</term>
				</item>
				<item>
					<term>
         
         If the conversion is successful, the resulting value is pushed onto the
         stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.u4.un"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.u4.un"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_U8_Un">
		<summary>
			<para>Converts the unsigned value on top of the evaluation
      stack to <see langword="unsigned int64"/>, throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 89</term>
					<description>conv.ovf.u8.un</description>
					<description>Converts an unsigned value to an
         <see langword="unsigned "/>
						<see langword="int64"/> (on the stack as <see langword="int64"/>) and
         throw an exception on overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted. If overflow occurs, an
      exception is thrown.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.u8.un"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.u8.un"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_I_Un">
		<summary>
			<para>Converts the unsigned value on top of the evaluation stack to signed
   <see langword="natural int"/>, throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 8A</term>
					<description>conv.ovf.i.un</description>
					<description>Converts an unsigned value to
            a <see langword="natural int"/> (on the stack as <see langword="natural int"/>) and
            throw an exception on overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
         stack and the conversion operation is attempted. If overflow occurs, an
         exception is thrown.</term>
				</item>
				<item>
					<term>
         
         If the conversion is successful, the resulting value is pushed onto the
         stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.i.un"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.i.un"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_U_Un">
		<summary>
			<para>Converts the unsigned value on top of the evaluation
      stack to <see langword="unsigned"/>
				<see langword="natural int"/>, throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 8B</term>
					<description>conv.ovf.u.un</description>
					<description>Converts un unsigned value to an <see langword="unsigned natural"/>
						<see langword="int"/> (on the stack as <see langword="natural int"/>) and
      throw an exception on overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted. If overflow occurs, an
      exception is thrown.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.u.un"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or <see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.uvf.u.un"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_I1">
		<summary>
			<para>Converts the signed value on top of the evaluation stack to
      signed <see langword="int8"/> and extends it to <see langword="int32"/>,
      throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> B3</term>
					<description>conv.ovf.i1</description>
					<description>Convert to an <see langword=" int8"/>
      (on the stack as <see langword=" int32"/>) and throw an exception on
      overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted. If overflow occurs, an
      exception is thrown.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.i1"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.i1"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_U1">
		<summary>
			<para>Converts the signed value on top of the evaluation stack
      to <see langword="unsigned int8"/> and extends it to <see langword="int32"/>, throwing
   <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> B4</term>
					<description>conv.ovf.u1</description>
					<description>Convert to an <see langword="unsigned"/>
						<see langword=" int8"/>
   (on the stack as <see langword=" int32"/>) and throw an exception on
   overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted. If overflow occurs, an
      exception is thrown.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.u1"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para> The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.u1"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_I2">
		<summary>
			<para>Converts the signed value on top of the evaluation stack to
      signed <see langword="int16"/> and extending it to <see langword="int32"/>,
      throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> B5</term>
					<description>conv.ovf.i2</description>
					<description>Convert to an <see langword=" int16"/>
      (on the stack as <see langword=" int32"/>) and throw an exception on
      overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted. If overflow occurs, an
      exception is thrown.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.i2"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.i2"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_U2">
		<summary>
			<para>Converts the signed value on top of the evaluation stack
      to <see langword="unsigned int16"/> and extends it to <see langword="int32"/>, throwing
   <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> B6</term>
					<description>conv.ovf.u2</description>
					<description>Convert to an <see langword="unsigned"/>
						<see langword=" int16"/>
   (on the stack as <see langword=" int32"/>) and throw an exception on
   overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted. If overflow occurs, an
      exception is thrown.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.u2"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.u2"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_U4">
		<summary>
			<para>Converts the signed value on top of the evaluation stack
      to <see langword="unsigned int32"/>, throwing <see cref="System.OverflowException"/> on
      overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> B8</term>
					<description>conv.ovf.u4</description>
					<description>Convert to an <see langword="unsigned"/>
						<see langword="int32"/>
   (on the stack as <see langword=" int32"/>) and throw an exception on
   overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted. If overflow occurs, an
      exception is thrown.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.u4"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.u4"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_I8">
		<summary>
			<para>Converts the signed value on top of the evaluation stack to signed <see langword="int64"/>,
   throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> B9</term>
					<description>conv.ovf.i8</description>
					<description>Convert to an <see langword=" int64"/>
      (on the stack as <see langword=" int64"/>) and throw an exception on
      overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted. If overflow occurs, an
      exception is thrown.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.i8"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.i8"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_U8">
		<summary>
			<para>Converts the signed value on top of the evaluation stack
      to <see langword="unsigned"/>
				<see langword="int64"/>, throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> BA</term>
					<description>conv.ovf.u8</description>
					<description>Convert to an <see langword="unsigned"/>
						<see langword="int64"/>
   (on the stack as <see langword=" int64"/>) and throw an exception on
   overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted. If overflow occurs, an
      exception is thrown.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.u8"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.u8"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_U2">
		<summary>
			<para>Converts the value on top of the evaluation stack to
   <see langword="unsigned"/>
				<see langword="int16"/>, and extends it to <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> D1</term>
					<description>conv.u2</description>
					<description>Convert to <see langword="int16"/>, pushing
      <see langword="int32"/> on stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.u2 "/>opcode converts the <paramref name="value"/> on top
of the stack to the type specified in the opcode, and leave that converted value
on the top of the stack. Integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.i"/> or<see langword=" conv.u"/> is used, in which case 
the result is also <see langword="natural int"/>). Floating-point values are
converted to the <see langword="F"/> type. </para>
			<para>Conversion from floating-point numbers to integer values 
   truncates the number toward zero. When converting from an
<see langword="float64"/> to an <see langword="float32"/>, precision can be 
   lost. If <paramref name="value"/> is too large to fit in a <see langword="float32 (F)"/>,
   positive infinity (if <paramref name="value"/> is positive) or negative infinity (if
<paramref name="value"/> is negative) is returned. If overflow occurs converting one integer 
   type to another, the high order bits are truncated. If the result is
   smaller than an <see langword="int32"/>, the value is sign-extended to fill the slot. </para>
			<para>If overflow occurs converting a floating-point type to an integer the value
   returned is unspecified. </para>
			<para>No exceptions are ever thrown when using this field. See <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I2"/> and <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un"/> for equivalent instructions that
will throw an exception when the result type can not properly represent the
result value. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.u2"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_U1">
		<summary>
			<para>Converts the value on top of the evaluation stack to
   <see langword="unsigned int8"/>, and extends it to <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> D2</term>
					<description>conv.u1</description>
					<description>Convert to <see langword="int8"/>, pushing
      <see langword="int32"/> on stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.u1 "/>opcode converts the <paramref name="value"/> on top
of the stack to the type specified in the opcode, and leave that converted value
on the top of the stack. Integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.i"/> or<see langword=" conv.u"/> is used, in which case 
the result is also <see langword="natural int"/>). Floating-point values are
converted to the <see langword="F"/> type. </para>
			<para>Conversion from floating-point numbers to integer values 
   truncates the number toward zero. When converting from an
<see langword="float64"/> to an <see langword="float32"/>, precision can be 
   lost. If <paramref name="value"/> is too large to fit in a <see langword="float32 (F)"/>,
   positive infinity (if <paramref name="value"/> is positive) or negative infinity (if
<paramref name="value"/> is negative) is returned. If overflow occurs converting one integer 
   type to another, the high order bits are truncated. If the result is
   smaller than an <see langword="int32"/>, the value is sign-extended to fill the slot. </para>
			<para>If overflow occurs converting a floating-point type to an integer the value
   returned is unspecified. </para>
			<para>No exceptions are ever thrown when using this field. See <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I1"/> and <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un"/> for equivalent instructions that
will throw an exception when the result type can not properly represent the
result value. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.u1"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_I">
		<summary>
			<para>Converts the value on top of the evaluation stack to
   <see langword="natural int"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> D3</term>
					<description>conv.i</description>
					<description>Convert to <see langword="natural int"/>,
         pushing <see langword="natural int"/> on stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value
      is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.i "/>opcode converts the <paramref name="value"/> on top of the stack to the type
specified in the opcode, and leave that converted value on the top of the
stack. Integer values of less than 4 bytes are extended to <see langword="int32"/> when they are loaded onto the
evaluation stack (unless <see langword="conv.i"/> or<see langword=" conv.u"/> is used, in which case the result is also <see langword="natural int"/>). Floating-point values are converted to the <see langword="F"/> type. </para>
			<para>Conversion from floating-point numbers to integer values truncates the
   number toward zero. When converting from an <see langword="float64"/> to an
<see langword="float32"/>, precision can be lost. If <paramref name="value"/> is too large to 
   fit in a <see langword="float32 (F)"/>, positive infinity (if
<paramref name="value"/> is positive) or negative 
   infinity (if <paramref name="value"/> is negative) is returned. If overflow
   occurs converting one integer type to another, the high order bits are
   truncated. If the result is smaller than an <see langword="int32"/>, the value is sign-extended to fill the slot. </para>
			<para>If overflow occurs converting a floating-point type to an integer the value
   returned is unspecified. </para>
			<para>No exceptions are ever thrown when using this field. See <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I"/> and <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un"/> for equivalent instructions that
will throw an exception when the result type can not properly represent the
result value. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.i"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_I">
		<summary>
			<para>Converts the signed value on top of the evaluation stack to
      signed <see langword="natural int"/>, throwing <see cref="System.OverflowException"/> on
      overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> D4</term>
					<description>conv.ovf.i</description>
					<description>Convert to a <see langword="natural int"/> (on the
         stack as <see langword="natural int"/>) and throw an exception on
         overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted. If overflow occurs, an
      exception is thrown.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para> The <see langword="conv.ovf.i"/> opcode converts the <paramref name="value"/>
on top of the stack to the
type specified in the opcode, and places that converted value on
the top of the stack. If the value is too large or too small
to be represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer
   values truncate the number toward zero. Note that integer values of less than 4
   bytes are extended to <see langword="int32"/> when they are
   loaded onto the evaluation stack (unless <see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in which case the result is also
<see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can
not be represented in the result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.i"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Conv_Ovf_U">
		<summary>
			<para>Converts the signed value on top of the evaluation stack
      to <see langword="unsigned"/>
				<see langword="natural int"/>, throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> D5</term>
					<description>conv.ovf.u</description>
					<description>Convert to an <see langword="unsigned"/>
						<see langword="natural int"/>
   (on the stack as <see langword="natural int"/>) and throw an exception on
   overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term><paramref name="value"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term><paramref name="value"/> is popped from the stack and the conversion operation is 
   attempted. If overflow occurs, an exception is thrown.</term>
				</item>
				<item>
					<term>If the conversion is successful, the resulting value is pushed onto the 
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.u"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.u"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Div">
		<summary>
			<para>Divides two values and pushes the
      result as a floating-point (type <see langword="F"/> ) or quotient (type
   <see langword="int32"/>) onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 5B</term>
					<description>div</description>
					<description>Divides two values to return a quotient or floating-point
            result.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; <paramref name="value1"/>
      is divided by <paramref name="value2"/>.</term>
				</item>
				<item>
					<term>
      
      The result is pushed onto the stack.</term>
				</item>
			</list>
			<para><paramref name="result"/> = <paramref name="value1"/> div value2 satisfies the following conditions:</para>
			<para>|<paramref name="result"/>| = |<paramref name="value1"/>| / |<paramref name="value2"/>|, and: </para>
			<para>sign(<paramref name="result"/>) = +, if sign(<paramref name="value1"/>) = sign(<paramref name="value2"/>),
or -, if sign(<paramref name="value1"/>) ~= sign(<paramref name="value2"/>) </para>
			<para>The <see langword="div"/> instruction
computes the result and pushes it
on the stack. </para>
			<para>Integer division truncates towards zero. </para>
			<para> Division of a finite
   number by zero produces the correctly signed infinite value. </para>
			<para> Dividing zero by zero or infinity by infinity produces the NaN (Not-A-Number)
   value. Any number divided by infinity will produce a zero value.</para>
			<para>Integral operations throw <see cref="System.ArithmeticException"/> if the result cannot be 
represented in the result type. This can happen if <paramref name="value1"/> is the
maximum negative value, and <paramref name="value2"/>
is -1. </para>
			<para>Integral operations throw <see cref="System.DivideByZeroException"/> if <paramref name="value2"/> is zero. </para>
			<para>Note that on Intel-based platforms an <see cref="System.OverflowException"/> is thrown when computing (minint div
-1). Floating-point operations never throw an exception (they produce NaNs or
infinities instead). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="div"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Cpblk">
		<summary>
			<para>Copies a specified number bytes from a source
      address to a destination address.
			</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            17</term>
					<description>cpblk</description>
					<description>Copy
            data from one memory block to another.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         
         The destination address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         The source address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         The number of bytes to copy is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         The number of bytes, the source address, and the destination address are
         popped from the stack; the specified number of bytes are copied from the
         source address to the destination address.</term>
				</item>
			</list>
			<para>The <see langword="cpblk"/>
instruction copies a number (type <see langword="unsigned int32"/>) of bytes from a source address (of type <see langword="*"/>, <see langword="natural int"/>, or
<see langword="&amp;"/>) to a 
destination address (of type
<see langword="*"/>, <see langword="natural int"/>, or <see langword="&amp;"/>). 
The behavior of <see langword="cpblk"/> is unspecified if the source and destination areas overlap.</para>
			<para><see langword="cpblk"/> assumes that
both the source and destination addressed are aligned to the natural size of the
machine. The <see langword="cpblk"/> instruction can be immediately preceded by
the <see langword="unaligned.&lt;prefix&gt;"/> instruction to indicate that
either the source or the destination is unaligned.</para>
			<para>The operation of the <see langword="cpblk"/> instruction can be altered by an immediately preceding <see cref="System.Reflection.Emit.OpCodes.Volatile"/> or <see cref="System.Reflection.Emit.OpCodes.Unaligned"/>
prefix instruction.</para>
			<para><see cref="System.NullReferenceException"/> may be thrown if an invalid address is
detected.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="cpblk"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Endfilter">
		<summary>
			<para>Transfers control from the <see langword="filter"/> clause of an exception back to
   the Common Language Infrastructure (CLI) exception handler.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            11</term>
					<description>endfilter</description>
					<description>End filter clause of SEH exception
            handling.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the stack;
      <see langword="endfilter"/> is executed and control is transferred to the exception handler.</term>
				</item>
			</list>
			<para><paramref name="Value"/> (which must be of type
<see langword="int32"/> and is one of a specific set of values) is 
returned from the filter clause. It should be one of: </para>
			<list type="bullet"><item>
					<term>
						<see langword="exception_continue_search"/> (<paramref name="value"/> = 0) to continue searching for an exception 
      handler</term>
				</item>
				<item>
					<term>
						<see langword="exception_execute_handler"/> (<paramref name="value"/> = 1) to start
      the second phase of exception handling where finally blocks are run until the
      handler associated with this filter clause is located. Upon discovery, the
      handler is executed.</term>
				</item>
			</list>
			<para>Other integer values will produce unspecified results. </para>
			<para>The entry point of a filter, as shown in the method's 
   exception table, must be the first instruction in the filter's code block. The
<see langword="endfilter"/> 
instruction must be the
last instruction in the filter's code block (hence there can only be one
<see langword="endfilter"/> for any single filter block). After executing the 
<see langword="endfilter"/> instruction, control logically flows back to the CLI 
exception handling mechanism. </para>
			<para>Control cannot be transferred into a filter block except through the
   exception mechanism. Control cannot be transferred out of a filter block except
   through the use of a <see langword="throw"/>
   instruction or by executing the final
<see langword="endfilter"/> instruction. You cannot embed a 
<see langword="try"/> block within a <see langword="filter"/> block. If an 
   exception is thrown inside the <see langword="filter"/> block, it is intercepted
   and a value of 0 (<see langword="exception_continue_search"/>) is returned. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="endfilter"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Endfinally">
		<summary>
			<para>Transfers control from the <see langword="fault "/>or<see langword=" finally"/> clause of an exception block back to the Common Language Infrastructure (CLI) exception handler.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> DC</term>
					<description>
						<para>endfinally</para>
						<para>endfault</para></description>
					<description>Ends the <see langword="finally"/> or
         <see langword="fault"/> clause of an exception
            block.</description>
				</item>
			</list>
			<para>There are no stack transition behaviors for this instruction.</para>
			<para><see langword="Endfinally"/> and
<see langword="endfault"/> signal the end of the <see langword="finally"/> or 
<see langword="fault"/> clause so that stack unwinding can continue until the 
   exception handler is invoked. The <see langword="endfinally"/> or <see langword="endfault "/>instruction transfers control back to the CLI
   exception mechanism. The mechanism then searches for the next
<see langword="finally"/> clause in the chain if the protected block was exited 
   with a leave instruction. If the protected block was exited with an exception,
   the CLI will search for the next <see langword="finally"/> or
<see langword="fault"/>, or enter the exception handler chosen
   during the first pass of exception handling.</para>
			<para>An <see langword="endfinally"/> instruction might only appear lexically within a
<see langword="finally"/> block. Unlike the <see langword="endfilter"/> 
instruction, there is no requirement that the block end with an
<see langword="endfinally"/> instruction, and there can be as many 
<see langword="endfinally"/> instructions within the block as required. These 
same restrictions apply to the <see langword="endfault"/> instruction and the
<see langword="fault"/> block.</para>
			<para>Control cannot be transferred into a <see langword="finally"/> (or
<see langword="fault"/>) block except through the exception mechanism. Control 
cannot be transferred out of a <see langword="finally"/> (or
<see langword="fault"/>) block except through the use of a <see langword="throw"/> 
instruction or executing the <see langword="endfinally "/>(or
<see langword="endfault"/> ) instruction. In particular, you cannot "fall 
out" of a <see langword="finally"/> (or <see langword="fault"/>) block or to
execute a <see cref="System.Reflection.Emit.OpCodes.Ret"/> or <see cref="System.Reflection.Emit.OpCodes.Leave"/> instruction within a
<see langword="finally"/> (or <see langword="fault"/>) block. </para>
			<para>Note that the <see langword="endfault"/> and 
<see langword="endfinally"/> instructions are aliases - they
correspond to the same opcode. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="endfinally"/> (<see langword="endfault"/>) opcode, as well as the
<see langword="ILGenerator"/> 
method <see cref="System.Reflection.Emit.ILGenerator.EndExceptionBlock"/>.</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
				<item>
					<term>
      
      ILGenerator.EndExceptionBlock()</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Initblk">
		<summary>
			<para>Initializes a specified block of memory at a specific address to a given size and initial value.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            18</term>
					<description>initblk</description>
					<description>Set each location in a block of memory to a given
            value.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
         A starting address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         An initialization value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         The number of bytes to initialize is pushed onto the
         stack.</term>
				</item>
				<item>
					<term>
         The number of bytes, the initialization value, and the starting address
         are popped from the stack, and the initialization is performed as per their
         values.</term>
				</item>
			</list>
			<para>The <see langword="initblk"/>
instruction sets the number (<see langword="unsigned int32"/>) of bytes starting
at the specified address (of type
<see langword="natural int"/>, <see langword="&amp;"/>, or <see langword="*"/>) to the initialization value (of type <see langword="unsigned int8"/>). <see langword="initblk "/>assumes that the starting 
address is aligned to the natural size of the
machine.</para>
			<para>The operation of the <see langword="initblk"/> instructions can be altered by an
immediately preceding <see cref="System.Reflection.Emit.OpCodes.Volatile"/> or <see cref="System.Reflection.Emit.OpCodes.Unaligned"/>
prefix instruction. </para>
			<para><see cref="System.NullReferenceException"/> may be thrown if an invalid address is detected. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="initblk"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Initobj">
		<summary>
			<para>Initializes all the fields of the object at a specific
      address to a null reference or a 0
      of the appropriate primitive type.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE 15
            &lt;<see langword="T"/>&gt;</term>
					<description>initobj<paramref name=" classTok"/></description>
					<description>Initializes a value type.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      
      The address of an object to initialize is pushed onto
      the stack.</term>
				</item>
				<item>
					<term>
      
      The address is popped from the stack; the value type object at the
      specified address is initialized as type <paramref name="classTok"/>.</term>
				</item>
			</list>
			<para>The <see langword="initobj"/>
instruction initializes all the fields of the object specified by the
pushed address (of type
<see langword="natural int"/>, <see langword="&amp;"/>, or <see langword="*"/>) to a null reference or a 0 of the appropriate 
primitive type. After this method is called, the instance is ready for the
constructor method to be called. Behavior is unspecified if either the
address is not a pointer to an instance of
the class represented by <paramref name="classTok"/>, or if <paramref name="classTok"/> does not
represent a value type.</para>
			<para>Unlike <see cref="System.Reflection.Emit.OpCodes.Newobj"/>, the constructor method is not called by
<see langword="initobj"/>. <see langword="Initobj"/> is intended for initializing 
value types, while <see langword="newobj"/> is used to allocate and initialize
objects. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor
overloadscan use the <see langword="initobj"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Type)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldarga_S">
		<summary>
			<para>Load an argument address, in short form, onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 0F
            &lt;<see langword="unsigned int8"/>&gt;</term>
					<description>ldarga.s<paramref name=" index"/></description>
					<description>Fetch the address of argument indexed by
      <paramref name="index"/>, short form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      The address <paramref name="addr"/> of the argument indexed by <paramref name="index"/> is pushed
      onto the stack.</term>
				</item>
			</list>
			<para><see langword="ldarga.s"/> (the short form of
<see langword="ldarga"/>) should be used for argument 
numbers 0 through 255, and is a more efficient
encoding.</para>
			<para>The <see langword="ldarga.s"/> 
instruction fetches the address (of type <see langword="*"/> ) of
the argument indexed by <paramref name="index"/>, where arguments are indexed from 0
onwards. The address <paramref name="addr"/> is always aligned to a natural boundary
on the target machine. </para>
			<para>For procedures that take a variable-length argument list, the
<see langword="ldarga.s"/> instruction can be used only for the initial fixed 
   arguments, not those in the variable part of the signature. </para>
			<para><see langword="ldarga.s"/> is used
for by-ref parameter passing. For other cases, <see cref="System.Reflection.Emit.OpCodes.Ldarg_S"/> and <see cref="System.Reflection.Emit.OpCodes.Starg_S"/> should be used. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldarga.s"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, byte)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldarga">
		<summary>
			<para>Load an argument address onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            0A &lt;<see langword="unsigned int16"/>&gt;</term>
					<description>ldarga<paramref name=" index"/></description>
					<description>Fetch the address of argument indexed by
      <paramref name="index"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      
      The address <paramref name="addr"/> of the argument indexed by <paramref name="index"/> is pushed
      onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldarga"/> instruction fetches the address (of type <see langword="*"/>) of the argument indexed by 
<paramref name="index"/>, where arguments are indexed from 0 onwards. The address 
<paramref name="addr"/> is always aligned to a natural boundary on the target machine.</para>
			<para>For procedures that take a variable-length argument list, the
<see langword="ldarga"/> instruction can be used only for the initial fixed 
   arguments, not those in the variable part of the signature. </para>
			<para><see langword="ldarga"/> is used for by-ref parameter passing. For other
cases, <see cref="System.Reflection.Emit.OpCodes.Ldarg"/> and <see cref="System.Reflection.Emit.OpCodes.Starg"/> should be used. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldarga"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, short)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldelema">
		<summary>
			<para>Loads the address of the array element at a specified
      array index onto the top of the evaluation stack as type <see langword="&amp; "/>
      (managed pointer).</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 8F
            &lt;<see langword="T"/>&gt;</term>
					<description>ldelema<paramref name=" class"/></description>
					<description>Loads the address of the array element at <paramref name="index
         "/>onto the top of the evaluation stack as type <see langword="&amp; "/>(managed pointer).</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      
      An object reference <paramref name="array"/>
      is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      An index value <paramref name="index"/> is
      pushed onto the stack.</term>
				</item>
				<item>
					<term>
						<paramref name="index"/> and <paramref name="array"/> are popped from the stack; the address
      stored at position <paramref name="index"/> in <paramref name="array"/> is looked up.</term>
				</item>
				<item>
					<term>
      
      The address is pushed onto the stack.</term>
				</item>
			</list>
			<para> The<see langword=" ldelema"/> is used to retrieve the
address of an object at a particular index in an array of objects (of type
<paramref name="class"/>). The
<see langword=" ldelema "/>instruction loads the address of the value at index
<paramref name="index"/> (type<see langword=" natural int"/>) in the zero-based one-dimensional array 
<paramref name="array"/> and places it on the top of the stack. Arrays are 
objects and hence represented by a value of type<see langword=" O"/>. The value must be of type <paramref name="class"/> passed with the instruction.</para>
			<para>The return value for <see langword="ldelema"/> is a managed pointer<see langword=" "/>(type <see langword="&amp;"/>).</para>
			<para>Note that integer values of less than 4 bytes are
   extended to<see langword=" int32 "/> (not
<see langword="natural int"/>) when they are loaded onto the 
   evaluation stack.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if<paramref name=" array"/> is a null reference.</para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if if 
<paramref name="array"/> does not hold elements of the required type.</para>
			<para><see cref="System.IndexOutOfRangeException"/> is thrown if
<paramref name="index"/> is negative, or larger than the bound of
<paramref name=" array"/> .</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldelema"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Type)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldelem_I1">
		<summary>
			<para>Loads the element with type <see langword="int8"/> at a specified array index onto the
   top of the evaluation stack as an <see langword="int32"/>.
			</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 90</term>
					<description>ldelem.i1</description>
					<description>Loads the element with type <see langword="int8"/> at <paramref name="index"/>
      onto the top of the stack as
      an <see langword="int32"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      
      An object reference <paramref name="array"/>
      is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      An index value <paramref name="index"/> is
      pushed onto the stack.</term>
				</item>
				<item>
					<term>
						<paramref name="index"/> and <paramref name="array"/> are popped from the stack; the value stored
      at position <paramref name="index"/> in <paramref name="array"/> is looked up.</term>
				</item>
				<item>
					<term>
      
      The value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldelem.i1"/> instruction loads the
value of the element with index <paramref name="index"/> (type <see langword="natural int"/>) in
the zero-based one-dimensional array <paramref name="array"/> and places it on the top of
the stack. Arrays are objects and hence represented by a value of type
<see langword="O"/>. </para>
			<para>The return value for <see langword="ldelem.i1"/> is
<see langword=" int8"/>. </para>
			<para>Note that integer values of less than 4 bytes are
   extended to <see langword="int32"/> (not <see langword="natural int"/>) when
   they are loaded onto the
   evaluation stack.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if if 
<paramref name="array"/> does not hold elements of the required
type. </para>
			<para><see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than the bound of <paramref name="array"/>. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldelem.i1"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldelem_U1">
		<summary>
			<para>Loads the element with type <see langword="unsigned int8"/> at a specified array index
   onto the top of the evaluation stack as an <see langword="int32"/>.
			</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 91</term>
					<description>ldelem.u1</description>
					<description>Loads the element with type <see langword="unsigned int8"/> at <paramref name="index"/> onto the top of the stack as an
      <see langword="int32 "/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      An object reference <paramref name="array"/>
      is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      An index value <paramref name="index"/> is
      pushed onto the stack.</term>
				</item>
				<item>
					<term>
						<paramref name="index"/> and <paramref name="array"/> are popped from the stack; the value stored
      at position <paramref name="index"/> in <paramref name="array"/> is looked up.</term>
				</item>
				<item>
					<term>
      The value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldelem.u1"/> instruction loads the
value of the element with index <paramref name="index"/> (type <see langword="natural int"/>) in
the zero-based one-dimensional array <paramref name="array"/> and places it on the top of
the stack. Arrays are objects and hence represented by a value of type
<see langword="O"/>. </para>
			<para>The return value for <see langword="ldelem.u1"/> is
<see langword=" int8"/>. </para>
			<para>Note that integer values of less than 4 bytes are
   extended to <see langword="int32"/> (not <see langword="natural int"/>
   ) when they are loaded
   onto the
   evaluation stack.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if if 
<paramref name="array"/> does not hold elements of the required
type. </para>
			<see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than the
bound of <paramref name="array"/>.
<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload 
can use the <see langword="ldelem.u1"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldelem_I2">
		<summary>
			<para>Loads the element with type <see langword="int16"/> at a specified array index onto the
   top of the evaluation stack as an <see langword="int32"/>.
			</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 92</term>
					<description>ldelem.i2</description>
					<description>Loads the element with type <see langword="int16"/> at <paramref name="index"/>
      onto the top of the stack as
      an <see langword="int32"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      An object reference <paramref name="array"/>
      is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      An index value <paramref name="index"/> is
      pushed onto the stack.</term>
				</item>
				<item>
					<term>
						<paramref name="index"/> and <paramref name="array"/> are popped from the stack; the value stored
      at position <paramref name="index"/> in <paramref name="array"/> is looked up.</term>
				</item>
				<item>
					<term>
      The value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldelem.i2"/> instruction loads the
value of the element with index <paramref name="index"/> (type <see langword="natural int"/>) in
the zero-based one-dimensional array <paramref name="array"/> and places it on the top of
the stack. Arrays are objects and hence represented by a value of type
<see langword="O"/>. </para>
			<para>The return value for <see langword="ldelem.i2"/> is
<see langword=" int16"/>. </para>
			<para>Note that integer values of less than 4 bytes are
   extended to <see langword="int32"/> (not natural int) when
   they are loaded onto the
   evaluation stack.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if <paramref name="array"/> does not hold elements of the required
type. </para>
			<see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than the
bound of <paramref name="array"/>.
<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload 
can use the <see langword="ldelem.i2"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldelem_U2">
		<summary>
			<para>Loads the element with type <see langword="unsigned int16"/> at a specified array index
   onto the top of the evaluation stack as an <see langword="int32"/>.
			</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 93</term>
					<description>ldelem.u2</description>
					<description>Loads the element with type <see langword="unsigned int16"/> at index onto the top of the stack as an
      <see langword="int32"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      An object reference <paramref name="array"/>
      is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      An index value <paramref name="index"/> is
      pushed onto the stack.</term>
				</item>
				<item>
					<term>
						<paramref name="index"/> and <paramref name="array"/> are popped from the stack; the value stored
      at position <paramref name="index"/> in <paramref name="array"/> is looked up.</term>
				</item>
				<item>
					<term>
      The value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldelem.u2"/> instruction loads the value of the element
with index <paramref name="index"/> (type <see langword="natural int"/>) in the zero-based
one-dimensional array <paramref name="array"/> and places it on the top of the stack. Arrays
are objects and hence represented by a value of type <see langword="O"/>. </para>
			<para>The return value for <see langword="ldelem.u2"/> is <see langword="int16"/>. </para>
			<para>Note that integer values of less than 4 bytes are
   extended to <see langword="int32"/> (not <see langword="natural int"/>
   ) when they are loaded onto the evaluation stack.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if if 
<paramref name="array"/> does not hold elements of the required
type. </para>
			<see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than the
bound of <paramref name="array"/>.
<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload 
can use the <see langword="ldelem.u2"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldelem_I4">
		<summary>
			<para>Loads the element with type <see langword="int32"/> at a specified array index onto the
   top of the evaluation stack as an <see langword="int32"/>.
			</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 94</term>
					<description>ldelem.i4</description>
					<description>Loads the element with type
         <see langword="int32"/> at <paramref name="index"/> onto the top of the stack as
            an <see langword="int32"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
         An object reference <paramref name="array"/>
         is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         An index value <paramref name="index"/> is
         pushed onto the stack.</term>
				</item>
				<item>
					<term>
						<paramref name="index"/> and <paramref name="array"/> are popped from the stack; the value stored
         at position <paramref name="index"/> in <paramref name="array"/> is looked up.</term>
				</item>
				<item>
					<term>
         The value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldelem.i4"/> instruction loads the
value of the element with index <paramref name="index"/> (type <see langword="natural int"/>) in
the zero-based one-dimensional array <paramref name="array"/> and places it on the top of
the stack. Arrays are objects and hence represented by a value of type
<see langword="O"/>. </para>
			<para>The return value for <see langword="ldelem.i4"/> is
<see langword=" int32"/>. </para>
			<para> Note that integer values of less than 4 bytes are
   extended to int32 (not natural int) when they are loaded onto the
   evaluation stack.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if if 
<paramref name="array"/> does not hold elements of the required
type. </para>
			<see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than the
bound of <paramref name="array"/>.
<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload 
can use the <see langword="ldelem.i4"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldelem_U4">
		<summary>
			<para>Loads the element with type <see langword="unsigned int32"/> at a specified array index
   onto the top of the evaluation stack as an <see langword="int32"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 94</term>
					<description>ldelem.u4</description>
					<description>Loads the element with type <see langword="unsigned int32"/> at index onto the top of the stack as an
      <see langword="int32"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      An object reference <paramref name="array"/>
      is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      An index value <paramref name="index"/> is
      pushed onto the stack.</term>
				</item>
				<item>
					<term>
						<paramref name="index"/> and <paramref name="array"/> are popped from the stack; the value stored
      at position <paramref name="index"/> in <paramref name="array"/> is looked up.</term>
				</item>
				<item>
					<term>
      The value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldelem.u4"/> instruction loads the value of the element
with index <paramref name="index"/> (type <see langword="natural int"/>) in the zero-based
one-dimensional array <paramref name="array"/> and places it on the top of the stack. Arrays
are objects and hence represented by a value of type <see langword="O"/>. </para>
			<para>The return value for <see langword="ldelem.u4"/> is <see langword="int32"/>. </para>
			<para>Note that integer values of less than 4 bytes are
   extended to <see langword="int32"/> (not <see langword="natural int"/>
   ) when they are loaded onto the evaluation stack.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if array does not hold elements of the required
type. </para>
			<see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than the
bound of <paramref name="array"/>.
<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload 
can use the <see langword="ldelem.u4"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldelem_I8">
		<summary>
			<para>Loads the element with type <see langword="int64"/> at a specified array index onto the
   top of the evaluation stack as an <see langword="int64"/>.
			</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 96</term>
					<description>ldelem.i8</description>
					<description>Loads the element with type <see langword="int64"/> at <paramref name="index"/>
      onto the top of the stack as an
   <see langword="int64"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      An object reference <paramref name="array"/>
      is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      An index value <paramref name="index"/> is
      pushed onto the stack.</term>
				</item>
				<item>
					<term>
						<paramref name="index"/> and <paramref name="array"/> are popped from the stack; the value stored
      at position <paramref name="index"/> in <paramref name="array"/> is looked up.</term>
				</item>
				<item>
					<term>
      The value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldelem.i8"/> instruction loads the
value of the element with index <paramref name="index"/> (type <see langword="natural int"/>) in
the zero-based one-dimensional array <paramref name="array"/> and places it on the top of
the stack. Arrays are objects and hence represented by a value of type
<see langword="O"/>. </para>
			<para>The return value for <see langword="ldelem.i8"/> is
<see langword=" int64"/>. </para>
			<para>Note that integer values of less than 4 bytes are
   extended to <see langword="int32"/> (not <see langword="natural int"/>) when
   they are loaded onto the
   evaluation stack.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if if 
<paramref name="array"/> does not hold elements of the required
type. </para>
			<see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than the
bound of <paramref name="array"/>.
<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload 
can use the <see langword="ldelem.i8"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldelem_I">
		<summary>
			<para>Loads the element with type <see langword="natural int"/> at a specified array
   index onto the top of the evaluation stack as a <see langword="natural int"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 97</term>
					<description>ldelem.i</description>
					<description>Loads the element with type <see langword="natural int"/> at <paramref name="index"/> onto the top of the stack as a <see langword="natural int "/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      
      An object reference <paramref name="array"/>
      is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      An index value <paramref name="index"/> is
      pushed onto the stack.</term>
				</item>
				<item>
					<term>
						<paramref name="index"/> and <paramref name="array"/> are popped from the stack; the value
      stored at position <paramref name="index"/> in <paramref name="array"/> is looked up.</term>
				</item>
				<item>
					<term>
      
      The value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldelem.i"/> instruction loads the
value of the element with index <paramref name="index"/> (type <see langword="natural int"/>) in
the zero-based one-dimensional array <paramref name="array"/> and places it on the top of
the stack. Arrays are objects and hence represented by a value of type
<see langword="O"/> .</para>
			<para>The return value for <see langword="ldelem.i"/> is
<see langword="natural int"/>.</para>
			<para>Note that integer values of less than 4 bytes are
   extended to <see langword="int32"/> (not <see langword="natural int"/>) when
   they are loaded onto the
   evaluation stack.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference. </para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if if 
<paramref name="array"/> does not hold elements of the required
type. </para>
			<para><see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than
the bound of <paramref name="array"/>. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldelem.i"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldelem_R4">
		<summary>
			<para>Loads the element with type <see langword="float32"/> at a specified array index onto
   the top of the evaluation stack as type <see langword="F"/>
   (float).
			</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 98</term>
					<description>ldelem.r4</description>
					<description>Loads the element with
            type <see langword="float32"/> at <paramref name="index "/> onto the top of the stack as a
            type <see langword="F"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
         An object reference <paramref name="array"/>
         is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         An index value <paramref name="index"/> is
         pushed onto the stack.</term>
				</item>
				<item>
					<term>
						<paramref name="index"/> and <paramref name="array"/> are popped from the stack; the value stored
         at position <paramref name="index"/> in <paramref name="array"/> is looked up.</term>
				</item>
				<item>
					<term>
         The value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldelem.r4"/> instruction loads the
value of the element with index <paramref name="index"/> (type <see langword="natural int"/>) in
the zero-based one-dimensional array <paramref name="array"/> and places it on the top of
the stack. Arrays are objects and hence represented by a value of type
<see langword="O"/>. </para>
			<para>The return value for <see langword="ldelem.r4"/> is <see langword="float32"/>. </para>
			<para> Floating-point values are converted to type
<see langword="F"/> 
when loaded onto the
evaluation stack.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if if 
<paramref name="array"/> does not hold elements of the required
type. </para>
			<see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than the
bound of <paramref name="array"/>.
<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload 
can use the <see langword="ldelem.r4"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldelem_R8">
		<summary>
			<para>Loads the element with type <see langword="float64"/> at a specified array index onto
   the top of the evaluation stack as type <see langword="F"/>
   (float).
			</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 99</term>
					<description>ldelem.r8</description>
					<description>Loads the element with
            type <see langword="float64"/> at <paramref name="index"/> onto the top of the stack as
            type <see langword="F"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
         An object reference <paramref name="array"/>
         is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         An index value <paramref name="index"/> is
         pushed onto the stack.</term>
				</item>
				<item>
					<term>
						<paramref name="index"/> and <paramref name="array"/> are popped from the stack; the value stored
         at position <paramref name="index"/> in <paramref name="array"/> is looked up.</term>
				</item>
				<item>
					<term>
         The value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldelem.r8"/> instruction loads the
value of the element with index <paramref name="index"/> (type <see langword="natural int"/>) in
the zero-based one-dimensional array <paramref name="array"/> and places it on the top of
the stack. Arrays are objects and hence represented by a value of type
<see langword="O"/>. </para>
			<para>The return value for <see langword="ldelem.r8"/> is
<see langword=" float64"/>. </para>
			<para> Floating-point values are converted to type
<see langword="F "/> 
when loaded onto the
evaluation stack.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if if 
<paramref name="array"/> does not hold elements of the required
type. </para>
			<see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than the
bound of <paramref name="array"/>.
<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload 
can use the <see langword="ldelem.r8"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldelem_Ref">
		<summary>
			<para>Loads the element containing an object reference at a
      specified array index onto the top of the evaluation stack as type<see langword=" O"/> (object reference). </para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 9A</term>
					<description>ldelem.ref</description>
					<description>Loads the element with an object reference at <paramref name="index
            "/>onto the top of the stack as type
         <see langword="O"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
         An object reference <paramref name="array"/>
         is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         An index value <paramref name="index"/> is
         pushed onto the stack.</term>
				</item>
				<item>
					<term>
						<paramref name="index"/> and <paramref name="array"/> are popped from the stack; the value stored
         at position <paramref name="index"/> in <paramref name="array"/> is looked up.</term>
				</item>
				<item>
					<term>
         The value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldelem.ref"/> instruction loads the
value of the element with index <paramref name="index"/> (type <see langword="natural int"/>) in
the zero-based one-dimensional array <paramref name="array"/> and places it on the top of
the stack. Arrays are objects and hence represented by a value of type
<see langword="O"/>. </para>
			<para>The return value for <see langword="ldelem.ref"/> is type <see langword="O"/> (object
reference). </para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if if 
<paramref name="array"/> does not hold elements of the required
type. </para>
			<see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than the
bound of <paramref name="array"/>.
<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload 
can use the <see langword="ldelem.ref"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldfld">
		<summary>
			<para> Finds the value of a field in the object whose reference is currently on the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 7B
            &lt;<see langword="T"/>&gt;</term>
					<description>ldfld<paramref name=" field"/></description>
					<description>Pushes the value of a field
         in a specified object onto the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order,
   is:</para>
			<list type="number"><item>
					<term>
      
      An object reference (or pointer) is pushed onto the
      stack.</term>
				</item>
				<item>
					<term>
      
      The object reference (or pointer) is popped from the
      stack; the value of the specified field in the object is found.</term>
				</item>
				<item>
					<term>
      
      The value stored in the field is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldfld"/>
instruction pushes the value of a field located in an object onto the stack. The
object must be on the stack as an object reference (type
<see langword="O"/>), a managed pointer (type <see langword="&amp;"/>), an 
unmanaged pointer (type <see langword="natural int"/>), a transient pointer (type
<see langword="*"/>), or an instance of a value type. The use of an 
unmanaged pointer is not permitted in verifiable code. The object's field is
specified by a metadata token that must refer to a field member. The return type
is the same as the one associated with the field. The field may be either an
instance field (in which case the object must not be a null reference) or a
static field.</para>
			<para>The <see langword="ldfld"/> 
instruction can be preceded by either or both of
the <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> and <see cref="System.Reflection.Emit.OpCodes.Volatile"/> prefixes. </para>
			<para><see cref="System.NullReferenceException"/> is thrown if the object is null and the field is not static. </para>
			<para><see cref="System.MissingFieldException"/> is thrown if the specified field is not found
in the metadata. This is typically checked when Microsoft
Intermediate Language (MSIL) instructions are converted to native code, not at run time. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldfld"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, FieldInfo)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldflda">
		<summary>
			<para>Finds the address of a field in the object whose reference is currently
      on the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 7C &lt;<see langword="T"/>&gt;</term>
					<description>ldflda<paramref name=" field"/></description>
					<description>Pushes the address of <paramref name="field"/> in a specified object onto the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      An object reference (or pointer) is pushed onto the
      stack.</term>
				</item>
				<item>
					<term>
      
      The object reference (or pointer) is popped from the
      stack; the address of the specified field in the object is found.</term>
				</item>
				<item>
					<term>
      
      The address stored in the field is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldflda"/> instruction pushes
the address of a field located in an object onto the stack. The object must
be on the stack as an object reference (type <see langword="O"/>), a managed
pointer (type <see langword="&amp;"/>), an unmanaged pointer (type
<see langword="natural int"/>), a transient pointer (type <see langword="*"/> 
), or an instance of a value type. The use of an unmanaged pointer
is not permitted in verifiable code. The object's field is specified by a metadata token that
must refer to a field member.</para>
			<para>The value returned by <see langword="ldflda"/> is a managed pointer (type
<see langword="&amp;"/>) unless the object is pushed onto the stack as an 
unmanaged pointer, in which case the return address is also an unmanaged pointer
(type <see langword="natural int"/>).</para>
			<para>The <see langword="ldflda"/> 
instruction can be preceded by either or both of
the <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> and <see cref="System.Reflection.Emit.OpCodes.Volatile"/> prefixes. </para>
			<para><see cref="System.InvalidOperationException"/> is thrown if the 
object is not
within the application domain from which it is being accessed. The address of a
field that is not inside the accessing application domain cannot be loaded. </para>
			<para><see cref="System.NullReferenceException"/> is thrown if the object is null and the field is not static. </para>
			<para><see cref="System.MissingFieldException"/> is thrown if the specified field is not found
in the metadata. This is typically checked when Microsoft
Intermediate Language (MSIL) instructions are converted to native code, not at run time. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldflda"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, FieldInfo)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldind_I1">
		<summary>
			<para> Loads a value of type <see langword="int8"/> as
   an <see langword="int32"/> onto the evaluation stack indirectly.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 46</term>
					<description>ldind.i1</description>
					<description>Loads the <see langword=" int8"/> value at
         address <paramref name="addr"/> onto the stack as an <see langword=" int32"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      The address is popped from the stack; the value
      located at the address is fetched.</term>
				</item>
				<item>
					<term>
      
      The fetched value is pushed onto the stack..</term>
				</item>
			</list>
			<para>The <see langword="ldind.i1"/>
instruction indirectly loads an <see langword="int8 "/>value from the specified
address (of type <see langword="natural int"/>, <see langword="&amp;"/>,
or *) onto the stack as an <see langword="int32"/>. </para>
			<para>All of the <see langword="ldind"/>
instructions are shortcuts for a <see cref="System.Reflection.Emit.OpCodes.Ldobj"/> instruction that specifies the
corresponding built-in value class. </para>
			<para>Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> (not <see langword="natural int"/>) when they are loaded 
   onto the evaluation stack. Floating-point values are converted to
<see langword="F"/> type when loaded onto the evaluation stack. </para>
			<para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures
   that the <see langword="ldind "/>instructions are used in a manner consistent
   with the type of the pointer. </para>
			<para>The address initially pushed onto the stack must be aligned to the natural 
   size of objects on the machine or a <see cref="System.NullReferenceException"/> can occur (see the <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix
   instruction for preventative measures). The results of all MSIL instructions
   that return addresses (for example, <see cref="System.Reflection.Emit.OpCodes.Ldloca"/> and <see cref="System.Reflection.Emit.OpCodes.Ldarga"/>) are safely aligned. For
   datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.
   Code that depends on byte ordering might not run on all platforms. </para>
			<para><see cref="System.NullReferenceException"/> can be thrown if an invalid address is detected. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldind.i1"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldind_U1">
		<summary>
			<para> Loads a value of type <see langword="unsigned int8"/> as an <see langword="int32"/> onto the evaluation stack indirectly.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 47</term>
					<description>ldind.u1</description>
					<description>Loads the u <see langword="nsigned int8"/> value at
         address <paramref name="addr"/> onto the stack
         as an <see langword="int32"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      The address is popped from the stack; the value
      located at the address is fetched.</term>
				</item>
				<item>
					<term>
      
      The fetched value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldind.u1"/>
instruction indirectly
loads an <see langword="unsigned int8"/> value from the specified address (of type <see langword="natural int"/>, <see langword="&amp;"/>, or *) onto the stack as an
<see langword=" int32"/>. </para>
			<para>All of the <see langword="ldind"/>
instructions are shortcuts for a <see cref="System.Reflection.Emit.OpCodes.Ldobj"/> instruction that specifies the
corresponding built-in value class. </para>
			<para>Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> (not <see langword="natural int"/>) when they are loaded 
   onto the evaluation stack. Floating-point values are converted to
<see langword="F"/> type when loaded onto the evaluation stack. </para>
			<para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures
   that the <see langword="ldind "/>instructions are used in a manner consistent
   with the type of the pointer. </para>
			<para>The address initially pushed onto the stack must be aligned to the natural 
   size of objects on the machine or a <see cref="System.NullReferenceException"/> can occur (see the <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix
   instruction for preventative measures). The results of all MSIL instructions
   that return addresses (for example, <see cref="System.Reflection.Emit.OpCodes.Ldloca"/> and <see cref="System.Reflection.Emit.OpCodes.Ldarga"/>) are safely aligned. For
   datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.
   Code that depends on byte ordering might not run on all platforms. </para>
			<para><see cref="System.NullReferenceException"/> can be thrown if an invalid address is detected. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldind.u1"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldind_I2">
		<summary>
			<para> Loads a value of type <see langword="int16"/> as
   an <see langword="int32"/> onto the evaluation stack indirectly.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 48</term>
					<description>ldind.i2</description>
					<description>Loads the <see langword=" int16"/> value at
         address <paramref name="addr"/> onto the stack as an <see langword=" int32"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      The address is popped from the stack; the value
      located at the address is fetched.</term>
				</item>
				<item>
					<term>
      
      The fetched value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldind.i2"/> instruction indirectly
loads an <see langword=" int16"/>
value from the specified address (of type <see langword="natural int"/>,
<see langword="&amp;"/>, or *) onto the stack as an
<see langword=" int32"/>. </para>
			<para>All of the <see langword="ldind"/>
instructions are shortcuts for a <see cref="System.Reflection.Emit.OpCodes.Ldobj"/> instruction that specifies the
corresponding built-in value class. </para>
			<para>Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> (not <see langword="natural int"/>) when they are loaded 
   onto the evaluation stack. Floating-point values are converted to
<see langword="F"/> type when loaded onto the evaluation stack. </para>
			<para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures
   that the <see langword="ldind "/>instructions are used in a manner consistent
   with the type of the pointer. </para>
			<para>The address initially pushed onto the stack must be aligned to the natural 
   size of objects on the machine or a <see cref="System.NullReferenceException"/> can occur (see the <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix
   instruction for preventative measures). The results of all MSIL instructions
   that return addresses (for example, <see cref="System.Reflection.Emit.OpCodes.Ldloca"/> and <see cref="System.Reflection.Emit.OpCodes.Ldarga"/>) are safely aligned. For
   datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.
   Code that depends on byte ordering might not run on all platforms. </para>
			<para><see cref="System.NullReferenceException"/> can be thrown if an invalid address is detected. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldind.i2"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldind_U2">
		<summary>
			<para> Loads a value of type <see langword="unsigned int16"/> as an <see langword="int32"/> onto the evaluation stack indirectly.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 49</term>
					<description>ldind.u2</description>
					<description>Loads the <see langword="unsigned int16"/> value at
         address <paramref name="addr"/> onto
         the stack as an <see langword="int32"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      The address is popped from the stack; the value
      located at the address is fetched.</term>
				</item>
				<item>
					<term>
      
      The fetched value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldind.u2"/> instruction indirectly
loads an <see langword="unsigned int16"/> value from the specified address (of type <see langword="natural int"/>, <see langword="&amp;"/>, or *) onto the stack as an
<see langword=" int32"/>. </para>
			<para>All of the <see langword="ldind"/>
instructions are shortcuts for a <see cref="System.Reflection.Emit.OpCodes.Ldobj"/> instruction that specifies the
corresponding built-in value class. </para>
			<para>Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> (not <see langword="natural int"/>) when they are loaded 
   onto the evaluation stack. Floating-point values are converted to
<see langword="F"/> type when loaded onto the evaluation stack. </para>
			<para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures
   that the <see langword="ldind "/>instructions are used in a manner consistent
   with the type of the pointer. </para>
			<para>The address initially pushed onto the stack must be aligned to the natural 
   size of objects on the machine or a <see cref="System.NullReferenceException"/> can occur (see the <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix
   instruction for preventative measures). The results of all MSIL instructions
   that return addresses (for example, <see cref="System.Reflection.Emit.OpCodes.Ldloca"/> and <see cref="System.Reflection.Emit.OpCodes.Ldarga"/>) are safely aligned. For
   datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.
   Code that depends on byte ordering might not run on all platforms. </para>
			<para><see cref="System.NullReferenceException"/> can be thrown if an invalid address is detected. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldind.u2"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldind_I4">
		<summary>
			<para> Loads a value of type <see langword="int32"/> as
   an <see langword="int32"/> onto the evaluation stack indirectly.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 4A</term>
					<description>ldind.i4</description>
					<description>Loads the <see langword=" int32"/> value at
         address <paramref name="addr"/> onto the stack as an <see langword=" int32"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      The address is popped from the stack; the value
      located at the address is fetched.</term>
				</item>
				<item>
					<term>
      
      The fetched value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldind.i4"/>
instruction indirectly
loads an <see langword=" int32"/>
value from the specified address (of type <see langword="natural int"/>,
<see langword="&amp;"/>, or *) onto the stack as a
<see langword=" int32"/>. </para>
			<para>All of the <see langword="ldind"/>
instructions are shortcuts for a <see cref="System.Reflection.Emit.OpCodes.Ldobj"/> instruction that specifies the
corresponding built-in value class. </para>
			<para>Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> (not <see langword="natural int"/>) when they are loaded 
   onto the evaluation stack. Floating-point values are converted to
<see langword="F"/> type when loaded onto the evaluation stack. </para>
			<para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures
   that the <see langword="ldind "/>instructions are used in a manner consistent
   with the type of the pointer. </para>
			<para>The address initially pushed onto the stack must be aligned to the natural 
   size of objects on the machine or a <see cref="System.NullReferenceException"/> can occur (see the <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix
   instruction for preventative measures). The results of all MSIL instructions
   that return addresses (for example, <see cref="System.Reflection.Emit.OpCodes.Ldloca"/> and <see cref="System.Reflection.Emit.OpCodes.Ldarga"/>) are safely aligned. For
   datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.
   Code that depends on byte ordering might not run on all platforms. </para>
			<para><see cref="System.NullReferenceException"/> can be thrown if an invalid address is detected. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldind.i4"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldind_U4">
		<summary>
			<para> Loads a value of type <see langword="unsigned int32"/> as an <see langword="int32"/> onto the evaluation stack indirectly.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 4B</term>
					<description>ldind.u4</description>
					<description>Loads the <see langword="unsigned int32"/> value at
         address <paramref name="addr"/> onto the stack as an <see langword=" int32"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      The address is popped from the stack; the value
      located at the address is fetched.</term>
				</item>
				<item>
					<term>
      
      The fetched value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldind.u4"/>
instruction indirectly
loads an <see langword="unsigned int32"/> value from the specified address (of type <see langword="natural int"/>, <see langword="&amp;"/>, or *) onto the stack as an
<see langword=" int32"/>. </para>
			<para>All of the <see langword="ldind"/>
instructions are shortcuts for a <see cref="System.Reflection.Emit.OpCodes.Ldobj"/> instruction that specifies the
corresponding built-in value class. </para>
			<para>Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> (not <see langword="natural int"/>) when they are loaded 
   onto the evaluation stack. Floating-point values are converted to
<see langword="F"/> type when loaded onto the evaluation stack. </para>
			<para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures
   that the <see langword="ldind "/>instructions are used in a manner consistent
   with the type of the pointer. </para>
			<para>The address initially pushed onto the stack must be aligned to the natural 
   size of objects on the machine or a <see cref="System.NullReferenceException"/> can occur (see the <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix
   instruction for preventative measures). The results of all MSIL instructions
   that return addresses (for example, <see cref="System.Reflection.Emit.OpCodes.Ldloca"/> and <see cref="System.Reflection.Emit.OpCodes.Ldarga"/>) are safely aligned. For
   datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.
   Code that depends on byte ordering might not run on all platforms. </para>
			<para><see cref="System.NullReferenceException"/> can be thrown if an invalid address is detected. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldind.u4"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldind_I8">
		<summary>
			<para> Loads a value of type <see langword="int64"/> as
   an <see langword="int64"/> onto the evaluation stack indirectly.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 4C</term>
					<description>ldind.i8</description>
					<description>Loads the <see langword=" int64"/> value at
         address <paramref name="addr"/> onto the stack as an <see langword=" int64"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      The address is popped from the stack; the value
      located at the address is fetched.</term>
				</item>
				<item>
					<term>
      
      The fetched value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldind.i8"/> instruction indirectly
loads an <see langword=" int64"/>
value from the specified address (of type <see langword="natural int"/>,
<see langword="&amp;"/>, or *) onto the stack as an
<see langword=" int64"/>. </para>
			<para>All of the <see langword="ldind"/>
instructions are shortcuts for a <see cref="System.Reflection.Emit.OpCodes.Ldobj"/> instruction that specifies the
corresponding built-in value class. </para>
			<para>Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> (not <see langword="natural int"/>) when they are loaded 
   onto the evaluation stack. Floating-point values are converted to
<see langword="F"/> type when loaded onto the evaluation stack. </para>
			<para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures
   that the <see langword="ldind "/>instructions are used in a manner consistent
   with the type of the pointer. </para>
			<para>The address initially pushed onto the stack must be aligned to the natural 
   size of objects on the machine or a <see cref="System.NullReferenceException"/> can occur (see the <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix
   instruction for preventative measures). The results of all MSIL instructions
   that return addresses (for example, <see cref="System.Reflection.Emit.OpCodes.Ldloca"/> and <see cref="System.Reflection.Emit.OpCodes.Ldarga"/>) are safely aligned. For
   datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.
   Code that depends on byte ordering might not run on all platforms. </para>
			<para><see cref="System.NullReferenceException"/> can be thrown if an invalid address is detected. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldind.i8"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldind_I">
		<summary>
			<para> Loads a value of type <see langword="natural int"/> as a
<see langword="natural int"/> onto the evaluation stack indirectly.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 4D</term>
					<description>ldind.i</description>
					<description>Loads the <see langword="natural int"/> value at
         address <paramref name="addr"/> onto the stack as a <see langword="natural int"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      The address is popped from the stack; the value
      located at the address is fetched.</term>
				</item>
				<item>
					<term>
      
      The fetched value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldind.i"/> instruction indirectly
loads a <see langword="natural int"/>
value from the specified address (of type <see langword="natural int"/>, <see langword="&amp;"/>, or *) onto the stack as a
<see langword="natural int"/> 
. </para>
			<para>All of the <see langword="ldind"/>
instructions are shortcuts for a <see cref="System.Reflection.Emit.OpCodes.Ldobj"/> instruction that specifies the
corresponding built-in value class.</para>
			<para>Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> (not <see langword="natural int"/>) when they are loaded 
   onto the evaluation stack. Floating-point values are converted to
<see langword="F"/> type when loaded onto the evaluation stack. </para>
			<para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures that the <see langword="ldind "/>instructions are used in
a manner consistent with the type of the pointer. </para>
			<para>The address initially pushed onto the stack must be aligned to the natural size of objects
   on the machine or a <see cref="System.NullReferenceException"/> can occur (see the <see cref="System.Reflection.Emit.OpCodes.Unaligned"/>
   prefix
   instruction for preventative measures). The results of
   all MSIL instructions that return addresses (for example, <see cref="System.Reflection.Emit.OpCodes.Ldloca"/> and <see cref="System.Reflection.Emit.OpCodes.Ldarga"/>) are safely aligned. For datatypes
   larger than 1 byte, the byte ordering is dependent on the target CPU. Code that
   depends on byte ordering might not run on all platforms. </para>
			<para><see cref="System.NullReferenceException"/> can be thrown if an invalid address is detected. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldind.i"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldind_R4">
		<summary>
			<para> Loads a value of
      type <see langword="float32"/> as a type <see langword="F"/> (float) onto the evaluation stack indirectly.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 4E</term>
					<description>ldind.r4</description>
					<description>Loads the <see langword=" float32"/> value at
         address <paramref name="addr"/> onto the stack as a
         type <see langword="F"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      The address is popped from the stack; the value
      located at the address is fetched.</term>
				</item>
				<item>
					<term>
      
      The fetched value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldind.r4"/> instruction indirectly
loads a <see langword=" float32"/>
value from the specified address (of type <see langword="natural int"/>,
<see langword="&amp;"/>, or *) onto the stack as a
type <see langword="F"/>. </para>
			<para>All of the <see langword="ldind"/>
instructions are shortcuts for a <see cref="System.Reflection.Emit.OpCodes.Ldobj"/> instruction that specifies the
corresponding built-in value class. </para>
			<para>Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> (not <see langword="natural int"/>) when they are loaded 
   onto the evaluation stack. Floating-point values are converted to
<see langword="F"/> type when loaded onto the evaluation stack. </para>
			<para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures
   that the <see langword="ldind "/>instructions are used in a manner consistent
   with the type of the pointer. </para>
			<para>The address initially pushed onto the stack must be aligned to the natural 
   size of objects on the machine or a <see cref="System.NullReferenceException"/> can occur (see the <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix
   instruction for preventative measures). The results of all MSIL instructions
   that return addresses (for example, <see cref="System.Reflection.Emit.OpCodes.Ldloca"/> and <see cref="System.Reflection.Emit.OpCodes.Ldarga"/>) are safely aligned. For
   datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.
   Code that depends on byte ordering might not run on all platforms. </para>
			<para><see cref="System.NullReferenceException"/> can be thrown if an invalid address is detected. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldind.r4"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldind_R8">
		<summary>
			<para> Loads a value of
      type <see langword="float64"/> as a type <see langword="F"/> (float) onto the evaluation stack indirectly.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 4F</term>
					<description>ldind.r8</description>
					<description>Loads the <see langword=" float64"/> value at
         address <paramref name="addr"/> onto the stack as a type <see langword="F"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      The address is popped from the stack; the value
      located at the address is fetched.</term>
				</item>
				<item>
					<term>
      
      The fetched value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldind.r8"/>
instruction indirectly
loads a <see langword=" float64"/>
value from the specified address (of type <see langword="natural int"/>,
<see langword="&amp;"/>, or *) onto the stack as a
<see langword=" float64"/>. </para>
			<para>All of the <see langword="ldind"/>
instructions are shortcuts for a <see cref="System.Reflection.Emit.OpCodes.Ldobj"/> instruction that specifies the
corresponding built-in value class. </para>
			<para>Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> (not <see langword="natural int"/>) when they are loaded 
   onto the evaluation stack. Floating-point values are converted to
<see langword="F"/> type when loaded onto the evaluation stack. </para>
			<para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures
   that the <see langword="ldind "/>instructions are used in a manner consistent
   with the type of the pointer. </para>
			<para>The address initially pushed onto the stack must be aligned to the natural 
   size of objects on the machine or a <see cref="System.NullReferenceException"/> can occur (see the <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix
   instruction for preventative measures). The results of all MSIL instructions
   that return addresses (for example, <see cref="System.Reflection.Emit.OpCodes.Ldloca"/> and <see cref="System.Reflection.Emit.OpCodes.Ldarga"/>) are safely aligned. For
   datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.
   Code that depends on byte ordering might not run on all platforms. </para>
			<para><see cref="System.NullReferenceException"/> can be thrown if an invalid address is detected. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldind.r8"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldind_Ref">
		<summary>
			<para> Loads an object reference as a
      type <see langword="O"/> (object reference) onto the evaluation stack indirectly.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 50</term>
					<description>ldind.ref</description>
					<description>Loads the object reference at
            address <paramref name="addr"/> onto the stack as a type <see langword=" O"/></description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         
         An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         The address is popped from the stack; the object
         reference located at the address is fetched.</term>
				</item>
				<item>
					<term>
         
         The fetched reference is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldind.ref"/>
instruction indirectly loads the object reference the specified address (of type
<see langword="natural int"/>, <see langword="&amp;"/>, or *) onto the stack
as type <see langword="O"/>. </para>
			<para>All of the <see langword="ldind"/>
instructions are shortcuts for a <see cref="System.Reflection.Emit.OpCodes.Ldobj"/> instruction that specifies the
corresponding built-in value class. </para>
			<para>Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> (not <see langword="natural int"/>) when they are loaded 
   onto the evaluation stack. Floating-point values are converted to
<see langword="F"/> type when loaded onto the evaluation stack. </para>
			<para>Correctly-formed Microsoft Intermediate Language (MSIL) ensures
   that the <see langword="ldind "/>instructions are used in a manner consistent
   with the type of the pointer. </para>
			<para>The address initially pushed onto the stack must be aligned to the natural 
   size of objects on the machine or a <see cref="System.NullReferenceException"/> can occur (see the <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix
   instruction for preventative measures). The results of all MSIL instructions
   that return addresses (for example, <see cref="System.Reflection.Emit.OpCodes.Ldloca"/> and <see cref="System.Reflection.Emit.OpCodes.Ldarga"/>) are safely aligned. For
   datatypes larger than 1 byte, the byte ordering is dependent on the target CPU.
   Code that depends on byte ordering might not run on all platforms. </para>
			<para><see cref="System.NullReferenceException"/> can be thrown if an invalid address is detected. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload can
use the <see langword="ldind.ref"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldnull">
		<summary>
			<para>Pushes a null reference (type <see langword="O"/>) onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 14</term>
					<description>ldnull</description>
					<description>push a null reference onto the
            stack</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         A null object reference is pushed onto the
         stack.</term>
				</item>
			</list>
			<para><see langword="ldnull"/> pushes a null
reference (type <see langword="O"/>) on the
stack. This is used to initialize locations before they are populated with data, or
when they become deprecated.</para>
			<para><see langword="ldnull"/> provides a 
null reference that is
size-independent.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldnull"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldobj">
		<summary>
			<para>Copies the value type object pointed to by an
      address to the top of the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 71
            &lt;<see langword="T"/>&gt;</term>
					<description>ldobj<paramref name=" class"/></description>
					<description>Copy instance of value type <paramref name="class"/> to the
      stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      The address of a value type object is pushed onto the
      stack.</term>
				</item>
				<item>
					<term>
      
      The address is popped from the stack and the instance
      at that particular address is looked up.</term>
				</item>
				<item>
					<term>
      
      The value of the object stored at that address <paramref name=""/>is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="ldobj"/>
instruction is used to pass a value type as a parameter.</para>
			<para>The <see langword="ldobj"/> instruction copies the value pointed to by
<paramref name="addrOfValObj "/>(of type <see langword="&amp;"/>, <see langword="*"/>, or 
<see langword="natural int"/>) to the top of the stack. The number of bytes copied depends on the 
size of the class (as specified by the <paramref name="class"/> parameter). The
<paramref name="class"/> parameter is a metadata token representing the value type. </para>
			<para>The operation of the <see langword="ldobj "/>instruction can be altered by an
immediately preceding <see cref="System.Reflection.Emit.OpCodes.Volatile"/> or <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix instruction. </para>
			<para><see cref="System.TypeLoadException"/> is thrown if class cannot be
found. This is typically detected when the Microsoft
Intermediate Language (MSIL) instruction is converted to native code rather than at runtime. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldobj"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Type)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldsfld">
		<summary>
			<para>Pushes the value of a static field onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 7E
            &lt;<see langword="T"/>&gt;</term>
					<description>ldsfld<paramref name=" field"/></description>
					<description>Push the value of <paramref name="field"/> on the
      stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      The value of the specific field is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldsfld"/>
instruction pushes the value of a static (shared among all instances of a class)
field on the stack. The return type is that associated with the passed
metadata token <paramref name="field"/>.</para>
			<para>The <see langword="ldsfld"/> 
instruction can have a <see cref="System.Reflection.Emit.OpCodes.Volatile"/> prefix. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldsfld"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, FieldInfo)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldsflda">
		<summary>
			<para>Pushes the address of a static field onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 7F
            &lt;<see langword="T"/>&gt;</term>
					<description>ldsflda <paramref name="field"/></description>
					<description>Push the address of <paramref name="field"/> on the
      stack</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      The address of a specific field is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldsflda"/>
instruction pushes the address of a static (shared among all instances of a
class) field on the stack. The address may be represented as a transient pointer (type
<see langword="*"/>) if the metadata token 
<paramref name="field "/> 
refers to a type whose memory is managed. Otherwise, it corresponds
to an unmanaged pointer (type <see langword="natural int"/>). Note that
<paramref name="field"/> may be a static global with an assigned relative 
virtual address (the offset of the field from the base address at which its containing
PE file is
loaded into memory) where the memory is unmanaged. </para>
			<para>The <see langword="ldsflda"/> 
instruction can have a <see cref="System.Reflection.Emit.OpCodes.Volatile"/>
prefix. </para>
			<para><see cref="System.MissingFieldException"/> is thrown if field is not
found in the metadata. This is typically checked when
Microsoft Intermediate Language (MSIL) instructions are converted to native code, not at runtime.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldsflda"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, FieldInfo)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ldtoken">
		<summary>
			<para>Converts a metadata token to its
      runtime representation, pushing it onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> D0
            &lt;<see langword="T"/>&gt;</term>
					<description>ldtoken<paramref name=" token"/></description>
					<description>Converts a metadata token to its runtime
         representation.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      The passed token is converted to a <see langword="RuntimeHandle"/> and
      pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldtoken"/> instruction pushes a
<see langword="RuntimeHandle"/> for the specified metadata token. A 
<see langword="RuntimeHandle"/> 
can be a <see langword="fieldref/fielddef"/>, a
<see langword="methodref/methoddef"/>, or a <see langword="typeref/typedef"/> .</para>
			<para>The value pushed on the stack can be used in calls to
<see langword="Reflection"/> methods in the system class library.</para>
			<para>For information on runtime handles, see the following classes: <see cref="System.RuntimeFieldHandle"/>, 
<see cref="System.RuntimeTypeHandle"/>, and <see cref="System.RuntimeMethodHandle"/>.</para>
			<para> The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overloads
can use the <see langword="ldtoken"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, MethodInfo)</term>
				</item>
				<item>
					<term>
      
      ILGenerator.Emit(OpCode, FieldInfo)</term>
				</item>
				<item>
					<term>
      
      ILGenerator.Emit(OpCode, Type)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Ret">
		<summary>
			<para> Returns from the current method, pushing a return value (if
      present) from the caller's evaluation stack onto the callee's evaluation
      stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 2A</term>
					<description>ret</description>
					<description>Returns from method, possibly returning a
            value.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         
         The return value is popped from the callee evaluation
         stack.</term>
				</item>
				<item>
					<term>
         
         The return value obtained in step 1 is pushed onto the caller evaluation
         stack.</term>
				</item>
			</list>
			<para>If the return value is not present on the callee evaluation stack, no value
   is returned (no stack transition behaviors for either the callee or caller
   method).</para>
			<para>The type of the return value, if any, of the
   current method determines the type of value to be fetched from the top of the
   stack and copied onto the stack of the method that called the current method.
   The evaluation stack for the current method must be empty except for the value
   to be returned.</para>
			<para>The <see langword="ret"/> instruction cannot be used to transfer control out
of a <see langword="try"/>, <see langword="filter"/>, <see langword="catch"/>, or
<see langword="finally"/> block. From within a <see langword="try"/> or 
<see langword="catch"/>, use the <see cref="System.Reflection.Emit.OpCodes.Leave"/> instruction with a 
destination of a <see langword="ret"/> instruction that is outside all enclosing
exception blocks. Because the <see langword="filter"/> and
<see langword="finally"/> blocks are logically part of exception 
handling and not the method in
which their code is embedded, correctly generated Microsoft Intermediate Language (MSIL) instructions do not
perform a method return from within a <see langword="filter"/> or
<see langword="finally"/>. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ret"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Rem_Un">
		<summary>
			<para>Divides two unsigned values and pushes the remainder onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 5E</term>
					<description>rem.un</description>
					<description>Pushes the remainder of dividing unsigned
         <paramref name="value1"/> by unsigned <paramref name="value2"/> onto the
            stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack and the
         remainder of <paramref name="value1"/> div <paramref name="value2"/>
         computed.</term>
				</item>
				<item>
					<term>
         The result is pushed onto the stack.</term>
				</item>
			</list>
			<para><paramref name="result"/> = <paramref name="value1"/>
				<see langword="rem.un"/>
				<paramref name="value2"/> satisfies the following conditions: </para>
			<para><paramref name="result"/> = <paramref name="value1"/>
				<see langword="-"/>
				<paramref name="value2 "/>x<paramref name=" "/>(<paramref name="value1"/>
				<see langword="div.un"/>
				<paramref name="value2"/>), and:</para>
			<para> 0 = <paramref name="result"/> &lt; <paramref name="value2"/>, where
<see langword="div.un"/> is the unsigned division instruction. </para>
			<para>The <see langword="rem.un"/> instruction computes
<paramref name="result"/> and pushes it on the stack. <see langword="Rem.un"/> treats its 
arguments as unsigned integers, while <see cref="System.Reflection.Emit.OpCodes.Rem"/> treats them as signed
integers. </para>
			<para><see langword="Rem.un"/> is unspecified for
floating-point numbers.</para>
			<para>Integral operations throw <see cref="System.DivideByZeroException"/> if
<paramref name="value2"/> is zero. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="rem.un"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Newarr">
		<summary>
			<para>Pushes an object reference to a new zero-based,
      one-dimensional array whose elements are of a specific type onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 8D
            &lt;<see langword="T"/>&gt;</term>
					<description>newarr <paramref name="etype"/></description>
					<description>Createa a new array with elements of type
      <paramref name="etype"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      
      The number of elements in the array is pushed onto
      the stack.</term>
				</item>
				<item>
					<term>
      
      The number of elementes is popped from the stack and
      the array is created.</term>
				</item>
				<item>
					<term>
      
      An object reference to the new array is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="newarr"/>
instruction pushes an object reference (type <see langword="O"/>) to a new zero-based, one-dimensional array whose elements are of type
<paramref name="etype"/> (a metadata token 
describing the type). The number of elements in the new array should
be specified as a <see langword="natural int"/>. Valid array
indexes range from zero to the
maximum number of elements minus one.</para>
			<para>The elements of an array can be any type, including value types.</para>
			<para>Zero-based, one-dimensional arrays of numbers are created using a metadata
   token referencing the appropriate value type (<see cref="System.Int32"/>, and so on). Elements of the array are
   initialized to 0 of the appropriate type. </para>
			<para> Nonzero-based one-dimensional arrays and multidimensional arrays are
   created using <see cref="System.Reflection.Emit.OpCodes.Newobj"/> rather than <see langword="newarr"/>.
   More commonly, they are created using the methods of the <see cref="System.Array"/> class in the
   .NET Framework. </para>
			<para><see cref="System.OutOfMemoryException"/> is thrown if there is insufficient memory to satisfy the
request. </para>
			<para><see cref="System.OverflowException"/> is thrown if<paramref name=" numElems"/> is less than 0.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="newarr"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Type)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stelem_I">
		<summary>
			<para>Replaces the array element at a given index with
      the <see langword="natural int"/> value on the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 9B</term>
					<description>stelem.i</description>
					<description>Replaces an array element at the supplied
            index with the <see langword="natural int"/> value on the
            stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         
         An object reference to an array, <paramref name="array"/>, is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         A valid index to an element in <paramref name="array"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         The value, the index, and the array reference are popped from the stack;
         the value is put into the array element at the given index.</term>
				</item>
			</list>
			<para>The <see langword="stelem.i"/> instruction replaces the 
value of the element <paramref name="index"/> in the one-dimensional array <paramref name="array"/> with
the <see langword="natural int"/> value pushed onto the stack.</para>
			<para>Arrays are objects and hence represented by a value of
   type <see langword="O"/>. The index is type <see langword="natural int"/>.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than 
the bound of <paramref name="array"/>. </para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if <paramref name="array"/> does not hold elements of the required
type. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stelem.i"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stelem_I1">
		<summary>
			<para>Replaces the array element at a given index with
      the <see langword="int8"/> value on the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 9C</term>
					<description>stelem.i1</description>
					<description>Replaces an array element at the supplied
            index with
            the <see langword="int8"/> value on the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         
         An object reference to an array, <paramref name="array"/>, is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         A valid index to an element in <paramref name="array"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         The value, the index, and the array reference are popped from the stack;
         the value is put into the array element at the given index.</term>
				</item>
			</list>
			<para>The <see langword="stelem.i1"/> instruction replaces the value of the element
<paramref name="index"/> in the one-dimensional array <paramref name="array"/> with the 
<see langword="int8"/> value pushed onto the stack.</para>
			<para>Arrays are objects and hence represented by a value of
   type <see langword="O"/>. The index is type <see langword="natural int"/>.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than 
the bound of <paramref name="array"/>. </para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if <paramref name="array"/> does not hold elements of the required
type. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stelem.i1"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stelem_I2">
		<summary>
			<para>Replaces the array element at a given index with
      the <see langword="int16"/> value on the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 9D</term>
					<description>stelem.i2</description>
					<description>Replaces an array element at the supplied
            index with the <see langword="int16"/> value on the
            stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         
         An object reference to an array, <paramref name="array"/>, is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         A valid index to an element in <paramref name="array"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         The value, the index, and the array reference are popped from the stack;
         the value is put into the array element at the given index.</term>
				</item>
			</list>
			<para>The <see langword="stelem.i2"/> instruction replaces the value of the element
<paramref name="index"/> in the one-dimensional array <paramref name="array"/> with the 
<see langword="int16"/> value pushed onto the stack.</para>
			<para>Arrays are objects and hence represented by a value of
   type <see langword="O"/>. The index is type <see langword="natural int"/>.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than 
the bound of <paramref name="array"/>. </para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if <paramref name="array"/> does not hold elements of the required
type. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stelem.i2"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stelem_I4">
		<summary>
			<para>Replaces the array element at a given index with
      the <see langword="int32"/> value on the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 9E</term>
					<description>stelem.i4</description>
					<description>Replaces an array element at the supplied
            index with the <see langword="int32"/> value on the
            stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         
         An object reference to an array, <paramref name="array"/>, is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         A valid index to an element in <paramref name="array"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         The value, the index, and the array reference are popped from the stack;
         the value is put into the array element at the given index.</term>
				</item>
			</list>
			<para>The <see langword="stelem.i4"/> instruction replaces the value of the element
<paramref name="index"/> in the one-dimensional array <paramref name="array"/> with the 
<see langword="int32"/> value pushed onto the stack.</para>
			<para>Arrays are objects and hence represented by a value of
   type <see langword="O"/>. The index is type <see langword="natural int"/>.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than 
the bound of <paramref name="array"/>. </para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if <paramref name="array"/> does not hold elements of the required
type. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stelem.i4"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stelem_I8">
		<summary>
			<para>Replaces the array element at a given index with
      the <see langword="int64"/> value on the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 9F</term>
					<description>stelem.i8</description>
					<description>Replaces an array element at the supplied
            index with the <see langword="int64"/> value on the
            stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         
         An object reference to an array, <paramref name="array"/>, is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         A valid index to an element in <paramref name="array"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         The value, the index, and the array reference are popped from the stack;
         the value is put into the array element at the given index.</term>
				</item>
			</list>
			<para>The <see langword="stelem.i8"/> instruction replaces the value of the element
<paramref name="index"/> in the one-dimensional array <paramref name="array"/> with the 
<see langword="int64"/> value pushed onto the stack.</para>
			<para>Arrays are objects and hence represented by a value of
   type <see langword="O"/>. The index is type <see langword="natural int"/>.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than 
the bound of <paramref name="array"/>. </para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if <paramref name="array"/> does not hold elements of the required
type. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stelem.i8"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stelem_R4">
		<summary>
			<para>Replaces the array element at a given index with
      the <see langword="float32"/> value on the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> A0</term>
					<description>stelem.r4</description>
					<description>Replaces an array element at the supplied
            index with the <see langword="float32"/> value on the
            stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         
         An object reference to an array, <paramref name="array"/>, is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         A valid index to an element in <paramref name="array"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         The value, the index, and the array reference are popped from the stack;
         the value is put into the array element at the given index.</term>
				</item>
			</list>
			<para>The <see langword="stelem.r4"/> instruction replaces the value of the element
<paramref name="index"/> in the one-dimensional array <paramref name="array"/> with the 
<see langword="float32"/> value pushed onto the stack.</para>
			<para>Arrays are objects and hence represented by a value of
   type <see langword="O"/>. The index is type <see langword="natural int"/>.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference.</para>
			<para><see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than 
the bound of <paramref name="array"/>. </para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if <paramref name="array"/> does not hold elements of the required
type. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stelem.r4"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Mul_Ovf">
		<summary>
			<para>Multiplies two integer
      values, performs an overflow check, and pushes the result
      onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> D8</term>
					<description>mul.ovf</description>
					<description>Multiplies two integer values on the stack with an overflow
            check.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term><paramref name="value1"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term><paramref name="value2"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term><paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; <paramref name="value1"/>
is multiplied by <paramref name="value2"/>, with an overflow check.</term>
				</item>
				<item>
					<term>The result is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="mul.ovf"/> instruction multiplies integer <paramref name="value1"/> by integer
<paramref name="value2"/> and pushes the result<paramref name=" "/>on the stack. An exception is thrown if the result will not fit in the result type.</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the result type. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="mul.ovf"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Leave">
		<summary>
			<para>Exits a protected region of code, unconditionally
      tranferring control to a specific target instruction.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> DD
            &lt;<see langword="int32"/>&gt;</term>
					<description>leave<paramref name=" target"/></description>
					<description>Exits a protected region of
         code.</description>
				</item>
			</list>
			<para>There is no stack transition behavior specified for this instruction.</para>
			<para>The <see langword="leave"/>
instruction unconditionally transfers control to the specific target instruction, represented as a 4-byte signed
offset from the beginning of the instruction following the current instruction.</para>
			<para>The <see langword="leave "/>instruction is similar to the <see langword="br"/>
instruction, but it can be used to exit a <see langword="try"/>,
<see langword="filter"/>, or <see langword="catch"/> block whereas the ordinary 
branch instructions can only be used in such a block to transfer control within
it. The <see langword="leave"/> instruction empties the evaluation stack and
ensures that the appropriate surrounding <see langword="finally"/> blocks are
executed.</para>
			<para> You cannot use a <see langword="leave"/> instruction to exit a
<see langword="finally"/> block. To ease code generation for exception handlers 
it is valid from within a catch block to use a <see langword="leave"/>
instruction to transfer control to any instruction within the associated
<see langword="try"/> block. </para>
			<para>If an instruction has one or more prefix codes, control can only be
   transferred to the first of these prefixes. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overloads
can use the <see langword="leave"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Leave_S">
		<summary>
			<para>Exits a protected region of code, unconditionally
      tranferring control to a target instruction (short form).</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> DE
            &lt;<see langword="int8"/>&gt;</term>
					<description>leave.s <paramref name="target"/></description>
					<description>Exit a protected region of code, short
         form.</description>
				</item>
			</list>
			<para>There is no stack transition behavior specified for this instruction.</para>
			<para>The <see langword="leave.s"/>
instruction unconditionally transfers control to the passed target instruction, represented as a 1-byte signed offset from the
beginning of the instruction following the current instruction. </para>
			<para>The <see langword="leave.s "/>instruction is similar to the
<see langword="br"/> instruction, but it can be used to exit a 
<see langword="try"/>, <see langword="filter"/>, or <see langword="catch"/> block 
whereas the ordinary branch instructions can only be used in such a block to
transfer control within it. The <see langword="leave.s"/> instruction empties the
evaluation stack and ensures that the appropriate surrounding
<see langword="finally"/> blocks are executed.</para>
			<para> You cannot use a <see langword="leave.s"/> instruction to exit a
<see langword="finally"/> block. To ease code generation for exception 
handlers it is valid from within a catch block to use a <see langword="leave.s"/>
instruction to transfer control to any instruction within the associated
<see langword="try"/> block. </para>
			<para>If an instruction has one or more prefix codes, control can only be
   transferred to the first of these prefixes. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="leave.s"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stind_Ref">
		<summary>
			<para>Stores a object reference value at a supplied
      address.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 51</term>
					<description>stind.ref</description>
					<description>Stores an object reference (type <see langword="O"/>) value at a given
         address.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      The value and the address are popped from the stack; the value is stored
      at the address.</term>
				</item>
			</list>
			<para>The <see langword="stind.ref "/>instruction stores an object reference value at the supplied address
(type <see langword="natural int"/>,
<see langword="*"/>, or <see langword="&amp;"/>). </para>
			<para>Type safe operation requires that the <see langword="stind.ref"/> instruction be
used in a manner consistent with the type of the pointer. The operation of the
<see langword="stind.ref"/> instruction can be altered by an immediately 
preceding <see cref="System.Reflection.Emit.OpCodes.Volatile"/> or <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix instruction. </para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="addr"/> is not naturally aligned for
the argument type implied by the instruction suffix. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stind.ref"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stind_I1">
		<summary>
			<para>Stores a value of type <see langword=" int8"/>
at a supplied address.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 52</term>
					<description>stind.i1</description>
					<description>Stores an <see langword=" int8"/>
      value at at a given address.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      The value and the address are popped from the stack; the value is stored
      at the address.</term>
				</item>
			</list>
			<para>The <see langword="stind.i1"/>
instruction stores an <see langword="int8"/> value at the
supplied address (type <see langword="natural int"/>,
<see langword="*"/>, or <see langword="&amp;"/>). </para>
			<para>Type safe operation requires that the <see langword="stind.i1"/> instruction be
used in a manner consistent with the type of the pointer. The operation of the
<see langword="stind.i1"/> instruction can be altered by an immediately 
preceding <see cref="System.Reflection.Emit.OpCodes.Volatile"/> or <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix instruction. </para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="addr"/> is not naturally aligned for
the argument type implied by the instruction suffix. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stind.i1"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stind_I2">
		<summary>
			<para>Stores a value of type <see langword=" int16"/>
at a supplied address.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 53</term>
					<description>stind.i2</description>
					<description>Stores an <see langword=" int16"/>
      value at at a given address.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      The value and the address are popped from the stack; the value is stored
      at the address.</term>
				</item>
			</list>
			<para>The <see langword="stind.i2"/>
instruction stores an <see langword="int16"/> value at the
supplied address (type <see langword="natural int"/>,
<see langword="*"/>, or <see langword="&amp;"/>). </para>
			<para>Type safe operation requires that the <see langword="stind.2i"/> instruction be
used in a manner consistent with the type of the pointer. The operation of the
<see langword="stind.i2"/> instruction can be altered by an immediately 
preceding <see cref="System.Reflection.Emit.OpCodes.Volatile"/> or <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix instruction. </para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="addr"/> is not naturally aligned for
the argument type implied by the instruction suffix. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stind.i2"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stind_I4">
		<summary>
			<para>Stores a value of type <see langword=" int32"/>
at a supplied address.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 54</term>
					<description>stind.i4</description>
					<description>Stores an <see langword=" int32"/>
      value at at a given address.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      The value and the address are popped from the stack; the value is stored
      at the address.</term>
				</item>
			</list>
			<para>The <see langword="stind.i4"/>
instruction stores an <see langword="int32"/> value at the
supplied address (type <see langword="natural int"/>,
<see langword="*"/>, or <see langword="&amp;"/>). </para>
			<para>Type safe operation requires that the <see langword="stind.i4"/> instruction be
used in a manner consistent with the type of the pointer. The operation of the
<see langword="stind.i4"/> instruction can be altered by an immediately 
preceding <see cref="System.Reflection.Emit.OpCodes.Volatile"/> or <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix instruction. </para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="addr"/> is not naturally aligned for
the argument type implied by the instruction suffix. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stind.i4"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stind_I8">
		<summary>
			<para>Stores a value of type <see langword=" int64"/>
at a supplied address.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 55</term>
					<description>stind.i8</description>
					<description>Stores an <see langword=" int64"/>
      value at at a given address.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      The value and the address are popped from the stack; the value is stored
      at the address.</term>
				</item>
			</list>
			<para>The <see langword="stind.i8"/>
instruction stores an <see langword="int64"/> value at the
supplied address (type <see langword="natural int"/>,
<see langword="*"/>, or <see langword="&amp;"/>). </para>
			<para>Type safe operation requires that the <see langword="stind.i8"/> instruction be
used in a manner consistent with the type of the pointer. The operation of the
<see langword="stind.i"/> instruction can be altered by an immediately 
preceding <see cref="System.Reflection.Emit.OpCodes.Volatile"/> or <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix instruction. </para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="addr"/> is not naturally aligned for
the argument type implied by the instruction suffix. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stind.i8"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stind_R4">
		<summary>
			<para>Stores a value of type <see langword=" float32"/>
at a supplied address.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 56</term>
					<description>stind.r4</description>
					<description>Stores a <see langword=" float32"/> value at at a given
         address.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      The value and the address are popped from the stack; the value is stored
      at the address.</term>
				</item>
			</list>
			<para>The <see langword="stind.r4"/>
instruction stores a <see langword="float32"/> value at the
supplied address (type <see langword="natural int"/>,
<see langword="*"/>, or <see langword="&amp;"/>). </para>
			<para>Type safe operation requires that the <see langword="stind.r4"/> instruction be
used in a manner consistent with the type of the pointer. The operation of the
<see langword="stind.r4"/> instruction can be altered by an immediately 
preceding <see cref="System.Reflection.Emit.OpCodes.Volatile"/> or <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix instruction. </para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="addr"/> is not naturally aligned for
the argument type implied by the instruction suffix. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stind.r4"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stind_R8">
		<summary>
			<para>Stores a value of type <see langword=" float64"/>
at a supplied address.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 57</term>
					<description>stind.r8</description>
					<description>Stores a <see langword="float64 "/>value at at a given address.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      The value and the address are popped from the stack; the value is stored
      at the address.</term>
				</item>
			</list>
			<para>The <see langword="stind.r8"/> instruction stores
a <see langword="float64"/> value at the
supplied address (type
<see langword="natural int"/>, <see langword="*"/>, or <see langword="&amp;"/>). </para>
			<para>Type safe operation requires that the <see langword="stind.r8"/> instruction
be used in a manner consistent with the type of the pointer. The operation of
the <see langword="stind.r8"/> instruction can be altered by an immediately
preceding <see cref="System.Reflection.Emit.OpCodes.Volatile"/> or <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix instruction. </para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="addr"/> is not naturally aligned for
the argument type implied by the instruction suffix. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stind.r8"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Sub">
		<summary>
			<para>Subtracts one value from another and
      pushes the result onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 59</term>
					<description>sub</description>
					<description>Subtracts one value from another, returning a new
            numeric value.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; <paramref name="value2"/>
      is subtracted from <paramref name="value1"/>.</term>
				</item>
				<item>
					<term>
      
      The result is pushed onto the stack.</term>
				</item>
			</list>
			<para>Overflow is not detected for integer operations (for
   proper overflow handling, see <see cref="System.Reflection.Emit.OpCodes.Sub_Ovf"/> ). </para>
			<para>Integer subtraction wraps, rather than saturates. For example: assuming 8-bit
   integers, where<paramref name=" value1"/> is set to 255 and <paramref name="value2"/> is set to 1, the
   "wrapped" result will be 0 rather than 256. </para>
			<para>Floating-point overflow returns <see langword="+inf"/>
(<see langword="PositiveInfinity"/>) or <see langword="-inf"/>
(<see langword="NegativeInfinity"/>). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="sub"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stfld">
		<summary>
			<para>Replaces the value stored in the field of an
      object reference or pointer with a new value.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 7D
            &lt;<see langword="T"/>&gt;</term>
					<description>stfld<paramref name=" field"/></description>
					<description>Replaces the value of <paramref name="field"/> of the object with a new
      value.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      An object reference or pointer is pushed onto the
      stack.</term>
				</item>
				<item>
					<term>
      
      A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      The value and the object reference/pointer are popped from the stack; the
      value of <paramref name="field"/> in the object is replaced with the supplied
      value.</term>
				</item>
			</list>
			<para>The <see langword="stfld"/> instruction replaces the value
of a field of an object (type <see langword="O"/>) or via a pointer (type
<see langword="natural int"/>, <see langword="&amp;"/>, or <see langword="*"/>) 
with a givne value. <paramref name="Field"/> is a
metadata token that refers to a field member reference. The
<see langword="stfld"/> instruction can have a prefix of either or both 
of <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> and <see cref="System.Reflection.Emit.OpCodes.Volatile"/>.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if the object
reference or pointer is a null reference and the
field isn't static. </para>
			<para><see cref="System.MissingFieldException"/> is thrown if <paramref name="field"/> is not found in the metadata. This is typically
checked
when the Microsoft Intermediate Language (MSIL) instruction is converted to native code, not at runtime. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stfld"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, FieldInfo)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stsfld">
		<summary>
			<para>Replaces the value of a static field with a value from the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 80
            &lt;<see langword="T"/>&gt;</term>
					<description>stsfld<paramref name=" field"/></description>
					<description>Replaces the value in <paramref name="field"/> with a supplied
      value.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      A value is popped from the stack and stored in <paramref name="field"/>.</term>
				</item>
			</list>
			<para>The <see langword="stsfld"/> 
instruction replaces the value of a static field with a value from the stack.
<paramref name="field"/> is a metadata token that must refer to a static
field member.</para>
			<para>The <see langword="stsfld"/> instruction may be prefixed
by <see cref="System.Reflection.Emit.OpCodes.Volatile"/> .</para>
			<para><see cref="System.MissingFieldException"/> is thrown if field is not 
found in the metadata. This is typically checked when Microsoft
Intermediate Language (MSIL) instructions are converted to native code, not at run time. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stsfld"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, FieldInfo)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stobj">
		<summary>
			<para>Copies a value of a specified type from the evaluation
      stack into a supplied memory address.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 81
            &lt;<see langword="T"/>&gt;</term>
					<description>stobj<paramref name=" class"/></description>
					<description>Stores a value of type <paramref name="class"/> from the
      stack into memory.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      A value type object of type <paramref name="class"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      The object and the address are popped from the stack; the value type
      object is stored at the address.</term>
				</item>
			</list>
			<para>The <see langword="stobj"/>
instruction copies the value type object into the address specified by the address <paramref name=" "/>(a pointer of
type <see langword="natural int"/>, <see langword="*"/>, or
<see langword="&amp;"/>). The number of bytes copied depends on the size of the 
class represented by <paramref name="class"/>, a metadata
token representing a value type.</para>
			<para>The operation of the <see langword="stobj"/> instruction can be altered by an immediately preceding <see cref="System.Reflection.Emit.OpCodes.Volatile"/> or <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix instruction.</para>
			<para><see cref="System.TypeLoadException"/> is thrown if class cannot be found.
This is typically detected when
Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at run
time.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stobj"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Type)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stelem_R8">
		<summary>
			<para>Replaces the array element at a given index with
      the <see langword="float64"/> value on the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> A1</term>
					<description>stelem.r8</description>
					<description>Replaces an array element at the supplied
            index with the <see langword="float64"/> value on the
            stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         
         An object reference to an array, <paramref name="array"/>, is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         A valid index to an element in <paramref name="array"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
         
         The value, the index, and the array reference are popped from the stack;
         the value is put into the array element at the given index.</term>
				</item>
			</list>
			<para>The <see langword="stelem.r8"/> instruction replaces the value of the element
<paramref name="index"/> in the one-dimensional array <paramref name="array"/> with the 
<see langword="float64"/> value pushed onto the stack.</para>
			<para>Arrays are objects and hence represented by a value of
   type <see langword="O"/>. The index is type <see langword="natural int"/>.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null
reference.</para>
			<para><see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> is negative, or larger than the bound of 
<paramref name="array"/>. </para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if <paramref name="array"/> does not hold elements of the required
type. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stelem.r8"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stelem_Ref">
		<summary>
			<para>Replaces the array element at a given index with the object ref value (type
   <see langword="O"/>) on the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> A2</term>
					<description>stelem.ref</description>
					<description>Replaces an array element at the supplied index with the <see langword="ref"/> value (type <see langword="O"/>) on the
         stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      An object reference to an array, <paramref name="array"/>, is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      A valid index to an element in <paramref name="array"/> is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      The value, the index, and the array reference are popped from the stack;
      the value is put into the array element at the given index.</term>
				</item>
			</list>
			<para>The <see langword="stelem.ref"/>
instruction replaces the value of the element at the supplied index in the one-dimensional array <paramref name="array"/> with
the <see langword="ref"/> (type <see langword="O"/>)
value pushed onto the stack.</para>
			<para>Arrays are objects and hence represented by a value of type
<see langword="O"/>. The index is type <see langword="natural int"/>.</para>
			<para>Note that <see langword="stelem.ref"/>
implicitly casts the supplied value to the element
type of <paramref name="array"/> before assigning the value to the array element.
This cast can fail, even for verified code. Thus the <see langword="stelem.ref"/> instruction can throw <see cref="System.InvalidCastException"/>. For one-dimensional arrays
that aren't zero-based and for multidimensional arrays, the <see cref="System.Array"/>
class provides a <see cref="System.Array.SetValue"/>method.</para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="array"/> is a null reference. </para>
			<para><see cref="System.IndexOutOfRangeException"/> is thrown if <paramref name="index"/> 
is negative, or larger than the bound of <paramref name="array"/>. </para>
			<para><see cref="System.ArrayTypeMismatchException"/> is thrown if <paramref name="array"/> does not hold elements of the required
type. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stelem.ref"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Sub_Ovf">
		<summary>
			<para>Subtracts one integer value from
      another, performs an overflow check, and pushes the result
      onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> DA</term>
					<description>sub.ovf</description>
					<description>Subtracts one integer value from another with an
            overflow check.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the 
         stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; <paramref name="value2"/>
      is subtracted from <paramref name="value1"/> with a check for overflow.</term>
				</item>
				<item>
					<term>
      The result is pushed onto the stack.</term>
				</item>
			</list>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be
represented in the result type.</para>
			<para>This operation is performed on signed integers; for floating-point values,
   use <see cref="System.Reflection.Emit.OpCodes.Sub"/>.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="sub.ovf"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Sub_Ovf_Un">
		<summary>
			<para>Subtracts one unsigned
      integer value from another, performs an overflow check, and
      pushes the result onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> DB</term>
					<description>sub.ovf.un</description>
					<description>Subtracts one unsigned integer value from
            anotherwith an overflow check.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value1"/> is pushed onto the
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the
   stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack; <paramref name="value2"/>
is subtracted from <paramref name="value1"/> with a check for overflow.</term>
				</item>
				<item>
					<term>      The result is pushed onto the stack.</term>
				</item>
			</list>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be
represented in the result type.</para>
			<para>This operation is performed on signed integers; for floating-point values,
   use <see cref="System.Reflection.Emit.OpCodes.Sub"/>.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="sub.ovf.un"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Stind_I">
		<summary>
			<para>Stores a value of type <see langword="natural int"/> at a supplied address.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> DF</term>
					<description>stind.i</description>
					<description>Stores a <see langword="natural int"/> value at at a given address.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      An address is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      The value and the address are popped from the stack; the value is stored
      at the address.</term>
				</item>
			</list>
			<para>The <see langword="stind.i"/>
instruction stores a <see langword="natural int"/> value at
the supplied address (type <see langword="natural int"/>,
<see langword="*"/>, or <see langword="&amp;"/> ).</para>
			<para>Type safe operation requires that the <see langword="stind.i"/> instruction be
used in a manner consistent with the type of the pointer. The operation of the
<see langword="stind.i"/> instruction can be altered by an immediately 
preceding <see cref="System.Reflection.Emit.OpCodes.Volatile"/> or <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> prefix instruction. </para>
			<para><see cref="System.NullReferenceException"/> is thrown if <paramref name="addr"/> is not naturally aligned for
the argument type implied by the instruction suffix. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="stind.i"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Unaligned">
		<summary>
			<para>Indicates that an address
      currently atop the evaluation stack might not be aligned to the natural size of
      the immediately following <see langword="ldind"/>, <see langword="stind"/>,
   <see langword="ldfld"/>, <see langword="stfld"/>, <see langword="ldobj"/>,
   <see langword="stobj"/>,<see langword=" initblk"/>, or <see langword="cpblk"/> instruction.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            12 &lt;<see langword="unsigned int8"/>&gt;</term>
					<description>unaligned. <paramref name="alignment"/></description>
					<description>Indicates that the subsequent pointer instruction may be
         unaligned.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      An address is pushed onto the stack.</term>
				</item>
			</list>
			<para><see langword="Unaligned"/>
specifies that the address (an
unmanaged pointer, <see langword="natural int"/>) on the stack might not be aligned
to the natural size of the immediately following <see langword="ldind"/>,
<see langword="stind"/>, <see langword="ldfld"/>, <see langword="stfld"/>, 
<see langword="ldobj"/>, <see langword="stobj"/>,<see langword=" initblk"/>, or 
<see langword="cpblk"/> instruction. 
That is, for a <see cref="System.Reflection.Emit.OpCodes.Ldind_I4"/>
instruction the alignment of the address may not be to a 4-byte boundary. For
<see langword="initblk"/> and <see langword="cpblk"/> the default alignment is 
architecture dependent (4-byte on 32-bit CPUs, 8-byte on 64-bit CPUs). Code
generators that do not restrict their output to a 32-bit word size must use
<see langword="unaligned"/> if the alignment is not known 
at compile time to be 8-byte.</para>
			<para>The value of alignment must be 1, 2, or 4 and means that
   the generated code should assume that the address is byte, double-byte, or
   quad-byte aligned, respectively. Note that transient pointers (type
<see langword="*"/>) are always aligned.</para>
			<para>While the alignment for a <see langword="cpblk"/> instruction would
logically require two numbers (one for the source and one for the destination),
there is no noticeable impact on performance if only the lower number is
specified.</para>
			<para>The <see langword="unaligned"/> and
<see langword="volatile"/> prefixes can be combined in 
either order. They must immediately precede a <see langword="ldind"/>, <see langword="stind"/>,
<see langword="ldfld"/>, <see langword="stfld"/>, <see langword="ldobj"/>, 
<see langword="stobj"/>, <see langword=" initblk"/>, or <see langword="cpblk"/> 
instruction. Only the <see cref="System.Reflection.Emit.OpCodes.Volatile"/> prefix is allowed for
the <see cref="System.Reflection.Emit.OpCodes.Ldsfld"/> and <see cref="System.Reflection.Emit.OpCodes.Stsfld"/>
instructions.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overloads
can use the <see langword="unaligned"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label)</term>
				</item>
				<item>
					<term>
      
      ILGenerator.Emit(Opcode, long)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Volatile">
		<summary>
			<para> Specifies that an address currently atop the evaluation stack might be
      volatile, and the results of reading that location cannot be cached or that
      multiple stores to that location cannot be suppressed.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            13</term>
					<description>volatile.</description>
					<description>Indicates that the subsequent pointer reference is
            volatile.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
         An address is pushed onto the stack.</term>
				</item>
			</list>
			<para><see langword="volatile"/>. 
specifies that the address is
a volatile address (that is, it can be referenced externally to the current thread of
execution) and the results of reading that location cannot be cached or that
multiple stores to that location cannot be suppressed. Marking an access as
<see langword="volatile"/> affects only that single access; other accesses to 
the same location must be marked separately. Access to volatile locations need
not be performed atomically.</para>
			<para>The <see cref="System.Reflection.Emit.OpCodes.Unaligned"/> and <see langword="volatile"/> prefixes can
be combined in either order. They must immediately precede a
<see langword="ldind"/>, <see langword="stind"/>, <see langword="ldfld"/>, 
<see langword="stfld"/>, <see langword="ldobj"/>, <see langword="stobj"/>,<see langword=" initblk"/>, or <see langword="cpblk"/> instruction. 
Only the <see langword="volatile"/> prefix is allowed for the
<see cref="System.Reflection.Emit.OpCodes.Ldsfld"/> and <see cref="System.Reflection.Emit.OpCodes.Stsfld"/> instructions.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="volatile"/>
opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc><doc for="OpCodes.Isinst">
		<summary>
			<para>Tests whether an object reference (type <see langword="O"/>) is an instance of a particular class.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 75
            &lt;<see langword="T"/>&gt;</term>
					<description>isinst<paramref name=" class"/></description>
					<description>Tests if an object reference is an instance of <paramref name="class"/>, returning either a
      null reference or an instance of that class or
      interface.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>      An object reference is pushed onto the stack.</term>
				</item>
				<item>
					<term>      The object reference is popped from the stack and tested to see if it is
      an instance of the class passed in <paramref name="class"/>.</term>
				</item>
				<item>
					<term>      The result (either an object reference or a null
      reference) is pushed onto
      the stack.</term>
				</item>
			</list>
			<para><paramref name="Class"/> is a metadata token
indicating the desired class. If the class of the object on the top of the stack implements
<paramref name="class "/>(if <paramref name="class"/> is an interface) or is a derived class of 
<paramref name="class"/> (if <paramref name="class"/> is a regular class) then it is cast to type 
<paramref name="class"/> and the result is pushed on the stack, exactly as 
though <see cref="System.Reflection.Emit.OpCodes.Castclass"/> had been called. Otherwise, a
null reference is pushed on the stack. If the object reference itself is a null
reference, then <see langword="isinst"/>
likewise returns a null reference.</para>
			<para><see cref="System.TypeLoadException"/> is thrown if class cannot be
found. This is typically detected when the Microsoft
Intermediate Language (MSIL) instructions are converted to native code rather than at runtime.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="isinst"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      ILGenerator.Emit(OpCode, Type)</term>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="OpCodes.Ckfinite">
		<summary>
			<para>Throws <see cref="System.ArithmeticException"/> if value is not a finite number.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> C3</term>
					<description>ckfinite</description>
					<description>throw <see cref="System.ArithmeticException"/> if value is not a finite
         number.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the
   stack..</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the stack and the
   <see langword="ckfinite"/> instruction is
   performed on it.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is pushed back onto the stack if no
   exception is thrown.</term>
				</item>
			</list>
			<para>The <see langword="ckfinite instruction"/>
throws <see cref="System.ArithmeticException"/> if <paramref name="value"/> (a floating-point number) is either a "not a
number" value (NaN) or a <see langword="+-"/>
infinity value. <see langword="Ckfinite"/>
leaves the value on the stack if no exception is thrown. Execution is
unspecified if <paramref name="value"/> is not a floating-point number.</para>
			<para><see cref="System.ArithmeticException"/> is thrown if <paramref name="value"/> is not a
'normal' number.</para>
			<para>Note that a special exception or a derived class
   of <see cref="System.ArithmeticException"/>
   may be more appropriate, passing the incorrect
   value to the exception handler.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ckfinite"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="OpCodes.Rem">
		<summary>
			<para>Divides two values and pushes
      the remainder onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 5D</term>
					<description>rem</description>
					<description>Pushes the remainder of dividing <paramref name="value1"/> by <paramref name="value2"/> onto the
         stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      A <paramref name="value1"/> is pushed onto
      the stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> is pushed onto the
   stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value2"/> and <paramref name="value1"/> are popped from the stack and the
   remainder of <paramref name="value1"/> div <paramref name="value2"/>
   computed.</term>
				</item>
				<item>
					<term>
      The result is pushed onto the stack.</term>
				</item>
			</list>
			<para><paramref name="result"/> = <paramref name="value1"/>
				<see langword="rem"/>
				<paramref name="value2"/> satisfies the following conditions:</para>
			<para><paramref name="result"/> = <paramref name="value1"/>
				<see langword="-"/>
				<paramref name="value2"/><see langword="×"/>(<paramref name="value1"/>
				<see langword="div"/>
				<paramref name="value2"/>), and:</para>
			<para> 0 = |<paramref name="result"/>| &lt; |<paramref name="value2"/>|,
sign(<paramref name="result"/>) = sign(<paramref name="value1"/>), where <see langword="div"/>
is the division instruction that
truncates towards zero.</para>
			<para>If <paramref name="value2"/> is zero or
<paramref name="value1"/> is infinity the result is NaN. If <paramref name="value2"/> is infinity, 
the result is <paramref name="value1"/> (negated for <see langword="-infinity"/>
).</para>
			<para>Integral operations throw <see cref="System.DivideByZeroException"/> if
<paramref name="value2"/> 
is zero.</para>
			<para>Note that on the Intel-based platforms an <see cref="System.OverflowException"/> is
thrown when computing (minint <see langword="rem"/> -1).</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="rem"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="OpCodes.Newobj">
		<summary>
			<para>Creates a new object or a new instance of a value type,
      pushing an object reference (type <see langword="O"/>) onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 73
            &lt;<see langword="T"/>&gt;</term>
					<description>newobj<paramref name=" ctor"/></description>
					<description>Allocates an uninitialized object or value type and calls the constructor
         method <paramref name="ctor"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>      Arguments <paramref name="arg1"/> through <paramref name="argn"/> are pushed on the stack in sequence.</term>
				</item>
				<item>
					<term>      Arguments <paramref name="argn"/> through <paramref name="arg1"/> are popped from the stack and
   passed to <paramref name="ctor"/> for object creation.</term>
				</item>
				<item>
					<term>      A reference to the new object is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="newobj"/> instruction creates a new
object or a new instance of a value type. <paramref name="Ctor"/> is a metadata token (a
<see langword="methodref"/> or <see langword="methoddef"/> that must be marked as a constructor) 
that indicates the name, class and signature of the constructor to call.</para>
			<para>The <see langword="newobj "/>instruction allocates a new
instance of the class associated with <paramref name="ctor"/> and initializes all the
fields in the new instance to 0 (of the proper type) or null references as
appropriate. It then calls the constructor <paramref name="ctor"/> with the given
arguments along with the newly created instance. After the constructor has been
called, the now initialized object reference (type <see langword="O"/>) is pushed
on the stack.</para>
			<para>From the constructor's point of view, the uninitialized
   object is argument 0 and the other arguments passed to newobj follow in order.</para>
			<para>All zero-based, one-dimensional arrays are created using
<see cref="System.Reflection.Emit.OpCodes.Newarr"/>, not <see langword="newobj"/>. On the 
   other hand, all other arrays (more than one dimension, or one-dimensional but
   not zero-based) are created using <see langword="newobj"/>.</para>
			<para>Value types are not usually created using
<see langword="newobj"/>. They are usually allocated either as arguments or local 
   variables, using <see langword="newarr"/> (for zero-based, one-dimensional
   arrays), or as fields of objects. Once allocated, they are initialized using
<see cref="System.Reflection.Emit.OpCodes.Initobj"/>. However, the <see langword="newobj"/> instruction can 
   be used to create a new instance of a value type on the stack, that can
   then be passed as an argument, stored in a local, and so on.</para>
			<para><see cref="System.OutOfMemoryException"/> is thrown if there is insufficient memory to satisfy the
request. </para>
			<para><see cref="System.MissingMethodException"/> is thrown if a constructor method <paramref name="ctor"/> with the indicated name, class and
signature could not be found. This is typically detected when Microsoft
Intermediate Language (MSIL) instructions are converted to native code, rather than at runtime. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="newobj"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      ILGenerator.Emit(OpCode, ConstructorInfo)</term>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="OpCodes.Call">
		<summary>
			<para>Calls the method indicated by the passed method descriptor.
      </para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 28
            &lt;<see langword="T"/>&gt;</term>
					<description>call<paramref name=" methodDesc"/></description>
					<description>Call the method described by
         <paramref name="methodDesc"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      Method arguments <paramref name="arg1"/> through <paramref name="argN"/> are pushed onto the stack.</term>
				</item>
				<item>
					<term>
      Method arguments <paramref name="arg1"/> through <paramref name="argN"/> are popped from the stack; the method
      call is performed with these arguments and control is transferred to the
      method referred to by the method descriptor. When complete, a return value is
      generated by the callee method and sent to the caller.</term>
				</item>
				<item>
					<term>
      The return value is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="call"/>
instruction calls the method indicated by the method descriptor passed with the
instruction. The method descriptor is a metadata token that
indicates the method to call and the number, type, and order of the arguments
that have been placed on the stack to be passed to that method as well as the
calling convention to be used. The <see langword="call"/> instruction can be
immediately preceded by a <see langword="tail"/> (<see cref="System.Reflection.Emit.OpCodes.Tailcall"/> ) prefix
instruction to specify that the current method state should be released before
transferring control. If the call transfers control to a method of higher trust than
the origin method, the stack frame is not released. Instead, the execution
continues silently as if the <see langword="tail"/> had not
been supplied. The metadata token carries sufficient information to determine
whether the call is to a static method, an instance method, a virtual method,
or a global function. In all of these cases the destination address is determined
entirely from the method descriptor (contrast this with the <see cref="System.Reflection.Emit.OpCodes.Callvirt"/>
instruction for calling virtual methods, where the destination address also
depends upon the runtime type of the instance reference pushed before the
<see cref="System.Reflection.Emit.OpCodes.Callvirt"/>).</para>
			<para>The arguments are placed on the stack in left-to-right order. That
   is, the first argument is computed and placed on the stack, then the second argument,
   then the third, until all necessary arguments are atop the stack in descending
   order. There are three important special cases:</para>
			<para>1. Calls to an instance (or virtual) method must push
   that instance reference before any of the user-visible arguments. The instance
   reference must not be a null reference. The signature carried in the metadata
   does not contain an entry in the parameter list for the <see langword="this"/>
   
   pointer; instead, it uses a bit to indicate whether the method
   requires passing the <see langword="this"/>
   
   pointer.</para>
			<para>2. It is valid to call a virtual method using <see langword="call"/> (rather
than <see langword="callvirt"/>
); this
indicates that the method is to be resolved using the class specified by
method rather than as specified dynamically from the object being invoked. </para>
			<para>3. Note that a delegate's <see langword="Invoke"/>
method can be called with either the
<see langword="call"/> or <see langword="callvirt"/> instruction. </para>
			<para><see cref="System.Security.SecurityException"/>may be thrown if
system security does not grant the caller
access to the called method. The security check may occur when the Microsoft Intermediate
Language (MSIL) instructions are converted to native code rather than at runtime. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="call"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      ILGenerator.Emit(OpCode, MethodInfo)</term>
				</item>
				<item>
					<term>
      ILGenerator.EmitCall(OpCode, MethodInfo, Type[])</term>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="OpCodes.Neg">
		<summary>
			<para>Negates a value and pushes the result onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 65</term>
					<description>neg</description>
					<description>Negates
            the value currently on top of the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>         A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>         A value is popped from the stack and negated.</term>
				</item>
				<item>
					<term>         The result is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="neg"/> instruction
negates value and pushes the result on top of the stack. The return type is
the same
as the operand type.</para>
			<para>Negation of integral values is standard two's complement
   negation. In particular, negating the most negative number (which does not have
   a positive counterpart) yields the most negative number. To detect this overflow
   use the <see cref="System.Reflection.Emit.OpCodes.Sub_Ovf"/> instruction instead (that is, subtract from
   0).</para>
			<para>Negating a floating-point number cannot overflow,
   and negating NaN returns NaN.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="neg"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="OpCodes.Mkrefany">
		<summary>
			<para>Pushes a typed reference to an instance of a
      specific type onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> C6
            &lt;<see langword="T"/>&gt;</term>
					<description>mkrefany<paramref name=" class"/></description>
					<description>Pushes a typed reference of type
         <paramref name="class"/> onto the stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>A pointer to piece of data is pushed onto the stack.</term>
				</item>
				<item>
					<term>The pointer is popped and converted to a typed reference of type
      <paramref name="class"/>.</term>
				</item>
				<item>
					<term>The typed reference is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="mkrefany"/>
instruction supports the passing of dynamically typed references. The
pointer must be of type
<see langword="&amp;"/>, <see langword="*"/>, or <see langword="natural int"/>, and 
hold the valid address of a piece of data. <paramref name="Class"/> is the
class token describing the type of the
data referenced by the pointer. <see langword="Mkrefany"/> pushes a typed reference on the stack,
providing an opaque descriptor of the pointer and the type <paramref name="class"/>.</para>
			<para> The only valid operation permitted upon a typed reference is to pass it to a
   method that requires a typed reference as a parameter. The callee can then use
   the <see cref="System.Reflection.Emit.OpCodes.Refanytype"/> and <see cref="System.Reflection.Emit.OpCodes.Refanyval"/>
   instructions to retrieve the type (class) and the address respectively.</para>
			<para><see cref="System.TypeLoadException"/> is thrown if <paramref name="class"/> cannot be found. This is typically detected when
Microsoft Intermediate Language (MSIL) instructions are converted to native code rather than at
runtime.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="mkrefany"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      ILGenerator.Emit(OpCode, Type)</term>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="OpCodes.Ldvirtftn">
		<summary>
			<para>Pushes an unmanaged pointer (type <see langword="natural int"/>) to the native code implementing a
   particular virtual method associated with a specified object onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            07 &lt;<see langword="T"/>&gt;</term>
					<description>ldvirtftn <paramref name="method"/></description>
					<description>Pushes the pointer to an object's virtual method <paramref name="method"/> on the
      stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>      An object reference is pushed onto the stack.</term>
				</item>
				<item>
					<term>      The object reference is popped from the stack and the address of the entry
      point to the method (as specified by the metadata token <paramref name="method"/>) is looked up.</term>
				</item>
				<item>
					<term>      The pointer to <paramref name="method"/> is pushed onto the stack.</term>
				</item>
			</list>
			<para>The resulting unmanaged pointer pushed onto the stack by
   the <see langword="ldvirtftn"/> instruction can be called using
   the <see cref="System.Reflection.Emit.OpCodes.Calli"/> instruction if it references a
   managed method (or a stub that
   transitions from managed to unmanaged code).</para>
			<para>The unmanaged pointer points to native code using the calling convention specified by in the metadata token
<paramref name="method"/>. As a result, the method pointer can be passed to unmanaged native code (for 
   example, as a callback routine) if that routine expects the corresponding calling
   convention. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="ldvirtftn"/> opcode:</para>
			<list type="bullet"><item>
					<term>      ILGenerator.Emit(OpCode, MethodInfo)</term>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="OpCodes.Tailcall">
		<summary>
			<para>Performs a postfixed method call instruction such that the current
      method's stack frame is removed before the actual call instruction is executed.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            14</term>
					<description>tail.</description>
					<description>Subsequent call terminates current
            methods</description>
				</item>
			</list>
			<para>There is no stack transition behavior defined for this instruction.</para>
			<para>The <see langword="tail"/> prefix instruction must
   immediately precede a <see cref="System.Reflection.Emit.OpCodes.Call"/>, <see cref="System.Reflection.Emit.OpCodes.Calli"/>, or <see cref="System.Reflection.Emit.OpCodes.Callvirt"/> instruction. It indicates that the
   current method's stack frame should be removed before the call instruction is
   executed. It also implies that the value returned from the following call is
   also the value returned by the current method, and the call can therefore be
   converted into a cross-method jump.</para>
			<para>The stack must be empty except for the arguments being transferred by the
   following call. The instruction following the call instruction must be a ret.
   Thus the only valid code sequence is <see langword="tail. call"/> (or
<see langword="calli"/> or <see langword="callvirt"/>). Correct Microsoft Intermediate Language 
   (MSIL) instructions must not
   branch to the <see langword="call"/> instruction, but they may branch to the
   subsequent <see cref="System.Reflection.Emit.OpCodes.Ret"/>. </para>
			<para> The current frame cannot be discarded when control is transferred
   from untrusted code to trusted code, since this would jeopardize code
   identity security. The .NET Framework security checks can therefore cause the
<see langword="tail"/> to be ignored, leaving a standard <see cref="System.Reflection.Emit.OpCodes.Call"/> instruction. Similarly, in order to 
   allow the exit of a synchronized region to occur after the call returns, the
<see langword="tail"/> prefix is ignored when used to exit a method that is 
   marked synchronized. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="tail"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="OpCodes.Ldloc_S">
		<summary>
			<para>Loads the local variable at a specific index onto the
      evaluation stack, short form.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 11
            &lt;<see langword="unsigned int8"/>&gt;</term>
					<description>ldloc.s <paramref name="index"/></description>
					<description>Loads the local variable at index <paramref name="index "/>onto stack,
      short form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      The local variable value at the specified index is pushed onto the stack.</term>
				</item>
			</list>
			<para>The <see langword="ldloc.s"/>
instruction pushes the contents of the local variable number at the passed
index onto the evaluation stack,
where the local variables are numbered 0 onwards. Local variables are initialized
to 0 before entering the method if the initialize flag on the method is true.
There are 256 (2^8) local variables possible (0-255) in the short form,
which is a more efficient encoding than <see langword="ldloc"/>.</para>
			<para>The type of the value is the same as the type of the local variable, which is
   specified in the method header. See Partition I. Local variables that are
   smaller than 4 bytes long are expanded to type <see langword="int32"/> when they
   are loaded onto the stack. Floating-point values are expanded to their native
   size (type <see langword="F"/>). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overloads
can use the <see langword="ldloc.s"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, LocalBuilder)</term>
				</item>
				<item>
					<term>
      ILGenerator.Emit(OpCode, byte)</term>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="OpCodes.Ldloc">
		<summary>
			<para>Loads the local variable at a specific index onto the evaluation stack.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            06 &lt;<see langword="unsigned int16"/>&gt;</term>
					<description>ldloc<paramref name=" index"/></description>
					<description>Loads the local variable at index <paramref name="index "/>onto
      stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      The local variable value at the specified index is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="ldloc"/> instruction pushes the contents
of the local variable number at the passed index onto the evaluation stack,
where the local variables are numbered 0 onwards. Local variables are
initialized to 0 before entering the method only if the initialize flag on the
method is true. There are 65,535 (2^16-1) local variables possible (0-65,534).
Index 65,535 is not valid since likely implementations will use a 2-byte integer
to track both a local's index, along with the total number of locals for a given
method. If an index of 65535 had been made valid, it would require a wider
integer to track the number of locals in such a method.</para>
			<para>The <see langword="ldloc.0"/>, <see langword="ldloc.1"/>,
<see langword="ldloc.2"/>, and <see langword="ldloc.3"/> instructions provide an 
efficient encoding for accessing the first four local variables. </para>
			<para>The type of the value is the same as the type of the local variable, which is
   specified in the method header. See Partition I. Local variables that are
   smaller than 4 bytes long are expanded to type <see langword="int32"/> when they
   are loaded onto the stack. Floating-point values are expanded to their native
   size (type <see langword="F"/>). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overloads
can use the <see langword="ldloc"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, LocalBuilder)</term>
				</item>
				<item>
					<term>ILGenerator.Emit(OpCode, short)</term>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="OpCodes.Stloc">
		<summary>
			<para>Pops the current value from the top of the evaluation
      stack and stores it in a the local variable list at a specified index.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> FE
            0E &lt;<see langword="unsigned int16"/>&gt;</term>
					<description>stloc<paramref name=" index"/></description>
					<description>Pops a value from the stack and stores it in local
         variable <paramref name="index"/>.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      A
      value is popped off of the stack and placed in local variable
   <paramref name="index"/>.</term>
				</item>
			</list>
			<para>The <see langword="stloc"/> instruction pops the top
value off the evalution stack and moves it into local variable number
<paramref name="index"/>, where local variables are 
numbered 0 onwards. The type of the value must match the type of the local variable as specified in the current method's
local signature.</para>
			<para>Storing into locals that hold an integer value smaller
   than 4 bytes long truncates the value as it moves from the stack to the local
   variable. Floating-point values are rounded from their native size (type
<see langword="F"/>) to the size associated with the argument.</para>
			<para>Correct Microsoft Intermediate Language (MSIL)
   instructions require that <paramref name="index"/> be a valid local index. For the
<see langword="stloc"/> instruction, <paramref name="index"/> must lie in the range 0 
   to 65534 inclusive (specifically, 65535 is not valid). The reason for excluding
   65535 is pragmatic: likely implementations will use a 2-byte integer to track
   both a local's index, as well as the total number of locals for a given method.
   If an index of 65535 had been made valid, it would require a wider integer to
   track the number of locals in such a method.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overloads
can use the <see langword="stloc"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, LocalBuilder)</term>
				</item>
				<item>
					<term>
      
      ILGenerator.Emit(OpCode, short)</term>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="OpCodes.Stloc_S">
		<summary>
			<para>Pops the current value from the top of the evaluation
      stack and stores it in a the local variable list at <paramref name="index"/> (short
      form).
			</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 
            13 &lt;<see langword="unsigned int8"/>&gt;</term>
					<description>stloc.s<paramref name=" index"/></description>
					<description>Pops a value from the stack and stores
         it in local variable <paramref name="index"/>, short
         form.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
      
      A value is popped off of the stack and placed in local variable
   <paramref name="index"/>.</term>
				</item>
			</list>
			<para>The <see langword="stloc.s"/> instruction pops the top
value off the evalution stack and moves it into local variable number
<paramref name="index"/>, where local variables are 
numbered 0 onwards. The type of the value must match the type of the local variable as specified in the
current method's local signature. </para>
			<para>The <see langword="stloc.s"/> instruction provides an
efficient encoding for local variables 0 through 255.</para>
			<para>Storing into locals that hold an integer value smaller
   than 4 bytes long truncates the value as it moves from the stack to the local
   variable. Floating-point values are rounded from their native size (type
<see langword="F"/>) to the size associated with the argument. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overloads
can use the <see langword="stloc.s"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, LocalBuilder)</term>
				</item>
				<item>
					<term>
      ILGenerator.Emit(OpCode, byte)</term>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="OpCodes.TakesSingleByteArgument">
		<summary>
			<para>Returns true or false if the supplied opcode takes a single byte
      argument.</para>
		</summary>
		<param name="inst">An instance of an Opcode object.</param>
		<returns>
			<para><see langword="True"/> or
<see langword="false"/>.</para>
		</returns>
		<remarks>
			<para> This method can be used to find which MSIL
      opcodes are "short
      form", for use in optimized code.</para>
			<para><see langword="TakesSingleByteArgument"/> returns <see langword="true"/> if the <see cref="System.Reflection.Emit.OpCode"/> instance takes a single byte
   argument in the following cases:</para>
			<list type="bullet"><item>
					<term>
      
      The opcode
      
      performs a branch instruction to a byte-sized address (for
      example, <see cref="System.Reflection.Emit.OpCodes.Br_S"/> and <see cref="System.Reflection.Emit.OpCodes.Bgt_S"/>).</term>
				</item>
				<item>
					<term>
      
      The opcode pushes a byte value onto the stack (for
      example, <see cref="System.Reflection.Emit.OpCodes.Ldc_I4_S"/>).</term>
				</item>
				<item>
					<term>
      
      The opcode references a variable or argument via the
      byte-sized "short form" (for example, <see cref="System.Reflection.Emit.OpCodes.Ldloc_S"/> and <see cref="System.Reflection.Emit.OpCodes.Stloc_S"/>
      ).</term>
				</item>
			</list>
			<para>Otherwise, it returns <see langword="false"/>. </para>
			<para>The example below demonstrates the use of 
<see langword="TakesSingleByteArgument"/> by reflecting on to the 
<see langword="OpCodes"/> class and testing to see whether 
   each <see langword="OpCode"/> field takes a single-byte argument. </para>
			<codelink SampleID="System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example" SnippetID="1"/>
		</remarks>
	</doc>
	<doc for="OpCodes.Conv_Ovf_I4">
		<summary>
			<para>Converts the signed value on top of the evaluation tack to signed
   <see langword="int32"/>, throwing <see cref="System.OverflowException"/> on overflow.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> B7</term>
					<description>conv.ovf.i4</description>
					<description>Convert to an <see langword=" int32"/>
      (on the stack as <see langword=" int32"/>) and throw an exception on
      overflow.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted. If overflow occurs, an
      exception is thrown.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.ovf.i4"/> opcode converts the <paramref name="value"/> on top of
the stack to the type specified in the opcode, and places that converted
value on the top of the stack. If the value is too large or too small to be
represented by the target type, an exception is thrown.</para>
			<para>Conversions from floating-point numbers to integer values truncate the number
   toward zero. Note that integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.ovf.i "/> or<see langword=" conv.ovf.u"/> are used, in 
   which case the result is also <see langword="natural int"/>).</para>
			<para><see cref="System.OverflowException"/> is thrown if the result can not be represented in the
result type.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.ovf.i4"/>
opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="OpCodes">
		<summary>
			<para>Provides field representations of the Microsoft
      Intermediate Language (MSIL) instructions for emission by the <see cref="System.Reflection.Emit.ILGenerator"/> class members (such as <see cref="System.Reflection.Emit.ILGenerator.Emit"/>).</para>
		</summary>
		<threadsafe>
			<para>Reflection Emit is thread-safe when using assemblies that were created with
      the <see cref="System.AppDomain.DefineDynamicAssembly" qualify="true"/> method with the Boolean parameter
   <paramref name="isSynchronized"/> set to <see langword="true"/>.</para>
		</threadsafe>
		<remarks>
			<para>See the Common Language Infrastructure Instruction Set documentation in the
      Tool Developers Guide for a detailed description of the member opcodes.</para>
		</remarks>
		<example>
			<para>The following example demonstrates the construction of a dynamic method 
      using <see cref="System.Reflection.Emit.ILGenerator"/> to emit <see langword="OpCodes"/> into a
   <see cref="System.Reflection.Emit.MethodBuilder"/>.</para>
			<codelink SampleID="System.Reflection.Emit.ILGenerator.OpCodes Example" SnippetID="1"/>
		</example>
	</doc>
	<doc for="OpCodes.Switch">
		<summary>
			<para>Implements a jump table.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 45
            &lt;<see langword="unsigned int32"/>&gt; &lt;<see langword="int32"/>&gt; ...
            &lt;<see langword=" int32"/>&gt;</term>
					<description>switch<paramref name=" (N, t1, t2 ... tN)"/></description>
					<description>Jumps
         to one of <paramref name="N"/>
         values.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is: </para>
			<list type="number"><item>
					<term>
      
      A value is pushed onto the stack.</term>
				</item>
				<item>
					<term>
      
      The value is popped off the stack and execution is transferred to the
      instruction at the offset indexed by the value, where the value is less
      than <paramref name="N"/>.</term>
				</item>
			</list>
			<para>The <see langword="switch"/> instruction implements a jump
table. The format of the instruction is an <see langword="unsigned int32"/>
representing the number of targets <paramref name="N"/>, followed by <paramref name="N "/>int32
values specifying jump targets. These targets are represented as offsets
(positive or negative) from the beginning of the instruction following this
<see langword="switch"/> instruction.</para>
			<para>The <see langword="switch"/>
instruction pops a value off the stack and
compares it, as an unsigned integer, to <paramref name="N"/>. If value is less than
<paramref name="N"/>, execution is transferred to the target indexed by value, where targets 
are numbered from 0 (for
example, a value of 0 takes the first target, a value of 1 takes the second target,
and so on). If the value is greater than or equal to <paramref name="N"/>, execution
continues at the next instruction (fall through). </para>
			<para>If the target instruction has one or more prefix codes, control can only be
   transferred to the first of these prefixes. </para>
			<para>Control transfers into and out of <see langword="try"/>,
<see langword="catch"/>, <see langword="filter"/>, and <see langword="finally"/> 
blocks cannot be performed by this instruction. (Such transfers are severely
restricted and must use the leave instruction instead). </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="switch"/> opcode. The <paramref name="Label[]"/>
argument is an array of Labels
representing 32-bit offsets.</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode, Label[])</term>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following code sample illustrates the use of the <see langword="Switch "/>opcode to generate a jump table using an array of <see cref="System.Reflection.Emit.Label"/>.</para>
			<codelink SampleID="System.Reflection.Emit.ILGenerator.Emit Example 2" SnippetID="1"/>
		</example>
	</doc>
	<doc for="OpCodes.Conv_U">
		<summary>
			<para>Converts the value on top of the evaluation stack to
   <see langword="unsigned"/>
				<see langword="natural int"/>, and extends it to <see langword="natural int"/>.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> E0</term>
					<description>conv.u</description>
					<description>Convert to <see langword="unsigned natural int"/>,
         pushing <see langword="natural int"/> on stack.</description>
				</item>
			</list>
			<para>The stack transitional behavior, in sequential order, is:</para>
			<list type="number"><item>
					<term>
						<paramref name="value"/> is pushed onto the 
      stack.</term>
				</item>
				<item>
					<term>
						<paramref name="value"/> is popped from the 
      stack and the conversion operation is attempted.</term>
				</item>
				<item>
					<term>
      
      If the conversion is successful, the resulting value is pushed onto the
      stack.</term>
				</item>
			</list>
			<para>The <see langword="conv.u "/>opcode converts the <paramref name="value"/> on top
of the stack to the type specified in the opcode, and leave that converted value
on the top of the stack. Integer values of less than 4 bytes are extended to
<see langword="int32"/> when they are loaded onto the evaluation stack (unless 
<see langword="conv.i"/> or <see langword=" conv.u"/> is used, in which case 
the result is also <see langword="natural int"/>). Floating-point values are
converted to the <see langword="F"/> type. </para>
			<para>Conversion from floating-point numbers to integer values
   truncates the number toward zero. When converting from an
<see langword="float64"/> to an <see langword="float32"/>, precision can be 
   lost. If <paramref name="value"/> is too large to fit in a <see langword="float32 (F)"/>,
   positive infinity (if <paramref name="value"/> is positive) or negative infinity (if
<paramref name="value"/> is negative) is returned. If overflow occurs converting one integer 
   type to another, the high order bits are truncated. If the result is
   smaller than an <see langword="int32"/>, the value is sign-extended to fill the slot. </para>
			<para>If overflow occurs converting a floating-point type to an integer the value
   returned is unspecified. </para>
			<para>No exceptions are ever thrown when using this field. See <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I"/> and <see cref="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un"/> for equivalent instructions that
will throw an exception when the result type can not properly represent the
result value. </para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="conv.u"/> opcode:</para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="OpCodes.Nop">
		<summary>
			<para>Fills space if opcodes are patched. No meaningful operation is
      performed although a processing cycle can be consumed.</para>
		</summary>
		<remarks>
			<para>The following table lists the instruction's hexadecimal and Microsoft
      Intermediate Language (MSIL) assembly format, along with a brief reference
      summary:</para>
			<list type="table">
				<listheader>
					<term>Format</term>
					<description>Assembly Format</description>
					<description>Description</description>
				</listheader>
				<item>
					<term> 00</term>
					<description>nop</description>
					<description>Performs an operation without
            behavior.</description>
				</item>
			</list>
			<para>There is no stack transitional behavior defined for this instruction.</para>
			<para>The <see langword="nop"/> operation does nothing. It is
   intended to fill in space if opcodes are patched.</para>
			<para>The following <see cref="System.Reflection.Emit.ILGenerator.Emit"/> constructor overload
can use the <see langword="nop"/> opcode: </para>
			<list type="bullet"><item>
					<term>
      
      ILGenerator.Emit(OpCode)</term>
				</item>
			</list>
		</remarks>
	</doc>
</docs>
