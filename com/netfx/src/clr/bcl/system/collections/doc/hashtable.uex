<docs>
    <doc for="Hashtable">
        <summary>
            <para>Represents a collection of key-and-value pairs that are
      organized based on the hash code of the key.</para>
        </summary>
        <threadsafe>
            <para>To support one or more writers, all operations on the <see cref="System.Collections.Hashtable" /> must be done through the wrapper returned by the <see cref="System.Collections.Hashtable.Synchronized" /> method.</para>
            <para>Enumerating through a collection is intrinsically not a thread-safe procedure.
   Even when a collection is synchronized, other threads could still modify the collection, which causes the enumerator to throw an exception.
   To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</para>
        </threadsafe>
        <remarks>
            <para>Each element is a key-and-value pair stored in a <see cref="System.Collections.DictionaryEntry" /> object.
 A key cannot be <see langword="null" />, but a value can be.</para>
            <para>The objects used as keys in a <see cref="System.Collections.Hashtable" /> must implement or inherit the <see cref="System.Object.GetHashCode" qualify="true" />
and <see cref="System.Object.Equals" qualify="true" /> methods. If key equality were
simply reference equality, the inherited implementation of these methods would
suffice. Furthermore, these methods must produce the same results when called
with the same parameters while the key exists in the <see cref="System.Collections.Hashtable" />.
Key objects must be immutable as long as they are used as keys in the <see cref="System.Collections.Hashtable" />.</para>
            <para>When an element is added to the <see cref="System.Collections.Hashtable" />, the element is placed into
a bucket based on the hash code of the key. Subsequent lookups of the key
use the hash code of the key to search in only one particular bucket, thus
substantially reducing the number of key comparisons required to find an element.</para>
            <para>The load factor of a <see cref="System.Collections.Hashtable" /> determines the maximum
ratio of elements to buckets. Smaller load factors cause faster average lookup
times at the cost of increased memory consumption. The default load
factor of 1.0 generally provides the best balance between speed and size. A
different load factor can also be specified when the <see cref="System.Collections.Hashtable" />
is created.</para>
            <para>As elements are added to a <see cref="System.Collections.Hashtable" />, the actual load factor of the <see cref="System.Collections.Hashtable" />
increases. When the actual load factor reaches the load factor, the
number of buckets in the <see cref="System.Collections.Hashtable" /> is automatically increased to the smallest
prime number that is larger than twice the current number of <see cref="System.Collections.Hashtable" /> buckets.</para>
            <para>Each key object in the <see cref="System.Collections.Hashtable" /> must provide its own hash function, which
can be accessed by calling <see cref="System.Collections.Hashtable.GetHash" />. However, any object implementing
<see cref="System.Collections.IHashCodeProvider" /> can be passed to a <see cref="System.Collections.Hashtable" />
constructor, and that hash function is used for all objects in the table.</para>
            <para lang="VB, C#">The <see langword="foreach" /> statement of the C# language (<see langword="for each" /> in Visual Basic) 
 requires the type of each element in the collection.
 Since each element of the <see cref="System.Collections.Hashtable" /> is a key-and-value pair,
 the element type is not the type of the key or the type of the value.
 Instead, the element type is <see cref="System.Collections.DictionaryEntry" />.
 For example:</para>
            <code lang="C#">foreach (DictionaryEntry myDE in myHashtable) {...}
</code>
            <code lang="VB">Dim myDE As DictionaryEntry
For Each myDE In myHashtable
   ...
Next myDE
</code>
            <para lang="VB, C#">The <see langword="foreach" /> statement is a wrapper around the enumerator,
 which only allows reading from, not writing to, the collection.</para>
        </remarks>
        <example>
            <para>The following example shows how to create and initialize a <see cref="System.Collections.Hashtable" />
and how to print out its keys and values.</para>
            <codelink SampleID="Classic Hashtable Example" SnippetID="1" />
        </example>
        <seealso cref="System.Collections.IDictionary" />
        <seealso cref="System.Collections.IHashCodeProvider" />
        <seealso cref="System.Object.GetHashCode" qualify="true" />
        <seealso cref="System.Object.Equals" qualify="true" />
        <seealso cref="System.Collections.DictionaryEntry" />
    </doc><doc for="Hashtable.hcp">
        <summary>
            <para>Gets or sets the object that can dispense hash codes.</para>
        </summary>
        <value>
            <para>The object that can dispense hash codes.</para>
        </value>
        <seealso cref="System.Collections.IHashCodeProvider" />
    </doc><doc for="Hashtable.comparer">
        <summary>
            <para>Gets or sets the comparer to use for the <see cref="System.Collections.Hashtable" />.</para>
        </summary>
        <value>
            <para>The comparer to use for the <see cref="System.Collections.Hashtable" />.</para>
        </value>
        <seealso cref="System.Collections.IComparer" />
    </doc><doc for="Hashtable.Hashtable">
        <overload>
            <para>Initializes a new instance of the <see cref="System.Collections.Hashtable" /> class.</para>
        </overload>
        <summary>
            <para> Creates an empty <see cref="System.Collections.Hashtable" /> 
 with the default initial capacity and using
 the default load factor, the default hash code provider and the default comparer.</para>
        </summary>
        <remarks>
            <para>A hashtable's capacity is used to calculate the optimal number of hashtable 
       buckets based on the load factor. The default initial capacity is zero. Capacity
       is automatically increased as required.</para>
            <para>The load factor is the maximum ratio of elements to buckets. A smaller
       load factor means faster lookup at the cost of increased memory consumption. The
       default load factor is 1.0, which is the best balance between speed and size.</para>
            <para>When the actual load factor reaches the load factor, the number of
       buckets is automatically increased to the smallest prime number that is larger
       than twice the current number of buckets.</para>
            <para>The hash code provider dispenses hash codes for keys
       in the <see cref="System.Collections.Hashtable" />. The default
       hash code provider is the key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
            <para>The comparer determines whether two keys are equal. Every key in
       a <see cref="System.Collections.Hashtable" /> must be unique.
       The default comparer is the key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
        </remarks>
        <seealso cref="System.Object.GetHashCode" qualify="true" />
        <seealso cref="System.Object.Equals" qualify="true" />
    </doc><doc for="Hashtable.Hashtable1">
        <summary>
            <para> Creates an empty <see cref="System.Collections.Hashtable" /> 
 with the specified initial capacity and using the default load
 factor, the default hash code provider and the default comparer.</para>
        </summary>
        <param name="capacity">The approximate number of elements that the <see cref="System.Collections.Hashtable" /> can initially contain. </param>
        <exception cref="System.ArgumentOutOfRangeException"><paramref name="capacity" /> is less than zero. </exception>
        <remarks>
            <para>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <see cref="System.Collections.Hashtable" />.
 Capacity is automatically increased as required based on the load factor.</para>
            <para>The load factor is the maximum ratio of elements to buckets. A smaller
       load factor means faster lookup at the cost of increased memory consumption. The
       default load factor is 1.0, which is the best balance between speed and
       size.</para>
            <para>When the actual load factor reaches the load factor, the number of
       buckets is automatically increased to the smallest prime number that is larger
       than twice the current number of buckets.</para>
            <para>The hash code provider dispenses hash codes for keys in the <see cref="System.Collections.Hashtable" />.
    The default hash code provider is the key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
            <para>The comparer determines whether two keys are equal. Every key in a
 <see cref="System.Collections.Hashtable" /> must be unique. The default comparer is the 
    key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
        </remarks>
        <seealso cref="System.Object.GetHashCode" qualify="true" />
        <seealso cref="System.Object.Equals" qualify="true" />
    </doc><doc for="Hashtable.Hashtable2">
        <summary>
            <para>Creates an empty <see cref="System.Collections.Hashtable" /> 
 with the specified initial capacity and using the specified load
 factor, the default hash code provider and the default comparer.</para>
        </summary>
        <param name="capacity">The approximate number of elements that the <see cref="System.Collections.Hashtable" /> can initially contain. </param>
        <param name="loadFactor">A number in the range from 0.1 through 1.0 indicating the maximum ratio of elements to buckets.</param>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="capacity" /> is less than zero.</para><para>-or-</para>
            <para><paramref name="loadFactor" /> is less than 0.1.</para><para>-or-</para>
            <para><paramref name="loadFactor" /> is greater than 1.0. </para></exception>
<remarks>
            <para>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <see cref="System.Collections.Hashtable" />.
       Capacity is automatically increased as required based on the load factor.</para>
            <para>The load factor is the maximum ratio of elements to buckets. A smaller 
       load factor means faster lookup at the cost of increased memory consumption. A
       load factor of 1.0 is the best balance between speed and size.</para>
            <para>When the actual load factor reaches the load factor, the number of
       buckets is automatically increased to the smallest prime number that is larger
       than twice the current number of buckets.</para>
            <para>The hash code provider dispenses hash codes for keys in the <see cref="System.Collections.Hashtable" />.
    The default hash code provider is the key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
            <para>The comparer determines whether two keys are equal. Every key in a
 <see cref="System.Collections.Hashtable" /> must be unique. The default comparer is the 
    key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
        </remarks>
        <seealso cref="System.Object.GetHashCode" qualify="true" />
        <seealso cref="System.Object.Equals" qualify="true" />
    </doc><doc for="Hashtable.Hashtable3">
        <summary>
            <para> Creates an empty <see cref="System.Collections.Hashtable" /> 
 with the specified initial capacity and using the specified load
 factor, the specified hash code provider and the specified comparer.</para>
        </summary>
        <param name="capacity">The approximate number of elements that the <see cref="System.Collections.Hashtable" /> can initially contain. </param>
        <param name="loadFactor">A number in the range from 0.1 through 1.0 indicating the maximum ratio of elements to buckets.</param>
        <param name="hcp">
            <para>The <see cref="System.Collections.IHashCodeProvider" /> that supplies the hash codes for all keys in the <see cref="System.Collections.Hashtable" />.</para>
            <para>-or-</para>
            <para><see langword="null" /> to use the default hash code provider, which is each key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
        </param>
        <param name="comparer">
            <para> The <see cref="System.Collections.IComparer" /> to use to determine whether two keys are equal.</para>
            <para> -or-</para>
            <para><see langword="null" /> to use the default comparer, which is each key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
        </param>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="capacity" /> is less than zero.</para><para>-or-</para>
            <para><paramref name="loadFactor" /> is less than 0.1.</para><para>-or-</para>
            <para><paramref name="loadFactor" /> is greater than 1.0. </para></exception>
<remarks>
            <para>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <see cref="System.Collections.Hashtable" />.
       Capacity is automatically increased as required based on the load factor.</para>
            <para>The load factor is the maximum ratio of elements to buckets. A smaller 
       load factor means faster lookup at the cost of increased memory consumption. A
       load factor of 1.0 is the best balance between speed and size.</para>
            <para>When the actual load factor reaches the load factor, the number of
       buckets is automatically increased to the smallest prime number that is larger
       than twice the current number of buckets.</para>
            <para>The hash code provider dispenses hash codes for keys in the <see cref="System.Collections.Hashtable" />.
    The default hash code provider is the key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
            <para>The comparer determines whether two keys are equal. Every key in a
 <see cref="System.Collections.Hashtable" /> must be unique. The default comparer is the 
    key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
            <para>The custom hash code provider and the custom comparer enable such scenarios
    as doing lookups with case-insensitive strings.</para>
        </remarks>
        <seealso cref="System.Collections.IHashCodeProvider" />
        <seealso cref="System.Collections.IComparer" />
        <seealso cref="System.Object.GetHashCode" qualify="true" />
        <seealso cref="System.Object.Equals" qualify="true" />
    </doc><doc for="Hashtable.Hashtable4">
        <summary>
            <para>Creates an empty <see cref="System.Collections.Hashtable" /> with 
    the default initial capacity and using the default load factor, the
    specified hash code provider and the specified comparer.</para>
        </summary>
        <param name="hcp">
            <para>The <see cref="System.Collections.IHashCodeProvider" /> that supplies the hash codes for all keys in the <see cref="System.Collections.Hashtable" />.</para>
            <para>-or-</para>
            <para><see langword="null" /> to use the default hash code provider, which is each key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
        </param>
        <param name="comparer">
            <para>The <see cref="System.Collections.IComparer" /> to use to determine whether two keys are equal.</para>
            <para>-or-</para>
            <para><see langword="null" /> to use the default comparer, which is each key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
        </param>
        <remarks>
            <para>A hashtable's capacity is used to calculate the optimal number of hashtable 
       buckets based on the load factor. The default initial capacity is zero. Capacity
       is automatically increased as required.</para>
            <para>The load factor is the maximum ratio of elements to buckets. A smaller 
       load factor means faster lookup at the cost of increased memory consumption. The
       default load factor is 1.0, which is the best balance between speed and
       size.</para>
            <para>When the actual load factor reaches the load factor, the number of
       buckets is automatically increased to the smallest prime number that is larger
       than twice the current number of buckets.</para>
            <para>The hash code provider dispenses hash codes for keys in the <see cref="System.Collections.Hashtable" />.
    The default hash code provider is the key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
            <para>The comparer determines whether two keys are equal. Every key in a
 <see cref="System.Collections.Hashtable" /> must be unique. The default comparer is the 
    key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
            <para>The custom hash code provider and the custom comparer enable such scenarios
    as doing lookups with case-insensitive strings.</para>
        </remarks>
        <seealso cref="System.Collections.IHashCodeProvider" />
        <seealso cref="System.Collections.IComparer" />
        <seealso cref="System.Object.GetHashCode" qualify="true" />
        <seealso cref="System.Object.Equals" qualify="true" />
    </doc><doc for="Hashtable.Hashtable5">
        <summary>
            <para>Creates an empty <see cref="System.Collections.Hashtable" /> with 
    the specified initial capacity and using the default load factor, the
    specified hash code provider and the specified comparer.</para>
        </summary>
        <param name="capacity">The approximate number of elements that the <see cref="System.Collections.Hashtable" /> can initially contain. </param>
        <param name="hcp">
            <para>The <see cref="System.Collections.IHashCodeProvider" /> that supplies the hash codes for all keys in the <see cref="System.Collections.Hashtable" />.</para>
            <para>-or-</para>
            <para><see langword="null" /> to use the default hash code provider, which is each key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
        </param>
        <param name="comparer">
            <para>The <see cref="System.Collections.IComparer" /> to use to determine whether two keys are equal.</para>
            <para>-or-</para>
            <para><see langword="null" /> to use the default comparer, which is each key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
        </param>
        <remarks>
            <para>Specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <see cref="System.Collections.Hashtable" />.
       Capacity is automatically increased as required based on the load factor.</para>
            <para>The load factor is the maximum ratio of elements to buckets. A smaller 
       load factor means faster lookup at the cost of increased memory consumption. The
       default load factor is 1.0, which is the best balance between speed and
       size.</para>
            <para>When the actual load factor reaches the load factor, the number of
       buckets is automatically increased to the smallest prime number that is larger
       than twice the current number of buckets.</para>
            <para>The hash code provider dispenses hash codes for keys in the <see cref="System.Collections.Hashtable" />.
    The default hash code provider is the key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
            <para>The comparer determines whether two keys are equal. Every key in a
 <see cref="System.Collections.Hashtable" /> must be unique. The default comparer is the 
    key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
            <para>The custom hash code provider and the custom comparer enable such scenarios
    as doing lookups with case-insensitive strings.</para>
        </remarks>
        <seealso cref="System.Collections.IHashCodeProvider" />
        <seealso cref="System.Collections.IComparer" />
        <seealso cref="System.Object.GetHashCode" qualify="true" />
        <seealso cref="System.Object.Equals" qualify="true" />
    </doc><doc for="Hashtable.Hashtable6">
        <summary>
            <para>Copies the elements from the specified dictionary to a 
       new <see cref="System.Collections.Hashtable" /> with the same
       initial capacity as the number of elements copied and using the default load factor, the
       default hash code provider and the default comparer.</para>
        </summary>
        <param name="d">The <see cref="System.Collections.IDictionary" /> to copy to a new <see cref="System.Collections.Hashtable" />.</param>
        <exception cref="System.ArgumentNullException"><paramref name="d" /> is <see langword="null" />.</exception>
        <remarks>
            <para> The initial capacity is set to the number
       of elements in the source dictionary. Capacity is automatically increased as required based on
       the load factor.</para>
            <para>The load factor is the maximum ratio of elements to buckets. A smaller
       load factor means faster lookup at the cost of increased memory consumption. The
       default load factor is 1.0, which is the best balance between speed and
       size.</para>
            <para>When the actual load factor reaches the load factor, the number of
       buckets is automatically increased to the smallest prime number that is larger
       than twice the current number of buckets.</para>
            <para>The hash code provider dispenses hash codes for keys in the <see cref="System.Collections.Hashtable" />.
    The default hash code provider is the key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
            <para>The comparer determines whether two keys are equal. Every key in a
 <see cref="System.Collections.Hashtable" /> must be unique. The default comparer is the 
    key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
            <para>The elements of the new <see cref="System.Collections.Hashtable" /> are sorted in the same order in which the enumerator iterates through the <see cref="System.Collections.IDictionary" />.</para>
        </remarks>
        <seealso cref="System.Collections.IDictionary" />
        <seealso cref="System.Object.GetHashCode" qualify="true" />
        <seealso cref="System.Object.Equals" qualify="true" />
    </doc><doc for="Hashtable.Hashtable7">
        <summary>
            <para>Copies the elements from the specified dictionary to a new <see cref="System.Collections.Hashtable" /> 
 with the same initial capacity as
 the number of elements copied and using the specified load factor, the
 default hash code provider and the default comparer.</para>
        </summary>
        <param name="d">The <see cref="System.Collections.IDictionary" /> to copy to a new <see cref="System.Collections.Hashtable" />.</param>
        <param name="loadFactor">A number in the range from 0.1 through 1.0 indicating the maximum ratio of elements to buckets.</param>
        <exception cref="System.ArgumentNullException"><paramref name="d" /> is <see langword="null" />. </exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="loadFactor" /> is less than 0.1.</para><para>-or-</para>
            <para><paramref name="loadFactor" /> is greater than 1.0. </para></exception>
<remarks>
            <para> The initial capacity is set to the number
       of elements in the source dictionary. Capacity is automatically increased as required based on
       the load factor.</para>
            <para>The load factor is the maximum ratio of elements to buckets. A smaller
       load factor means faster lookup at the cost of increased memory consumption. A
       load factor of 1.0 is the best balance between speed and size.</para>
            <para>When the actual load factor reaches the load factor, the number of
       buckets is automatically increased to the smallest prime number that is larger
       than twice the current number of buckets.</para>
            <para>The hash code provider dispenses hash codes for keys in the <see cref="System.Collections.Hashtable" />.
    The default hash code provider is the key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
            <para>The comparer determines whether two keys are equal. Every key in a
 <see cref="System.Collections.Hashtable" /> must be unique. The default comparer is the 
    key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
            <para>The elements of the new <see cref="System.Collections.Hashtable" /> are sorted in the same order in which the enumerator iterates through the <see cref="System.Collections.IDictionary" />.</para>
        </remarks>
        <seealso cref="System.Collections.IDictionary" />
        <seealso cref="System.Object.GetHashCode" qualify="true" />
        <seealso cref="System.Object.Equals" qualify="true" />
    </doc><doc for="Hashtable.Hashtable8">
        <summary>
            <para>Copies the elements from the specified dictionary to a new <see cref="System.Collections.Hashtable" /> 
 with the same initial capacity as
 the number of elements copied and using the default load factor, the
 specified hash code provider and the specified comparer.</para>
        </summary>
        <param name="d">The <see cref="System.Collections.IDictionary" /> to copy to a new <see cref="System.Collections.Hashtable" />.</param>
        <param name="hcp">
            <para>The <see cref="System.Collections.IHashCodeProvider" /> that supplies the hash codes for all keys in the <see cref="System.Collections.Hashtable" />.</para>
            <para>-or-</para>
            <para><see langword="null" /> to use the default hash code provider, which is each key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
        </param>
        <param name="comparer">
            <para>The <see cref="System.Collections.IComparer" /> to use to determine whether two keys are equal.</para>
            <para>-or-</para>
            <para><see langword="null" /> to use the default comparer, which is each key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
        </param>
        <exception cref="System.ArgumentNullException"><paramref name="d" /> is <see langword="null" />. </exception>
        <remarks>
            <para> The initial capacity is set to the number
       of elements in the source dictionary. Capacity is automatically increased as required based on
       the load factor.</para>
            <para>The load factor is the maximum ratio of elements to buckets. A smaller
       load factor means faster lookup at the cost of increased memory consumption. The
       default load factor is 1.0, which is the best balance between speed and
       size.</para>
            <para>When the actual load factor reaches the load factor, the number of
       buckets is automatically increased to the smallest prime number that is larger
       than twice the current number of buckets.</para>
            <para>The hash code provider dispenses hash codes for keys in the <see cref="System.Collections.Hashtable" />.
    The default hash code provider is the key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
            <para>The comparer determines whether two keys are equal. Every key in a
 <see cref="System.Collections.Hashtable" /> must be unique. The default comparer is the 
    key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
            <para>The custom hash code provider and the custom comparer enables scenarios
 such as doing lookups with case-insensitive strings.</para>
            <para>The elements of the new <see cref="System.Collections.Hashtable" /> are sorted in the same order in which the enumerator iterates through the <see cref="System.Collections.IDictionary" />. </para>
        </remarks>
        <seealso cref="System.Collections.IDictionary" />
        <seealso cref="System.Collections.IHashCodeProvider" />
        <seealso cref="System.Collections.IComparer" />
        <seealso cref="System.Object.GetHashCode" qualify="true" />
        <seealso cref="System.Object.Equals" qualify="true" />
    </doc><doc for="Hashtable.Hashtable9">
        <summary>
            <para>Copies the elements from the specified dictionary to a new <see cref="System.Collections.Hashtable" /> 
 with the same initial capacity as
 the number of elements copied and using the specified load factor, the
 specified hash code provider and the specified comparer.</para>
        </summary>
        <param name="d">The <see cref="System.Collections.IDictionary" /> to copy to a new <see cref="System.Collections.Hashtable" />.</param>
        <param name="loadFactor">A number in the range from 0.1 through 1.0 indicating the maximum ratio of elements to buckets.</param>
        <param name="hcp">
            <para>The <see cref="System.Collections.IHashCodeProvider" /> that supplies the hash codes for all keys in the <see cref="System.Collections.Hashtable" />.</para>
            <para>-or-</para>
            <para><see langword="null" /> to use the default hash code provider, which is each key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
        </param>
        <param name="comparer">
            <para>The <see cref="System.Collections.IComparer" /> to use to determine whether two keys are equal.</para>
            <para>-or-</para>
            <para><see langword="null" /> to use the default comparer, which is each key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
        </param>
        <exception cref="System.ArgumentNullException"><paramref name="d" /> is <see langword="null" />. </exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="loadFactor" /> is less than 0.1.</para><para>-or-</para>
            <para><paramref name="loadFactor" /> is greater than 1.0. </para></exception>
<remarks>
            <para> The initial capacity is set to the number
       of elements in the source dictionary. Capacity is automatically increased as required based on
       the load factor.</para>
            <para>The load factor is the maximum ratio of elements to buckets. A smaller
       load factor means faster lookup at the cost of increased memory consumption. A
       load factor of 1.0 is the best balance between speed and size.</para>
            <para>When the actual load factor reaches the load factor, the number of
       buckets is automatically increased to the smallest prime number that is larger
       than twice the current number of buckets.</para>
            <para>The hash code provider dispenses hash codes for keys in the <see cref="System.Collections.Hashtable" />.
    The default hash code provider is the key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
            <para>The comparer determines whether two keys are equal. Every key in a
 <see cref="System.Collections.Hashtable" /> must be unique. The default comparer is the 
    key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
 The custom hash code provider and the custom
 comparer enable such scenarios as doing lookups with case-insensitive strings.
 <para>The elements of the new <see cref="System.Collections.Hashtable" /> are sorted in the same order in which the enumerator iterates through the <see cref="System.Collections.IDictionary" />. </para></remarks>
    </doc><doc for="Hashtable.Hashtable10">
        <summary>
            <para>Creates an empty <see cref="System.Collections.Hashtable" /> that is serializable with the specified 
 <see cref="System.Runtime.Serialization.SerializationInfo" /> and <see cref="System.Runtime.Serialization.StreamingContext" />.</para>
        </summary>
        <param name="info">A <see cref="System.Runtime.Serialization.SerializationInfo" /> object containing the information required to serialize the <see cref="System.Collections.Hashtable" />.</param>
        <param name="context">A <see cref="System.Runtime.Serialization.StreamingContext" /> object containing the source and destination of the serialized stream associated with the <see cref="System.Collections.Hashtable" />.</param>
        <exception cref="System.ArgumentNullException"><paramref name="info" /> is <see langword="null" />.</exception>
        <remarks>
            <para>A hashtable's capacity is used to calculate the optimal number of hashtable buckets based on the load factor.
 The default initial capacity is zero. Capacity is automatically increased as required.</para>
            <para>The load factor is the maximum ratio of elements to buckets.
 A smaller load factor means faster lookup at the cost of increased memory consumption.
 The default load factor is 1.0, which is the best balance between speed and size.</para>
            <para>When the actual load factor reaches the load factor,
 the number of buckets is automatically increased to the smallest prime number that is larger than twice the current number of buckets.</para>
            <para>The hash code provider dispenses hash codes for keys in the <see cref="System.Collections.Hashtable" />. 
 The default hash code provider is the key's implementation of <see cref="System.Object.GetHashCode" qualify="true" />.</para>
            <para>The comparer determines whether two keys are equal. Every key in a <see cref="System.Collections.Hashtable" /> must be unique.
 The default comparer is the key's implementation of <see cref="System.Object.Equals" qualify="true" />.</para>
        </remarks>
        <seealso cref="System.Runtime.Serialization.ISerializable" />
        <seealso cref="System.Runtime.Serialization.SerializationInfo" />
        <seealso cref="System.Runtime.Serialization.StreamingContext" />
        <seealso cref="System.Collections.Hashtable.OnDeserialization" />
        <seealso cref="System.Object.GetHashCode" qualify="true" />
        <seealso cref="System.Object.Equals" qualify="true" />
    </doc><doc for="Hashtable.Add">
        <summary>
            <para>Adds an element with the specified key and value into the <see cref="System.Collections.Hashtable" />.</para>
        </summary>
        <param name="key">The key of the element to add.</param>
        <param name="value">The value of the element to add. The value can be <see langword="null" />.</param>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="key" /> is <see langword="null" />.</para></exception>
        <exception cref="System.ArgumentException"><para>An element with the same key already exists in the <see cref="System.Collections.Hashtable" />.</para></exception>
        <exception cref="System.NotSupportedException"><para>The <see cref="System.Collections.Hashtable" /> is read-only.</para><para>-or-</para><para>The <see cref="System.Collections.Hashtable" /> has a fixed size.</para></exception>
<remarks>
            <para>A key cannot be <see langword="null" />, but a value can be.</para>
            <para>An object that has no correlation between its
   state and its hash code value should typically not be used as the key. For
   example, String objects are better than StringBuilder objects for use as keys.</para>
            <para>The <see cref="System.Collections.Hashtable.this" /> property can also be used to add new
elements by setting the value of a key that does not exist in the <see cref="System.Collections.Hashtable" />.
For example: <c>myCollection["myNonexistentKey"] = myValue</c>. However, if the
specified key already exists in the <see cref="System.Collections.Hashtable" />, setting the
<see cref="System.Collections.Hashtable.this" /> property overwrites the old
value. In contrast, the <see cref="System.Collections.Hashtable.Add" /> method does not modify existing
elements.</para>
        </remarks>
        <example>
            <para>The following example shows how to add elements to the <see cref="System.Collections.Hashtable" />.</para>
            <codelink SampleID="Classic Hashtable.Add Example" SnippetID="1" />
        </example>
        <seealso cref="System.Collections.Hashtable.Remove" />
        <seealso cref="System.Collections.Hashtable.this" />
        <seealso cref="System.Collections.IDictionary.Add" qualify="true" />
    </doc><doc for="Hashtable.Clear">
        <summary>
            <para>Removes all elements from the <see cref="System.Collections.Hashtable" />.</para>
        </summary>
<exception cref="System.NotSupportedException">The <see cref="System.Collections.Hashtable" /> is read-only.</exception>
        <remarks>
            <para><see cref="System.Collections.Hashtable.Count" /> is set to zero.
 The capacity remains unchanged.</para>
        </remarks>
        <example>
            <para>The following example shows how to clear the values of the <see cref="System.Collections.Hashtable" />.</para>
            <codelink SampleID="Classic Hashtable.Clear Example" SnippetID="1" />
        </example>
        <seealso cref="System.Collections.IDictionary.Clear" qualify="true" />
    </doc><doc for="Hashtable.Clone">
        <summary>
            <para>Creates a shallow copy of the <see cref="System.Collections.Hashtable" />.</para>
        </summary>
        <returns>
            <para>A shallow copy of the <see cref="System.Collections.Hashtable" />.</para>
        </returns>
        <remarks>
            <para> A shallow copy of a collection copies only the elements of the collection, whether they are reference types or value types,
      but it does not copy the objects that the references refer to.
      The references in the new collection point to the same objects that the references in the original collection point to.</para>
            <para>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</para>
            <para>The <see cref="System.Collections.Hashtable" /> clone has the same count, the same capacity, 
 the same <see cref="System.Collections.IHashCodeProvider" /> implementation,
 and the same <see cref="System.Collections.IComparer" /> implementation
 as the original <see cref="System.Collections.Hashtable" />.</para>
        </remarks>
        <seealso cref="System.Collections.Hashtable.CopyTo" />
    </doc><doc for="Hashtable.Contains">
        <summary>
            <para>Determines whether the <see cref="System.Collections.Hashtable" /> contains a specific key.</para>
        </summary>
        <param name="key">The key to locate in the <see cref="System.Collections.Hashtable" />.</param>
        <returns>
            <para><see langword="true" /> if the <see cref="System.Collections.Hashtable" /> contains an element with the 
    specified key; otherwise, <see langword="false" />.</para>
        </returns>
        <exception cref="System.ArgumentNullException"><paramref name="key" /> is <see langword="null" />. </exception>
        <remarks>
            <para>This implementation is close to O(1) in most cases.</para>
            <para><see cref="System.Collections.Hashtable.Contains" /> implements <see cref="System.Collections.IDictionary.Contains" qualify="true" />. It behaves
    exactly as <see cref="System.Collections.Hashtable.ContainsKey" />.</para>
        </remarks>
        <example>
            <para>The following example shows how to determine whether the <see cref="System.Collections.Hashtable" /> 
 contains a specific element.</para>
            <codelink SampleID="Classic Hashtable.Contains Example" SnippetID="1" />
        </example>
        <seealso cref="System.Collections.Hashtable.ContainsKey" />
        <seealso cref="System.Collections.IDictionary" />
    </doc><doc for="Hashtable.ContainsKey">
        <summary>
            <para>Determines whether the <see cref="System.Collections.Hashtable" /> contains a specific key.</para>
        </summary>
        <param name="key">The key to locate in the <see cref="System.Collections.Hashtable" />.</param>
        <returns>
            <para><see langword="true" /> if the <see cref="System.Collections.Hashtable" /> contains an element with the 
    specified key; otherwise, <see langword="false" />.</para>
        </returns>
        <exception cref="System.ArgumentNullException"><paramref name="key" /> is <see langword="null" />. </exception>
        <remarks>
            <para>This implementation is close to O(1) in most cases.</para>
            <para>This method behaves exactly as <see cref="System.Collections.Hashtable.Contains" />.</para>
        </remarks>
        <example>
            <para>The following example shows how to determine whether the <see cref="System.Collections.Hashtable" /> 
 contains a specific element.</para>
            <codelink SampleID="Classic Hashtable.Contains Example" SnippetID="1" />
        </example>
        <seealso cref="System.Collections.Hashtable.Contains" />
        <seealso cref="System.Collections.Hashtable.ContainsValue" />
    </doc><doc for="Hashtable.ContainsValue">
        <summary>
            <para>Determines whether the <see cref="System.Collections.Hashtable" /> contains a specific value.</para>
        </summary>
        <param name="value">The value to locate in the <see cref="System.Collections.Hashtable" />. The value can be <see langword="null" />.</param>
        <returns>
            <para><see langword="true" /> if the <see cref="System.Collections.Hashtable" /> contains an element with
   the specified <paramref name="value" />; otherwise, <see langword="false" />.</para>
        </returns>
        <remarks>
            <para>This method performs a linear search; therefore, the
      average execution time is proportional to <see cref="System.Collections.Hashtable.Count" />. That is, this method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is
   <see cref="System.Collections.Hashtable.Count" />.</para>
            <para>The values of the elements of the <see cref="System.Collections.Hashtable" /> are compared to the
   specified value using the <see cref="System.Object.Equals" qualify="true" /> method.</para>
        </remarks>
        <example>
            <para>The following example shows how to determine whether the <see cref="System.Collections.Hashtable" />
contains a specific element.</para>
            <codelink SampleID="Classic Hashtable.Contains Example" SnippetID="1" />
        </example>
        <seealso cref="System.Collections.Hashtable.ContainsKey" />
        <seealso cref="System.Object.Equals" qualify="true" />
    </doc><doc for="Hashtable.CopyTo">
        <summary>
            <para>Copies the <see cref="System.Collections.Hashtable" /> elements to a
    one-dimensional <see cref="System.Array" /> instance at the specified index.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> that is the destination of the <see cref="System.Collections.DictionaryEntry" /> objects copied from <see cref="System.Collections.Hashtable" />. The <see cref="System.Array" /> must have zero-based indexing.</param>
        <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
        <exception cref="System.ArgumentNullException"><paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="System.ArgumentOutOfRangeException"><paramref name="arrayIndex" /> is less than zero.</exception>
        <exception cref="System.ArgumentException">
            <para><paramref name="array" /> is multidimensional.</para><para>-or-</para>
            <para><paramref name="arrayIndex" /> is equal to or greater than the length of <paramref name="array" />.</para><para>-or-</para><para>The number of elements in the source <see cref="System.Collections.Hashtable" /> is greater than the available space from <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.</para></exception>
<exception cref="System.InvalidCastException">The type of the source <see cref="System.Collections.Hashtable" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
<remarks>
            <para>The elements are copied to the <see cref="System.Array" /> in the same order in which 
    the enumerator iterates through the <see cref="System.Collections.Hashtable" />.</para>
            <para>To copy only the keys in the <see cref="System.Collections.Hashtable" />, 
 use <c>Hashtable.Keys.CopyTo</c>.</para>
            <para>To copy only the values in the <see cref="System.Collections.Hashtable" />, 
 use <c>Hashtable.Values.CopyTo</c>.</para>
        </remarks>
        <example>
            <para>The following example shows how to copy the list of keys or the list of values in a <see cref="System.Collections.Hashtable" /> 
 into a one-dimensional <see cref="System.Array" />.</para>
            <codelink SampleID="Classic Hashtable.CopyTo Example" SnippetID="1" />
        </example>
        <seealso cref="System.Array" />
        <seealso cref="System.Collections.DictionaryEntry" />
        <seealso cref="System.Collections.Hashtable.GetEnumerator" />
    </doc><doc for="Hashtable.this">
        <summary>
            <para>Gets or sets the value associated with the specified key.</para>
        </summary>
        <param name="key">The key whose value to get or set.</param>
        <value>
            <para> The value associated with the specified key. If
      the specified key is not found, attempting to get it returns
   <see langword="null" />,
      and attempting to set it creates a new element using the
      specified key.</para>
        </value>
        <exception cref="System.ArgumentNullException"><paramref name="key" /> is <see langword="null" />. </exception>
        <exception cref="System.NotSupportedException"><para>The property is set and the <see cref="System.Collections.Hashtable" /> is read-only.</para><para>-or-</para><para>The property is set, <paramref name="key" /> does not exist in the collection, and the <see cref="System.Collections.Hashtable" /> has a fixed size.</para></exception>
        <remarks>
            <para>This property provides the ability to access a specific element in the
      collection by using the following syntax: <c>myCollection[key]</c>.</para>
            <para>When setting this property, if the specified key already exists in the
   <see cref="System.Collections.Hashtable" />, the value is replaced; otherwise, a new
      element is created. In contrast, the <see cref="System.Collections.Hashtable.Add" /> method does not modify existing
      elements.</para>
            <para>A key cannot be <see langword="null" />, but a value can be.
 To distinguish between <see langword="null" /> that is returned because the specified key is not found
 and <see langword="null" /> that is returned because the value of the specified key is <see langword="null" />,
 use the <see cref="System.Collections.Hashtable.Contains" /> method
 or the <see cref="System.Collections.Hashtable.ContainsKey" /> method
 to determine if the key exists in the list.</para>
        </remarks>
        <seealso cref="System.Collections.Hashtable.Add" />
    </doc><doc for="Hashtable.IEnumerable.GetEnumerator">
        <summary>
            <para>Returns an <see cref="System.Collections.IEnumerator" /> that can iterate through the <see cref="System.Collections.Hashtable" />.</para>
        </summary>
        <returns>
            <para>An <see cref="System.Collections.IEnumerator" /> for the <see cref="System.Collections.Hashtable" />.</para>
        </returns>
        <remarks>
            <para> Enumerators only allow reading the data in the collection.
 Enumerators cannot be used to modify the underlying collection.</para>
            <para>Initially, the enumerator is positioned before the first element in the collection.
 <see cref="System.Collections.IEnumerator.Reset" /> also brings the enumerator back to this position.
 At this position, calling <see cref="System.Collections.IEnumerator.Current" /> throws an exception.
 Therefore, you must call <see cref="System.Collections.IEnumerator.MoveNext" /> to advance the enumerator to the first element of the collection
 before reading the value of <see cref="System.Collections.IEnumerator.Current" />.</para>
            <para><see cref="System.Collections.IEnumerator.Current" /> returns the same object until either <see cref="System.Collections.IEnumerator.MoveNext" /> or <see cref="System.Collections.IEnumerator.Reset" /> is called.
<see cref="System.Collections.IEnumerator.MoveNext" /> sets <see cref="System.Collections.IEnumerator.Current" /> to the next element.</para>
            <para>After the end of the collection is passed, the enumerator is positioned after the last element in the collection, and calling <see cref="System.Collections.IEnumerator.MoveNext" /> returns <see langword="false" />.
 If the last call to <see cref="System.Collections.IEnumerator.MoveNext" /> returned <see langword="false" />, calling <see cref="System.Collections.IEnumerator.Current" /> throws an exception.
 To set <see cref="System.Collections.IEnumerator.Current" /> to the first element of the collection again,
 you can call <see cref="System.Collections.IEnumerator.Reset" /> followed by <see cref="System.Collections.IEnumerator.MoveNext" />.</para>
            <para>An enumerator remains valid as long as the collection remains unchanged.
 If changes are made to the collection, such as adding, modifying or deleting elements, the enumerator is irrecoverably invalidated
 and the next call to <see cref="System.Collections.IEnumerator.MoveNext" /> or <see cref="System.Collections.IEnumerator.Reset" /> throws an <see cref="System.InvalidOperationException" />. 
 If the collection is modified between <see cref="System.Collections.IEnumerator.MoveNext" /> and <see cref="System.Collections.IEnumerator.Current" />,
 <see cref="System.Collections.IEnumerator.Current" /> will return the element that it is set to, even if the enumerator is already invalidated.</para>
            <para>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.
 Even when a collection is synchronized, other threads could still modify the collection, which causes the enumerator to throw an exception.
 To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</para>
        </remarks>
        <seealso cref="System.Collections.IDictionaryEnumerator" />
        <seealso cref="System.Collections.IEnumerator" />
    </doc><doc for="Hashtable.GetEnumerator">
        <summary>
            <para> Returns an <see cref="System.Collections.IDictionaryEnumerator" /> that can iterate through the <see cref="System.Collections.Hashtable" />.</para>
        </summary>
        <returns>
            <para>An <see cref="System.Collections.IDictionaryEnumerator" /> for the <see cref="System.Collections.Hashtable" />.</para>
        </returns>
        <remarks>
            <para> Enumerators only allow reading the data in the collection.
 Enumerators cannot be used to modify the underlying collection.</para>
            <para>Initially, the enumerator is positioned before the first element in the collection.
 <see cref="System.Collections.IEnumerator.Reset" /> also brings the enumerator back to this position.
 At this position, calling <see cref="System.Collections.IEnumerator.Current" /> throws an exception.
 Therefore, you must call <see cref="System.Collections.IEnumerator.MoveNext" /> to advance the enumerator to the first element of the collection
 before reading the value of <see cref="System.Collections.IEnumerator.Current" />.</para>
            <para><see cref="System.Collections.IEnumerator.Current" /> returns the same object until either <see cref="System.Collections.IEnumerator.MoveNext" /> or <see cref="System.Collections.IEnumerator.Reset" /> is called.
<see cref="System.Collections.IEnumerator.MoveNext" /> sets <see cref="System.Collections.IEnumerator.Current" /> to the next element.</para>
            <para>After the end of the collection is passed, the enumerator is positioned after the last element in the collection, and calling <see cref="System.Collections.IEnumerator.MoveNext" /> returns <see langword="false" />.
 If the last call to <see cref="System.Collections.IEnumerator.MoveNext" /> returned <see langword="false" />, calling <see cref="System.Collections.IEnumerator.Current" /> throws an exception.
 To set <see cref="System.Collections.IEnumerator.Current" /> to the first element of the collection again,
 you can call <see cref="System.Collections.IEnumerator.Reset" /> followed by <see cref="System.Collections.IEnumerator.MoveNext" />.</para>
            <para>An enumerator remains valid as long as the collection remains unchanged.
 If changes are made to the collection, such as adding, modifying or deleting elements, the enumerator is irrecoverably invalidated
 and the next call to <see cref="System.Collections.IEnumerator.MoveNext" /> or <see cref="System.Collections.IEnumerator.Reset" /> throws an <see cref="System.InvalidOperationException" />. 
 If the collection is modified between <see cref="System.Collections.IEnumerator.MoveNext" /> and <see cref="System.Collections.IEnumerator.Current" />,
 <see cref="System.Collections.IEnumerator.Current" /> will return the element that it is set to, even if the enumerator is already invalidated.</para>
            <para>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.
 Even when a collection is synchronized, other threads could still modify the collection, which causes the enumerator to throw an exception.
 To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</para>
        </remarks>
        <seealso cref="System.Collections.IDictionaryEnumerator" />
        <seealso cref="System.Collections.IEnumerator" />
    </doc><doc for="Hashtable.GetHash">
        <summary>
            <para>Returns the hash code for the specified key.</para>
        </summary>
        <param name="key">The <see cref="System.Object" /> for which a hash code is to be returned.</param>
        <returns>
            <para>The hash code for <paramref name="key" />.</para>
        </returns>
        <exception cref="System.NullReferenceException"><paramref name="key" /> is <see langword="null" />. </exception>
        <remarks>
            <para>If the hashtable was created with a
       specific <see cref="System.Collections.IHashCodeProvider" />
       implementation, this method uses that hash code provider; otherwise, it uses
       the <see cref="System.Object.GetHashCode" qualify="true" />
       implementation of <paramref name="key" />.</para>
        </remarks>
        <seealso cref="System.Object.GetHashCode" qualify="true" />
        <seealso cref="System.Object" />
        <seealso cref="System.Collections.IHashCodeProvider" />
    </doc><doc for="Hashtable.IsReadOnly">
        <summary>
            <para>Gets a value indicating whether the <see cref="System.Collections.Hashtable" />
 is read-only.</para>
        </summary>
        <value>
            <para><see langword="true" /> if the <see cref="System.Collections.Hashtable" /> is read-only; otherwise, 
 <see langword="false" />. The default is 
 <see langword="false" />. </para>
        </value>
        <remarks>
            <para>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</para>
            <para>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection;
 therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</para>
        </remarks>
    </doc><doc for="Hashtable.IsFixedSize">
        <summary>
            <para>Gets a value indicating whether the <see cref="System.Collections.Hashtable" />
 has a fixed size.</para>
        </summary>
        <value>
            <para><see langword="true" /> if the <see cref="System.Collections.Hashtable" /> has a fixed size; otherwise, 
 <see langword="false" />. The default is 
 <see langword="false" />. </para>
        </value>
        <remarks>
            <para>A collection with a fixed size does not allow the addition or removal of elements after the collection is created,
 but it allows the modification of existing elements.</para>
            <para>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements;
 therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</para>
        </remarks>
    </doc><doc for="Hashtable.IsSynchronized">
        <summary>
            <para>Gets a value indicating whether access to the <see cref="System.Collections.Hashtable" />
is synchronized (thread-safe).</para>
        </summary>
        <value>
            <para><see langword="true" /> if access to the <see cref="System.Collections.Hashtable" /> is synchronized
 (thread-safe); otherwise, <see langword="false" />. The
 default is <see langword="false" />.</para>
        </value>
        <remarks>
            <para>A <see cref="System.Collections.Hashtable" /> can safely support one writer and multiple
 readers concurrently. To support multiple writers, all operations
 must be done through the wrapper returned by the <see cref="System.Collections.Hashtable.Synchronized" /> method.</para>
            <para>Enumerating through a collection is intrinsically not a thread-safe procedure.
 Even when a collection is synchronized, other threads could still modify the collection,
 which causes the enumerator to throw an exception. To guarantee thread safety during enumeration,
 you can either lock the collection during the entire enumeration
 or catch the exceptions resulting from changes made by other threads.</para>
            <para lang="VB, C#">The following code example shows how to lock the collection using the <see cref="System.Collections.Hashtable.SyncRoot" /> during the entire enumeration:</para>
            <code lang="C#">Hashtable myCollection = new Hashtable();
 lock( myCollection.SyncRoot ) {
 foreach ( Object item in myCollection ) {
 // Insert your code here.
 }
}
</code>
            <code lang="VB">Dim myCollection As New Hashtable()
Dim item As Object
SyncLock myCollection.SyncRoot
 For Each item In myCollection
 ' Insert your code here.
 Next item
End SyncLock
</code>
        </remarks>
        <example>
            <para>The following example shows how to synchronize a <see cref="System.Collections.Hashtable" />, determine if
 a <see cref="System.Collections.Hashtable" /> is synchronized and use a synchronized <see cref="System.Collections.Hashtable" />.</para>
            <codelink SampleID="Classic Hashtable.IsSynchronized Example" SnippetID="1" />
        </example>
        <seealso cref="System.Collections.Hashtable.Synchronized" />
        <seealso cref="System.Collections.Hashtable.SyncRoot" />
    </doc><doc for="Hashtable.KeyEquals">
        <summary>
            <para>Compares a specific <see cref="System.Object" /> with a specific key in the <see cref="System.Collections.Hashtable" />.</para>
        </summary>
        <param name="item">The <see cref="System.Object" /> to compare with <paramref name="key" />.</param>
        <param name="key">The key in the <see cref="System.Collections.Hashtable" /> to compare with <paramref name="item" />.</param>
        <returns>
            <para><see langword="true" /> if <paramref name="item" /> and <paramref name="key" /> are equal; otherwise, 
 <see langword="false" />. </para>
        </returns>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="item" /> is <see langword="null" />. </para><para>-or-</para>
            <para><paramref name="key" /> is <see langword="null" />. </para></exception>
<remarks>
            <para>If the hashtable was created with a
       specific <see cref="System.Collections.IComparer" /> implementation,
       this method uses that comparer; that is, <see cref="System.Collections.IComparer.Compare" />(<paramref name="item" />, <paramref name="key" />). Otherwise, it uses <c>item.Equals(key)</c>.</para>
        </remarks>
        <seealso cref="System.Object" />
        <seealso cref="System.Collections.IComparer.Compare" />
        <seealso cref="System.Object.Equals" qualify="true" />
    </doc><doc for="Hashtable.Keys">
        <summary>
            <para>Gets an <see cref="System.Collections.ICollection" /> containing the keys in the <see cref="System.Collections.Hashtable" />.</para>
        </summary>
        <value>
            <para>An <see cref="System.Collections.ICollection" />
 containing the keys in the <see cref="System.Collections.Hashtable" />.</para>
        </value>
        <remarks>
            <para>The order of the keys in the <see cref="System.Collections.ICollection" /> is unspecified, but it is
    the same order as the associated values in the <see cref="System.Collections.ICollection" />
    returned by the <see cref="System.Collections.Hashtable.Values" /> method.</para>
            <para>The returned <see cref="System.Collections.ICollection" /> is not a static copy;
 instead, the <see cref="System.Collections.ICollection" /> refers back to the keys
 in the original <see cref="System.Collections.Hashtable" />.
 Therefore, changes to the <see cref="System.Collections.Hashtable" />
 continue to be reflected in the <see cref="System.Collections.ICollection" />.</para>
        </remarks>
        <seealso cref="System.Collections.ICollection" />
        <seealso cref="System.Collections.Hashtable.Values" />
    </doc><doc for="Hashtable.Values">
        <summary>
            <para>Gets an <see cref="System.Collections.ICollection" /> containing the values in the <see cref="System.Collections.Hashtable" />.</para>
        </summary>
        <value>
            <para>An <see cref="System.Collections.ICollection" />
 containing the values in the <see cref="System.Collections.Hashtable" />.</para>
        </value>
        <remarks>
            <para>The order of the values in the <see cref="System.Collections.ICollection" /> is unspecified, but it is
    the same order as the associated keys in the <see cref="System.Collections.ICollection" /> returned by the <see cref="System.Collections.Hashtable.Keys" /> method.</para>
            <para>The returned <see cref="System.Collections.ICollection" /> is not a static copy;
 instead, the <see cref="System.Collections.ICollection" /> refers back to the values
 in the original <see cref="System.Collections.Hashtable" />.
 Therefore, changes to the <see cref="System.Collections.Hashtable" />
 continue to be reflected in the <see cref="System.Collections.ICollection" />.</para>
        </remarks>
        <seealso cref="System.Collections.ICollection" />
        <seealso cref="System.Collections.Hashtable.Keys" />
    </doc><doc for="Hashtable.Remove">
        <summary>
            <para>Removes the element with the specified key from the <see cref="System.Collections.Hashtable" />.</para>
        </summary>
        <param name="key">The key of the element to remove.</param>
        <exception cref="System.ArgumentNullException"><paramref name="key" /> is <see langword="null" />. </exception>
        <exception cref="System.NotSupportedException"><para>The <see cref="System.Collections.Hashtable" /> is read-only.</para><para>-or-</para><para>The <see cref="System.Collections.Hashtable" /> has a fixed size.</para></exception>
        <remarks>
            <para>If the <see cref="System.Collections.Hashtable" /> does not contain an element with the 
 specified key, the <see cref="System.Collections.Hashtable" /> remains unchanged. No exception is
 thrown.</para>
        </remarks>
        <example>
            <para>The following example shows how to remove elements from the <see cref="System.Collections.Hashtable" />.</para>
            <codelink SampleID="Classic Hashtable.Remove Example" SnippetID="1" />
        </example>
        <seealso cref="System.Collections.Hashtable.Add" />
        <seealso cref="System.Collections.IDictionary.Remove" qualify="true" />
    </doc><doc for="Hashtable.SyncRoot">
        <summary>
            <para>Gets an object that can be used to synchronize access to the <see cref="System.Collections.Hashtable" />.</para>
        </summary>
        <value>
            <para>An object that can be used to synchronize access to the <see cref="System.Collections.Hashtable" />.</para>
        </value>
        <remarks>
            <para>To create a synchronized version of the <see cref="System.Collections.Hashtable" />, use the <see cref="System.Collections.Hashtable.Synchronized" /> method.
 However, derived classes can provide their own synchronized version of the <see cref="System.Collections.Hashtable" /> using the <see cref="System.Collections.Hashtable.SyncRoot" /> property.
 The synchronizing code must perform operations on the <see cref="System.Collections.Hashtable.SyncRoot" /> of the <see cref="System.Collections.Hashtable" />,
 not directly on the <see cref="System.Collections.Hashtable" />. This ensures proper operation of collections that are derived from other objects.
 Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the <see cref="System.Collections.Hashtable" /> object.</para>
            <para>Enumerating through a collection is intrinsically not a thread-safe procedure.
 Even when a collection is synchronized, other threads could still modify the collection,
 which causes the enumerator to throw an exception. To guarantee thread safety during enumeration,
 you can either lock the collection during the entire enumeration
 or catch the exceptions resulting from changes made by other threads.</para>
            <para lang="VB, C#">The following code example shows how to lock the collection using the <see cref="System.Collections.Hashtable.SyncRoot" /> during the entire enumeration:</para>
            <code lang="C#">Hashtable myCollection = new Hashtable();
 lock( myCollection.SyncRoot ) {
 foreach ( Object item in myCollection ) {
 // Insert your code here.
 }
}
</code>
            <code lang="VB">Dim myCollection As New Hashtable()
Dim item As Object
SyncLock myCollection.SyncRoot
 For Each item In myCollection
 ' Insert your code here.
 Next item
End SyncLock
</code>
        </remarks>
        <seealso cref="System.Collections.Hashtable.IsSynchronized" />
        <seealso cref="System.Collections.Hashtable.Synchronized" />
    </doc><doc for="Hashtable.Count">
        <summary>
            <para>Gets the number of key-and-value pairs contained in the <see cref="System.Collections.Hashtable" />.</para>
        </summary>
        <value>
            <para>The number of key-and-value pairs contained in the <see cref="System.Collections.Hashtable" />.</para>
        </value>
    </doc><doc for="Hashtable.Synchronized">
        <summary>
            <para>Returns a synchronized (thread-safe) wrapper for the <see cref="System.Collections.Hashtable" />.</para>
        </summary>
        <param name="table">The <see cref="System.Collections.Hashtable" /> to synchronize.</param>
        <returns>
            <para>A synchronized (thread-safe) wrapper for the <see cref="System.Collections.Hashtable" />.</para>
        </returns>
        <exception cref="System.ArgumentNullException"><paramref name="table" /> is <see langword="null" />. </exception>
        <remarks>
            <para>A <see cref="System.Collections.Hashtable" /> can safely support one writer and multiple
 readers concurrently. To support multiple writers, all operations must be
 done through this wrapper only.</para>
            <para>Enumerating through a collection is intrinsically not a thread-safe procedure.
 Even when a collection is synchronized, other threads could still modify the collection,
 which causes the enumerator to throw an exception. To guarantee thread safety during enumeration,
 you can either lock the collection during the entire enumeration
 or catch the exceptions resulting from changes made by other threads.</para>
            <para lang="VB, C#">The following code example shows how to lock the collection using the <see cref="System.Collections.Hashtable.SyncRoot" /> during the entire enumeration:</para>
            <code lang="C#">Hashtable myCollection = new Hashtable();
 lock( myCollection.SyncRoot ) {
 foreach ( Object item in myCollection ) {
 // Insert your code here.
 }
}
</code>
            <code lang="VB">Dim myCollection As New Hashtable()
Dim item As Object
SyncLock myCollection.SyncRoot
 For Each item In myCollection
 ' Insert your code here.
 Next item
End SyncLock
</code>
        </remarks>
        <example>
            <para>The following example shows how to synchronize a <see cref="System.Collections.Hashtable" />, determine if
 a <see cref="System.Collections.Hashtable" /> is synchronized and use a synchronized <see cref="System.Collections.Hashtable" />.</para>
            <codelink SampleID="Classic Hashtable.IsSynchronized Example" SnippetID="1" />
        </example>
        <seealso cref="System.Collections.Hashtable.IsSynchronized" />
        <seealso cref="System.Collections.Hashtable.SyncRoot" />
    </doc><doc for="Hashtable.GetObjectData">
        <summary>
            <para>Implements the <see cref="System.Runtime.Serialization.ISerializable" /> interface and returns the data
    needed to serialize the <see cref="System.Collections.Hashtable" />.</para>
        </summary>
        <param name="info">A <see cref="System.Runtime.Serialization.SerializationInfo" /> object containing the information required to serialize the <see cref="System.Collections.Hashtable" />.</param>
        <param name="context">A <see cref="System.Runtime.Serialization.StreamingContext" /> object containing the source and destination of the serialized stream associated with the <see cref="System.Collections.Hashtable" />.</param>
        <exception cref="System.ArgumentNullException"><paramref name="info" /> is <see langword="null" />.</exception>
        <seealso cref="System.Runtime.Serialization.ISerializable" />
        <seealso cref="System.Runtime.Serialization.SerializationInfo" />
        <seealso cref="System.Runtime.Serialization.StreamingContext" />
        <seealso cref="System.Collections.Hashtable.OnDeserialization" />
    </doc><doc for="Hashtable.OnDeserialization">
        <summary>
            <para>Implements the <see cref="System.Runtime.Serialization.ISerializable" /> interface and raises the
    deserialization event when the deserialization is complete.</para>
        </summary>
        <param name="sender">The source of the deserialization event.</param>
<exception cref="System.Runtime.Serialization.SerializationException">The <see cref="System.Runtime.Serialization.SerializationInfo" qualify="true" /> object associated with the current <see cref="System.Collections.Hashtable" /> is invalid.</exception>
        <seealso cref="System.Runtime.Serialization.ISerializable" />
        <seealso cref="System.Collections.Hashtable.GetObjectData" />
    </doc>
</docs>
