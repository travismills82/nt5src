// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace System {
    
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.CompilerServices;

	// This class will not be marked serializable
    /// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator"]/*' />
	// TODO: put this back in [System.Runtime.CompilerServices.NotInGCHeap] 
	[StructLayout(LayoutKind.Auto)]
    public struct ArgIterator
    {
    	// create an arg iterator that points at the first argument that
    	// is not statically declared (that is the first ... arg)
    	// 'arglist' is the value returned by the ARGLIST instruction
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.ArgIterator"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public extern ArgIterator(RuntimeArgumentHandle arglist);
    
    	// create an arg iterator that points just past 'firstArg'.  
    	// 'arglist' is the value returned by the ARGLIST instruction
    	// This is much like the C va_start macro
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.ArgIterator1"]/*' />
		[MethodImplAttribute(MethodImplOptions.InternalCall), CLSCompliant(false)]
    	public unsafe extern ArgIterator(RuntimeArgumentHandle arglist, void* ptr);

    	// Fetch an argument as a typed referece, advance the iterator.
    	// Throws an exception if past end of argument list
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.GetNextArg"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall), CLSCompliant(false)]
    	public extern TypedReference GetNextArg();

        // Alternate version of GetNextArg() intended primarily for IJW code
        // generated by VC's "va_arg()" construct. 
        /// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.GetNextArg1"]/*' />
        [CLSCompliant(false)]
        public TypedReference GetNextArg(RuntimeTypeHandle rth)
        {
            if (SigPtr != 0)
            {
                // This is an ordinary ArgIterator capable of determining
                // types from a signature. Just do a regular GetNextArg.
                return GetNextArg();
            }
            else
            {
                return InternalGetNextArg(rth);
            }
        }


        [MethodImplAttribute(MethodImplOptions.InternalCall), CLSCompliant(false)]
        private extern TypedReference InternalGetNextArg(RuntimeTypeHandle rth);

    	// Invalidate the iterator (va_end)
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.End"]/*' />
    	public void End()
    	{
    		//@todo: Invalidate the iterator.
    	}
    
    	// How many arguments are left in the list 
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.GetRemainingCount"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public extern int GetRemainingCount();
    
    	// Gets the type of the current arg, does NOT advance the iterator
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.GetNextArgType"]/*' />
    	[MethodImplAttribute(MethodImplOptions.InternalCall)]
    	public extern RuntimeTypeHandle GetNextArgType();
    
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.GetHashCode"]/*' />
    	public override int GetHashCode()
    	{
    		return ArgCookie;
    	}
    
    	// Inherited from object
    	/// <include file='doc\ArgIterator.uex' path='docs/doc[@for="ArgIterator.Equals"]/*' />
    	public override bool Equals(Object o)
    	{
    		throw new NotSupportedException(Environment.GetResourceString("NotSupported_NYI"));
    	}
    
    	private int	ArgCookie;				// Cookie from the EE.
    	private int	SigPtr;					// Pointer to remaining signature.
    	private int	ArgPtr;					// Pointer to remaining args.
    	private int	RemainingArgs;			// # of remaining args.

		//
        // This is just designed to prevent compiler warnings.
        // This field is used from native, but we need to prevent the compiler warnings.
        //
#if _DEBUG
        private void DontTouchThis() {
			ArgCookie = 0;
			SigPtr = 0;
			ArgPtr = 0;
			RemainingArgs = 0;
		}
#endif
    }
}
