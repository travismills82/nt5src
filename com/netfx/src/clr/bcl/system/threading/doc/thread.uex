<docs>
	<doc for="Thread.Sleep1">
		<summary>
			<para> Blocks the current thread for a specified time. 
   </para>
		</summary>
		<param name="timeout">A <see cref="System.TimeSpan"/> set to the amount of time for which the thread is blocked. Specify zero to indicate that this thread should be suspended to allow other waiting threads to execute. Specify <see cref="System.Threading.Timeout.Infinite"/> to block the thread indefinitely. </param>
		<exception cref="System.ArgumentOutOfRangeException">The value of <paramref name="timeout"/> is negative and is not equal to <see cref="System.Threading.Timeout.Infinite" qualify="true"/> in milliseconds, or is greater than <see cref="System.Int32.MaxValue"/> milliseconds.</exception>
		<remarks>
			<para> The thread will not be scheduled for execution by the 
      operating system for the amount of time specified. This method changes the state
      of the thread to include <see cref="System.Threading.ThreadState.WaitSleepJoin"/>
      .
      </para>
		</remarks>
	</doc>
	<doc for="Thread.Name">
		<summary>
			<para> Gets or
      sets the name of
      the thread.
      </para>
		</summary>
		<value>
			<para> A string containing the name of the thread, or <see langword="null"/> 
if no name
was set.
</para>
		</value>
		<exception cref="System.InvalidOperationException">A set operation was requested, and the <see langword="Name"/> property has already been set.</exception>
		<remarks>
			<para>This property is write-once.</para>
		</remarks>
	</doc>
	<doc for="Thread.CurrentUICulture">
		<summary>
			<para>Gets or sets the current culture used by the Resource Manager to look up 
      culture-specific resources at run time.</para>
		</summary>
		<value>
			<para>A <see cref="System.Globalization.CultureInfo"/> representing the current culture.</para>
		</value>
		<exception cref="System.ArgumentNullException">The property value is <see langword="null"/>.</exception>
	</doc>
	<doc for="Thread.CurrentPrincipal">
		<summary>
			<para> Gets or sets the thread's current principal (for role-based
      security).
      </para>
		</summary>
		<value>
			<para>An <see cref="System.Security.Principal.IPrincipal"/> value representing the security context.</para>
		</value>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<permission cref="System.Security.Permissions.SecurityPermission">to manipulate the principal object. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" qualify="true"/>.</permission>
	</doc><doc for="Thread.GetDomain">
		<summary>
			<para> 
      Returns the current domain
      in which the current thread is running.
   </para>
		</summary>
		<returns>
			<para>An <see cref="System.AppDomain"/> representing the current application domain of the
   running thread.</para>
		</returns>
		<remarks>
			<para>The <see langword="get"/> and <see langword="set"/> accessors work on the hard 
   thread, not the logical thread. Therefore, they are package-protected and should
   not be available for general consumption.</para>
		</remarks>
	</doc><doc for="Thread.ApartmentState">
		<summary>
			<para> Gets or sets
      the apartment state of this thread.
      </para>
		</summary>
		<value>
			<para> One of the <see cref="System.Threading.ApartmentState"/> values. The initial value is
<see langword="Unknown"/>.
   </para>
		</value>
		<exception cref="System.ArgumentException">An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment ( <see langword="STA"/>) or multithreaded apartment ( <see langword="MTA"/>)). </exception>
		<remarks>
			<para> The <see langword="ApartmentState"/> property marks a thread to indicate that it will execute
   in a single-threaded or multithreaded apartment. This property can be set when
   the thread is in the <see langword="Unstarted"/> or <see langword="Running"/> thread state; however,
   it can be set only once for a thread. If the property has not been set, it
   returns <see langword="Unknown"/>
   .
   </para>
		</remarks>
		<seealso cref="System.Threading.ThreadState"/>
	</doc>
	<doc for="Thread.CurrentThread">
		<summary>
			<para> Gets the currently running thread.
      </para>
		</summary>
		<value>
			<para> A <see cref="System.Threading.Thread"/> that is 
   the representation of the currently
   running thread.</para>
		</value>
	</doc>
	<doc for="Thread.SpinWait">
		<summary>
			<para>Causes a thread to wait the number of
      times defined by the <paramref name="iterations"/> parameter.</para>
		</summary>
		<param name="iterations">A 32-bit signed integer that defines how long a thread is to wait.</param>
	</doc>
	<doc for="Thread.GetDomainID">
		<summary>
			<para>Returns a unique application domain identifier.</para>
		</summary>
		<returns>
			<para>A 32-bit signed integer uniquely identifying the application domain.</para>
		</returns>
	</doc>
	<doc for="Thread.Finalize">
		<summary>
			<para> Releases the resources held by this instance.
      </para>
		</summary>
		<remarks>
			<para>Application code does not call this method; it is automatically invoked
      during garbage collection.</para>
			<para>See <see topic="cpconprogrammingessentialsforgarbagecollection"/> for more information.</para>
		</remarks>
	</doc><doc for="Thread.SetCompressedStack">
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc>
	<doc for="Thread.GetCompressedStack">
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc>
	<doc for="Thread.IsAlive">
		<summary>
			<para> Gets a value
      indicating the execution status of the current thread.
      </para>
		</summary>
		<value>
			<para><see langword="true"/> if this thread has been started
   and has not terminated normally or aborted; otherwise,
<see langword="false"/>
.</para>
		</value>
	</doc>
	<doc for="Thread.CurrentCulture">
		<summary>
			<para>Gets or sets the culture for the
      current thread.</para>
		</summary>
		<value>
			<para>A <see cref="System.Globalization.CultureInfo"/> representing the culture for the current thread.</para>
		</value>
		<permission cref="System.Security.Permissions.SecurityPermission">for setting the property. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlThread" qualify="true"/></permission>
	</doc>
	<doc for="Thread.IsThreadPoolThread">
		<summary>
			<para>Gets a value indicating whether or not a thread belongs
      to the managed thread pool.</para>
		</summary>
		<value>
			<para><see langword="true"/> if this thread belongs to the 
   managed thread pool; otherwise, <see langword="false"/>.</para>
		</value>
	</doc>
	<doc for="Thread.VolatileRead">
		<overload>
			<para>Reads the value of a field. The value is the latest written by any processor 
      in a computer, regardless of the number of processors or the state of processor
      cache.</para>
		</overload>
		<summary>
			<para>Reads the value of a field. The value is the latest 
      written by any processor in a computer, regardless of the number of processors
      or the state of processor cache.</para>
		</summary>
		<param name="address">The field to be read.</param>
		<returns>
			<para>The latest value written to the field by any processor.</para>
		</returns>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of synchronization. 
   Under normal circumstances, the C# <see langword="lock"/> statement, the Visual
   Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/>
   class provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> obtains the very latest value 
written to a memory location by any processor. This might require flushing
processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a 
value is read or written to memory, and not cached (for example, in a processor
register). Thus, you can use them to synchronize access to a field that can be
updated by another thread, or by hardware. </para>
			<para>Calling this method affects only a single memory access. 
   To provide effective synchronization for a field, all access to the field must
   use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all 
   access to that field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileRead1">
		<summary>
			<para>Reads the value of a field. The value is the latest written by any processor 
      in a computer, regardless of the number of processors or the state of processor
      cache.</para>
		</summary>
		<param name="address">The field to be read.</param>
		<returns>
			<para>The latest value written to the field by any processor.</para>
		</returns>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of synchronization. 
   Under normal circumstances, the C# <see langword="lock"/> statement, the Visual
   Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/>
   class provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> obtains the very latest value 
written to a memory location by any processor. This might require flushing
processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a 
value is read or written to memory, and not cached (for example, in a processor
register). Thus, you can use them to synchronize access to a field that can be
updated by another thread, or by hardware. </para>
			<para>Calling this method affects only a single memory access. 
   To provide effective synchronization for a field, all access to the field must
   use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all 
   access to that field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileRead2">
		<summary>
			<para>Reads the value of a field. The value is the latest written by any processor 
      in a computer, regardless of the number of processors or the state of processor
      cache.</para>
		</summary>
		<param name="address">The field to be read.</param>
		<returns>
			<para>The latest value written to the field by any processor.</para>
		</returns>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of synchronization. 
   Under normal circumstances, the C# <see langword="lock"/> statement, the Visual
   Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/>
   class provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> obtains the very latest value 
written to a memory location by any processor. This might require flushing
processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a 
value is read or written to memory, and not cached (for example, in a processor
register). Thus, you can use them to synchronize access to a field that can be
updated by another thread, or by hardware. </para>
			<para>Calling this method affects only a single memory access. 
   To provide effective synchronization for a field, all access to the field must
   use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all 
   access to that field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileRead3">
		<summary>
			<para>Reads the value of a field. The value is the latest written by any processor 
      in a computer, regardless of the number of processors or the state of processor
      cache.</para>
		</summary>
		<param name="address">The field to be read.</param>
		<returns>
			<para>The latest value written to the field by any processor.</para>
		</returns>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of synchronization. 
   Under normal circumstances, the C# <see langword="lock"/> statement, the Visual
   Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/>
   class provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> obtains the very latest value 
written to a memory location by any processor. This might require flushing
processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a 
value is read or written to memory, and not cached (for example, in a processor
register). Thus, you can use them to synchronize access to a field that can be
updated by another thread, or by hardware. </para>
			<para>Calling this method affects only a single memory access. 
   To provide effective synchronization for a field, all access to the field must
   use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all 
   access to that field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileRead4">
		<summary>
			<para>Reads the value of a field. The value is the latest written by any processor 
      in a computer, regardless of the number of processors or the state of processor
      cache.</para>
		</summary>
		<param name="address">The field to be read.</param>
		<returns>
			<para>The latest value written to the field by any processor.</para>
		</returns>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of synchronization. 
   Under normal circumstances, the C# <see langword="lock"/> statement, the Visual
   Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/>
   class provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> obtains the very latest value 
written to a memory location by any processor. This might require flushing
processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a 
value is read or written to memory, and not cached (for example, in a processor
register). Thus, you can use them to synchronize access to a field that can be
updated by another thread, or by hardware. </para>
			<para>Calling this method affects only a single memory access. 
   To provide effective synchronization for a field, all access to the field must
   use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all 
   access to that field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileRead5">
		<summary>
			<para>Reads the value of a field. The value is the latest written by any processor 
      in a computer, regardless of the number of processors or the state of processor
      cache.</para>
		</summary>
		<param name="address">The field to be read.</param>
		<returns>
			<para>The latest value written to the field by any processor.</para>
		</returns>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of synchronization. 
   Under normal circumstances, the C# <see langword="lock"/> statement, the Visual
   Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/>
   class provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> obtains the very latest value 
written to a memory location by any processor. This might require flushing
processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a 
value is read or written to memory, and not cached (for example, in a processor
register). Thus, you can use them to synchronize access to a field that can be
updated by another thread, or by hardware. </para>
			<para>Calling this method affects only a single memory access. 
   To provide effective synchronization for a field, all access to the field must
   use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all 
   access to that field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileRead6">
		<summary>
			<para>Reads the value of a field. The value is the latest written by any processor 
      in a computer, regardless of the number of processors or the state of processor
      cache.</para>
		</summary>
		<param name="address">The field to be read.</param>
		<returns>
			<para>The latest value written to the field by any processor.</para>
		</returns>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of synchronization. 
   Under normal circumstances, the C# <see langword="lock"/> statement, the Visual
   Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/>
   class provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> obtains the very latest value 
written to a memory location by any processor. This might require flushing
processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a 
value is read or written to memory, and not cached (for example, in a processor
register). Thus, you can use them to synchronize access to a field that can be
updated by another thread, or by hardware. </para>
			<para>Calling this method affects only a single memory access. 
   To provide effective synchronization for a field, all access to the field must
   use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all 
   access to that field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileRead7">
		<summary>
			<para>Reads the value of a field. The value is the latest written by any processor 
      in a computer, regardless of the number of processors or the state of processor
      cache.</para>
		</summary>
		<param name="address">The field to be read.</param>
		<returns>
			<para>The latest value written to the field by any processor.</para>
		</returns>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of synchronization. 
   Under normal circumstances, the C# <see langword="lock"/> statement, the Visual
   Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/>
   class provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> obtains the very latest value 
written to a memory location by any processor. This might require flushing
processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a 
value is read or written to memory, and not cached (for example, in a processor
register). Thus, you can use them to synchronize access to a field that can be
updated by another thread, or by hardware. </para>
			<para>Calling this method affects only a single memory access. 
   To provide effective synchronization for a field, all access to the field must
   use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all 
   access to that field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileRead8">
		<summary>
			<para>Reads the value of a field. The value is the latest written by any processor 
      in a computer, regardless of the number of processors or the state of processor
      cache.</para>
		</summary>
		<param name="address">The field to be read.</param>
		<returns>
			<para>The latest value written to the field by any processor.</para>
		</returns>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of synchronization. 
   Under normal circumstances, the C# <see langword="lock"/> statement, the Visual
   Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/>
   class provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> obtains the very latest value 
written to a memory location by any processor. This might require flushing
processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a 
value is read or written to memory, and not cached (for example, in a processor
register). Thus, you can use them to synchronize access to a field that can be
updated by another thread, or by hardware. </para>
			<para>Calling this method affects only a single memory access. 
   To provide effective synchronization for a field, all access to the field must
   use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all 
   access to that field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileRead9">
		<summary>
			<para>Reads the value of a field. The value is the latest written by any processor 
      in a computer, regardless of the number of processors or the state of processor
      cache.</para>
		</summary>
		<param name="address">The field to be read.</param>
		<returns>
			<para>The latest value written to the field by any processor.</para>
		</returns>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of synchronization. 
   Under normal circumstances, the C# <see langword="lock"/> statement, the Visual
   Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/>
   class provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> obtains the very latest value 
written to a memory location by any processor. This might require flushing
processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a 
value is read or written to memory, and not cached (for example, in a processor
register). Thus, you can use them to synchronize access to a field that can be
updated by another thread, or by hardware. </para>
			<para>Calling this method affects only a single memory access. 
   To provide effective synchronization for a field, all access to the field must
   use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all 
   access to that field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileRead10">
		<summary>
			<para>Reads the value of a field. The value is the latest written by any processor 
      in a computer, regardless of the number of processors or the state of processor
      cache.</para>
		</summary>
		<param name="address">The field to be read.</param>
		<returns>
			<para>The latest value written to the field by any processor.</para>
		</returns>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of synchronization. 
   Under normal circumstances, the C# <see langword="lock"/> statement, the Visual
   Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/>
   class provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> obtains the very latest value 
written to a memory location by any processor. This might require flushing
processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a 
value is read or written to memory, and not cached (for example, in a processor
register). Thus, you can use them to synchronize access to a field that can be
updated by another thread, or by hardware. </para>
			<para>Calling this method affects only a single memory access. 
   To provide effective synchronization for a field, all access to the field must
   use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all 
   access to that field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileRead11">
		<summary>
			<para>Reads the value of a field. The value is the latest written by any processor 
      in a computer, regardless of the number of processors or the state of processor
      cache.</para>
		</summary>
		<param name="address">The field to be read.</param>
		<returns>
			<para>The latest value written to the field by any processor.</para>
		</returns>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of synchronization. 
   Under normal circumstances, the C# <see langword="lock"/> statement, the Visual
   Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/>
   class provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> obtains the very latest value 
written to a memory location by any processor. This might require flushing
processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a 
value is read or written to memory, and not cached (for example, in a processor
register). Thus, you can use them to synchronize access to a field that can be
updated by another thread, or by hardware. </para>
			<para>Calling this method affects only a single memory access. 
   To provide effective synchronization for a field, all access to the field must
   use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all 
   access to that field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileRead12">
		<summary>
			<para>Reads the value of a field. The value is the latest written by any processor 
      in a computer, regardless of the number of processors or the state of processor
      cache.</para>
		</summary>
		<param name="address">The field to be read.</param>
		<returns>
			<para>The latest value written to the field by any processor.</para>
		</returns>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of synchronization. 
   Under normal circumstances, the C# <see langword="lock"/> statement, the Visual
   Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/>
   class provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> obtains the very latest value 
written to a memory location by any processor. This might require flushing
processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a 
value is read or written to memory, and not cached (for example, in a processor
register). Thus, you can use them to synchronize access to a field that can be
updated by another thread, or by hardware. </para>
			<para>Calling this method affects only a single memory access. 
   To provide effective synchronization for a field, all access to the field must
   use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all 
   access to that field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileWrite">
		<overload>
			<para>Writes a value to a field immediately, so that the value is visible to all 
      processors in the computer.</para>
		</overload>
		<summary>
			<para>Writes a value to a field immediately, so that the value 
      is visible to all processors in the computer.</para>
		</summary>
		<param name="address">The field to which the value is to be written.</param>
		<param name=" value">The value to be written.</param>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of 
   synchronization. Under normal circumstances, the C# <see langword="lock"/>
   statement, the Visual Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/> class
   provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileWrite"/> ensures that a value written to a 
memory location is immediately visible to all processors. This might
require flushing processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a value is read or written 
to memory, and not cached (for example, in a processor register). Thus, you can
use them to synchronize access to a field that can be updated by another thread,
or by hardware. </para>
			<para>Calling this method affects only a single memory access. To provide effective 
   synchronization for a field, all access to the field must use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all access to that 
   field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileWrite1">
		<summary>
			<para>Writes a value to a field immediately, so that the value 
      is visible to all processors in the computer.</para>
		</summary>
		<param name="address">The field to which the value is to be written.</param>
		<param name=" value">The value to be written.</param>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of 
   synchronization. Under normal circumstances, the C# <see langword="lock"/>
   statement, the Visual Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/> class
   provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileWrite"/> ensures that a value written to a 
memory location is immediately visible to all processors. This might
require flushing processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a value is read or written 
to memory, and not cached (for example, in a processor register). Thus, you can
use them to synchronize access to a field that can be updated by another thread,
or by hardware. </para>
			<para>Calling this method affects only a single memory access. To provide effective 
   synchronization for a field, all access to the field must use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all access to that 
   field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileWrite2">
		<summary>
			<para>Writes a value to a field immediately, so that the value 
      is visible to all processors in the computer.</para>
		</summary>
		<param name="address">The field to which the value is to be written.</param>
		<param name=" value">The value to be written.</param>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of 
   synchronization. Under normal circumstances, the C# <see langword="lock"/>
   statement, the Visual Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/> class
   provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileWrite"/> ensures that a value written to a 
memory location is immediately visible to all processors. This might
require flushing processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a value is read or written 
to memory, and not cached (for example, in a processor register). Thus, you can
use them to synchronize access to a field that can be updated by another thread,
or by hardware. </para>
			<para>Calling this method affects only a single memory access. To provide effective 
   synchronization for a field, all access to the field must use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all access to that 
   field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileWrite3">
		<summary>
			<para>Writes a value to a field immediately, so that the value 
      is visible to all processors in the computer.</para>
		</summary>
		<param name="address">The field to which the value is to be written.</param>
		<param name=" value">The value to be written.</param>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of 
   synchronization. Under normal circumstances, the C# <see langword="lock"/>
   statement, the Visual Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/> class
   provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileWrite"/> ensures that a value written to a 
memory location is immediately visible to all processors. This might
require flushing processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a value is read or written 
to memory, and not cached (for example, in a processor register). Thus, you can
use them to synchronize access to a field that can be updated by another thread,
or by hardware. </para>
			<para>Calling this method affects only a single memory access. To provide effective 
   synchronization for a field, all access to the field must use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all access to that 
   field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileWrite4">
		<summary>
			<para>Writes a value to a field immediately, so that the value 
      is visible to all processors in the computer.</para>
		</summary>
		<param name="address">The field to which the value is to be written.</param>
		<param name=" value">The value to be written.</param>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of 
   synchronization. Under normal circumstances, the C# <see langword="lock"/>
   statement, the Visual Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/> class
   provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileWrite"/> ensures that a value written to a 
memory location is immediately visible to all processors. This might
require flushing processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a value is read or written 
to memory, and not cached (for example, in a processor register). Thus, you can
use them to synchronize access to a field that can be updated by another thread,
or by hardware. </para>
			<para>Calling this method affects only a single memory access. To provide effective 
   synchronization for a field, all access to the field must use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all access to that 
   field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileWrite5">
		<summary>
			<para>Writes a value to a field immediately, so that the value 
      is visible to all processors in the computer.</para>
		</summary>
		<param name="address">The field to which the value is to be written.</param>
		<param name=" value">The value to be written.</param>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of 
   synchronization. Under normal circumstances, the C# <see langword="lock"/>
   statement, the Visual Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/> class
   provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileWrite"/> ensures that a value written to a 
memory location is immediately visible to all processors. This might
require flushing processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a value is read or written 
to memory, and not cached (for example, in a processor register). Thus, you can
use them to synchronize access to a field that can be updated by another thread,
or by hardware. </para>
			<para>Calling this method affects only a single memory access. To provide effective 
   synchronization for a field, all access to the field must use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all access to that 
   field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileWrite6">
		<summary>
			<para>Writes a value to a field immediately, so that the value 
      is visible to all processors in the computer.</para>
		</summary>
		<param name="address">The field to which the value is to be written.</param>
		<param name=" value">The value to be written.</param>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of 
   synchronization. Under normal circumstances, the C# <see langword="lock"/>
   statement, the Visual Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/> class
   provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileWrite"/> ensures that a value written to a 
memory location is immediately visible to all processors. This might
require flushing processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a value is read or written 
to memory, and not cached (for example, in a processor register). Thus, you can
use them to synchronize access to a field that can be updated by another thread,
or by hardware. </para>
			<para>Calling this method affects only a single memory access. To provide effective 
   synchronization for a field, all access to the field must use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all access to that 
   field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileWrite7">
		<summary>
			<para>Writes a value to a field immediately, so that the value 
      is visible to all processors in the computer.</para>
		</summary>
		<param name="address">The field to which the value is to be written.</param>
		<param name=" value">The value to be written.</param>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of 
   synchronization. Under normal circumstances, the C# <see langword="lock"/>
   statement, the Visual Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/> class
   provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileWrite"/> ensures that a value written to a 
memory location is immediately visible to all processors. This might
require flushing processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a value is read or written 
to memory, and not cached (for example, in a processor register). Thus, you can
use them to synchronize access to a field that can be updated by another thread,
or by hardware. </para>
			<para>Calling this method affects only a single memory access. To provide effective 
   synchronization for a field, all access to the field must use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all access to that 
   field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileWrite8">
		<summary>
			<para>Writes a value to a field immediately, so that the value 
      is visible to all processors in the computer.</para>
		</summary>
		<param name="address">The field to which the value is to be written.</param>
		<param name=" value">The value to be written.</param>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of 
   synchronization. Under normal circumstances, the C# <see langword="lock"/>
   statement, the Visual Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/> class
   provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileWrite"/> ensures that a value written to a 
memory location is immediately visible to all processors. This might
require flushing processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a value is read or written 
to memory, and not cached (for example, in a processor register). Thus, you can
use them to synchronize access to a field that can be updated by another thread,
or by hardware. </para>
			<para>Calling this method affects only a single memory access. To provide effective 
   synchronization for a field, all access to the field must use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all access to that 
   field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileWrite9">
		<summary>
			<para>Writes a value to a field immediately, so that the value 
      is visible to all processors in the computer.</para>
		</summary>
		<param name="address">The field to which the value is to be written.</param>
		<param name=" value">The value to be written.</param>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of 
   synchronization. Under normal circumstances, the C# <see langword="lock"/>
   statement, the Visual Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/> class
   provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileWrite"/> ensures that a value written to a 
memory location is immediately visible to all processors. This might
require flushing processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a value is read or written 
to memory, and not cached (for example, in a processor register). Thus, you can
use them to synchronize access to a field that can be updated by another thread,
or by hardware. </para>
			<para>Calling this method affects only a single memory access. To provide effective 
   synchronization for a field, all access to the field must use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all access to that 
   field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileWrite10">
		<summary>
			<para>Writes a value to a field immediately, so that the value 
      is visible to all processors in the computer.</para>
		</summary>
		<param name="address">The field to which the value is to be written.</param>
		<param name=" value">The value to be written.</param>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of 
   synchronization. Under normal circumstances, the C# <see langword="lock"/>
   statement, the Visual Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/> class
   provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileWrite"/> ensures that a value written to a 
memory location is immediately visible to all processors. This might
require flushing processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a value is read or written 
to memory, and not cached (for example, in a processor register). Thus, you can
use them to synchronize access to a field that can be updated by another thread,
or by hardware. </para>
			<para>Calling this method affects only a single memory access. To provide effective 
   synchronization for a field, all access to the field must use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all access to that 
   field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileWrite11">
		<summary>
			<para>Writes a value to a field immediately, so that the value 
      is visible to all processors in the computer.</para>
		</summary>
		<param name="address">The field to which the value is to be written.</param>
		<param name=" value">The value to be written.</param>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of 
   synchronization. Under normal circumstances, the C# <see langword="lock"/>
   statement, the Visual Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/> class
   provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileWrite"/> ensures that a value written to a 
memory location is immediately visible to all processors. This might
require flushing processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a value is read or written 
to memory, and not cached (for example, in a processor register). Thus, you can
use them to synchronize access to a field that can be updated by another thread,
or by hardware. </para>
			<para>Calling this method affects only a single memory access. To provide effective 
   synchronization for a field, all access to the field must use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all access to that 
   field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.VolatileWrite12">
		<summary>
			<para>Writes a value to a field immediately, so that the value 
      is visible to all processors in the computer.</para>
		</summary>
		<param name="address">The field to which the value is to be written.</param>
		<param name=" value">The value to be written.</param>
		<remarks>
			<para><see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> are for special cases of 
   synchronization. Under normal circumstances, the C# <see langword="lock"/>
   statement, the Visual Basic <see langword="SyncLock"/> statement, and the <see cref="System.Threading.Monitor"/> class
   provide easier alternatives.</para>
			<para>On a multiprocessor system, <see cref="System.Threading.Thread.VolatileWrite"/> ensures that a value written to a 
memory location is immediately visible to all processors. This might
require flushing processor caches.</para>
			<para>Even on a uniprocessor system, <see cref="System.Threading.Thread.VolatileRead"/> and <see cref="System.Threading.Thread.VolatileWrite"/> ensure that a value is read or written 
to memory, and not cached (for example, in a processor register). Thus, you can
use them to synchronize access to a field that can be updated by another thread,
or by hardware. </para>
			<para>Calling this method affects only a single memory access. To provide effective 
   synchronization for a field, all access to the field must use <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>. </para>
			<note type="note">
   In C#, using the
<see langword="volatile"/> modifier on a field guarantees that all access to that 
   field uses <see cref="System.Threading.Thread.VolatileRead"/> or <see cref="System.Threading.Thread.VolatileWrite"/>.
</note>
		</remarks>
	</doc>
	<doc for="Thread.MemoryBarrier">
		<summary>
			<para>Synchronizes memory. In effect, flushes the contents of 
      cache memory to main memory, for the processor executing the current thread.</para>
		</summary>
		<remarks>
			<para><see cref="System.Threading.Thread.MemoryBarrier"/> is required only on multiprocessor 
   systems with weak memory ordering (for example, a system employing multiple
   Intel Itanium processors).</para>
			<para>For most purposes, the C# <see langword="lock"/> statement, the Visual Basic 
<see langword="SyncLock"/> statement, or the <see cref="System.Threading.Monitor"/> class provide easier ways to 
synchronize data. </para>
		</remarks>
	</doc>
	<doc for="Thread.Start">
		<summary>
			<para> Causes the operating system to change the state of the
      current instance to <see cref="System.Threading.ThreadState.Running" qualify="true"/>
      . </para>
		</summary>
		<exception cref="System.Threading.ThreadStateException">The thread has already been started. </exception>
		<exception cref="System.Security.SecurityException">The caller does not have the appropriate <see cref="System.Security.Permissions.SecurityPermission"/> . </exception>
		<exception cref="System.OutOfMemoryException">There is not enough memory available to start this thread.</exception>
		<exception cref="System.NullReferenceException">This method was invoked on a thread reference that is <see langword="null"/>.</exception>
		<remarks>
			<para> Once a thread is in the <see langword="Running"/> state,
   the operating system can schedule it for execution. When the thread begins
   executing, the <see cref="System.Threading.ThreadStart"/> delegate supplied to the constructor for the
   thread invokes its
   methods.
   </para>
			<para> Once the thread terminates, it cannot be restarted with
   another call to <see langword="Start"/>
   .
   </para>
		</remarks>
		<example>
			<para>The following example demonstrates creating a thread and
      starting it.</para>
			<para>This code produces the following output:</para>
			<codelink SampleID="ThreadStart" SnippetID="1"/>
			<code>
    In main.
    Working thread...
    In main. Working thread...
    In main.
    Working thread...
   </code>
			<para>Note that the sequence of the output statements is
   typical, but is not guaranteed to be identical across systems.</para>
		</example>
		<seealso topic="cpconCreatingThreads"/>
	</doc>
	<doc for="Thread.ResetAbort">
		<summary>
			<para> Cancels an <see cref="System.Threading.Thread.Abort"/> requested for the current
   thread.</para>
		</summary>
		<exception cref="System.Threading.ThreadStateException"><see langword="Abort"/> was not invoked on the current thread.</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required security permission for the current thread.</exception>
		<remarks>
			<para> This method can only be called by code with the proper
      permissions. For more information see <see topic="cpconMakingSecurityDemands"/>
      .
      </para>
			<para> When a call is made to <see langword="Abort"/> to
   terminate a thread, the system throws a <see cref="System.Threading.ThreadAbortException"/>. <see langword="ThreadAbortException"/> is a
   special exception that can be caught by application code, but is rethrown at the
   end of the catch block unless <see langword="ResetAbort"/> is called.
<see langword="ResetAbort"/> cancels the request to abort, and prevents the 
<see langword="ThreadAbortException"/> from terminating the thread. </para>
			<para>See <see cref="System.Threading.ThreadAbortException"/> for an example that demonstrates calling the
<see langword="ResetAbort"/> method.</para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermissionAttribute">for advanced operations on threads. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlThread" qualify="true"/>.</permission>
		<seealso topic="cpconDestroyingThreads"/>
		<seealso topic="cpconThreadActivityStates"/>
	</doc>
	<doc for="Thread.Suspend">
		<summary>
			<para> Either suspends the thread, or if the thread is already
      suspended, has no effect.
      </para>
		</summary>
		<exception cref="System.Threading.ThreadStateException">The thread has not been started or is dead. </exception>
		<exception cref="System.Security.SecurityException">The caller does not have the appropriate <see cref="System.Security.Permissions.SecurityPermission"/> . </exception>
		<remarks>
			<para> If the thread is already suspended, this method has no effect.
      </para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermissionAttribute">for advanced operations on threads. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlThread" qualify="true"/>.</permission>
		<seealso topic="cpconWorkingWithThreads"/>
		<seealso topic="cpconThreadActivityStates"/>
	</doc>
	<doc for="Thread.Resume">
		<summary>
			<para> Resumes a thread that has been suspended.
      </para>
		</summary>
		<exception cref="System.Threading.ThreadStateException">The thread has not been started, is dead, or is not in the suspended state. </exception>
		<exception cref="System.Security.SecurityException">The caller does not have the appropriate <see cref="System.Security.Permissions.SecurityPermission"/> . </exception>
		<permission cref="System.Security.Permissions.SecurityPermissionAttribute">for advanced operations on threads. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlThread" qualify="true"/>.</permission>
		<seealso topic="cpconWorkingWithThreads"/>
		<seealso topic="cpconThreadActivityStates"/>
	</doc>
	<doc for="Thread.Interrupt">
		<summary>
			<para> Interrupts a thread that is in the
   <see langword="WaitSleepJoin"/> thread
      state.
      </para>
		</summary>
		<exception cref="System.Security.SecurityException">The caller does not have the appropriate <see cref="System.Security.Permissions.SecurityPermission"/> . </exception>
		<remarks>
			<para> If this thread is not currently blocked in a wait, sleep, or join
      state, it will be interrupted when it next begins to block.
      </para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermissionAttribute">for advanced operations on threads. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlThread" qualify="true"/>.</permission>
		<seealso cref="System.Threading.ThreadState"/>
		<seealso topic="cpconWorkingWithThreads"/>
		<seealso topic="cpconThreadActivityStates"/>
	</doc>
	<doc for="Thread.Priority">
		<summary>
			<para> Gets or sets a value indicating
      the scheduling priority of a thread.
      </para>
		</summary>
		<value>
			<para> One of the <see cref="System.Threading.ThreadPriority"/> values. The default value is
<see langword="Normal"/>.
   </para>
		</value>
		<exception cref="System.Threading.ThreadStateException">The thread has reached a final state, such as <see cref="System.Threading.ThreadState.Aborted"/> . </exception>
		<exception cref="System.ArgumentException">The value specified for a set operation is not a valid <see langword="ThreadPriority"/> value. </exception>
		<remarks>
			<para>A thread can be assigned any one of the following
      priority values:</para>
			<list type="bullet"><item>
					<term><see langword="Highest"/></term>
				</item>
				<item>
					<term><see langword="AboveNormal"/></term>
				</item>
				<item>
					<term><see langword="Normal"/></term>
				</item>
				<item>
					<term><see langword="BelowNormal"/></term>
				</item>
				<item>
					<term><see langword="Lowest"/></term>
				</item>
			</list>
			<para> Operating systems are not required to honor the
   priority of a thread.</para>
		</remarks>
		<seealso cref="System.Threading.ThreadPriority"/>
		<seealso topic="cpconSchedulingThreads"/>
	</doc>
	<doc for="Thread.Join">
		<overload>
			<para> Blocks the calling thread until a thread terminates.
      </para>
		</overload>
		<summary>
			<para> Blocks the calling thread until
      a thread terminates.
      </para>
		</summary>
		<exception cref="System.Threading.ThreadStateException">The caller attempted to join a thread that is in the <see cref="System.Threading.ThreadState.Unstarted" qualify="true"/> state. </exception>
		<exception cref="System.Threading.ThreadInterruptedException">The thread is interrupted while waiting. </exception>
		<remarks>
			<para>Use this method to ensure a thread has terminated. The caller will block
      indefinitely if the thread does not terminate.</para>
			<para>This method changes the state of the calling thread to include <see cref="System.Threading.ThreadState.WaitSleepJoin" qualify="true"/>. You cannot invoke <see langword="Join"/> on a
   thread that is in the <see cref="System.Threading.ThreadState.Unstarted" qualify="true"/> state.</para>
		</remarks>
		<seealso topic="cpconThreadActivityStates"/>
	</doc>
	<doc for="Thread.Join1">
		<summary>
			<para> Blocks the calling thread until a thread terminates or the specified time elapses.
      </para>
		</summary>
		<param name="millisecondsTimeout">The number of milliseconds to wait for the thread to terminate. </param>
		<returns>
			<para><see langword="true "/>if the thread has terminated; <see langword="false "/>if the thread has
   not terminated after the amount of time
   specified by the <paramref name="millisecondsTimeout"/> parameter
   has elapsed.
   </para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException">The value of <paramref name="millisecondsTimeout"/> is negative and is not equal to <see cref="System.Threading.Timeout.Infinite" qualify="true"/> in milliseconds. </exception>
		<exception cref="System.Threading.ThreadStateException">The thread has not been started. </exception>
		<remarks>
			<para>If <see cref="System.Threading.Timeout.Infinite" qualify="true"/> is specified for the <paramref name="millisecondsTimeout"/> parameter,
   this method behaves identically to <see topic="frlrfSystemThreadingThreadClassJoinTopic1" title="Join()"/>, except for the return value.</para>
			<para>This method changes the state of the calling thread to include <see cref="System.Threading.ThreadState.WaitSleepJoin" qualify="true"/>. You cannot invoke
<see langword="Join"/> on a thread that is in the <see cref="System.Threading.ThreadState.Unstarted" qualify="true"/> state.</para>
		</remarks>
		<seealso topic="cpconThreadActivityStates"/>
	</doc>
	<doc for="Thread.Join2">
		<summary>
			<para> Blocks the calling thread until a thread terminates or the specified time
      elapses.
      </para>
		</summary>
		<param name="timeout">A <see cref="System.TimeSpan"/> set to the amount of time to wait for the thread to terminate. </param>
		<returns>
			<para><see langword="true"/> if the thread terminated; <see langword="false"/> if the thread has not terminated
   after the amount of time specified by the <paramref name="timeout"/> parameter
   has elapsed.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException">The value of <paramref name="timeout"/> is negative and is not equal to <see cref="System.Threading.Timeout.Infinite" qualify="true"/> in milliseconds, or is greater than <see cref="System.Int32.MaxValue"/> milliseconds. </exception>
		<exception cref="System.Threading.ThreadStateException">The caller attempted to join a thread that is in the <see cref="System.Threading.ThreadState.Unstarted"/> state. </exception>
		<remarks>
			<para>If <see cref="System.Threading.Timeout.Infinite" qualify="true"/> is specified for <paramref name="timeout"/>, this
   method behaves identically to
<see topic="frlrfSystemThreadingThreadClassJoinTopic1" title="Join()"/>, except for the return value.</para>
			<para>This method changes the state of the current thread to include <see cref="System.Threading.ThreadState.WaitSleepJoin"/>. You
cannot invoke <see langword="Join"/> on a thread that is in the <see cref="System.Threading.ThreadState.Unstarted" qualify="true"/> state.</para>
		</remarks>
		<seealso topic="cpconThreadActivityStates"/>
	</doc>
	<doc for="Thread.AllocateDataSlot">
		<summary>
			<para> Allocates an unnamed data
      slot on all
      the threads.
      </para>
		</summary>
		<returns>
			<para>A <see cref="System.LocalDataStoreSlot"/> . </para>
		</returns>
		<remarks>
			<para> The slot
      is allocated on all threads.
      </para>
			<para>Threads use a local store memory mechanism to store
      thread-specific data. The common language runtime allocates a multi-slot data
      store array to each process when it is created. The thread can allocate a data
      slot in the data store, store and retrieve a data value in the slot, and free
      the slot for reuse after the thread expires. Data slots are unique per thread. No other thread
      (not even a child thread) can get that data.</para>
		</remarks>
		<seealso topic="cpconThreadsThreading"/>
		<seealso topic="cpconThread-LocalStorageThread-RelativeStaticFields"/>
	</doc>
	<doc for="Thread.AllocateNamedDataSlot">
		<summary>
			<para> Allocates a
      named data slot on all threads.
      </para>
		</summary>
		<param name="name">The name of the data slot to be allocated. </param>
		<returns>
			<para>A <see cref="System.LocalDataStoreSlot"/> .</para>
		</returns>
		<remarks>
			<para> Threads use a local store memory mechanism to store
      thread-specific data. The common language runtime allocates a multi-slot data
      store array to each process when it is created. The thread can allocate a data
      slot in the data store, store and retrieve a data value in the slot, and free
      the slot for reuse after the thread expires. Data slots are unique per
      thread. No other thread (not even a child thread) can get that
      data.
      </para>
			<para> Slots allocated with this method must be freed with
      <see cref="System.Threading.Thread.FreeNamedDataSlot"/> . </para>
		</remarks>
		<seealso topic="cpconThreadsThreading"/>
		<seealso topic="cpconThread-LocalStorageThread-RelativeStaticFields"/>
	</doc>
	<doc for="Thread.GetNamedDataSlot">
		<summary>
			<para> Looks up a named data slot.
      </para>
		</summary>
		<param name="name">The name of the local data slot.</param>
		<returns>
			<para>A <see cref="System.LocalDataStoreSlot"/> allocated for this
   thread.</para>
		</returns>
		<remarks>
			<para>Threads use a local store memory mechanism to store thread-specific data. The
      common language runtime allocates a multi-slot data store array to each process
      when it is created. The thread can allocate a data slot in the data store, store
      and retrieve a data value in the slot, and free the slot for reuse after the
      thread expires. Data slots are unique per thread. No other thread (not even a
      child thread) can get that data.</para>
			<para>If the named slot does not exist, a new slot is allocated. Named data slots
      are public and can be manipulated by anyone. </para>
		</remarks>
		<seealso topic="cpconThreadsThreading"/>
		<seealso topic="cpconThread-LocalStorageThread-RelativeStaticFields"/>
	</doc>
	<doc for="Thread.FreeNamedDataSlot">
		<summary>
			<para> Eliminates the association between a name and a slot,
      for all threads in the process.
      </para>
		</summary>
		<param name="name">The name of the data slot to be freed. </param>
		<remarks>
			<para> After any thread calls
      <see langword="FreeNamedDataSlot"/>, any other thread that calls <see cref="System.Threading.Thread.GetNamedDataSlot"/> with the same name will allocate a new slot
      associated with the name. Subsequent calls
      to <see langword="GetNamedDataSlot"/> by any thread will return
      the new slot. However, any thread that still has a <see cref="System.LocalDataStoreSlot" qualify="true"/> returned by an earlier call
      to <see langword="GetNamedDataSlot"/>
      can continue to use the old slot.
      </para>
			<para>A slot that has been associated with a name is released only when
      every <see langword="LocalDataStoreSlot"/> that was obtained prior to the
      call to <see langword="FreeNamedDataSlot"/> has been released and
      garbage-collected.</para>
			<para>Threads use a local store memory mechanism to store thread-specific data. The
      common language runtime allocates a multi-slot data store array to each process
      when it is created. The thread can allocate a data slot in the data store, store
      and retrieve a data value in the slot, and free the slot for reuse after the
      thread expires. Data slots are unique per thread. No other thread (not even a
      child thread) can get that data.</para>
		</remarks>
		<seealso topic="cpconThreadsThreading"/>
		<seealso topic="cpconThread-LocalStorageThread-RelativeStaticFields"/>
	</doc>
	<doc for="Thread.Sleep">
		<overload>
			<para> Blocks the current thread for the specified number of milliseconds.
      </para>
		</overload>
		<summary>
			<para> Suspends the current thread for a specified time.
      </para>
		</summary>
		<param name="millisecondsTimeout">The number of milliseconds for which the thread is blocked. Specify zero (0) to indicate that this thread should be suspended to allow other waiting threads to execute. Specify <see cref="System.Threading.Timeout.Infinite"/> to block the thread indefinitely. </param>
		<exception cref="System.ArgumentOutOfRangeException">The time-out value is negative and is not equal to <see cref="System.Threading.Timeout.Infinite"/> . </exception>
		<remarks>
			<para> The thread will not be scheduled for execution by the
      operating system for the amount of time specified. This method changes the state
      of the thread to include <see cref="System.Threading.ThreadState.WaitSleepJoin"/>
      .
      </para>
		</remarks>
	</doc>
	<doc for="Thread.IsBackground">
		<summary>
			<para> Gets or sets a
      value indicating whether or not a thread is a background thread.
      </para>
		</summary>
		<value>
			<para><see langword="true "/>if this thread is or is to become
   a background thread; otherwise, <see langword="false"/>
   .
   </para>
		</value>
		<exception cref="System.Threading.ThreadStateException"> The thread is dead. </exception>
		<remarks>
			<para> A thread is either a background thread or
      a foreground thread. Background threads are identical to foreground threads, except
      that background threads do not prevent a process from terminating.
      Once all foreground threads belonging to a process have terminated, the common
      language runtime ends the process by invoking <see cref="System.Threading.Thread.Abort"/>
      on any background threads that
      are still alive.
      </para>
		</remarks>
		<seealso topic="cpconThreadLevels"/>
	</doc>
	<doc for="Thread.ThreadState">
		<summary>
			<para> Gets a value containing the states of the
      current thread.
      </para>
		</summary>
		<value>
			<para>One of the <see cref="System.Threading.ThreadState"/> values indicating the state of the current
   thread. The initial value is
<see langword="Unstarted"/>.</para>
		</value>
		<remarks>
			<para>The <see cref="System.Threading.Thread.ThreadState"/> property provides more 
   specific information than the <see cref="System.Threading.Thread.IsAlive"/>
   property.</para>
		</remarks>
		<seealso topic="cpconThreadActivityStates"/>
	</doc>
	<doc for="Thread.GetData">
		<overload>
			<para> Retrieves the value from
      the specified slot.
      </para>
		</overload>
		<summary>
			<para> Retrieves the value
      from the specified slot on the current thread, within the current thread's current domain.
      </para>
		</summary>
		<param name="slot">The <see cref="System.LocalDataStoreSlot"/> from which to get the value. </param>
		<returns>
			<para> The retrieved value.
      </para>
		</returns>
		<remarks>
			<para>Threads use a local store memory mechanism to store thread-specific data. The
      common language runtime allocates a multi-slot data store array to each process
      when it is created. The thread can allocate a data slot in the data store, store
      and retrieve a data value in the slot, and free the slot for reuse after the
      thread expires. Data slots are unique per thread. No other thread (not even a
      child thread) can get that data.</para>
			<note lang="VB" type="note">
				<see cref="System.Threading.Thread.GetData"/> is
      a <see langword="Shared"/> method that always applies to the currently
      executing thread, even if you call it using a
      variable that refers to another thread. To avoid confusion, use the class name when
      calling <see langword="Shared"/> methods: <c>Dim test As Object = Thread.GetData(testSlot)</c>.
</note>
		</remarks>
		<seealso cref="System.Threading.Thread.SetData"/>
		<seealso topic="cpconThreadsThreading"/>
		<seealso topic="cpconThread-LocalStorageThread-RelativeStaticFields"/>
	</doc>
	<doc for="Thread.SetData">
		<summary>
			<para> Sets the
      data in the specified slot on the currently running thread, for that thread's current domain.
      </para>
		</summary>
		<param name="slot">The <see cref="System.LocalDataStoreSlot"/> in which to set the value. </param>
		<param name="data">The value to be set. </param>
		<remarks>
			<para>Threads use a local store memory mechanism to store
      thread-specific data. The common language runtime allocates a multi-slot data
      store array to each process when it is created. The thread can allocate a data
      slot in the data store, store and retrieve a data value in the slot, and free
      the slot for reuse after the thread expires. Data slots are unique per thread.
      No other thread (not even a child thread) can get that data.</para>
			<note lang="VB" type="note">
				<see cref="System.Threading.Thread.SetData"/> is
      a <see langword="Shared"/> method that always applies to the currently
      executing thread, even if you call it using a variable
      that refers to another thread. To avoid confusion, use the class name when
      calling <see langword="Shared"/> methods: <c>Thread.SetData(testSlot, "test data")</c>.
</note>
		</remarks>
		<seealso cref="System.Threading.Thread.GetData"/>
		<seealso topic="cpconThreadsThreading"/>
		<seealso topic="cpconThread-LocalStorageThread-RelativeStaticFields"/>
	</doc>
	<doc for="Thread.Thread">
		<summary>
			<para> Initializes a new instance of the <see cref="System.Threading.Thread"/>
class.</para>
		</summary>
		<param name="start">A <see cref="System.Threading.ThreadStart"/> delegate that references the methods to be invoked when this thread begins executing. </param>
		<exception cref="System.ArgumentNullException">The <paramref name="start "/>parameter is <see langword="null"/> . </exception>
		<remarks>
			<para> To schedule the thread for execution,
      call the <see cref="System.Threading.Thread.Start"/>
      method.
      </para>
			<note lang="VB" type="note">
      Visual Basic users can omit the <see cref="System.Threading.ThreadStart"/>
      constructor when creating a thread. Use the <see langword="AddressOf"/> operator when passing
      your method, for example <c>Dim t As New Thread(AddressOf ThreadProc)</c>.
      Visual Basic automatically calls the <see cref="System.Threading.ThreadStart"/>
   constructor.
</note>
		</remarks>
		<seealso topic="cpconCreatingThreads"/>
	</doc>
	<doc for="Thread.Abort">
		<overload>
			<para> Raises a <see cref="System.Threading.ThreadAbortException"/>
in the thread on which it is invoked, to begin the process
of terminating the thread. Calling this method usually terminates
the thread.</para>
		</overload>
		<summary>
			<para> Raises a <see cref="System.Threading.ThreadAbortException"/> in the thread on which it is invoked, to begin the
   process of terminating the thread while also providing exception information about the thread termination. Calling this method usually terminates
   the thread.</para>
		</summary>
		<param name="stateInfo">An object that contains application-specific information, such as state, which can be used by the thread being aborted.</param>
		<exception cref="System.Security.SecurityException"> The caller does not have the required permission.</exception>
		<remarks>
			<para>When this method is invoked on a thread, the system throws a <see cref="System.Threading.ThreadAbortException"/> in the thread to abort it. <see langword="ThreadAbortException"/> is a special exception that can be caught by application code, but is re-thrown at the end of the <see langword="catch"/> block unless <see cref="System.Threading.Thread.ResetAbort"/> is called. <see langword="ResetAbort"/> cancels the request to abort, and prevents the <see langword="ThreadAbortException"/> from
   terminating the thread. Unexecuted <see langword="finally"/> blocks are executed before the thread is aborted.</para>
			<note type="note">
   When a thread calls
<see langword="Abort"/> on itself, the effect is similar to throwing an 
   exception; the <see cref="System.Threading.ThreadAbortException"/> happens immediately, and the result is
   predictable. However, if one thread calls <see langword="Abort"/> on another thread, the abort interrupts
   whatever code is running. There is a chance the thread could abort while a
<see langword="finally"/> block is running, in which case the 
<see langword="finally"/> 
block is aborted. There is also a chance that a static constructor could be
aborted. In rare cases, this might prevent instances of that class from being
created in that application domain.
</note>
			<para> The thread is not guaranteed to abort immediately, or at all. This situation can occur if a thread does an unbounded amount of computation in the <see langword="finally"/> blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort. To ensure a thread has aborted, invoke a <see cref="System.Threading.Thread.Join"/> method on the thread after calling <see langword="Abort"/>.</para>
			<para>If <see langword="Abort"/> is called on a thread that has not been started, the thread will abort when <see cref="System.Threading.Thread.Start"/> is called. If <see langword="Abort"/> is called on a thread that has been suspended, the thread is resumed and then aborted. If <see langword="Abort"/> is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted. If, while executing unmanaged code, a thread ignores a <see langword="ThreadAbortException"/>, the system re-throws the <see langword="ThreadAbortException"/> when the thread begins executing managed code.</para>
			<para>If two calls to <see langword="Abort"/> come at the same time, it is possible that one call sets the state information, and the other call executes the <see langword="Abort"/> . However, an application cannot distinguish this.</para>
			<para>After <see langword="Abort"/> is invoked on a thread, the state of the thread includes <see cref="System.Threading.ThreadState.AbortRequested"/>. After the thread has terminated
as a result of a successful call to <see langword="Abort"/> , the state of the thread is changed to <see cref="System.Threading.ThreadState.Stopped"/>. With sufficient permissions, a thread that is the target of an <see langword="Abort"/> can cancel the abort using the <see langword="ResetAbort"/> method. For an example that demonstrates calling the <see langword="ResetAbort"/> method, see the <see langword="ThreadAbortException"/> class.</para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermissionAttribute">for advanced operations on threads. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlThread" qualify="true"/>.</permission>
		<seealso cref="System.Threading.ThreadAbortException"/>
		<seealso cref="System.Threading.ThreadState.Aborted"/>
		<seealso cref="System.Threading.ThreadState.AbortRequested"/>
		<seealso topic="cpconThreadsThreading"/>
		<seealso topic="cpconUsingThreadsThreading"/>
		<seealso topic="cpconDestroyingThreads"/>
	</doc>
	<doc for="Thread.Abort1">
		<summary>
			<para> Raises a <see cref="System.Threading.ThreadAbortException"/> in the thread on which it is
   invoked, to begin the process of terminating the thread. Calling this method usually terminates
   the thread.
   </para>
		</summary>
		<exception cref="System.Security.SecurityException"> The caller does not have the required permission.</exception>
		<remarks>
			<para>When this method is invoked on a thread, the system throws a <see cref="System.Threading.ThreadAbortException"/> in the thread to abort it. <see langword="ThreadAbortException"/>
is a special exception that can be caught by application code, but is re-thrown
at the end of the <see langword="catch"/>
block unless <see cref="System.Threading.Thread.ResetAbort"/> is called.
<see langword="ResetAbort"/> cancels the request to abort, and prevents the 
<see langword="ThreadAbortException"/> from 
terminating the thread. Unexecuted <see langword="finally"/> blocks are executed before the
thread is aborted.</para>
			<note type="note">
   When a thread calls
<see langword="Abort"/> on itself, the effect is similar to throwing an 
   exception; the <see cref="System.Threading.ThreadAbortException"/> happens immediately, and the result is
   predictable. However, if one thread calls <see langword="Abort"/> on another thread, the abort interrupts
   whatever code is running. There is a chance the thread could abort while a
<see langword="finally"/> block is running, in which case the 
<see langword="finally"/> 
block is aborted. There is also a chance that a static constructor could be
aborted. In rare cases, this might prevent instances of that class from being
created in that application domain.
</note>
			<para> The thread is not guaranteed to abort immediately, or
   at all. This situation can occur if a thread does an unbounded amount of
   computation in the <see langword="finally"/> blocks that are called as part of
   the abort procedure, thereby indefinitely delaying the abort. To ensure a thread
   has aborted, invoke a <see cref="System.Threading.Thread.Join"/> method on the thread after calling
<see langword="Abort"/>.</para>
			<para> If <see langword="Abort"/> is called on a thread that has not been started, the thread will abort when <see cref="System.Threading.Thread.Start"/> is called. If <see langword="Abort"/> is called on a thread that has been suspended, the thread is resumed and then aborted. If <see langword="Abort"/> is called on a thread that is blocked or is
sleeping, the thread is interrupted and then aborted. If, while executing
unmanaged code, a thread ignores a <see langword="ThreadAbortException"/>, the
system re-throws the <see langword="ThreadAbortException"/> when the thread
begins executing managed code.</para>
			<para> If two calls to <see langword="Abort"/> come at the same
time, it is possible that one call set the state information and the other call executes
the <see langword="Abort"/> . However, an application cannot distinguish this.</para>
			<para> After <see langword="Abort"/> is invoked on a thread, the
state of the thread includes <see cref="System.Threading.ThreadState.AbortRequested"/>. After the thread has terminated
as a result of a successful call to <see langword="Abort"/>
, the state of the thread is changed to
<see cref="System.Threading.ThreadState.Stopped"/>. With sufficient permissions, a 
thread that is the target of an <see langword="Abort"/> can cancel the abort
using the <see langword="ResetAbort"/> method. For an example that demonstrates
calling the <see langword="ResetAbort"/> method, see the
<see langword="ThreadAbortException"/> 
class.</para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermissionAttribute">for advanced operations on threads. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlThread" qualify="true"/>.</permission>
		<seealso cref="System.Threading.ThreadAbortException"/>
		<seealso cref="System.Threading.ThreadState.Aborted"/>
		<seealso cref="System.Threading.ThreadState.AbortRequested"/>
		<seealso topic="cpconThreadsThreading"/>
		<seealso topic="cpconUsingThreadsThreading"/>
		<seealso topic="cpconDestroyingThreads"/>
	</doc>
	<doc for="Thread.CurrentContext">
		<summary>
			<para> Gets the current context in which the thread is executing.
      </para>
		</summary>
		<value>
			<para>A <see cref="System.Runtime.Remoting.Contexts.Context" qualify="true"/> representing the
   current thread context.</para>
		</value>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<permission cref="System.Security.Permissions.SecurityPermissionAttribute">to get the current context. Associated enumerations: <see cref="System.Security.Permissions.SecurityAction.LinkDemand" qualify="true"/> and <see cref="System.Security.Permissions.SecurityPermissionFlag.Infrastructure" qualify="true"/></permission>
	</doc>
	<doc for="Thread">
		<summary>
			<para> Creates and controls a thread, sets its priority, and gets its
      status.
      </para>
		</summary>
		<threadsafe>
			<para>This type is safe for multithreaded operations.</para>
		</threadsafe>
		<remarks>
			<para> A process can create one or more threads to
      execute a portion of the program code associated with the process.
      Use a <see cref="System.Threading.ThreadStart"/> delegate to specify the program code executed by a thread.
      </para>
			<para> For the duration of its existence, a thread is always in
      one or more of the states defined by <see cref="System.Threading.ThreadState"/>. A scheduling priority level,
      as defined by <see cref="System.Threading.ThreadPriority"/>, can be requested for a thread, but is not guaranteed to be honored by the operating system.
      </para>
			<para><see cref="System.Object.GetHashCode"/> provides identification for managed threads.
   For the lifetime of your thread, it will not collide with the value from any
   other thread, regardless of the application domain from which you obtain the
   value.</para>
			<note type="note">
   An operating-system ThreadId has no
   fixed relationship to a managed thread, because an unmanaged host can control
   the relationship between managed and unmanaged threads. Specifically, a
   sophisticated host can use the CLR Hosting API to schedule many managed threads
   against the same operating system thread, or to move a managed thread between
   different operating system threads.
</note>
		</remarks>
		<example>
			<para> The following code example demonstrates simple threading functionality.
      </para>
			<codelink SampleID="Classic Thread Example" SnippetID="1"/>
			<para>This code produces output similar to the following:</para>
			<code>
[VB, C++, C#]
Main thread: Start a second thread.
Main thread: Do some work.
ThreadProc: 0
Main thread: Do some work.
ThreadProc: 1
Main thread: Do some work.
ThreadProc: 2
Main thread: Do some work.
ThreadProc: 3
Main thread: Call Join(), to wait until ThreadProc ends.
ThreadProc: 4
ThreadProc: 5
ThreadProc: 6
ThreadProc: 7
ThreadProc: 8
ThreadProc: 9
Main thread: ThreadProc.Join has returned.  Press Enter to end program.
</code>
		</example>
		<seealso topic="cpconThreadsThreading"/>
		<seealso topic="cpconUsingThreadsThreading"/>
	</doc>
</docs>
