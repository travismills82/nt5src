<docs>
	<doc for="RegisteredWaitHandle.Finalize">
		<summary>
			<para>Ensures that resources are freed and other cleanup 
      operations are performed when the garbage collector reclaims the
   <see langword="RegisteredWaitHandle"/> .</para>
		</summary>
	</doc>
	<doc for="ThreadPool.BindHandle">
		<summary>
			<para> Binds an operating system handle to the
   <see langword="ThreadPool"/> .
      </para>
		</summary>
		<param name="osHandle">An <see cref="System.IntPtr"/> that holds the handle. The handle must have been opened for overlapped I/O on the unmanaged side.</param>
		<returns>
			<para><see langword="true"/> to bind the handle; otherwise,
<see langword="false"/>.</para>
		</returns>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<permission cref="System.Security.Permissions.SecurityPermissionAttribute">for access to unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/>.</permission>
	</doc><doc for="IOCompletionCallback">
		<summary>
			<para>Receives the error code, number of bytes, and overlapped value type when an
 I/O operation completes on the thread pool.</para>
		</summary>
		<param name="errorCode">The error code.</param>
		<param name=" numBytes">The number of bytes that are transferred.</param>
		<param name=" pOVERLAP">A <see cref="System.Threading.NativeOverlapped"/> representing an unmanaged pointer to the native overlapped value type.</param>
	</doc>
	<doc for="ThreadPool.UnsafeQueueUserWorkItem">
		<summary>
			<para> Queues a user work item to the thread pool.</para>
		</summary>
		<param name="callBack">A <see langword="WaitCallback"/> representing the delegate to invoke when a thread in the thread pool picks up the work item. </param>
		<param name="state">The object that is passed to the delegate when serviced from the thread pool. </param>
		<returns>
			<para><see langword="true "/>if the method succeeds; otherwise, <see langword="false"/> . </para>
		</returns>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>This is an unsafe version of <see cref="System.Threading.ThreadPool.QueueUserWorkItem"/> that does not
   propagate the calling stack onto the worker thread. This allows code to lose the
   calling stack and thereby elevate its security privileges.</para>
			<note type="caution">
   
   Using <see langword="UnsafeQueueUserWorkItem"/> could inadvertently open up
   a security hole. Code access security bases its permission checks on the
   permissions of all the callers on the stack. When work is queued on a thread
   pool thread using <see langword="UnsafeQueueUserWorkItem"/>, the stack of
   the thread pool thread will not have the context of the actual callers.
   Malicious code might be able exploit this to avoid permission checks.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">to provide evidence and view and modify policy. Associated enumerations: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>, <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" qualify="true"/>.</permission>
		<seealso topic="cpconThreadPooling"/>
	</doc>
	<doc for="ThreadPool.UnsafeRegisterWaitForSingleObject">
		<overload>
			<para> Queues the specified delegate to the thread pool. </para>
		</overload>
		<summary>
			<para>Queues the specified delegate to the thread pool.</para>
		</summary>
		<param name="waitObject">The <see cref="System.Threading.WaitHandle"/> to register. </param>
		<param name="callBack">The delegate to call when the <paramref name="waitObject"/> parameter is signaled. </param>
		<param name="state">The object that is passed to the delegate. </param>
		<param name="millisecondsTimeOutInterval">The time-out in milliseconds. If the <paramref name="millisecondsTimeOutInterval"/> parameter is zero (0), the function tests the object's state and returns immediately. If <paramref name="millisecondsTimeOutInterval"/> is -1, the function's time-out interval never elapses. </param>
		<param name="executeOnlyOnce"><see langword="true"/> to indicate the thread will no longer wait on the <paramref name="waitObject"/> parameter after the delegate has been called; <see langword="false"/> to indicate the timer is reset every time the wait operation completes until the wait is unregistered. </param>
		<returns>
			<para>The <see cref="System.Threading.RegisteredWaitHandle"/> object that can be used to cancel the registered wait operation.</para>
		</returns>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>This is an unsafe version of <see cref="System.Threading.ThreadPool.RegisterWaitForSingleObject"/> that does not propagate the calling
   stack onto the worker thread. This allows code to lose the calling stack and
   thereby elevate its security privileges. </para>
			<note type="caution">
   Using <see langword="UnsafeRegisterWaitForSingleObject"/> could inadvertently open up a
   security hole. Code access security bases its permission checks on the
   permissions of all the callers on the stack. When work is queued on a thread
   pool thread using <see langword="UnsafeRegisterWaitForSingleObject"/>, the stack of the
   thread pool thread will not have the context of the actual callers. Malicious
   code might be able exploit this to avoid permission checks.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">to provide evidence and view and modify policy. Associated enumerations: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>, <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" qualify="true"/>.</permission>
		<seealso topic="cpconThreadPooling"/>
	</doc>
	<doc for="ThreadPool.UnsafeRegisterWaitForSingleObject1">
		<summary>
			<para>Queues the specified delegate to the thread pool.</para>
		</summary>
		<param name="waitObject">The <see cref="System.Threading.WaitHandle"/> to register. </param>
		<param name="callBack">The delegate to call when the <paramref name="waitObject"/> parameter is signaled. </param>
		<param name="state">The object that is passed to the delegate. </param>
		<param name="millisecondsTimeOutInterval">The time-out in milliseconds. If the <paramref name="millisecondsTimeOutInterval"/> parameter is zero (0), the function tests the object's state and returns immediately. If <paramref name="millisecondsTimeOutInterval"/> is -1, the function's time-out interval never elapses. </param>
		<param name="executeOnlyOnce"><see langword="true"/> to indicate the thread will no longer wait on the <paramref name="waitObject"/> parameter after the delegate has been called; <see langword="false"/> to indicate the timer is reset every time the wait operation completes until the wait is unregistered. </param>
		<returns>
			<para>The <see cref="System.Threading.RegisteredWaitHandle"/> object that can be used to cancel the registered wait operation.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException">The <paramref name="millisecondsTimeOutInterval"/> parameter is less than -1.</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>This is an unsafe version of <see cref="System.Threading.ThreadPool.RegisterWaitForSingleObject"/> that does not propagate the calling
   stack onto the worker thread. This allows code to lose the calling stack and
   thereby elevate its security privileges. </para>
			<note type="caution">
   Using <see langword="UnsafeRegisterWaitForSingleObject"/> could inadvertently open up a
   security hole. Code access security bases its permission checks on the
   permissions of all the callers on the stack. When work is queued on a thread
   pool thread using <see langword="UnsafeRegisterWaitForSingleObject"/>, the stack of the
   thread pool thread will not have the context of the actual callers. Malicious
   code might be able exploit this to avoid permission checks.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">to provide evidence and view and modify policy. Associated enumerations: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>, <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" qualify="true"/>.</permission>
		<seealso topic="cpconThreadPooling"/>
	</doc>
	<doc for="ThreadPool.UnsafeRegisterWaitForSingleObject2">
		<summary>
			<para>Queues the specified delegate to the thread pool.</para>
		</summary>
		<param name="waitObject">The <see cref="System.Threading.WaitHandle"/> to register. </param>
		<param name="callBack">The delegate to call when the <paramref name="waitObject"/> parameter is signaled. </param>
		<param name="state">The object that is passed to the delegate. </param>
		<param name="millisecondsTimeOutInterval">The time-out in milliseconds. If the <paramref name="millisecondsTimeOutInterval"/> parameter is zero (0), the function tests the object's state and returns immediately. If <paramref name="millisecondsTimeOutInterval"/> is -1, the function's time-out interval never elapses. </param>
		<param name="executeOnlyOnce"><see langword="true"/> to indicate the thread will no longer wait on the <paramref name="waitObject"/> parameter after the delegate has been called; <see langword="false"/> to indicate the timer is reset every time the wait operation completes until the wait is unregistered. </param>
		<returns>
			<para>The <see cref="System.Threading.RegisteredWaitHandle"/> object that can be used to cancel the registered wait operation.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException">The <paramref name="millisecondsTimeOutInterval"/> parameter is less than -1.</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>This is an unsafe version of <see cref="System.Threading.ThreadPool.RegisterWaitForSingleObject"/> that does not propagate the calling
   stack onto the worker thread. This allows code to lose the calling stack and
   thereby elevate its security privileges. </para>
			<note type="caution">
   Using <see langword="UnsafeRegisterWaitForSingleObject"/> could inadvertently open up a
   security hole. Code access security bases its permission checks on the
   permissions of all the callers on the stack. When work is queued on a thread
   pool thread using <see langword="UnsafeRegisterWaitForSingleObject"/>, the stack of the
   thread pool thread will not have the context of the actual callers. Malicious
   code might be able exploit this to avoid permission checks.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">to provide evidence and view and modify policy. Associated enumerations: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>, <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" qualify="true"/>.</permission>
		<seealso topic="cpconThreadPooling"/>
	</doc>
	<doc for="ThreadPool.RegisterWaitForSingleObject1">
		<summary>
			<para>Registers a delegate that is waiting for a <see cref="System.Threading.WaitHandle"/>, using a 32-bit signed integer for the
   time-out in
   milliseconds. </para>
		</summary>
		<param name="waitObject">The <see cref="System.Threading.WaitHandle"/> to register. </param>
		<param name=" callBack">The <see cref="System.Threading.WaitOrTimerCallback"/> delegate to call when the <paramref name="waitObject"/> parameter is signaled. </param>
		<param name=" state">The object passed to the delegate. </param>
		<param name=" millisecondsTimeOutInterval">The time-out in milliseconds. If the <paramref name="millisecondsTimeOutInterval"/> parameter is zero (0), the function tests the object's state and returns immediately. If <paramref name="millisecondsTimeOutInterval"/> is -1, the function's time-out interval never elapses. </param>
		<param name=" executeOnlyOnce"><see langword="true"/> to indicate the thread will no longer wait on the <paramref name="waitObject"/> parameter after the delegate has been called; <see langword="false"/> to indicate the timer is reset every time the wait operation completes until the wait is unregistered. </param>
		<returns>
			<para>The <see cref="System.Threading.RegisteredWaitHandle"/>
that encapsulates the
native handle.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException">The <paramref name="millisecondsTimeOutInterval"/> parameter is less than -1.</exception>
		<remarks>
			<para>The <see langword="RegisterWaitForSingleObject"/> method queues the specified 
   delegate to the thread pool. A worker thread will execute the delegate when one
   of the following occurs: </para>
			<list type="bullet"><item>
					<term>
      The specified object is in the signaled state.</term>
				</item>
				<item>
					<term>
      The time-out interval elapses.</term>
				</item>
			</list>
			<para>The <see langword="RegisterWaitForSingleObject"/> method checks the current 
state of the specified object's <see cref="System.Threading.WaitHandle"/> . If the object's state is
unsignaled, the method registers a wait operation. The wait operation is
performed by a thread from the thread pool. The delegate is executed by a worker
thread when the object's state becomes signaled or the time-out interval
elapses. If the <paramref name="timeOutInterval"/> parameter is not zero (0) and the
<paramref name="executeOnlyOnce"/> parameter is not <see langword="false"/>, the timer is 
reset every time the event is signaled or the time-out interval elapses. </para>
			<para>To cancel the wait operation, call the <see cref="System.Threading.RegisteredWaitHandle.Unregister" qualify="true"/> 
method.</para>
			<para>The wait thread uses the Win32 <see langword="WaitForMultipleObjects"/> 
function to monitor registered wait operations. Therefore, if you must use the
same native operating system handle in multiple calls to
<see langword="RegisterWaitForSingleObject"/>, you must duplicate the handle 
using the Win32 <see langword="DuplicateHandle"/> function. Note that you should
not pulse an event object passed to
<see langword="RegisterWaitForSingleObject"/>, because the wait thread might not 
detect that the event is signaled before it is reset. </para>
			<para>Before returning, the function modifies the state of some types of 
   synchronization objects. Modification occurs only for the object whose signaled
   state caused the wait condition to be satisfied. For example, the count of a
   semaphore is decreased by one. </para>
		</remarks>
		<seealso topic="cpconThreadPooling"/>
	</doc>
	<doc for="ThreadPool.RegisterWaitForSingleObject2">
		<summary>
			<para>Registers a delegate that is waiting for a <see cref="System.Threading.WaitHandle"/>, using a 32-bit unsigned integer for the
   time-out in
   milliseconds. </para>
		</summary>
		<param name="waitObject">The <see cref="System.Threading.WaitHandle"/> to register. </param>
		<param name=" callBack">The <see cref="System.Threading.WaitOrTimerCallback"/> delegate to call when the <paramref name="waitObject"/> parameter is signaled. </param>
		<param name=" state">The object passed to the delegate. </param>
		<param name=" millisecondsTimeOutInterval">The time-out in milliseconds. If the <paramref name="millisecondsTimeOutInterval"/> parameter is zero (0), the function tests the object's state and returns immediately. If <paramref name="millisecondsTimeOutInterval"/> is -1, the function's time-out interval never elapses. </param>
		<param name=" executeOnlyOnce"><see langword="true"/> to indicate the thread will no longer wait on the <paramref name="waitObject"/> parameter after the delegate has been called; <see langword="false"/> to indicate the timer is reset every time the wait operation completes until the wait is unregistered. </param>
		<returns>
			<para>The <see cref="System.Threading.RegisteredWaitHandle"/>
that encapsulates the
native handle.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException">The <paramref name="millisecondsTimeOutInterval"/> parameter is less than -1.</exception>
		<remarks>
			<para>The <see langword="RegisterWaitForSingleObject"/> method queues the specified 
   delegate to the thread pool. A worker thread will execute the delegate when one
   of the following occurs: </para>
			<list type="bullet"><item>
					<term>
      The specified object is in the signaled state.</term>
				</item>
				<item>
					<term>
      The time-out interval elapses.</term>
				</item>
			</list>
			<para>The <see langword="RegisterWaitForSingleObject"/> method checks the current 
state of the specified object's <see cref="System.Threading.WaitHandle"/> . If the object's state is
unsignaled, the method registers a wait operation. The wait operation is
performed by a thread from the thread pool. The delegate is executed by a worker
thread when the object's state becomes signaled or the time-out interval
elapses. If the <paramref name="timeOutInterval"/> parameter is not zero (0) and the
<paramref name="executeOnlyOnce"/> parameter is not <see langword="false"/>, the timer is 
reset every time the event is signaled or the time-out interval elapses. </para>
			<para>To cancel the wait operation, call the <see cref="System.Threading.RegisteredWaitHandle.Unregister" qualify="true"/> 
method.</para>
			<para>The wait thread uses the Win32 <see langword="WaitForMultipleObjects"/> 
function to monitor registered wait operations. Therefore, if you must use the
same native operating system handle in multiple calls to
<see langword="RegisterWaitForSingleObject"/>, you must duplicate the handle 
using the Win32 <see langword="DuplicateHandle"/> function. Note that you should
not pulse an event object passed to
<see langword="RegisterWaitForSingleObject"/>, because the wait thread might not 
detect that the event is signaled before it is reset. </para>
			<para>Before returning, the function modifies the state of some types of 
   synchronization objects. Modification occurs only for the object whose signaled
   state caused the wait condition to be satisfied. For example, the count of a
   semaphore is decreased by one. </para>
		</remarks>
		<seealso topic="cpconThreadPooling"/>
	</doc>
	<doc for="ThreadPool.RegisterWaitForSingleObject3">
		<summary>
			<para>Registers a delegate that is waiting for a <see cref="System.Threading.WaitHandle"/>, using a <see cref="System.TimeSpan"/> value
   for the time-out. </para>
		</summary>
		<param name="waitObject">The <see cref="System.Threading.WaitHandle"/> to register. </param>
		<param name=" callBack">The <see cref="System.Threading.WaitOrTimerCallback"/> delegate to call when the <paramref name="waitObject"/> parameter is signaled. </param>
		<param name=" state">The object passed to the delegate. </param>
		<param name=" timeout">The time-out represented by a <see cref="System.TimeSpan"/> . If <paramref name="timeout"/> is zero, the function tests the object's state and returns immediately. If <paramref name="timeout"/> is -1, the function's time-out interval never elapses. </param>
		<param name=" executeOnlyOnce"><see langword="true"/> to indicate the thread will no longer wait on the <paramref name="waitObject"/> parameter after the delegate has been called; <see langword="false"/> to indicate the timer is reset every time the wait operation completes until the wait is unregistered. </param>
		<returns>
			<para>The <see cref="System.Threading.RegisteredWaitHandle"/>
that encapsulates the
native handle.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException">The <paramref name="timeout"/> parameter is less than -1.</exception>
		<exception cref="System.NotSupportedException">The <paramref name="timeout"/> parameter is greater than <see cref="System.Int32.MaxValue" qualify="true"/> .</exception>
		<remarks>
			<para>The <see langword="RegisterWaitForSingleObject"/> method queues the specified 
   delegate to the thread pool. A worker thread will execute the delegate when one
   of the following occurs: </para>
			<list type="bullet"><item>
					<term>
      The specified object is in the signaled state.</term>
				</item>
				<item>
					<term>
      The time-out interval elapses.</term>
				</item>
			</list>
			<para>The <see langword="RegisterWaitForSingleObject"/> method checks the current 
state of the specified object's <see cref="System.Threading.WaitHandle"/> . If the object's state is
unsignaled, the method registers a wait operation. The wait operation is
performed by a thread from the thread pool. The delegate is executed by a worker
thread when the object's state becomes signaled or the time-out interval
elapses. If the <paramref name="timeOutInterval"/> parameter is not zero (0) and the
<paramref name="executeOnlyOnce"/> parameter is not <see langword="false"/>, the timer is 
reset every time the event is signaled or the time-out interval elapses. </para>
			<para>To cancel the wait operation, call the <see cref="System.Threading.RegisteredWaitHandle.Unregister" qualify="true"/> 
method.</para>
			<para>The wait thread uses the Win32 <see langword="WaitForMultipleObjects"/> 
function to monitor registered wait operations. Therefore, if you must use the
same native operating system handle in multiple calls to
<see langword="RegisterWaitForSingleObject"/>, you must duplicate the handle 
using the Win32 <see langword="DuplicateHandle"/> function. Note that you should
not pulse an event object passed to
<see langword="RegisterWaitForSingleObject"/>, because the wait thread might not 
detect that the event is signaled before it is reset. </para>
			<para>Before returning, the function modifies the state of some types of 
   synchronization objects. Modification occurs only for the object whose signaled
   state caused the wait condition to be satisfied. For example, the count of a
   semaphore is decreased by one. </para>
		</remarks>
		<seealso topic="cpconThreadPooling"/>
	</doc>
	<doc for="ThreadPool.UnsafeRegisterWaitForSingleObject3">
		<summary>
			<para>Queues the specified delegate to the thread pool.</para>
		</summary>
		<param name="waitObject">The <see cref="System.Threading.WaitHandle"/> to register. </param>
		<param name="callBack">The delegate to call when the <paramref name="waitObject"/> parameter is signaled. </param>
		<param name="state">The object that is passed to the delegate. </param>
		<param name="timeout">The time-out represented by a <see cref="System.TimeSpan"/>. If <paramref name="timeout"/> is zero, the function tests the object's state and returns immediately. If <paramref name="timeout"/> is -1, the function's time-out interval never elapses. </param>
		<param name="executeOnlyOnce"><see langword="true"/> to indicate the thread will no longer wait on the <paramref name="waitObject"/> parameter after the delegate has been called; <see langword="false"/> to indicate the timer is reset every time the wait operation completes until the wait is unregistered. </param>
		<returns>
			<para>The <see cref="System.Threading.RegisteredWaitHandle"/> object that can be used to cancel the registered wait operation.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException">The <paramref name="timeout"/> parameter is less than -1.</exception>
		<exception cref="System.NotSupportedException">The <paramref name="timeout"/> parameter is greater than <see cref="System.Int32.MaxValue" qualify="true"/>.</exception>
		<exception cref="System.Security.SecurityException">The caller does not have the required permission.</exception>
		<remarks>
			<para>This is an unsafe version of <see cref="System.Threading.ThreadPool.RegisterWaitForSingleObject"/> that does not propagate the calling
   stack onto the worker thread. This allows code to lose the calling stack and
   thereby elevate its security privileges. </para>
			<note type="caution">
   Using <see langword="UnsafeRegisterWaitForSingleObject"/> could inadvertently open up a
   security hole. Code access security bases its permission checks on the
   permissions of all the callers on the stack. When work is queued on a thread
   pool thread using <see langword="UnsafeRegisterWaitForSingleObject"/>, the stack of the
   thread pool thread will not have the context of the actual callers. Malicious
   code might be able exploit this to avoid permission checks.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">to provide evidence and view and modify policy. Associated enumerations: <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" qualify="true"/>, <see cref="System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" qualify="true"/>.</permission>
		<seealso topic="cpconThreadPooling"/>
	</doc>
	<doc for="ThreadPool.GetMaxThreads">
		<summary>
			<para> Retrieves the number of requests to the thread pool
      that can be active concurrently. All requests above that number remain queued
      until thread pool threads become available.</para>
		</summary>
		<param name="workerThreads">The maximum number of worker threads in the thread pool.</param>
		<param name=" completionPortThreads">The maximum number of asynchronous I/O threads in the thread pool.</param>
		<remarks>
			<para>When <see cref="System.Threading.ThreadPool.GetMaxThreads"/> returns, the variable specified by <paramref name="workerThreads"/> contains the maximum number of worker 
   threads allowed in
   the thread pool, and the variable specified by<paramref name="completionPortThreads"/> contains the maximum number of
   asynchronous I/O
   threads allowed in the thread pool.</para>
			<para>You can use <see cref="System.Threading.ThreadPool.GetAvailableThreads"/> to determine the actual number of threads
in the
thread pool at any given time.</para>
			<para>You can queue as many thread pool requests as system 
   memory allows. If there are more requests than thread pool threads, the
   additional requests
   remain queued
   until thread pool threads become available.</para>
		</remarks>
	</doc>
	<doc for="ThreadPool.GetAvailableThreads">
		<summary>
			<para>Retrieves the difference between the maximum number of 
      thread pool threads, returned by <see cref="System.Threading.ThreadPool.GetMaxThreads"/>, and the number
      currently
      active.</para>
		</summary>
		<param name="workerThreads">The number of available worker threads.</param>
		<param name="completionPortThreads">The number of available asynchronous I/O threads.</param>
		<remarks>
			<para>When <see cref="System.Threading.ThreadPool.GetAvailableThreads"/> returns, the variable 
   specified by <paramref name="workerThreads"/> contains the number of additional
   worker threads that can be started, and the variable specified
   by <paramref name="completionPortThreads"/> contains the number of additional
   asynchronous I/O threads that can be started.</para>
			<para>If there are no available threads, additional thread pool requests remain 
   queued until thread pool threads become available.</para>
		</remarks>
	</doc>
	<doc for="RegisteredWaitHandle.Unregister">
		<summary>
			<para> Cancels a registered wait operation issued by the
   <see cref="System.Threading.ThreadPool.RegisterWaitForSingleObject"/>
   
   method.
   </para>
		</summary>
		<param name="waitObject">The <see cref="System.Threading.WaitHandle"/> to be signaled. </param>
		<returns>
			<para><see langword="true "/>if the function succeeds;
   otherwise, <see langword="false"/>.
   </para>
		</returns>
		<remarks>
			<para>If <paramref name="waitObject"/> is specified, it is signaled
   only if the <see cref="System.Threading.RegisteredWaitHandle"/> is successfully unregistered. If a callback
   method is in progress when <see cref="System.Threading.RegisteredWaitHandle.Unregister"/>
   executes, <paramref name="waitObject"/> is not signaled until the callback method
   completes. In particular, if a callback method executes <see cref="System.Threading.RegisteredWaitHandle.Unregister"/>,
<paramref name="waitObject"/>
is not signaled until that callback method completes.</para>
		</remarks>
		<example>
			<codelink SampleID="System.Threading.ThreadPool RegisterWaitForSingleObject0" SnippetID="1"/>
		</example>
		<seealso topic="cpconThreadPooling"/>
	</doc>
	<doc for="WaitOrTimerCallback">
		<summary>
			<para> Represents a method to be called when a <see cref="System.Threading.WaitHandle"/> is
   signaled or
   times out.
   </para>
		</summary>
		<param name="state">An object containing information to be used by the callback method each time it executes. </param>
		<param name=" timedOut"><see langword="true"/> if the <see cref="System.Threading.WaitHandle"/> timed out; <see langword="false"/> if it was signaled. </param>
		<remarks>
			<para><see cref="System.Threading.WaitOrTimerCallback"/> represents a
   callback method that you want to execute when a registered wait handle times out
   or is signaled. Create the delegate by passing your callback method to
   the <see cref="System.Threading.WaitOrTimerCallback"/>
   constructor. Your method must have the signature shown
   here.</para>
			<para>Create the registered wait handle by passing
   the <see cref="System.Threading.WaitOrTimerCallback"/> delegate and a <see cref="System.Threading.WaitHandle"/> to
<see cref="System.Threading.ThreadPool.RegisterWaitForSingleObject" qualify="true"/>. Your callback method 
   executes each time the <see cref="System.Threading.WaitHandle"/>
   times out or is
   signaled.</para>
			<note lang="VB" type="note">
   Visual Basic users can omit the <see cref="System.Threading.WaitOrTimerCallback"/> constructor, and simply use the
<see langword="AddressOf"/> operator when passing the callback method to <see cref="System.Threading.ThreadPool.RegisterWaitForSingleObject"/>. Visual Basic automatically calls 
   the correct delegate constructor.
</note>
			<para> If you want to pass information to your callback method,
   create an object that contains the necessary information and pass it to <see cref="System.Threading.ThreadPool.RegisterWaitForSingleObject"/> when you create the
   registered wait handle. Each time your callback method executes, the <paramref name="state"/> parameter contains this object.</para>
			<para>For more information about using callback methods to synchronize thread pool
   threads, see <see topic="cpconthreadpooling"/>. </para>
		</remarks>
		<example>
			<codelink SampleID="System.Threading.ThreadPool RegisterWaitForSingleObject0" SnippetID="1"/>
		</example>
		<seealso topic="cpconThreadsThreading"/>
		<seealso topic="cpconThreadPooling"/>
	</doc>
	<doc for="ThreadPool">
		<summary>
			<para>Provides a pool of threads that can be used to post work items,
      process asynchronous I/O, wait on behalf of other threads, and process timers.</para>
		</summary>
		<remarks>
			<para> Many applications create threads that spend a
      great deal of time in the sleeping state, waiting for an event to occur. Other
      threads might enter a sleeping state only to be awakened periodically to poll for a
      change or update status information. Thread pooling enables you to use threads
      more efficiently by providing your application with a pool of worker threads that are managed by the
      system. One thread monitors the status of several wait operations queued to the thread
      pool. When a wait operation completes, a worker thread from the thread pool executes the
      corresponding callback function.</para>
			<para> You can also queue work items that are not related
      to a wait operation to the thread pool. To request that a work item be handled
      by a thread in the thread pool, call the <see cref="System.Threading.ThreadPool.QueueUserWorkItem"/> method.
      This
      method takes as a parameter a reference to the method or
      delegate that will be called by the thread selected from the thread pool.
      There is no way to cancel a work item after it has been queued.</para>
			<para>Timer-queue timers and registered wait operations also use the
      thread pool. Their callback functions are queued to the thread pool.</para>
			<para>The thread pool is created the first time you create an
      instance of the <see langword="ThreadPool"/> class. The thread pool has
      a default limit of 25 threads per available processor, which could be changed
      using <see langword="CorSetMaxThreads"/> as defined in
      the mscoree.h file. Each thread uses the
      
      default stack size and runs at the default
      priority. Each process can have only one operating system thread pool.</para>
		</remarks>
		<example>
			<codelink SampleID="System.Threading.ThreadPool QueueUserWorkItem0" SnippetID="1"/>
		</example>
		<seealso topic="cpconThreadsThreading"/>
		<seealso topic="cpconThreadPooling"/>
	</doc>
	<doc for="ThreadPool.RegisterWaitForSingleObject">
		<overload>
			<para> Registers a delegate that is waiting for a <see cref="System.Threading.WaitHandle"/>
.</para>
		</overload>
		<summary>
			<para> Registers a delegate that is waiting for a <see cref="System.Threading.WaitHandle"/>, using a 32-bit unsigned integer for
   the time-out in milliseconds.</para>
		</summary>
		<param name="waitObject">The <see cref="System.Threading.WaitHandle"/> to register. </param>
		<param name=" callBack">The <see cref="System.Threading.WaitOrTimerCallback"/> delegate to call when the <paramref name="waitObject"/> parameter is signaled. </param>
		<param name=" state">The object passed to the delegate. </param>
		<param name=" millisecondsTimeOutInterval">The time-out in milliseconds. If the <paramref name="millisecondsTimeOutInterval"/> parameter is zero (0), the function tests the object's state and returns immediately. If <paramref name="millisecondsTimeOutInterval"/> is -1, the function's time-out interval never elapses. </param>
		<param name=" executeOnlyOnce"><see langword="true"/> to indicate the thread will no longer wait on the <paramref name="waitObject"/> parameter after the delegate has been called; <see langword="false"/> to indicate the timer is reset every time the wait operation completes until the wait is unregistered. </param>
		<returns>
			<para> The <see cref="System.Threading.RegisteredWaitHandle"/> that can be used
   to cancel the registered
   wait operation.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException">The <paramref name="millisecondsTimeOutInterval"/> parameter is less than -1.</exception>
		<remarks>
			<para>The <see langword="RegisterWaitForSingleObject"/> method queues the specified
   delegate to the thread pool. A worker thread will execute the delegate when one
   of the following occurs: </para>
			<list type="bullet"><item>
					<term>
      The specified object is in the signaled state.</term>
				</item>
				<item>
					<term>
      The time-out interval elapses.</term>
				</item>
			</list>
			<para>The <see langword="RegisterWaitForSingleObject"/> method checks the current
state of the specified object's <see cref="System.Threading.WaitHandle"/> . If the object's state is unsignaled, the
method registers a wait operation. The wait operation is performed by a thread
from the thread pool. The delegate is executed by a worker thread when the
object's state becomes signaled or the time-out interval elapses. If the
<paramref name="timeOutInterval"/> parameter is not zero (0) and the <paramref name="executeOnlyOnce"/> parameter is not 
<see langword="false"/>, the timer is reset every time the event is signaled or 
the time-out interval elapses. </para>
			<para>To cancel the wait operation, call the <see cref="System.Threading.RegisteredWaitHandle.Unregister" qualify="true"/>
method.</para>
			<para>The wait thread uses the Win32 <see langword="WaitForMultipleObjects"/> function to
monitor registered wait operations. Therefore, if you must use the same native
operating system handle in multiple calls to
<see langword="RegisterWaitForSingleObject"/>, you must duplicate the handle 
using the Win32 <see langword="DuplicateHandle"/> function. Note that you should
not pulse an event object passed to
<see langword="RegisterWaitForSingleObject"/>, because the wait thread might not 
detect that the event is signaled before it is reset. </para>
			<para> Before returning, the function modifies the state of some types
   of synchronization objects. Modification occurs only for the object whose
   signaled state caused the wait condition to be satisfied. For example, the count of
   a semaphore is decreased by one. </para>
		</remarks>
		<example>
			<codelink SampleID="System.Threading.ThreadPool RegisterWaitForSingleObject0" SnippetID="1"/>
		</example>
		<seealso topic="cpconThreadPooling"/>
	</doc>
	<doc for="ThreadPool.QueueUserWorkItem">
		<overload>
			<para> Queues a method for execution. The method executes when a thread pool thread becomes available.
      </para>
		</overload>
		<summary>
			<para> Queues a method for execution, and specifies an object
      containing data to be used by the method. The method executes when a thread pool thread becomes available.
      </para>
		</summary>
		<param name="callBack">A <see cref="System.Threading.WaitCallback"/> representing the method to execute. </param>
		<param name="state">An object containing data to be used by the method. </param>
		<returns>
			<para><see langword="true "/>if the method is successfully queued;
   otherwise, <see langword="false"/> .
   </para>
		</returns>
		<remarks>
			<para>If the queued method requires only a single data item,
      you can cast that data item to type <see cref="System.Object"/> . If the method requires
      more complex data, you must define a class to contain the data. </para>
			<note lang="VB" type="note">
      Visual Basic users can omit the <see cref="System.Threading.WaitCallback"/>
      constructor, and simply use the <see langword="AddressOf"/> operator when
      passing the callback method to <see cref="System.Threading.ThreadPool.QueueUserWorkItem"/>. Visual Basic automatically calls the correct
      delegate constructor.
      
   </note>
		</remarks>
		<example>
			<codelink SampleID="System.Threading.ThreadPool QueueUserWorkItem0" SnippetID="1"/>
		</example>
		<seealso topic="cpconThreadPooling"/>
	</doc>
	<doc for="ThreadPool.QueueUserWorkItem1">
		<summary>
			<para> Queues a method for execution. The method executes when a thread pool thread becomes available.
      </para>
		</summary>
		<param name="callBack">A <see langword="WaitCallback"/> representing the method to be executed. </param>
		<returns>
			<para><see langword="true "/>if the method is successfully queued;
   otherwise, <see langword="false"/> .
   </para>
		</returns>
		<remarks>
			<para>You can place data required by the queued method in the
      instance fields of the class in which the method is defined, or you can use
      the <see cref="System.Threading.ThreadPool.QueueUserWorkItem"/>
      overload that accepts an object containing the necessary data. </para>
			<note lang="VB" type="note">
      Visual Basic users can omit the <see cref="System.Threading.WaitCallback"/>
      constructor, and simply use the <see langword="AddressOf"/> operator when
      passing the callback method to <see cref="System.Threading.ThreadPool.QueueUserWorkItem"/>. Visual Basic automatically calls the correct
      delegate constructor.
      
   </note>
		</remarks>
		<example>
			<codelink SampleID="System.Threading.ThreadPool QueueUserWorkItem1" SnippetID="1"/>
		</example>
		<seealso topic="cpconThreadPooling"/>
	</doc>
	<doc for="WaitCallback">
		<summary>
			<para> Represents a callback method to be executed
      by a thread pool thread.</para>
		</summary>
		<param name="state">An object containing information to be used by the callback method. </param>
		<remarks>
			<para><see cref="System.Threading.WaitCallback"/>
represents a callback method that you want to execute on a <see cref="System.Threading.ThreadPool"/> thread. Create the delegate by passing your
callback method to the <see cref="System.Threading.WaitCallback"/>
constructor. Your method must have the signature shown
here.</para>
			<para>Queue your task for execution by passing
   the <see cref="System.Threading.WaitCallback"/> delegate to <see cref="System.Threading.ThreadPool.QueueUserWorkItem" qualify="true"/>
   . Your callback method executes when a thread pool thread
   becomes available.</para>
			<note lang="VB" type="note">
   
   Visual Basic users can omit the <see cref="System.Threading.WaitCallback"/> constructor, and simply use the
<see langword="AddressOf"/> operator when passing the callback method to <see cref="System.Threading.ThreadPool.QueueUserWorkItem"/>
. Visual Basic
automatically calls the correct delegate constructor.
</note>
			<para> If you want to pass information to your callback
   method, create an object that contains the necessary information and pass
   it to <see cref="System.Threading.ThreadPool.QueueUserWorkItem"/> when you queue your task for execution. Each
   time your callback method executes, the <paramref name="state"/>
   
   parameter contains this object.</para>
			<para> For more information about using callbacks to
   synchronize thread pool threads, see <see topic="cpconthreadpooling"/>. </para>
		</remarks>
		<example>
			<codelink SampleID="System.Threading.ThreadPool QueueUserWorkItem0" SnippetID="1"/>
		</example>
		<seealso cref="System.Threading.ThreadPool"/>
		<seealso topic="cpconThreadsThreading"/>
		<seealso topic="cpconThreadPooling"/>
	</doc>
	<doc for="RegisteredWaitHandle">
		<summary>
			<para> Represents a handle that has been registered when
      calling <see cref="System.Threading.ThreadPool.RegisterWaitForSingleObject"/>. This
      class cannot be inherited.
      </para>
		</summary>
		<threadsafe>
			<para>This type is safe for multithreaded operations.</para>
		</threadsafe>
		<example>
			<codelink SampleID="System.Threading.ThreadPool RegisterWaitForSingleObject0" SnippetID="1"/>
		</example>
		<seealso topic="cpconThreadPooling"/>
	</doc>
</docs>
