<docs>
	<doc for="String.IConvertible.ToBoolean">
		<summary>
			<para>Returns a Boolean value indicating whether the value of 
       this instance of <see langword="String"/>
       is <see langword="true"/> or <see langword="false"/>.</para>
		</summary>
		<returns>
			<para>A Boolean representation of this instance.</para>
		</returns>
		<remarks>
			<para>The value of this instance must be <see cref="System.Boolean.TrueString"/> or 
 <see cref="System.Boolean.FalseString"/>, with optional leading and trailing white space.</para>
		</remarks>
	</doc>
	<doc for="String.IConvertible.ToChar">
		<summary>
			<para>Converts a
       non-empty string of length one to a <see cref="System.Char"/>.</para>
		</summary>
		<returns>
			<para>The character at index 0 within value.</para>
		</returns>
		<remarks>
			<para>Implementation is the same as <see cref="System.Convert.ToChar"/>.
    (For additional information, see <see cref="System.Char"/> and <see cref="System.Convert"/>.)</para>
		</remarks>
	</doc>
	<doc for="String.IConvertible.ToSByte">
		<summary>
			<para>Converts an <see cref="System.SByte"/> to a string.</para>
		</summary>
		<returns>
			<para>The SByte representation of the string as a base number.</para>
		</returns>
		<exception cref="System.ArgumentException">If the string is not base 2, 8, 10, or 16.</exception>
		<exception cref="FormatException">If the string cannot be parsed as a base number.</exception>
		<exception cref="System.ArgumentNullException">If the string is null.</exception>
		<exception cref="System.OverflowException">If the string is greater than SByte.MaxValue or less than SByte.MinValue.</exception>
		<remarks>
			<para>If the number is base 16,
       the number may be preceded by "0x"; any other leading or trailing
       character causes an error.</para>
			<para>The <see langword="ToSByte"/> implementation is the same as <see cref="System.Convert.ToSByte"/>.
    (For additional information, see <see cref="System.SByte"/> and <see cref="System.Convert"/>.)</para>
		</remarks>
	</doc>
	<doc for="String.IConvertible.ToByte">
		<summary>
			<para>Returns an 8-bit unsigned integer equivalent to the number represented by 
       this instance of <see langword="String"/>. </para>
		</summary>
		<returns>
			<para>An 8-bit unsigned integer.</para>
		</returns>
		<exception cref="System.ArgumentException">If the string is not base 2, 8, 10, or 16.</exception>
		<exception cref="System.FormatException">If the string cannot be parsed as a base number.</exception>
		<exception cref="System.ArgumentNullException">If the string is null.</exception>
		<exception cref="System.OverflowException">If the string is greater than Byte.MaxValue or less than Byte.MinValue.</exception>
		<remarks>
			<para>If the number is
       base 16, the number may be preceded by "0x"; any other leading or
       trailing character causes an error.</para>
			<para>The ToByte implementation is the same as <see cref="System.Convert.ToByte"/>.
    (For additional information, see <see cref="System.Byte"/> and <see cref="System.Convert"/>.)</para>
		</remarks>
	</doc>
	<doc for="String.IConvertible.ToInt16">
		<summary>
			<para>Converts a specified string to an <see cref="System.Int16"/> in
    the specified base.</para>
		</summary>
		<returns>
			<para>The Int16
       representation of value as a base number.</para>
		</returns>
		<exception cref="System.ArgumentException">If the string is not base 2, 8, 10, or 16.</exception>
		<exception cref="System.ArgumentException">If the string is null.</exception>
		<exception cref="System.FormatException">If the string cannot be parsed as a base number or the value represented is greater than Int16.MaxValue or less than Int16.MinValue.</exception>
		<remarks>
			<para>If the string is base 16,
       the number may be preceded by "0x"; any other leading or trailing
       characters cause an error.</para>
			<para>The <see langword="ToInt16"/> implementation is the same as
 <see cref="System.Convert.ToInt16"/>.
    (For additional information, see <see cref="System.Int16"/> and <see cref="System.Convert"/>.)</para>
		</remarks>
	</doc>
	<doc for="String.IConvertible.ToUInt16">
		<summary>
			<para>Converts a string to a <see cref="System.UInt16"/>
 value.</para>
		</summary>
		<returns>
			<para>The UInt16
       representation of the string.</para>
		</returns>
		<exception cref="System.ArgumentException">If the string is not base 2, 8, 10, or 16.</exception>
		<exception cref="System.ArgumentException">If the string is null.</exception>
		<exception cref="System.FormatException">If the string cannot be parsed as a base number or the value represented is greater than UInt16.MaxValue or less than UInt16.MinValue.</exception>
		<remarks>
			<para>If the string is base 16,
       the number may be preceded by "0x"; any other leading or trailing
       characters cause an error.</para>
		</remarks>
	</doc>
	<doc for="String.IConvertible.ToInt32">
		<summary>
			<para>Converts a string to an <see cref="System.Int32"/>.</para>
		</summary>
		<returns>
			<para>An Int32
       with the value represented by value.</para>
		</returns>
		<remarks>
			<para>Implementation is the same as <see cref="System.Convert.ToInt32"/>.
    (For additional information, see <see cref="System.Int32"/> and <see cref="System.Convert"/>.)</para>
			<para>The string is parsed
    as a decimal unless it is preceded by "0x", in which case it is
    parsed as a hexadecimal number. White space or trailing characters will cause a
    FormatException.</para>
			<para>Note that if the
    beginning of the string value contains a properly formatted numerical value
    that will result in an OverflowException, and in
    addition, the end of the string is improperly formed, it cannot be determined whether an
    OverflowException or a FormatException
    will be thrown. This has been implemented this way for performance reasons.</para>
		</remarks>
	</doc>
	<doc for="String.IConvertible.ToUInt32">
		<summary>
			<para>Returns a 32-bit unsigned integer equivalent to the 
       number represented by this instance of <see langword="String"/>.</para>
		</summary>
		<returns>
			<para>A 32-bit unsigned integer.</para>
		</returns>
		<exception cref="System.ArgumentException">
			<para> This string is not base 2, 8, 10, or 16.</para>
			<para>-or-</para>
			<para>This string is <see langword="null"/>.</para>
		</exception>
		<exception cref="System.FormatException"> The string cannot be parsed or the value represented is greater than UInt32.MaxValue or less than UInt32.MinValue</exception>
		<remarks>
			<para>A string value can
       only be base 2, 8, 10, or 16. If the string is base 16, the number may be preceded
       by "0x"; any other leading or trailing characters cause an error.</para>
		</remarks>
	</doc>
	<doc for="String.IConvertible.ToInt64">
		<summary>
			<para>Converts a string to an <see cref="System.Int64"/>
 value.</para>
		</summary>
		<returns>
			<para>An Int64
       with the value represented by value.</para>
		</returns>
		<remarks>
			<para>The ToInt64
       implementation is the same as <see cref="System.Convert.ToInt64"/>.
       (For additional information, see <see cref="System.Int64"/> and <see cref="System.Convert"/>.)</para>
			<para>If the string is parsed as a decimal unless it is
       preceded by "0x", in which case it is parsed as a hexadecimal number. White
       space or trailing characters will cause a FormatException. The implementation is
       provided by <see cref="System.Int64.Parse"/>.</para>
			<para>Note that if the
       beginning of the string value contains a properly formatted numerical value
       that will result in an overflow and, in addition, the end of the string is
       improperly formed, it cannot be determined whether an OverflowException
       or a FormatException will be thrown. This has been
       implemented this way for performance reasons.</para>
		</remarks>
	</doc>
	<doc for="String.IConvertible.ToUInt64">
		<summary>
			<para>Converts a string to a <see cref="System.UInt64"/>
 value.</para>
		</summary>
		<returns>
			<para>The converted string.</para>
		</returns>
		<remarks>
			<para>The ToUInt64 implementation is the same as <see cref="System.Convert.ToUInt64"/>. (For additional information, see
    U<see cref="System.Int64"/> and <see cref="System.Convert"/>.)</para>
			<para>The string is parsed as a decimal unless it is preceded by "0x". In that
    case, it is parsed as a hexadecimal number.</para>
			<para>White space or trailing characters will cause a FormatException.</para>
			<para>Note that if the
    beginning of the string value contains a properly formatted numerical value
    that will result in an overflow and, in addition, the end of the string is
    improperly formed, it cannot be determined whether an OverflowException
    or a FormatException will be thrown. This has been
    implemented this way for performance reasons.</para>
		</remarks>
	</doc>
	<doc for="String.IConvertible.ToSingle">
		<summary>
			<para>Returns a string representing the specified number as a <see cref="System.Single"/>.</para>
		</summary>
		<returns>
			<para>The string represented as a Single.</para>
		</returns>
		<remarks>
			<para>The ToSingle implementation is the same as <see cref="System.Single.ToString"/>.
    (For additional information, see <see cref="System.Single"/> and <see cref="System.Convert"/>.)</para>
		</remarks>
	</doc>
	<doc for="String.IConvertible.ToDouble">
		<summary>
			<para>Converts a string to a <see cref="System.Double"/>.</para>
		</summary>
		<returns>
			<para>The Double
       with the value represented by value.</para>
		</returns>
		<exception cref="System.ArgumentException">If the string is null.</exception>
		<exception cref="System.FormatException">If the string does not contain a representation that can be converted to a Double using the Parse(String) method implemented by that type.</exception>
		<exception cref="System.OverflowException">If the string represents a number that is less than Double.MaxValue or greater than Double.MinValue.</exception>
		<remarks>
			<para>The <see langword="ToDouble"/> implementation is the same as <see cref="System.Double.Parse"/> and
 <see cref="System.Convert.ToDouble"/>. (For additional
    information, see <see cref="System.Double"/> and <see cref="System.Convert"/>.)</para>
		</remarks>
		<seealso cref="System.Double"/>
	</doc>
	<doc for="String.IConvertible.ToDecimal">
		<summary>
			<para>Converts a string to a <see cref="System.Decimal"/>.</para>
		</summary>
		<returns>
			<para>The Decimal
       with the value represented by value.</para>
		</returns>
		<exception cref="System.ArgumentException">If the string is null.</exception>
		<exception cref="System.FormatException">If the string does not contain a representation that can be converted to a Decimal using the Parse(String) method implemented by that type.</exception>
		<exception cref="System.OverflowException">If the string represents a number that is less than Decimal.MaxValue or greater than Decimal.MinValue.</exception>
		<remarks>
			<para>The ToDecimal implementation is the same as <see cref="System.Decimal.Parse"/> and
 <see cref="System.Convert.ToDecimal"/>. (In addition
    information, see <see cref="System.Decimal"/> and <see cref="System.Convert"/>.)</para>
			<para>Note that if the beginning
    of the string contains a properly formatted numerical value that will
    result in an overflow, and in addition, the end of the string is improperly
    formed, it cannot be determined whether an OverflowException
    or a FormatException will be thrown. This has been
    implemented this way for performance reasons.</para>
		</remarks>
	</doc>
	<doc for="String.IConvertible.ToDateTime">
		<summary>
			<para>
       Returns the specified
       string converted to <see cref="System.DateTime"/>
       format.
    </para>
		</summary>
		<returns>
			<para>
       The string formatted
       as a DateTime type.
    </para>
		</returns>
		<remarks>
			<para>
       The ToDateTime implementation is the same as <see cref="System.DateTime.Parse"/> and
    <see cref="System.Convert.ToDateTime"/> (In addition
       information, see <see cref="System.DateTime"/> and <see cref="System.Convert"/>.)
    </para>
		</remarks>
	</doc>
	<doc for="String.IConvertible.ToType">
		<summary>
			<para>
       Retrieves the <see cref="System.Type"/> for a specified object.
    </para>
		</summary>
		<param name="type">
    The Type of the object.
 </param>
		<returns>
			<para>
       The Type
       identification of the specified object.
    </para>
		</returns>
		<exception cref="System.InvalidCastException">
    If it is the wrong type.
 </exception>
		<remarks>
			<para>
       The ToType
       method accesses the Type class to return the classification of an object,
       whether it is a class, a interface, an enumeration, a method, a property, or a
       field.
    </para>
		</remarks>
	</doc>
	<doc for="String.GetEnumerator">
		<summary>
			<para>Retrieves an object that can iterate through the
 individual characters in this instance.</para>
		</summary>
		<returns>
			<para>A <see cref="System.CharEnumerator"/> object.</para>
		</returns>
		<remarks>
			<para>This method is required by programming languages that
 support the <see cref="System.Collections.IEnumerator"/> interface to iterate through members of a
 collection. For example, the Microsoft Visual Basic and C# programming languages'
 <see langword="foreach"/> 
 statement invokes this method to return a <see cref="System.CharEnumerator"/> object that can provide read-only
 access to the characters in this instance of <see cref="System.String"/>.</para>
		</remarks>
		<seealso cref="System.Collections.IEnumerator"/>
		<seealso cref="System.Collections.IEnumerable"/>
		<seealso cref="System.String.this"/>
	</doc>
	<doc for="String.operatorEQ">
		<overload>
			<para> Determines whether two specified instances of 
 <see cref="System.String"/> or <see cref="System.Object"/> have the
 same value.</para>
		</overload>
		<summary>
			<para> Determines whether two specified <see cref="System.String"/> objects have the
 same value.</para>
		</summary>
		<altmember cref="System.String.Equals"/>
		<param name="a">A <see cref="System.String"/> or <see langword="null"/>.</param>
		<param name="b">A <see cref="System.String"/> or <see langword="null"/>.</param>
		<returns>
			<para><see langword="true"/> if the value of <paramref name="a"/> is the same as the value of <paramref name="b"/>; otherwise, <see langword="false"/>.</para>
		</returns>
		<remarks>
			<para> This operator is implemented using the <see cref="System.String.Equals"/> method,
 which means the comparands are tested for a combination of reference and
 value equality. The comparison
 is case-sensitive.</para>
		</remarks>
	</doc>
	<doc for="String.Substring1">
		<summary>
			<para>Retrieves a substring from this instance. The substring starts at a specified character position and has a specified
 length.</para>
		</summary>
		<param name="startIndex">The index of the start of the substring.</param>
		<param name="length">The number of characters in the substring.</param>
		<returns>
			<para>A <see cref="System.String"/> equivalent
 to the substring of length <paramref name="length"/> that begins at <paramref name="startIndex"/> in this instance.</para>
			<para>-or-</para>
			<para><see cref="System.String.Empty"/> if
<paramref name="startIndex "/>is equal to the length of this instance and 
<paramref name="length"/> is zero.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="startIndex "/>plus<paramref name=" length"/> indicates a position not within this instance.</para>
			<para>-or-</para>
			<para>
				<paramref name="startIndex"/> or <paramref name="length"/> is less than zero.</para></exception>
		<remarks>
			<para><paramref name="startIndex"/> is zero-based.</para>
		</remarks>
		<example>
			<codelink SampleID="Classic String.Substring1 Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.Concat"/>
		<seealso cref="System.String.Insert"/>
		<seealso cref="System.String.Join"/>
		<seealso cref="System.String.Remove"/>
		<seealso cref="System.String.Replace"/>
		<seealso cref="System.String.Split"/>
		<seealso cref="System.String.Trim"/>
	</doc>
	<doc for="String.ToString1">
		<summary>
			<para>Returns this instance of <see cref="System.String"/>; no
 actual conversion is performed.</para>
		</summary>
		<param name="provider">(Reserved) An <see cref="System.IFormatProvider"/> that supplies culture-specific formatting information.</param>
		<returns>
			<para>This <see cref="System.String"/>.</para>
		</returns>
		<remarks>
			<para><paramref name="provider"/> is reserved, and does not
 currently participate in this operation.</para>
		</remarks>
	</doc>
	<doc for="String.IEnumerable.GetEnumerator">
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc><doc for="String.operatorNE">
		<overload>
			<para> Determines whether two specified instances of
      <see cref="System.String"/> or <see cref="System.Object"/> have
      different values.</para>
		</overload>
		<summary>
			<para> Determines whether two specified <see cref="System.String"/> objects have
   different values.</para>
		</summary>
		<altmember cref="System.String.Equals"/>
		<param name="a">A <see langword="String"/> or <see langword="null"/>.</param>
		<param name="b">A <see langword="String"/> or <see langword="null"/>.</param>
		<returns>
			<para><see langword="true"/> if the value of <paramref name="a"/> is different from the value of <paramref name="b"/>; otherwise, <see langword="false"/>.</para>
		</returns>
		<remarks>
			<para>This operator is implemented using the <see cref="System.String.Equals"/> method, which means the comparands are tested for a combination of reference and value equality. The comparison is case-sensitive.</para>
		</remarks>
	</doc><doc for="String.Empty">
		<summary>
			<para> Represents the empty string. This field is read-only.</para>
		</summary>
		<remarks>
			<para>The value of this field is the zero-length string, "".</para>
		</remarks>
		<example>
			<para>The following examples demonstrate how the <see cref="System.String.Empty"/> field can be used. </para>
			<para>In the first example, the <see cref="System.String.Empty"/> string is returned as a default value 
if the value of another field is <see langword="null"/>.</para>
			<codelink SampleID="DataBinding" SnippetID="1"/>
			<para>In the second example, the <see cref="System.String.Empty"/> string is used in <see cref="System.String.Compare"/> to test a 
substring.</para>
			<codelink SampleID="Classic String.Substring1 Example" SnippetID="1"/>
			<para>In the third example, the <see cref="System.String.Empty"/> string is used in the decision block 
of the <see langword="XPathNavigator"/> to make decisions about XML parsing.</para>
			<codelink SampleID="XPathNavigator.MoveToNext" SnippetID="1"/>
		</example>
	</doc>
	<doc for="String.CopyTo">
		<summary>
			<para>Copies a specified number of characters from a specified
      position in this instance
      to a specified position in an array of Unicode characters.</para>
		</summary>
		<param name="sourceIndex">A character position in this instance.</param>
		<param name="destination">An array of Unicode characters.</param>
		<param name="destinationIndex">An array element in <paramref name="destination"/>.</param>
		<param name="count">The number of characters in this instance to copy to <paramref name="destination"/>.</param>
		<exception cref="System.ArgumentNullException"><paramref name="destination"/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para>
				<paramref name="sourceIndex"/>, <paramref name="destinationIndex"/>, or <paramref name="count"/> is negative</para>
			<para>-or-</para>
			<para>
				<paramref name="count"/> is greater than the length of the substring from <paramref name="startIndex"/> to the end of this instance </para>
			<para>-or-</para>
			<para>
				<paramref name="count"/> is greater than the length of the subarray from <paramref name="destinationIndex"/> to the end of <paramref name="destination"/></para></exception>
		<remarks>
			<para><paramref name="count"/> characters are copied from the
<paramref name="sourceIndex"/> position of this instance to the <paramref name="destinationIndex"/>
position of <paramref name="destination"/>.</para>
			<para><paramref name="sourceIndex"/> and <paramref name="destinationIndex"/> are
zero-based.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates the <see cref="System.String.CopyTo"/>method.</para>
			<codelink SampleID="stringcopyto" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.Insert"/>
		<seealso cref="System.String.Substring"/>
	</doc>
	<doc for="String.Insert">
		<summary>
			<para> Inserts a specified instance of <see cref="System.String"/> at a specified
   index position in this instance.
   </para>
		</summary>
		<param name="startIndex">The index position of the insertion. </param>
		<param name="value">The <see cref="System.String"/> to insert. </param>
		<returns>
			<para> A new <see cref="System.String"/> equivalent to this instance
   but with <paramref name="value"/> inserted at position <paramref name="startIndex"/>.
   </para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>. </exception>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="startIndex"/> is negative or greater than the length of this instance. </para></exception>
		<remarks>
			<para>If <paramref name="startIndex"/> is equal to the length of this instance,
<paramref name="value"/> is appended to the end of this instance.</para>
			<para>For example, the return value of <c>"abc".Insert(2, "XYZ")</c> is "abXYZc".</para>
		</remarks>
		<example>
			<para>The following console application provides a simple demonstration of 
      the <see cref="System.String.Insert"/> method.</para>
			<codelink SampleID="stringinsert" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.Concat"/>
		<seealso cref="System.String.CopyTo"/>
		<seealso cref="System.String.Insert"/>
		<seealso cref="System.String.Join"/>
		<seealso cref="System.String.Remove"/>
		<seealso cref="System.String.Replace"/>
		<seealso cref="System.String.Split"/>
		<seealso cref="System.String.Substring"/>
		<seealso cref="System.String.Trim"/>
	</doc>
	<doc for="String.PadRight">
		<overload>
			<para>Left-aligns the characters in this string, padding on the right with spaces or a specified Unicode character,
      for a specified total length.</para>
		</overload>
		<summary>
			<para>Left-aligns the characters in this string, padding with spaces on the right,
      for a specified total length.</para>
		</summary>
		<param name="totalWidth">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</param>
		<returns>
			<para>A new <see cref="System.String"/> that
   is equivalent to this
   instance, but left-aligned and padded on the right with as many spaces as
   needed to create a length of <paramref name="totalWidth"/>.</para>
			<para>-or-</para>
			<para>If <paramref name="totalWidth "/>is less than
the length of this instance, a new <see cref="System.String"/> that is identical
to this instance.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="totalWidth "/>is less than zero.</exception>
		<remarks>
			<para>A Unicode space is defined as hexadecimal 0x20.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates the <see cref="System.String.PadRight"/> method.</para>
			<codelink SampleID="Classic String.PadRight Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.PadLeft"/>
		<seealso cref="System.String.Trim"/>
	</doc>
	<doc for="String.PadRight1">
		<summary>
			<para>Left-aligns the characters in this string, padding on the right with a specified
      Unicode character, for a specified total length.</para>
		</summary>
		<param name="totalWidth">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters. </param>
		<param name="paddingChar">A Unicode padding character.</param>
		<returns>
			<para>A new <see cref="System.String"/> that
   is equivalent to this
   instance, but left-aligned and padded on the right with as many
<paramref name="paddingChar"/> characters as needed to create a length of 
<paramref name="totalWidth"/>.</para>
			<para>-or-</para>
			<para>If <paramref name="totalWidth "/>is less than
the length of this instance, a new <see cref="System.String"/> that is identical
to this instance.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="totalWidth"/> is less than zero.</exception>
		<example>
			<para>The following code example demonstrates the <see cref="System.String.PadRight"/> method.</para>
			<codelink SampleID="Classic String.PadRight1 Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.PadLeft"/>
		<seealso cref="System.String.Trim"/>
	</doc>
	<doc for="String.Split">
		<overload>
			<para>Identifies the substrings in this instance that are
      delimited by one or more characters specified in an array, then places the
      substrings into a <see cref="System.String"/>
      array.</para>
		</overload>
		<summary>
			<para>Identifies the substrings in this instance that are
      delimited by one or more characters specified in an array, then places the
      substrings into a <see cref="System.String"/> array.</para>
		</summary>
		<param name="separator">An array of Unicode characters that delimit the substrings in this instance, an empty array containing no delimiters, or <see langword="null"/>.</param>
		<returns>
			<para>An array consisting of a single element containing this instance, if
      this instance contains none of the characters in <paramref name="separator"/>.</para>
			<para>-or-</para>
			<para>An array of substrings if this instance is delimited by one or more
      of the characters in <paramref name="separator"/>. </para>
			<para>-or-</para>
			<para>An array of the substrings in this instance delimited by white space
      characters if those characters occur and <paramref name="separator"/> is
   <see langword="null"/>
   or contains no delimiter characters.</para>
			<para><see cref="System.String.Empty"/> is returned for any substring where two delimiters are
adjacent, or a delimiter is found at the beginning or end of this
instance.</para>
			<para>Delimiter characters are not included in the substrings.</para>
		</returns>
		<remarks>
			<para> For example:</para>
			<list type="table">
				<listheader>
					<term>Input</term>
					<description>separator</description>
					<description>Output</description>
				</listheader>
				<item>
					<term> "42,
            12, 19"</term>
					<description> new Char[] {',', ' '} </description>
					<description> {"42", "", "12", "", "19"} </description>
				</item>
				<item>
					<term> "42..12..19"</term>
					<description>new Char[] {'.'} </description>
					<description>{"42", "", "12", "", "19"} </description>
				</item>
				<item>
					<term> "Banana"</term>
					<description>new Char[] {'.'}</description>
					<description>{"Banana"} </description>
				</item>
				<item>
					<term> "Darb\nSmarba"</term>
					<description>new Char[] {}</description>
					<description>{"Darb", "Smarba"}</description>
				</item>
				<item>
					<term> "Darb\nSmarba"</term>
					<description>null</description>
					<description>{"Darb", "Smarba"}</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following code example demonstrates how you can tokenize a string with 
      the <see cref="System.String.Split"/> method.</para>
			<codelink SampleID="stringsplit" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.String.Concat"/>
		<seealso cref="System.String.Insert"/>
		<seealso cref="System.String.Join"/>
		<seealso cref="System.String.Remove"/>
		<seealso cref="System.String.Replace"/>
		<seealso cref="System.String.Substring"/>
		<seealso cref="System.String.Trim"/>
	</doc>
	<doc for="String.String5">
		<summary>
			<para>Initializes a new instance of the <see cref="System.String"/>
class to the value indicated by an array of Unicode characters.</para>
		</summary>
		<param name="value">An array of Unicode characters.</param>
		<remarks>
			<para>If value is <see langword="null"/>
or contains no element, an <see cref="System.String.Empty"/> instance is
initialized.</para>
		</remarks>
		<example>
			<para>The following simple code example demonstrates how you can create an instance 
      of the <see cref="System.String"/> class with this constructor.</para>
			<codelink SampleID="stringexample1" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
	</doc>
	<doc for="String.String6">
		<summary>
			<para>Initializes a new instance of the <see cref="System.String"/> class to the value indicated by a specified Unicode character
   repeated a
   specified number of times.</para>
		</summary>
		<param name="c">A Unicode character. </param>
		<param name=" count">The number of times <paramref name="c"/> occurs. </param>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="count"/> is less than zero.</exception>
		<remarks>
			<para>If <paramref name="count"/> is zero, an
<see cref="System.String.Empty"/> instance is initialized.</para>
		</remarks>
		<example>
			<para>The following simple code example demonstrates how you can create an instance 
      of the <see cref="System.String"/>
      class with this constructor.</para>
			<codelink SampleID="stringexample1" SnippetID="3"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
	</doc>
	<doc for="String.String7">
		<summary>
			<para>Initializes a new instance of the <see cref="System.String"/> class to the value indicated by an array of Unicode characters,
   a starting character position within that array,
   and a length.</para>
		</summary>
		<param name="value">An array of Unicode characters.</param>
		<param name="startIndex">The starting position within <paramref name="value"/>.</param>
		<param name="length">The number of characters within <paramref name="value"/> to use.</param>
		<exception cref="System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="startIndex"/> or <paramref name="length"/> is less than zero.</para>
			<para>-or-</para>
			<para>The sum of <paramref name="startIndex"/> and <paramref name="length"/> is greater than the number of elements in <paramref name="value"/>.</para></exception>
		<remarks>
			<para>If <paramref name="length"/> is zero, an <see cref="System.String.Empty"/> instance is initialized.</para>
			<para>This constructor copies Unicode characters from <paramref name="value"/>, starting at
<paramref name="startIndex"/> and ending at (<paramref name="startIndex"/> + <paramref name="length"/> - 1).</para>
		</remarks>
		<example>
			<para>The following simple code example demonstrates how you can create an instance
      of the <see cref="System.String"/>
      class with this constructor.</para>
			<codelink SampleID="stringexample1" SnippetID="3"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
	</doc>
	<doc for="String.PadLeft">
		<overload>
			<para>Right-aligns the characters in this instance, padding on the left with spaces or a specified Unicode character
      for a specified total length.</para>
		</overload>
		<summary>
			<para>Right-aligns the characters in this instance, padding with spaces on the left
      for a specified total length.</para>
		</summary>
		<param name="totalWidth">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</param>
		<returns>
			<para> A new <see cref="System.String"/> that
   is equivalent to this
   instance, but right-aligned and padded on the left with as many spaces as
   needed to create a length of <paramref name="totalWidth"/>.</para>
			<para>-or-</para>
If <paramref name="totalWidth"/> is less than
the length of this instance, a new <see langword="String"/> that is identical to
this instance.
</returns>
		<exception cref="System.ArgumentException"><paramref name="totalWidth "/> is less than zero.</exception>
		<remarks>
			<para>A Unicode space is defined as hexadecimal 0x20.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates the <see cref="System.String.PadLeft"/>
method.</para>
			<codelink SampleID="Classic String.PadLeft Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.PadRight"/>
		<seealso cref="System.String.Trim"/>
	</doc>
	<doc for="String.PadLeft1">
		<summary>
			<para>Right-aligns the characters in this instance, padding on the left with a specified
      Unicode character for a specified total length.</para>
		</summary>
		<param name="totalWidth">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters. </param>
		<param name="paddingChar">A Unicode padding character.</param>
		<returns>
			<para>A new <see cref="System.String"/> that
   is
   equivalent to
   this instance, but right-aligned and padded on the left with as many
<paramref name="paddingChar"/> characters as needed to create a length of 
<paramref name="totalWidth"/>.</para>
			<para>-or-</para>
If <paramref name="totalWidth"/> is
less than the length of this instance, a new <see cref="System.String"/> that is identical to
this instance.
</returns>
		<exception cref="System.ArgumentException"><paramref name="totalWidth"/> is less than zero.</exception>
		<example>
			<para>The following code example demonstrates the <see cref="System.String.PadLeft"/> method.</para>
			<codelink SampleID="Classic String.PadLeft1 Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.PadRight"/>
		<seealso cref="System.String.Trim"/>
	</doc>
	<doc for="String.GetHashCode">
		<summary>
			<para>Returns the hash code for this instance.</para>
		</summary>
		<returns>
			<para>A 32-bit signed integer hash code.</para>
		</returns>
		<remarks>
			<para>The behavior of <see cref="System.String.GetHashCode"/> is dependent on its implementation, which might change 
   from one version of the common language runtime to another. A reason why this
   might happen is to improve the performance of <see cref="System.String.GetHashCode"/>. If
   you require the behavior of <see cref="System.String.GetHashCode"/> be constant, override the runtime implementation
   of <see cref="System.String.GetHashCode"/>
   with an implementation of your own that you know
   will never change.</para>
		</remarks>
		<seealso cref="System.Int32"/>
	</doc>
	<doc for="String.Clone">
		<summary>
			<para>Returns a reference to this instance of <see cref="System.String"/>.</para>
		</summary>
		<returns>
			<para>This instance of <see langword="String"/>.</para>
		</returns>
		<remarks>
			<para>The return value is not an independent copy of this
      instance; it is simply another view of the same data. Use the <see cref="System.String.Copy"/> or <see cref="System.String.CopyTo"/> method to create a separate <see cref="System.String"/> object with the
      same value as this instance.</para>
		</remarks>
		<example>
			<para>The following simple code example demonstrates 
      the <see cref="System.String.Clone"/> method.</para>
			<codelink SampleID="stringexample1" SnippetID="3"/>
		</example>
		<seealso cref="System.Object"/>
		<seealso cref="System.String.Copy"/>
		<seealso cref="System.String.CopyTo"/>
	</doc>
	<doc for="String.Format1">
		<summary>
			<para>Replaces the format item in a specified
   <see cref="System.String"/> with the text
      equivalent of the value of two specified <see cref="System.Object"/> instances.</para>
		</summary>
		<param name="format">A <see cref="System.String"/> containing zero or more format items.</param>
		<param name="arg0">The first <see cref="System.Object"/> to format.</param>
		<param name="arg1">The second <see cref="System.Object"/> to format.</param>
		<returns>
			<para>A copy of <paramref name="format"/> in which
   the first and second format items have been replaced by the
<see cref="System.String"/> equivalents of <paramref name="arg0"/> and <paramref name="arg1"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="format "/>is <see langword="null"/>.</exception>
		<exception cref="System.FormatException"><para><paramref name="format "/>is invalid.</para>
			<para>-or-</para>
			<para> The number indicating an argument to format is less than zero, or greater than or equal to the number of specified objects to format.</para></exception>
		<remarks>
			<para>For more information about formatting, see <see topic="cpConFormattingTypes"/> and <see topic="cpConFormattingOverview"/>. For more information about the
   composite formatting feature supported by <see cref="System.String.Format"/>, see <see topic="cpConCompositeFormatting"/>.</para>
			<para> The <paramref name="format"/> parameter is
embedded with zero or more format items of the form,
{index[,alignment][:formatString]}, where: </para>
			<list type="termdef">
				<item>
					<term> index </term>
					<description>A zero-based integer that indicates which
         element in a list of objects to format. If the object specified by index
         is <see langword="null"/>, then the format item is replaced by the empty
         string ("").</description>
				</item>
				<item>
					<term> alignment </term>
					<description>An 
         optional integer indicating the minimum width of the region to contain
         the formatted value. If the length of the formatted value is less than alignment,
         then the region is padded with spaces. If alignment is negative, the
         formatted value is left justified in the region; if alignment is positive,
         the formatted value is right justified. If alignment is not specified,
         the length of the region is the length of the formatted value. The
         comma is required if alignment is specified.</description>
				</item>
				<item>
					<term> formatString </term>
					<description>An optional string of formatting codes. If
         formatString is not specified and the corresponding argument implements
         the <see cref="System.IFormattable"/> interface, then <see langword="null"/> is used as
         the <see cref="System.IFormattable.ToString " qualify="true"/> format string. Therefore, all
         implementations of <see cref="System.IFormattable.ToString " qualify="true"/> are required to allow
      <see langword="null"/> as a format string, and return default formatting of
         the object representation as a <see cref="System.String"/>. The colon is required if
         formatString is specified. </description>
				</item>
			</list>
			<para>The leading and trailing brace characters, '{' and '}',
   are required. To specify a single literal brace character in <paramref name="format"/>, specify two
   leading or trailing brace characters; that is, "{{" or "}}".</para>
			<para>If the value of <paramref name="format"/> is, "Thank you for your purchase of {0:####}
copies of Microsoft® .NET (Core Reference).", and <paramref name="arg0"/> is an <see cref="System.Int16"/> with the value
123, then the return value will be:</para>
			<para>"Thank you for your purchase of 123 copies of Microsoft® .NET (Core Reference)." </para>
			<para>If the value of <paramref name="format"/> is, "Brad's dog has {0,-8:G} fleas.", <paramref name="arg0
"/>is an <see cref="System.Int16"/> with the value 42, (and in this example, underscores
represent padding spaces) then the return
value will be: </para>
			<para>"Brad's dog has 42______ fleas."</para>
		</remarks>
		<example>
			<para>The following example demonstrates formatting multiple values.</para>
			<codelink SampleID="CallContext" SnippetID="2"/>
		</example>
		<seealso cref="System.Object"/>
		<seealso topic="cpConFormattingOverview"/>
		<seealso topic="cpConFormattingTypes"/>
	</doc>
	<doc for="String.Format2">
		<summary>
			<para>Replaces the format item in a specified
   <see cref="System.String"/> with the text
      equivalent of the value of three specified <see cref="System.Object"/> instances.</para>
		</summary>
		<param name="format">A <see cref="System.String"/> containing zero or more format items.</param>
		<param name="arg0">The first <see cref="System.Object"/> to format.</param>
		<param name="arg1">The second <see cref="System.Object"/> to format.</param>
		<param name="arg2">The third <see cref="System.Object"/> to format.</param>
		<returns>
			<para>A copy of <paramref name="format"/> in which
   the first, second, and third format items have been replaced by the
<see cref="System.String"/> equivalents of <paramref name="arg0"/>, <paramref name="arg1"/>, and<paramref name=" arg2"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="format "/>is <see langword="null"/>.</exception>
		<exception cref="System.FormatException"><para><paramref name="format "/>is invalid.</para>
			<para>-or-</para>
			<para>The number indicating an argument to format is less than zero, or greater than or equal to the number of specified objects to format.</para></exception>
		<remarks>
			<para>For more information about formatting, see <see topic="cpConFormattingTypes"/> and <see topic="cpConFormattingOverview"/>. For more information about the
   composite formatting feature supported by <see cref="System.String.Format"/>, see <see topic="cpConCompositeFormatting"/>.</para>
			<para> The <paramref name="format"/> parameter is
embedded with zero or more format items of the form,
{index[,alignment][:formatString]}, where: </para>
			<list type="termdef">
				<item>
					<term> index </term>
					<description>A zero-based integer that indicates which
         element in a list of objects to format. If the object specified by index
         is <see langword="null"/>, then the format item is replaced by the empty
         string ("").</description>
				</item>
				<item>
					<term> alignment </term>
					<description>An 
         optional integer indicating the minimum width of the region to contain
         the formatted value. If the length of the formatted value is less than alignment,
         then the region is padded with spaces. If alignment is negative, the
         formatted value is left justified in the region; if alignment is positive,
         the formatted value is right justified. If alignment is not specified,
         the length of the region is the length of the formatted value. The
         comma is required if alignment is specified.</description>
				</item>
				<item>
					<term> formatString </term>
					<description>An optional string of formatting codes. If
         formatString is not specified and the corresponding argument implements
         the <see cref="System.IFormattable"/> interface, then <see langword="null"/> is used as
         the <see cref="System.IFormattable.ToString " qualify="true"/> format string. Therefore, all
         implementations of <see cref="System.IFormattable.ToString " qualify="true"/> are required to allow
      <see langword="null"/> as a format string, and return default formatting of
         the object representation as a <see cref="System.String"/>. The colon is required if
         formatString is specified. </description>
				</item>
			</list>
			<para>The leading and trailing brace characters, '{' and '}',
   are required. To specify a single literal brace character in <paramref name="format"/>, specify two
   leading or trailing brace characters; that is, "{{" or "}}".</para>
			<para>If the value of <paramref name="format"/> is, "Thank you for your purchase of {0:####}
copies of Microsoft® .NET (Core Reference).", and <paramref name="arg0"/> is an <see cref="System.Int16"/> with the value
123, then the return value will be:</para>
			<para>"Thank you for your purchase of 123 copies of Microsoft® .NET (Core Reference)." </para>
			<para>If the value of <paramref name="format"/> is, "Brad's dog has {0,-8:G} fleas.", <paramref name="arg0
"/>is an <see cref="System.Int16"/> with the value 42, (and in this example, underscores
represent padding spaces) then the return
value will be: </para>
			<para>"Brad's dog has 42______ fleas."</para>
		</remarks>
		<example>
			<para>The following example demonstrates formatting multiple values.</para>
			<codelink SampleID="CallContext" SnippetID="2"/>
		</example>
		<seealso cref="System.Object"/>
		<seealso topic="cpConFormattingOverview"/>
		<seealso topic="cpConFormattingTypes"/>
	</doc>
	<doc for="String.Length">
		<summary>
			<para> Gets the number of characters in this instance.</para>
		</summary>
		<value>
			<para>The number of characters in this instance.</para>
		</value>
		<remarks>
			<para>The <see cref="System.String.Length"/> property returns the number of <see cref="System.Char"/> objects in this 
   instance, not the number of Unicode characters. The reason is that a Unicode
   character might be represented by more than one <see cref="System.Char"/>. Use the <see cref="System.Globalization.StringInfo" qualify="true"/> class to work with each Unicode character
   instead of each <see cref="System.Char"/>.</para>
		</remarks>
		<seealso cref="System.Int32"/>
	</doc>
	<doc for="String.String4">
		<summary>
			<para>Initializes a new instance of the <see cref="System.String"/> class to the
   value indicated by a specified pointer to an array of 8-bit signed integers, a
   starting character position within that array, a length, and an <see cref="System.Text.Encoding"/>
   object.</para>
		</summary>
		<param name="value">A pointer to an array of 8-bit signed integers.</param>
		<param name="startIndex">The starting position within <paramref name="value"/>.</param>
		<param name="length">The number of characters within <paramref name="value"/> to use.</param>
		<param name=" enc">An <see cref="System.Text.Encoding"/> object that specifies how the array referenced by <paramref name="value"/> is encoded.</param>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="startIndex"/> or <paramref name="length"/> is less than zero.</para></exception>
		<exception cref="System.ArgumentException"><para><paramref name="value"/> + <paramref name="startIndex"/> is less than 64K.</para>
			<para>-or-</para>
			<para>A new instance of <see cref="System.String"/> could not be initialized using <paramref name="value"/> and the current code page.</para></exception>
		<remarks>
			<para>If <paramref name="value"/> is a null pointer or <paramref name="length"/>
is zero, the new instance is initialized to the empty string ("").</para>
		</remarks>
		<example>
			<para>The following simple code example demonstrates how you can create an instance
      of a UTF-8 <see cref="System.String"/> with this constructor.</para>
			<codelink SampleID="stringexample1" SnippetID="4"/>
		</example>
		<seealso cref="System.SByte"/>
		<seealso cref="System.Int32"/>
	</doc>
	<doc for="String.ToUpper">
		<overload>
			<para>Returns a copy of this <see cref="System.String"/> in uppercase.</para>
		</overload>
		<summary>
			<para>Returns a copy of this <see cref="System.String"/> in uppercase, using the casing 
   rules of the current culture.</para>
		</summary>
		<returns>
			<para>A <see cref="System.String"/>
in uppercase.</para>
		</returns>
		<remarks>
			<para> This method takes into account the current culture. For more information, see the <see cref="System.Globalization.CultureInfo"/> topic.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates how you can make a <see cref="System.String"/> comparison
   case-insensitive using the <see cref="System.String.ToUpper"/> method.</para>
			<codelink SampleID="stringexample1" SnippetID="2"/>
		</example>
		<seealso cref="System.String.ToLower"/>
	</doc>
	<doc for="String.StartsWith">
		<summary>
			<para> Determines whether the beginning of this instance
      matches the specified <see cref="System.String"/>.</para>
		</summary>
		<param name="value">The <see cref="System.String"/> to seek. </param>
		<returns>
			<para><see langword="true"/> if <paramref name="value"/> matches the
   beginning of this string or is <see cref="System.String.Empty"/>; otherwise <see langword="false"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>. </exception>
		<remarks>
			<para> This method makes a comparison at the
      beginning of the string, determines whether it matches this current instance,
      and returns a <see cref="System.Boolean"/>
      representation of their relationship.
      The specified string must match the prefix or be an empty string (that is, equals
   <see cref="System.String.Empty"/>). </para>
			<para>This method performs a word (case-sensitive and culture-sensitive) search 
      using the current culture.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates how you can use
      the <see cref="System.String.StartsWith"/> method. </para>
			<codelink SampleID="stringstartswith" SnippetID="1"/>
		</example>
		<seealso cref="System.String.EndsWith"/>
	</doc>
	<doc for="String.Concat4">
		<summary>
			<para>Concatenates the <see cref="System.String"/> representations of the elements in a specified <see cref="System.Object"/> array.</para>
		</summary>
		<param name="args">An <see cref="System.Object"/> array.</param>
		<returns>
			<para>The concatenated <see cref="System.String"/> representations of the values of the
   elements in <paramref name="args"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="args"/> is <see langword="null"/>.</exception>
		<remarks>
			<para>An <see cref="System.String.Empty"/> string is
   used in place of any null object in the array.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates the use of the <see cref="System.String.Concat"/> method
   with an <see cref="System.Object"/> array.</para>
			<codelink SampleID="stringconcat1" SnippetID="1"/>
		</example>
		<seealso cref="System.Object"/>
		<seealso cref="System.String.Join"/>
	</doc>
	<doc for="String.Concat6">
		<summary>
			<para>Concatenates three specified instances of
   <see cref="System.String"/>.</para>
		</summary>
		<param name="str0">The first <see cref="System.String"/>.</param>
		<param name="str1">The second <see cref="System.String"/>.</param>
		<param name="str2">The third <see cref="System.String"/>.</param>
		<returns>
			<para>The concatenation of <paramref name="str0"/>, <paramref name="str1"/>, and
<paramref name="str2"/>.</para>
		</returns>
		<remarks>
			<para>An <see cref="System.String.Empty"/> string is used in place of any null argument.</para>
		</remarks>
		<example>
			<para>In the following code example, the output to the Console is generated using
      this <see cref="System.String.Concat"/> method. </para>
			<codelink SampleID="Classic DateTime.ToString2 Example" SnippetID="1"/>
		</example>
		<seealso cref="System.String.Join"/>
	</doc>
	<doc for="String.Concat7">
		<summary>
			<para>Concatenates four specified instances of <see cref="System.String"/>.</para>
		</summary>
		<param name="str0">The first <see cref="System.String"/>.</param>
		<param name="str1">The second <see cref="System.String"/>.</param>
		<param name="str2">The third <see cref="System.String"/>.</param>
		<param name=" str3">The fourth <see cref="System.String"/>.</param>
		<returns>
			<para>The concatenation of <paramref name="str0"/>, <paramref name="str1"/>, <paramref name="str2"/>, and <paramref name="str3"/>.</para>
		</returns>
		<remarks>
			<para>An <see cref="System.String.Empty"/> string is used in place of any null object in the array.</para>
		</remarks>
		<example>
			<para>In the following code example the DataBinding output is generated using
      this <see cref="System.String.Concat"/> method.</para>
			<codelink SampleID="DataBinding" SnippetID="10"/>
		</example>
		<seealso cref="System.String.Join"/>
	</doc>
	<doc for="String.Concat8">
		<summary>
			<para>Concatenates the elements of a specified
   <see cref="System.String"/> array.</para>
		</summary>
		<param name="values">An array of <see cref="System.String"/> instances.</param>
		<returns>
			<para> The concatenated elements of <paramref name="values"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="values"/> is <see langword="null"/>.</exception>
		<remarks>
			<para>An <see cref="System.String.Empty"/> string is used in place of any null object in the array.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates the use of the <see cref="System.String.Concat"/> method with
   a <see cref="System.String"/>
   array.</para>
			<codelink SampleID="stringconcat3" SnippetID="1"/>
		</example>
		<seealso cref="System.String.Join"/>
	</doc>
	<doc for="String.EndsWith">
		<summary>
			<para>Determines whether the end of this instance matches the
      specified <see cref="System.String"/>.</para>
		</summary>
		<param name="value">A <see cref="System.String"/>.</param>
		<returns>
			<para><see langword="true"/> if the end of
   this instance matches <paramref name="value"/>; otherwise, <see langword="false "/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
		<remarks>
			<para> This method compares <paramref name="value"/> with the substring
   at the end of the current instance that has a length of
<paramref name="value"/>.<see cref="System.String.Length"/>.</para>
			<para>This method performs a word (case-sensitive and culture-sensitive) search 
   using the current culture.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates how you can use the <see cref="System.String.EndsWith"/>
method.</para>
			<codelink SampleID="stringendswith" SnippetID="1"/>
		</example>
		<seealso cref="System.String.StartsWith"/>
		<seealso cref="System.String.Compare"/>
	</doc>
	<doc for="String.Equals1">
		<summary>
			<para>Determines whether this instance and a specified
   <see cref="System.String"/> have the same value.</para>
		</summary>
		<param name="value">A <see cref="System.String"/>.</param>
		<returns>
			<para><see langword="true"/> if the value
   of <paramref name="value"/> is the same as this instance; otherwise, <see langword="false"/>.</para>
		</returns>
		<exception cref="System.NullReferenceException">This instance is <see langword="null"/>.</exception>
		<remarks>
			<para>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</para>
		</remarks>
		<example>
			<para>The following example demonstrates the <see cref="System.String.Equals"/>
method.</para>
			<codelink SampleID="BoundColumn_FormatDataValue" SnippetID="1"/>
		</example>
		<seealso cref="System.String.CompareOrdinal"/>
	</doc>
	<doc for="String.Join">
		<overload>
			<para>Concatenates a specified separator <see cref="System.String"/> between each element of a specified
<see cref="System.String"/> array, yielding a single
   concatenated string. </para>
		</overload>
		<summary>
			<para> Concatenates a specified separator <see cref="System.String"/> between each element of a specified
<see cref="System.String"/> array, yielding
   a single concatenated string.
   </para>
		</summary>
		<param name="separator">A <see cref="System.String"/>. </param>
		<param name="value">An array of <see cref="System.String"/>. </param>
		<returns>
			<para> A <see cref="System.String"/>
consisting of the elements of <paramref name="value"/> interspersed with the
<paramref name="separator"/> 
string.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
		<remarks>
			<para>For example if <paramref name="separator"/> is ", " and the elements of
<paramref name="value"/> are "apple", "orange", "grape", and "pear", <c>Join(separator, value)</c> returns "apple, orange, grape, 
pear".</para>
			<para>If <paramref name="separator"/> is <see langword="null"/>, the empty string (<see cref="System.String.Empty"/>) is used
instead.</para>
		</remarks>
		<example>
			<para>The following example demonstrates the <see cref="System.String.Join"/>method.</para>
			<codelink SampleID="stringjoin" SnippetID="1"/>
		</example>
		<seealso cref="System.String.Concat"/>
	</doc>
	<doc for="String.Format">
		<overload>
			<para> Replaces each format item in a specified
   <see cref="System.String"/> with the text
      equivalent of a corresponding object's value.</para>
		</overload>
		<summary>
			<para>Replaces the format item in a specified
   <see cref="System.String"/> with the text
      equivalent of the value of a specified <see cref="System.Object"/> instance.</para>
		</summary>
		<param name="format">A <see cref="System.String"/> containing zero or more format items.</param>
		<param name="arg0">An <see cref="System.Object"/> to format.</param>
		<returns>
			<para>A copy of <paramref name="format"/> in which
   the first format item has been replaced by the <see cref="System.String"/> equivalent of
<paramref name="arg0"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="format "/>or <paramref name="arg0"/> is <see langword="null"/>.</exception>
		<exception cref="System.FormatException"><para>The format item in <paramref name="format"/> is invalid.</para>
			<para>-or-</para>
			<para>The number indicating an argument to format is less than zero, or greater than or equal to the number of specified objects to format.</para></exception>
		<remarks>
			<para>For more information about formatting, see <see topic="cpConFormattingTypes"/> and <see topic="cpConFormattingOverview"/>. For more information about the
   composite formatting feature supported by <see cref="System.String.Format"/>, see <see topic="cpConCompositeFormatting"/>.</para>
			<para> The <paramref name="format"/> parameter is
embedded with zero or more format items of the form,
{index[,alignment][:formatString]}, where: </para>
			<list type="termdef">
				<item>
					<term> index </term>
					<description>A zero-based integer that indicates which
         element in a list of objects to format. If the object specified by index
         is <see langword="null"/>, then the format item is replaced by the empty
         string ("").</description>
				</item>
				<item>
					<term> alignment </term>
					<description>An
         optional integer indicating the minimum width of the region to contain
         the formatted value. If the length of the formatted value is less than alignment,
         then the region is padded with spaces. If alignment is negative, the
         formatted value is left justified in the region; if alignment is positive,
         the formatted value is right justified. If alignment is not specified,
         the length of the region is the length of the formatted value. The
         comma is required if alignment is specified.</description>
				</item>
				<item>
					<term> formatString </term>
					<description>An optional string of formatting codes. If
         formatString is not specified and the corresponding argument implements
         the <see cref="System.IFormattable"/> interface, then <see langword="null"/> is used as
         the <see cref="System.IFormattable.ToString " qualify="true"/> format string. Therefore, all
         implementations of <see cref="System.IFormattable.ToString " qualify="true"/> are required to allow
      <see langword="null"/> as a format string, and return default formatting of
         the object representation as a <see cref="System.String"/>. The colon is required if
         formatString is specified. </description>
				</item>
			</list>
			<para>The leading and trailing brace characters, '{' and '}',
   are required. To specify a single literal brace character in <paramref name="format"/>, specify two
   leading or trailing brace characters; that is, "{{" or "}}".</para>
			<para>If the value of <paramref name="format"/> is, "Thank you for your purchase of {0:####}
copies of Microsoft® .NET (Core Reference).", and <paramref name="arg0"/> is an <see cref="System.Int16"/> with the value
123, then the return value will be:</para>
			<para>"Thank you for your purchase of 123 copies of Microsoft® .NET (Core Reference)." </para>
			<para>If the value of <paramref name="format"/> is, "Brad's dog has {0,-8:G} fleas.", <paramref name="arg0
"/>is an <see cref="System.Int16"/> with the value 42, (and in this example, underscores
represent padding spaces) then the return
value will be: </para>
			<para>"Brad's dog has 42______ fleas."</para>
		</remarks>
		<example>
			<para> The following example demonstrates formatting multiple values.</para>
			<codelink SampleID="CallContext" SnippetID="2"/>
		</example>
		<seealso cref="System.Object"/>
		<seealso topic="cpConFormattingOverview"/>
		<seealso topic="cpConFormattingTypes"/>
	</doc>
	<doc for="String.Format3">
		<summary>
			<para>Replaces the format item in a specified
   <see cref="System.String"/> with the text
      equivalent of the value of a corresponding <see cref="System.Object"/> instance in a specified array.</para>
		</summary>
		<param name="format">A <see cref="System.String"/> containing zero or more format items.</param>
		<param name="args">An <see cref="System.Object"/> array containing zero or more objects to format.</param>
		<returns>
			<para>A copy of <paramref name="format"/> in which
   the format items have been replaced by the <see cref="System.String"/> equivalent of the corresponding
   instances of <see cref="System.Object"/> in <paramref name="args"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="format "/>or <paramref name="args "/>is <see langword="null"/>.</exception>
		<exception cref="System.FormatException"><para><paramref name="format "/>is invalid.</para>
			<para>-or-</para>
			<para>The number indicating an argument to format is less than zero, or greater than or equal to the length of the <paramref name="args"/> array.</para></exception>
		<remarks>
			<para>For more information about formatting, see <see topic="cpConFormattingTypes"/> and <see topic="cpConFormattingOverview"/>. For more information about the
   composite formatting feature supported by <see cref="System.String.Format"/>, see <see topic="cpConCompositeFormatting"/>.</para>
			<para> The <paramref name="format"/> parameter is
embedded with zero or more format items of the form,
{index[,alignment][:formatString]}, where: </para>
			<list type="termdef">
				<item>
					<term> index </term>
					<description>A zero-based integer that indicates which
         element in a list of objects to format. If the object specified by index
         is <see langword="null"/>, then the format item is replaced by the empty
         string ("").</description>
				</item>
				<item>
					<term> alignment </term>
					<description>An
         optional integer indicating the minimum width of the region to contain
         the formatted value. If the length of the formatted value is less than alignment,
         then the region is padded with spaces. If alignment is negative, the
         formatted value is left justified in the region; if alignment is positive,
         the formatted value is right justified. If alignment is not specified,
         the length of the region is the length of the formatted value. The
         comma is required if alignment is specified.</description>
				</item>
				<item>
					<term> formatString </term>
					<description>An optional string of formatting codes. If
         formatString is not specified and the corresponding argument implements
         the <see cref="System.IFormattable"/> interface, then <see langword="null"/> is used as
         the <see cref="System.IFormattable.ToString " qualify="true"/> format string. Therefore, all
         implementations of <see cref="System.IFormattable.ToString " qualify="true"/> are required to allow
      <see langword="null"/> as a format string, and return default formatting of
         the object representation as a <see cref="System.String"/>. The colon is required if
         formatString is specified. </description>
				</item>
			</list>
			<para>The leading and trailing brace characters, '{' and '}',
   are required. To specify a single literal brace character in <paramref name="format"/>, specify two
   leading or trailing brace characters; that is, "{{" or "}}".</para>
			<para>If the value of <paramref name="format"/> is,
"Thank you for your purchase of {0:####} copies of Microsoft® .NET (Core
Reference).", and arg[0] is an <see cref="System.Int16"/> with the value
123, then the return value will be:</para>
			<para>"Thank you for your purchase of 123 copies of Microsoft® .NET (Core Reference)." </para>
			<para>If the value of <paramref name="format"/> is,
"Brad's dog has {0,-8:G} fleas.", arg[0]<paramref name=" "/>is an <see cref="System.Int16"/> with the value 42, (and in this example, underscores
represent padding spaces) then the return
value will be: </para>
			<para>"Brad's dog has 42______ fleas."</para>
		</remarks>
		<example>
			<para>The following example demonstrates formatting multiple values.</para>
			<codelink SampleID="CallContext" SnippetID="2"/>
		</example>
		<seealso cref="System.Object"/>
		<seealso topic="cpConFormattingOverview"/>
		<seealso topic="cpConFormattingTypes"/>
	</doc>
	<doc for="String.Format4">
		<summary>
			<para>Replaces the format item in a specified <see cref="System.String"/> with the text
   equivalent of the value of a corresponding <see cref="System.Object"/>
   instance in a specified array. A specified parameter supplies culture-specific
   formatting information.</para>
		</summary>
		<param name="provider">An <see cref="System.IFormatProvider"/> that supplies culture-specific formatting information.</param>
		<param name="format">A <see cref="System.String"/> containing zero or more format items.</param>
		<param name="args">An <see cref="System.Object"/> array containing zero or more objects to format.</param>
		<returns>
			<para>A copy of <paramref name="format"/> in which
   the format items have been replaced by the <see cref="System.String"/> equivalent of the corresponding
   instances of <see cref="System.Object"/> in <paramref name="args"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="format "/>or <paramref name="args "/>is <see langword="null"/>.</exception>
		<exception cref="System.FormatException"><para><paramref name="format "/> is invalid.</para>
			<para>-or-</para>
			<para>The number indicating an argument to format is less than zero, or greater than or equal to the length of the <paramref name="args"/> array.</para></exception>
		<remarks>
			<para>For more information about formatting, see <see topic="cpConFormattingTypes"/> and <see topic="cpConFormattingOverview"/>. For more information about the
   composite formatting feature supported by <see cref="System.String.Format"/>, see <see topic="cpConCompositeFormatting"/>.</para>
			<para> The <paramref name="provider"/> parameter supplies custom and
culture-specific information used to moderate the formatting process. For more
information, see the Format Providers section of <see topic="cpConFormattingOverview"/>. </para>
			<para> The <paramref name="format"/> parameter is embedded with zero or more
format items of the form, {index[,alignment][:formatString]}, where: </para>
			<list type="termdef">
				<item>
					<term> index </term>
					<description>A zero-based integer that indicates which
         element in a list of objects to format. If the object specified by index
         is <see langword="null"/>, then the format item is replaced by the empty
         string ("").</description>
				</item>
				<item>
					<term> alignment </term>
					<description>An
         optional integer indicating the minimum width of the region to contain
         the formatted value. If the length of the formatted value is less than alignment,
         then the region is padded with spaces. If alignment is negative, the
         formatted value is left justified in the region; if alignment is positive,
         the formatted value is right justified. If alignment is not specified,
         the length of the region is the length of the formatted value. The
         comma is required if alignment is specified.</description>
				</item>
				<item>
					<term> formatString </term>
					<description>An optional string of formatting codes. If
         formatString is not specified and the corresponding argument implements
         the <see cref="System.IFormattable"/> interface, then <see langword="null"/> is used as
         the <see cref="System.IFormattable.ToString " qualify="true"/> format string. Therefore, all
         implementations of <see cref="System.IFormattable.ToString " qualify="true"/> are required to allow
      <see langword="null"/> as a format string, and return default formatting of
         the object representation as a <see cref="System.String"/>. The colon is required if
         formatString is specified. </description>
				</item>
			</list>
			<para>The leading and trailing brace characters, '{' and '}',
   are required. To specify a single literal brace character in <paramref name="format"/>, specify two
   leading or trailing brace characters; that is, "{{" or "}}".</para>
			<para>If the value of <paramref name="format"/> is,
"Thank you for your purchase of {0:####} copies of Microsoft® .NET (Core
Reference).", and arg[0] is an <see cref="System.Int16"/> with the value
123, then the return value will be:</para>
			<para>"Thank you for your purchase of 123 copies of Microsoft® .NET (Core Reference)." </para>
			<para>If the value of <paramref name="format"/> is,
"Brad's dog has {0,-8:G} fleas.", arg[0]<paramref name=" "/>is an <see cref="System.Int16"/> with the value 42, (and in this example, underscores
represent padding spaces) then the return
value will be: </para>
			<para>"Brad's dog has 42______ fleas."</para>
		</remarks>
		<example>
			<para>The following example demonstrates formatting multiple values.</para>
			<codelink SampleID="CallContext" SnippetID="2"/>
		</example>
		<seealso cref="System.Object"/>
		<seealso topic="cpConFormattingOverview"/>
		<seealso topic="cpConFormattingTypes"/>
	</doc>
	<doc for="String.CompareTo">
		<overload>
			<para>Compares this instance with a specified object.</para>
		</overload>
		<summary>
			<para>Compares this instance with a specified
   <see cref="System.Object"/>.</para>
		</summary>
		<param name="value">An <see cref="System.Object"/> that evaluates to a <see langword="String"/>.</param>
		<returns>
			<para>A 32-bit signed integer indicating the lexical relationship between the two
      comparands.</para>
			<list type="table">
				<listheader>
					<term>Value</term>
					<description>Condition</description>
				</listheader>
				<item>
					<term> Less than zero</term>
					<description>This
            instance is less than <paramref name="value"/>.</description>
				</item>
				<item>
					<term> Zero</term>
					<description>This
            instance is equal to <paramref name="value"/>.</description>
				</item>
				<item>
					<term>
						<para> Greater than zero</para></term>
					<description>
						<para>This instance is greater than <paramref name="value"/>.</para>
						<para>-or-</para>
						<para><paramref name="value"/> is
         <see langword="null"/>.</para></description>
				</item>
			</list>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="value"/> is not a <see cref="System.String"/>.</exception>
		<remarks>
			<para><paramref name="value"/> must be a <see cref="System.String"/>
object.</para>
			<para> This method performs a word (case-sensitive and culture-sensitive) comparison 
   using the current culture. For more information about word, string, and ordinal
   sorts, see <see cref="System.Globalization.CompareOptions" qualify="true"/>.</para>
			<para>For more information about the behavior of this method, see the Remarks section of the <see cref="System.String.Compare"/> method.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates how you can use
      the <see cref="System.String.CompareTo"/> method with an <see cref="System.Object"/>.</para>
			<codelink SampleID="ExToString" SnippetID="1"/>
		</example>
		<seealso cref="System.String.Compare"/>
		<seealso cref="System.String.CompareOrdinal"/>
	</doc>
	<doc for="String.CompareTo1">
		<summary>
			<para>Compares this instance with a specified <see cref="System.String"/> object.</para>
		</summary>
		<param name="strB">A <see cref="System.String"/>.</param>
		<returns>
			<para>A 32-bit signed integer indicating the lexical relationship between the two
      comparands.</para>
			<list type="table">
				<listheader>
					<term>Value</term>
					<description>Condition</description>
				</listheader>
				<item>
					<term> Less than zero</term>
					<description>This instance is less than <paramref name="strB"/>.</description>
				</item>
				<item>
					<term> Zero</term>
					<description>This instance is equal to <paramref name="strB"/>.</description>
				</item>
				<item>
					<term>
						<para>Greater than zero</para></term>
					<description>
						<para>This instance is greater than <paramref name="strB"/>.</para>
						<para>-or-</para>
						<para><paramref name="strB"/> is <see langword="null"/>.</para></description>
				</item>
			</list>
		</returns>
		<remarks>
			<para> This method performs a word (case-sensitive and 
      culture-sensitive) comparison using the current culture. For more information
      about word, string, and ordinal sorts, see <see cref="System.Globalization.CompareOptions" qualify="true"/>.</para>
			<para>For more information about the behavior of this method, see the Remarks 
      section of the <see cref="System.String.Compare"/> method.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates how you can use the <see cref="System.String.CompareTo"/> method
   with another <see cref="System.String"/>.</para>
			<codelink SampleID="stringcompareto" SnippetID="1"/>
		</example>
		<seealso cref="System.String.Compare"/>
		<seealso cref="System.String.CompareOrdinal"/>
	</doc>
	<doc for="String.IndexOf">
		<overload>
			<para>Reports the index of the first occurrence of a
   <see cref="System.String"/>, or one or more characters, within this instance.</para>
		</overload>
		<summary>
			<para>Reports the index of the first occurrence of the
      specified Unicode character in this instance.</para>
		</summary>
		<param name="value">A Unicode character to seek.</param>
		<returns>
			<para>The index position of <paramref name="value"/>
if that character is found, or -1 if it is not.</para>
		</returns>
		<remarks>
			<para>Index numbering starts from zero.</para>
			<para>The search for <paramref name="value"/> is case-sensitive.</para>
			<para>This method performs an ordinal (culture-insensitive) search, where a
   character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <see cref="System.Globalization.CompareInfo.IndexOf" qualify="true"/> method, where a Unicode scalar value representing
   a precomposed character, such as the ligature 'Æ' (U+00C6), might be considered
   equivalent to any occurrence of the character's components in the correct
   sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates how you can search a <see cref="System.String"/> for a character
   using the <see cref="System.String.IndexOf"/> method.</para>
			<codelink SampleID="stringexample1" SnippetID="3"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.String.IndexOfAny"/>
		<seealso cref="System.String.LastIndexOf"/>
		<seealso cref="System.String.LastIndexOfAny"/>
	</doc>
	<doc for="String.IndexOf2">
		<summary>
			<para>Reports the index of the first occurrence of the specified character in this instance. The search
      starts at a specified character position and examines a specified
      number of character positions.</para>
		</summary>
		<param name="value">A Unicode character to seek.</param>
		<param name="startIndex">The search starting position.</param>
		<param name="count">The number of character positions to examine.</param>
		<returns>
			<para>The index position of <paramref name="value"/> if that character is found, or -1 if it is not.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException"><para>
				<paramref name="count"/> or <paramref name="startIndex "/> is negative.</para>
			<para>-or-</para>
			<para>
				<paramref name="count"/> + <paramref name="startIndex "/>specifies a position beyond the end of this instance.</para></exception>
		<remarks>
			<para> The search begins at <paramref name="startIndex"/> and continues to <paramref name="startIndex"/> + <paramref name="count"/> -1. The
   character at <paramref name="startIndex"/> + <paramref name="count"/>
   is not included in the search.</para>
			<para>Index numbering starts from zero.</para>
			<para>The search for <paramref name="value"/> is case-sensitive.</para>
			<para>This method performs an ordinal (culture-insensitive) search, where a
   character is considered equivalent to another character only if their Unicode scalar value are the same. To perform a culture-sensitive search, use the <see cref="System.Globalization.CompareInfo.IndexOf" qualify="true"/> method, where a Unicode scalar value representing
   a precomposed character, such as the ligature 'Æ' (U+00C6), might be considered
   equivalent to any occurrence of the character's components in the correct
   sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
		</remarks>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.IndexOfAny"/>
		<seealso cref="System.String.LastIndexOf"/>
		<seealso cref="System.String.LastIndexOfAny"/>
	</doc>
	<doc for="String.IndexOfAny1">
		<overload>
			<para>Reports the index of the first occurrence in this instance of any character
      in a specified array of Unicode characters.</para>
		</overload>
		<summary>
			<para>Reports the index of the first occurrence in this
      instance of any character in a specified array of Unicode
      characters.</para>
		</summary>
		<param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
		<returns>
			<para> The index position of the first occurrence in
      this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if
      no character in <paramref name="anyOf"/> was found.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="anyOf"/> is <see langword="null"/>.</exception>
		<remarks>
			<para>Index numbering starts from zero.</para>
			<para>The search for <paramref name="anyOf"/> is case-sensitive.</para>
			<para>This method performs an ordinal (culture-insensitive) search, where a
   character is considered equivalent to another character only if their Unicode scalar value are the same. To perform a culture-sensitive search, use the <see cref="System.Globalization.CompareInfo.IndexOf" qualify="true"/> method, where a Unicode scalar value representing
   a precomposed character, such as the ligature 'Æ' (U+00C6), might be considered
   equivalent to any occurrence of the character's components in the correct
   sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
		</remarks>
		<example>
			<para>The following code example uses the <see cref="System.String.IndexOfAny"/> method
   to check for invalid characters in a user entered string.</para>
			<codelink SampleID="Classic TreeNode.BeginEdit Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
		<seealso cref="System.Array"/>
		<seealso cref="System.String.IndexOf"/>
		<seealso cref="System.String.LastIndexOf"/>
		<seealso cref="System.String.LastIndexOfAny"/>
	</doc>
	<doc for="String.IndexOf6">
		<summary>
			<para>Reports the index of the first occurrence of the
      specified <see cref="System.String"/> in this instance.</para>
		</summary>
		<param name="value">The <see cref="System.String"/> to seek.</param>
		<returns>
			<para>The index position of <paramref name="value"/> if that string
   is found, or -1 if it is not. If <paramref name="value"/> is <see cref="System.String.Empty"/>, the
   return value is 0.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
		<remarks>
			<para>Index numbering starts from zero.</para>
			<para>This method performs a word (case-sensitive and culture-sensitive) search 
      using the current culture. The search begins at the first character position of
      this instance and continues until the last character position.</para>
		</remarks>
		<example>
			<para>The following code exampled demonstrates the <see cref="System.String.IndexOf"/>
method.</para>
			<codelink SampleID="stringinsert" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.Globalization.CultureInfo"/>
		<seealso cref="System.String.IndexOfAny"/>
		<seealso cref="System.String.LastIndexOf"/>
		<seealso cref="System.String.LastIndexOfAny"/>
	</doc>
	<doc for="String.LastIndexOf">
		<overload>
			<para>Reports the index position of the last occurrence of a
      specified Unicode character or <see cref="System.String"/> within this instance.</para>
		</overload>
		<summary>
			<para>Reports the index position of the last occurrence of a specified Unicode
      character within this instance.</para>
		</summary>
		<param name="value">A Unicode character to seek. </param>
		<returns>
			<para> The index position of <paramref name="value"/>
if that character
is found, or -1 if it is not.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>. </exception>
		<remarks>
			<para>Index numbering starts from zero.</para>
			<para>This method begins searching at the last character position of this instance and precedes backwards towards the beginning until either <paramref name="value"/> is found or the first character position has been 
   examined. The search is case-sensitive.</para>
			<para> This method performs an ordinal (culture-insensitive)
   search, where a character is considered equivalent to another character only if
   their Unicode scalar values are the same. To perform a culture-sensitive search, use the
<see cref="System.Globalization.CompareInfo.LastIndexOf" qualify="true"/> method, where a Unicode scalar value representing 
   a precomposed character, such as the ligature 'Æ' (U+00C6), might be considered
   equivalent to any occurrence of the character's components in the correct
   sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates how you can search a <see cref="System.String"/> for a character
   using the <see cref="System.String.LastIndexOf"/> method.</para>
			<codelink SampleID="stringexample1" SnippetID="3"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.String.IndexOf"/>
		<seealso cref="System.String.IndexOfAny"/>
		<seealso cref="System.String.LastIndexOfAny"/>
	</doc>
	<doc for="String.LastIndexOf6">
		<summary>
			<para>Reports the index position of the last occurrence of a
      specified <see cref="System.String"/> within this instance.</para>
		</summary>
		<param name="value">A <see cref="System.String"/> to seek.</param>
		<returns>
			<para>The index position of <paramref name="value"/> if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="System.String.Empty"/>, the return value is 0.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
		<remarks>
			<para>Index numbering starts from zero.</para>
			<para> This method performs a word (case-sensitive and
      culture-sensitive) search using the current culture. The search begins at the last character position of this instance and precedes backwards towards the beginning until either <paramref name="value"/> is found or the first character position has been
      examined.</para>
		</remarks>
		<example>
			<para>The following example application shows how the <see cref="System.String.LastIndexOf"/>
method can be used to make decisions while parsing string input.</para>
			<codelink SampleID="stringendswith" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.IndexOf"/>
		<seealso cref="System.String.IndexOfAny"/>
		<seealso cref="System.String.LastIndexOfAny"/>
	</doc>
	<doc for="String.String">
		<overload>
			<para>Initializes a new instance of the <see cref="System.String"/> class.</para>
		</overload>
		<summary>
			<para>Initializes a new instance of the <see cref="System.String"/> class to the value indicated by a specified pointer to an array of Unicode characters.</para>
		</summary>
		<param name="value">A pointer to a null terminated array of Unicode characters.</param>
		<remarks>
			<para>If <paramref name="value"/> is a null pointer, an <see cref="System.String.Empty"/>
instance is initialized.</para>
			<para>This constructor copies the sequence of Unicode characters at the specified 
 pointer until a null character (hexadecimal 0x00) is reached.</para>
			<para>If the specified array is not null-terminated, the behavior of this 
 constructor is system dependent. For example, such a situation might cause an
 access violation.</para>
			<para>In C#, this constructor is defined only in the context of unmanaged code.</para>
		</remarks>
		<seealso cref="System.Char"/>
	</doc>
	<doc for="String.TrimStart">
		<summary>
			<para> Removes all occurrences of a set of characters specified in an array from
      the beginning of this instance.</para>
		</summary>
		<param name="trimChars">An array of Unicode characters to be removed or <see langword="null"/>.</param>
		<returns>
			<para>The <see cref="System.String"/> that
   remains after all occurrences of characters in
<paramref name="trimChars"/> are 
   removed from the
   beginning. If <paramref name="trimChars"/> is <see langword="null"/>, white space characters
   are removed instead.</para>
		</returns>
		<remarks>
			<para>For more information about what Unicode characters are categorized as white space characters, see
      the Remarks section of the <see cref="System.Char.IsWhiteSpace" qualify="true"/>
      method.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates how you can use the <see cref="System.String.TrimStart"/> method
   to trim white space or other characters from the beginning of a string.</para>
			<codelink SampleID="stringtrim" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.String.Trim"/>
		<seealso cref="System.String.TrimEnd"/>
	</doc>
	<doc for="String.TrimEnd">
		<summary>
			<para> Removes all occurrences of a set of characters specified in an array from
      the end of this instance.</para>
		</summary>
		<param name="trimChars">An array of Unicode characters to be removed or <see langword="null"/>.</param>
		<returns>
			<para>The <see cref="System.String"/> that
   remains after all occurrences of the characters in
<paramref name="trimChars"/> are 
   removed from the
   end. If <paramref name="trimChars"/> is <see langword="null"/>, white space characters
   are removed instead.</para>
		</returns>
		<remarks>
			<para>For more information about what Unicode characters are categorized as white space characters, see
      the Remarks section of the <see cref="System.Char.IsWhiteSpace" qualify="true"/>
      method.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates how you can use the <see cref="System.String.TrimEnd"/> method to
   trim white space or other characters from the end of a string.</para>
			<codelink SampleID="stringtrim" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.String.Trim"/>
		<seealso cref="System.String.TrimStart"/>
	</doc>
	<doc for="String.CompareOrdinal1">
		<summary>
			<para>Compares two specified <see cref="System.String"/> objects by evaluating the numeric
   values of the corresponding <see cref="System.Char"/> objects in each substring. Parameters specify the
   length and starting positions of the substrings.</para>
		</summary>
		<param name="strA">The first <see cref="System.String"/>.</param>
		<param name="indexA">The starting index of the substring in <paramref name="strA"/>.</param>
		<param name="strB">The second <see cref="System.String"/>.</param>
		<param name="indexB">The starting index of the substring in <paramref name="strB"/>.</param>
		<param name="length">The maximum number of characters in the substrings to compare.</param>
		<returns>
			<para>A 32-bit signed integer indicating the lexical relationship between the two comparands.</para>
			<list type="table">
				<listheader>
					<term>Value Type</term>
					<description>Condition</description>
				</listheader>
				<item>
					<term> Less than zero</term>
					<description>The substring in <paramref name="strA"/> is less than the substring in <paramref name="strB"/>.</description>
				</item>
				<item>
					<term> Zero</term>
					<description>The substrings are equal, or <paramref name="length"/> is zero.</description>
				</item>
				<item>
					<term> Greater than zero</term>
					<description>The substring in <paramref name="strA"/> is greater than the substring in <paramref name="strB"/>.</description>
				</item>
			</list>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="indexA"/> is greater than <paramref name="strA"/>.<see cref="System.String.Length"/>.</para><para>-or-</para><para><paramref name="indexB"/> is greater than <paramref name="strB"/>.<see cref="System.String.Length"/>.</para><para>-or-</para><para><paramref name="indexA"/>, <paramref name="indexB"/>, or <paramref name="length"/> is negative.</para></exception>
		<remarks>
			<para>The <paramref name="indexA"/>, <paramref name="indexB"/>, and <paramref name="length"/> parameters
   must be
   nonnegative.</para>
			<para>The number of characters compared is the lesser of the length of <paramref name="strA"/>
less <paramref name="indexA"/>, the length of <paramref name="strB"/> less <paramref name="indexB"/>, and
<paramref name="length"/>.</para>
			<para>This method performs a comparison using ordinal sort rules. For more information
   about word, string, and ordinal sorts, see <see cref="System.Globalization.CompareOptions" qualify="true"/>.</para>
		</remarks>
		<example>
			<para>This following example demonstrates that <see cref="System.String.CompareOrdinal"/>
and <see cref="System.String.Compare"/> use different sort
orders.</para>
			<codelink SampleID="StringCompareOrdinal" SnippetID="1"/>
		</example>
		<seealso cref="System.String.Compare"/>
		<seealso cref="System.String.CompareTo"/>
		<seealso cref="System.Int32"/>
	</doc>
	<doc for="String.Compare">
		<overload>
			<para>Compares two specified <see cref="System.String"/> objects.</para>
		</overload>
		<summary>
			<para>Compares two specified <see cref="System.String"/> objects.</para>
		</summary>
		<param name="strA">The first <see cref="System.String"/>.</param>
		<param name="strB">The second <see cref="System.String"/>.</param>
		<returns>
			<para>A 32-bit signed integer indicating the lexical relationship between the two comparands.</para>
			<list type="table">
				<listheader>
					<term> Value</term>
					<description>Meaning</description>
				</listheader>
				<item>
					<term> Less than zero</term>
					<description><paramref name="strA"/> is less than <paramref name="strB"/>.</description>
				</item>
				<item>
					<term> Zero</term>
					<description><paramref name="strA"/> equals <paramref name="strB"/>.</description>
				</item>
				<item>
					<term> Greater than zero</term>
					<description><paramref name="strA"/> is greater than
<paramref name="strB"/>.</description>
				</item>
			</list>
		</returns>
		<remarks>
			<para>The comparison uses the current culture to obtain 
      culture-specific information such as casing rules and the alphabetic order of
      individual characters. For example, a culture could specify that certain
      combinations of characters be treated as a single character, or uppercase and
      lowercase characters be compared in a particular way, or that the sorting order
      of a character depends on the characters that precede or follow it. </para>
			<para>The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <see cref="System.Globalization.CompareOptions" qualify="true"/>.</para>
			<para>One or both comparands can be <see langword="null"/>. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</para>
			<para>The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed. </para>
			<para>Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter 'i' in "file". </para>
			<code>
static String IsFileURI(String path) { 
   return (String.Compare(path, 0, "file:", 0, 5, true)== 0); }
</code>
			<para>The path name needs to be compared in an invariant manner. The correct code to do this is as follows. </para>
			<code>
static String IsFileURI(String path) { 
   return (String.Compare(path, 0, "file:", 0, 5, true, CultureInfo.InvariantCulture)== 0); }
</code>
		</remarks>
		<example>
			<para>In the following code example, the <see langword="ReverseStringComparer"/>
class demonstrates how you can evaluate two strings with the <see cref="System.String.Compare"/>
method.</para>
			<codelink SampleID="ArrayList" SnippetID="7"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.CompareOrdinal"/>
		<seealso cref="System.String.CompareTo"/>
	</doc>
	<doc for="String.String3">
		<summary>
			<para>Initializes a new instance of the <see cref="System.String"/> class to the value indicated by a specified pointer to an array of 8-bit signed integers,
   a starting character position within that array,
   and a length.</para>
		</summary>
		<param name="value">A pointer to an array of 8-bit signed integers.</param>
		<param name="startIndex">The starting position within <paramref name="value"/>.</param>
		<param name="length">The number of characters within <paramref name="value"/> to use.</param>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="startIndex"/> or <paramref name="length"/> is less than zero.</para></exception>
		<exception cref="System.ArgumentException"><para><paramref name="value"/> + <paramref name="startIndex"/> is less than 64K.</para>
			<para>-or-</para>
			<para>A new instance of <see cref="System.String"/> could not be initialized using <paramref name="value"/> and the current code page.</para></exception>
		<remarks>
			<para>If <paramref name="value"/> is a null pointer or <paramref name="length"/> is zero, the new instance is initialized to the
   empty string ("").</para>
			<para>This constructor copies Unicode characters from <paramref name="value"/>, starting at
<paramref name="startIndex"/> and ending at (<paramref name="startIndex"/> + <paramref name="length"/> - 1).</para>
			<para>If the specified range is outside of the memory allocated for the sequence of
   characters, the behavior of this constructor is system dependent. For example,
   such a situation might cause an access violation.</para>
			<para>In C#, this constructor is defined only in the context of unmanaged code.</para>
		</remarks>
		<example>
			<para>The following simple code example demonstrates how you can create an instance
      of the <see cref="System.String"/>
      class with this constructor.</para>
			<codelink SampleID="stringexample1" SnippetID="2"/>
		</example>
		<seealso cref="System.SByte"/>
		<seealso cref="System.Int32"/>
	</doc>
	<doc for="String.String2">
		<summary>
			<para>Initializes a new instance of the <see cref="System.String"/> class to the value indicated by a pointer to an array of 8-bit signed integers.</para>
		</summary>
		<param name="value">A pointer to a null terminated array of 8-bit signed integers.</param>
		<exception cref="ArgumentException">A new instance of <see cref="System.String"/> could not be initialized using <paramref name="value"/> and the current code page.</exception>
		<remarks>
			<para>If <paramref name="value"/> is a null pointer, the new instance is
   initialized to the empty string ("").</para>
			<para>This constructor copies the sequence of characters at the specified pointer
   until a null character (hexadecimal 0x00) is reached.</para>
			<para>If the specified array is not null-terminated, the behavior of this
   constructor is system dependent. For example, such a situation might cause an
   access violation.</para>
			<para>In C#, this constructor is defined only in the context of unmanaged code.</para>
		</remarks>
		<example>
			<para>The following simple code example demonstrates how you
      can create an instance of the <see cref="System.String"/> class with this constructor.</para>
			<codelink SampleID="stringexample1" SnippetID="2"/>
		</example>
		<seealso cref="System.SByte"/>
	</doc>
	<doc for="String.this">
		<summary>
			<para> Gets the character at a specified character position in this
      instance.</para>
		</summary>
		<param name="index">A character position in this instance.</param>
		<value>
			<para>A Unicode character.</para>
		</value>
		<exception cref="System.IndexOutOfRangeException"><paramref name="index"/> is greater than or equal to the length of this object or less than zero.</exception>
		<remarks>
			<para>The <paramref name="index"/> parameter is zero-based.</para>
			<para>This property returns the <see cref="System.Char"/> at the position specified by the <paramref name="index"/>
parameter. However, a Unicode character might be represented by more than one <see cref="System.Char"/>. Use the <see cref="System.Globalization.StringInfo" qualify="true"/> class to work with each
Unicode character instead of each <see cref="System.Char"/>.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates how you can
      use this indexer in a routine to validate a string.</para>
			<codelink SampleID="Uri_IsHexDigit" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.String.GetEnumerator"/>
		<seealso cref="System.Int32"/>
	</doc>
	<doc for="String">
		<summary>
			<para> Represents text; that is, a series of Unicode characters.</para>
		</summary>
		<threadsafe>
			<para>This type is safe for multithreaded operations.</para>
		</threadsafe>
		<remarks>
			<para>A string is a sequential collection of Unicode
      characters, typically used to represent text, while a <see cref="System.String"/> is a sequential collection of <see cref="System.Char" qualify="true"/> objects that represents a string. The value of the
   <see cref="System.String"/> is the
      content of the
      sequential collection, and the value is immutable.</para>
			<para> A <see cref="System.String"/> is called immutable
   because its value cannot be modified once it has been created. Methods that
   appear to modify a <see cref="System.String"/>
   actually
   return a new <see cref="System.String"/> containing the modification. If it is necessary to
   modify the actual contents of a string-like object, use the <see cref="System.Text.StringBuilder" qualify="true"/> class.</para>
			<para> Each Unicode character in a string is defined by a Unicode scalar value, also called a Unicode
   code point or the ordinal (numeric) value of the Unicode character. Each code point
   is encoded using UTF-16 encoding, and the numeric value of each element of
   the encoding is represented by a <see cref="System.Char"/>. The resulting collection of <see cref="System.Char"/> objects constitutes the <see cref="System.String"/>.</para>
			<para>A single <see cref="System.Char"/> usually represents a single code point; that is, the
numeric value of the <see cref="System.Char"/>
equals the code point. However, a code point might require more than
one encoded element. For example, a Unicode supplementary code point (a
surrogate pair) is encoded with two <see cref="System.Char"/> objects.</para>
			<para>An index is the position of a <see cref="System.Char"/>, not a Unicode character, in a <see cref="System.String"/>. An index is a
zero-based, nonnegative number starting from the first position in the string,
which is index position zero. Consecutive index values might not correspond to
consecutive Unicode characters because a Unicode character might be encoded as
more than one <see cref="System.Char"/>. To work with each Unicode character instead of
each <see cref="System.Char"/>,
use the <see cref="System.Globalization.StringInfo" qualify="true"/> class.</para>
			<para>Members of <see cref="System.String"/> perform either an ordinal or linguistic operation on a
<see cref="System.String"/>. An 
ordinal operation acts on the numeric value of each <see cref="System.Char"/> object. A
linguistic operation acts on the value of the <see cref="System.String"/>
taking into account culture-specific
casing, sorting, formatting, and parsing rules. Linguistic operations execute in
the context of an explicitly declared culture or the implicit current culture.
For more information about the current culture, see the <see cref="System.Globalization.CultureInfo.CurrentCulture" qualify="true"/> topic.</para>
			<para>Casing rules determine how to change a Unicode character between one case and
   another; for example, from lowercase to uppercase.</para>
			<para>Formatting rules determine how to convert a value to its string
   representation, while parsing rules determine how to convert a string
   representation to a value.</para>
			<para>Sort rules determine the alphabetic order of Unicode characters and how two
   strings compare to each other. For example, the <see cref="System.String.Compare"/> method
   performs a linguistic comparison while the <see cref="System.String.CompareOrdinal"/>
   method performs an ordinal comparison. Consequently, if the current culture is
   U.S. English, the <see cref="System.String.Compare"/> method considers 'a' less than 'A' while the <see cref="System.String.CompareOrdinal"/>
   method considers 'a' greater than 'A'.</para>
			<para>The .NET Framework supports word, string, and ordinal sort rules. A word sort performs
   a culture-sensitive comparison of strings in which certain nonalphanumeric
   Unicode characters might have special weights assigned to them. For
   example, the hyphen ("-") might have a very small weight assigned to it so that
   "coop" and "co-op" appear next to each other in a sorted list. A string sort
   is similar to a word sort, except that there are no special cases and all
   nonalphanumeric symbols come before all alphanumeric Unicode characters. An
   ordinal sort compares strings based on the numeric value of each <see cref="System.Char"/> in the string. For more information about word, string, and
   ordinal sort rules, see the <see cref="System.Globalization.CompareOptions" qualify="true"/> topic.</para>
			<para>Comparison and search procedures are case-sensitive by
   default and use the culture associated with the current thread unless specified
   otherwise. By definition, any
   string, including the empty string (""), compares greater than a
   null reference, and two null references compare equal to each other.</para>
			<para>If your application makes security decisions based on
   the result of a comparison or case change operation, then the operation should
   use the invariant culture to ensure the result is not affected by the value of
   the current culture. For more information, see the <see cref="System.Globalization.CultureInfo.InvariantCulture" qualify="true"/>
   topic.</para>
			<para>Use <see cref="System.String.Compare"/>, <see cref="System.String.CompareOrdinal"/>,
<see cref="System.String.CompareTo"/>, <see cref="System.String.Equals"/>, <see cref="System.String.EndsWith"/>, and <see cref="System.String.StartsWith"/> for comparisons. Use <see cref="System.String.IndexOf"/>, <see cref="System.String.IndexOfAny"/>, 
<see cref="System.String.LastIndexOf"/>, and <see cref="System.String.LastIndexOfAny"/> to obtain the index of a substring or 
Unicode character in a string. Use <see cref="System.String.Copy"/> and <see cref="System.String.CopyTo"/> to copy a
string or substring to another string or an array of <see cref="System.Char"/>.</para>
			<para>Use <see cref="System.String.Substring"/> and <see cref="System.String.Split"/> to create one or more new strings from
portions of an original string, and <see cref="System.String.Concat"/> and <see cref="System.String.Join"/> to create a new string from one or more
substrings. Use <see cref="System.String.Insert"/>, <see cref="System.String.Replace"/>, <see cref="System.String.Remove"/>, <see cref="System.String.PadLeft"/>, <see cref="System.String.PadRight"/>, <see cref="System.String.Trim"/>, <see cref="System.String.TrimEnd"/>, and <see cref="System.String.TrimStart"/>
to modify all or part of a string.</para>
			<para>Use <see cref="System.String.ToLower"/> and <see cref="System.String.ToUpper"/> to change
the case of Unicode characters in a string. Use <see cref="System.String.Format"/> to replace
one or more placeholders in a string with the string representation of one or
more values. Use the <see cref="System.String.Length"/>
property to obtain the number of <see cref="System.Char"/> objects in a string, and the <see cref="System.String.this"/> property to access the
actual <see cref="System.Char"/> objects in a string.</para>
			<para>String implements the <see cref="System.IComparable"/>, <see cref="System.ICloneable"/>, <see cref="System.IConvertible"/>, and <see cref="System.Collections.IEnumerable"/> interfaces. Use the <see cref="System.Convert"/> class for
conversions instead of this type's explicit interface member implementation of
<see cref="System.IConvertible"/>.</para>
		</remarks>
		<seealso cref="System.IComparable"/>
		<seealso cref="System.ICloneable"/>
		<seealso cref="System.IConvertible"/>
		<seealso cref="System.Collections.IEnumerable"/>
		<seealso cref="System.Text.StringBuilder" qualify="true"/>
		<seealso cref="System.Globalization.CultureInfo"/>
		<seealso topic="cpConFormattingOverview"/>
	</doc>
	<doc for="String.Remove">
		<summary>
			<para>Deletes a specified number of characters from this
      instance beginning at a specified position.</para>
		</summary>
		<param name="startIndex">The position in this instance to begin deleting characters.</param>
		<param name="count">The number of characters to delete.</param>
		<returns>
			<para> A new <see cref="System.String"/> that
   is equivalent to this instance less <paramref name="count"/>
   number of characters.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException"><para>Either <paramref name="startIndex"/> or <paramref name="count"/> is less than zero.</para>
			<para>-or-</para>
			<para>
				<paramref name="startIndex"/> plus <paramref name="count"/> is greater than the length of this instance.</para></exception>
		<remarks>
			<para>For example, the following C# code prints "123456".</para>
			<para><c>String s
      = "123abc456"; </c>
			</para>
			<para><c>Console.WriteLine(s.Remove(3, 3));</c>
			</para>
		</remarks>
		<example>
			<para>The following code example demonstrates how you can 
      remove the middle name from a complete
      name.</para>
			<codelink SampleID="stringremove" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.Concat"/>
		<seealso cref="System.String.Insert"/>
		<seealso cref="System.String.Join"/>
		<seealso cref="System.String.Replace"/>
		<seealso cref="System.String.Split"/>
		<seealso cref="System.String.Substring"/>
		<seealso cref="System.String.Trim"/>
	</doc>
	<doc for="String.Concat5">
		<summary>
			<para>Concatenates two specified instances of <see cref="System.String"/>.</para>
		</summary>
		<param name="str0">The first <see cref="System.String"/>.</param>
		<param name="str1">The second <see cref="System.String"/>.</param>
		<returns>
			<para>The concatenation of <paramref name="str0"/> and
<paramref name="str1"/>.</para>
		</returns>
		<remarks>
			<para>An <see cref="System.String.Empty"/> string is used in place of any null argument.</para>
		</remarks>
		<example>
			<para>The following code example concatenates a person's first, middle, and last name.</para>
			<codelink SampleID="stringconcat4" SnippetID="1"/>
		</example>
		<seealso cref="System.String.Join"/>
	</doc>
	<doc for="String.Split1">
		<summary>
			<para>Identifies the substrings in this instance that are
      delimited by one or more characters specified in an array, then places the
      substrings into a <see cref="System.String"/> array. A parameter specifies the maximum number of array elements to return. </para>
		</summary>
		<param name="separator">An array of Unicode characters that delimit the substrings in this instance, an empty array containing no delimiters, or <see langword="null"/>.</param>
		<param name="count">The maximum number of array elements to return.</param>
		<returns>
			<para>An array consisting of a single element containing this instance, if this instance contains none of the characters in <paramref name="separator"/>.</para>
			<para>-or-</para>
			<para>An array of substrings if this instance is delimited by one or more of the characters in <paramref name="separator"/>. </para>
			<para>-or-</para>
			<para>An array of the substrings in this instance delimited by white space characters if those characters occur and <paramref name="separator"/> is <see langword="null"/> or contains no delimiter characters.</para>
			<para><see cref="System.String.Empty"/> is returned for any substring where two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance.</para>
			<para>Delimiter characters are not included in the substrings.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="count"/> is negative.</exception>
		<remarks>
			<para>If there are more than <paramref name="count"/> substrings in this
   instance, the first <paramref name="count"/> minus 1 substrings are returned in
   the first <paramref name="count"/> minus 1 elements of the return
   value, and the remaining characters in this instance are returned in the last element
   of the return value.</para>
			<para>If <paramref name="count"/> is greater than the number of substrings, the substrings
are returned and no exception is thrown.</para>
			<para>For example:</para>
			<list type="table">
				<listheader>
					<term>Input</term>
					<description>separator, count</description>
					<description>Output</description>
				</listheader>
				<item>
					<term> "42,
         12, 19" </term>
					<description> new Char[] {',', ' '}, 2 </description>
					<description>{"42", " 12, 19"} </description>
				</item>
				<item>
					<term> "42..12..19" </term>
					<description>new Char[] {'.'}, 4 </description>
					<description>{"42", "", "12", ".19"} </description>
				</item>
				<item>
					<term> "Banana" </term>
					<description>new Char[] {'.'}, 2 </description>
					<description>{"Banana"} </description>
				</item>
				<item>
					<term> "Darb\nSmarba" </term>
					<description>new Char[] {}, 1 </description>
					<description>{"Darb\nSmarba"} </description>
				</item>
				<item>
					<term> "Darb\nSmarba" </term>
					<description>new Char[] null, 2 </description>
					<description>{"Darb", "Smarba"} </description>
				</item>
				<item>
					<term> "Darb\nSmarba" </term>
					<description>new Char[] null, 100 </description>
					<description>{"Darb", "Smarba"} </description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following code example demonstrates how 
   <paramref name="count"/> affects the number of strings returned by <see cref="System.String.Split"/>. </para>
			<codelink SampleID="StringSplit2" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Array"/>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.Concat"/>
		<seealso cref="System.String.Insert"/>
		<seealso cref="System.String.Join"/>
		<seealso cref="System.String.Remove"/>
		<seealso cref="System.String.Replace"/>
		<seealso cref="System.String.Substring"/>
		<seealso cref="System.String.Trim"/>
	</doc>
	<doc for="String.ToCharArray">
		<overload>
			<para> Copies the characters in this instance to a Unicode character array.
      </para>
		</overload>
		<summary>
			<para>Copies the characters in this instance to a Unicode character array. </para>
		</summary>
		<returns>
			<para> A Unicode character array whose elements are the
      individual characters of this instance. If this instance is an empty string, the returned array is empty
      and has a zero length.</para>
		</returns>
		<example>
			<para>The following example demonstrates how to easily create a Unicode character 
      array from a <see cref="System.String"/>. The array is then used with the <see cref="System.String.Split"/> method.</para>
			<codelink SampleID="StringSplit2" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Array"/>
	</doc>
	<doc for="String.Substring">
		<overload>
			<para> Retrieves a substring from
      this instance.</para>
		</overload>
		<summary>
			<para> Retrieves a substring from this instance. The substring starts at a specified character position.</para>
		</summary>
		<param name="startIndex">The starting character position of a substring in this instance.</param>
		<returns>
			<para>A <see cref="System.String"/>
equivalent to the substring that begins at <paramref name="startIndex"/>
in this instance.</para>
			<para> -or-</para>
			<para><see cref="System.String.Empty"/> if
<paramref name="startIndex "/>is 
equal to the length of this instance.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero or greater than the length of this instance.</exception>
		<remarks>
			<para>The index is zero-based.</para>
		</remarks>
		<example>
			<para>The following example demonstrates obtaining a substring from a 
      string.</para>
			<codelink SampleID="stringsubstring" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.Concat"/>
		<seealso cref="System.String.Insert"/>
		<seealso cref="System.String.Join"/>
		<seealso cref="System.String.Remove"/>
		<seealso cref="System.String.Replace"/>
		<seealso cref="System.String.Split"/>
		<seealso cref="System.String.Trim"/>
	</doc>
	<doc for="String.IndexOf7">
		<summary>
			<para>Reports the index of the first occurrence of the
      specified <see cref="System.String"/> in this instance. The
      search starts at a specified character position.</para>
		</summary>
		<param name="value">The <see cref="System.String"/> to seek.</param>
		<param name="startIndex">The search starting position.</param>
		<returns>
			<para>The index position of <paramref name="value"/> if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="System.String.Empty"/>, the return value is
<paramref name="startIndex"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para>
				<paramref name="startIndex"/> is negative.</para><para>-or-</para>
			<para><paramref name="startIndex"/> specifies a position not within this instance.</para></exception>
		<remarks>
			<para>Index numbering starts from zero.</para>
			<para>This method performs a word (case-sensitive and
      culture-sensitive) search using the current culture. The search begins at the <paramref name="startIndex"/> character position of this instance and
      continues until the last character position.</para>
		</remarks>
		<example>
			<para>The following example searches for all occurrences of a 
      specified string within a target string.</para>
			<codelink SampleID="stringindexof4" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.Globalization.CultureInfo"/>
		<seealso cref="System.String.IndexOfAny"/>
		<seealso cref="System.String.LastIndexOf"/>
		<seealso cref="System.String.LastIndexOfAny"/>
	</doc>
	<doc for="String.ToLower">
		<overload>
			<para>Returns a copy of this <see cref="System.String"/> in lowercase.</para>
		</overload>
		<summary>
			<para>Returns a copy of this <see cref="System.String"/> in lowercase, using the casing rules of the current culture.</para>
		</summary>
		<returns>
			<para>A <see cref="System.String"/> in lowercase.</para>
		</returns>
		<remarks>
			<para>This method takes into account the current culture. For more information, see the <see cref="System.Globalization.CultureInfo"/> topic.</para>
		</remarks>
		<example>
			<para>The following example converts several mixed case strings to lowercase.</para>
			<codelink SampleID="stringlowerupper" SnippetID="1"/>
		</example>
		<seealso cref="System.String.ToUpper"/>
	</doc>
	<doc for="String.Trim1">
		<summary>
			<para> Removes all occurrences of white space characters from the beginning
      and end of this instance.</para>
		</summary>
		<returns>
			<para>A new <see cref="System.String"/> equivalent to this
   instance after
   white space characters
   are removed from the
   beginning and end.</para>
		</returns>
		<remarks>
			<para>For more information about what Unicode characters are categorized as white space characters, see
      the Remarks section of the <see cref="System.Char.IsWhiteSpace" qualify="true"/>
      method.</para>
		</remarks>
		<example>
			<para>The following example demonstrates the <see cref="System.String.Trim"/> method.</para>
			<codelink SampleID="stringtrim" SnippetID="1"/>
		</example>
		<seealso cref="System.String.TrimEnd"/>
		<seealso cref="System.String.TrimStart"/>
	</doc>
	<doc for="String.Replace">
		<overload>
			<para>Replaces all occurrences of a specified Unicode
      character or <see cref="System.String"/> in
      this instance, with another specified Unicode character or <see cref="System.String"/>. </para>
		</overload>
		<summary>
			<para>Replaces all occurrences of a specified Unicode character in this instance
      with another specified Unicode character. </para>
		</summary>
		<param name="oldChar">A Unicode character to be replaced. </param>
		<param name="newChar">A Unicode character to replace all occurrences of <paramref name="oldChar"/>. </param>
		<returns>
			<para> A <see cref="System.String"/> equivalent to this instance but
   with all instances of <paramref name="oldChar"/> replaced with <paramref name="newChar"/>.</para>
		</returns>
		<remarks>
			<para>This method performs an ordinal (case-sensitive and culture-insensitive) search to find
   <paramref name="oldChar"/>.</para>
		</remarks>
		<example>
			<para>The following example creates a comma separated value list by substituting 
      commas for the blanks between a series of numbers.</para>
			<codelink SampleID="string.replace1" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.String.Concat"/>
		<seealso cref="System.String.Insert"/>
		<seealso cref="System.String.Join"/>
		<seealso cref="System.String.Remove"/>
		<seealso cref="System.String.Split"/>
		<seealso cref="System.String.Substring"/>
		<seealso cref="System.String.Trim"/>
	</doc>
	<doc for="String.ToString">
		<overload>
			<para>Converts the value of this instance to a
   <see cref="System.String"/>.</para>
		</overload>
		<summary>
			<para>Returns this instance of <see cref="System.String"/>; no
   actual conversion is performed.</para>
		</summary>
		<returns>
			<para>This <see cref="System.String"/>.</para>
		</returns>
		<example>
			<para>The following example demonstrates the <see cref="System.String.ToString"/> method.</para>
			<codelink SampleID="string.tostring" SnippetID="1"/>
		</example>
		<seealso cref="System.String.Clone"/>
	</doc>
	<doc for="String.Trim">
		<overload>
			<para> Removes all occurrences of a set of specified characters
      from the beginning and end of this instance.</para>
		</overload>
		<summary>
			<para> Removes all occurrences of a set of characters specified in an array from the beginning
      and end of this instance.</para>
		</summary>
		<param name="trimChars">An array of Unicode characters to be removed or <see langword="null"/>.</param>
		<returns>
			<para>The <see cref="System.String"/> that
   remains after all occurrences of the characters in
<paramref name="trimChars"/> are 
   removed from the
   beginning and end of this
   instance. If <paramref name="trimChars"/> is <see langword="null"/>, white space characters
   are removed instead.</para>
		</returns>
		<remarks>
			<para>For more information about what Unicode characters are categorized as white space characters, see
      the Remarks section of the <see cref="System.Char.IsWhiteSpace" qualify="true"/>
      method.</para>
		</remarks>
		<example>
			<para>The following example demonstrates the <see cref="System.String.Trim"/> method.</para>
			<codelink SampleID="string.trim2" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.String.TrimEnd"/>
		<seealso cref="System.String.TrimStart"/>
	</doc>
	<doc for="String.Concat">
		<overload>
			<para>Concatenates one or more instances of <see cref="System.String"/>, or the <see cref="System.String"/> representations
   of the values of one or more instances of <see cref="System.Object"/>.</para>
		</overload>
		<summary>
			<para>Creates the <see cref="System.String"/>
representation of a specified object.</para>
		</summary>
		<param name="arg0">An <see cref="System.Object"/> or <see langword="null"/>.</param>
		<returns>
			<para>The <see cref="System.String"/> representation
   of the value of <paramref name="arg0"/>.</para>
		</returns>
		<remarks>
			<para>An <see cref="System.String.Empty"/> string is used in place of any null argument.</para>
		</remarks>
		<example>
			<para>The following example demonstrates the <see cref="System.String.Concat"/> method.</para>
			<codelink SampleID="string.concat5" SnippetID="1"/>
		</example>
		<seealso cref="System.Object"/>
		<seealso cref="System.String.Join"/>
	</doc>
	<doc for="String.Concat1">
		<summary>
			<para> Concatenates the <see cref="System.String"/> representations of two specified objects.</para>
		</summary>
		<param name="arg0">The first <see cref="System.Object"/>.</param>
		<param name="arg1">The second <see cref="System.Object"/>.</param>
		<returns>
			<para>The concatenated <see cref="System.String"/> representations of the values of <paramref name="arg0"/> and <paramref name="arg1"/>.</para>
		</returns>
		<remarks>
			<para>An <see cref="System.String.Empty"/> string is used in place of any null argument.</para>
			<para>If either of the arguments is an array reference, the
   method concatenates a string representing that array, instead of its members (for example, "System.String[]").</para>
		</remarks>
		<example>
			<para>The following example demonstrates the <see cref="System.String.Concat"/> method.</para>
			<codelink SampleID="string.concat5" SnippetID="1"/>
		</example>
		<seealso cref="System.Object"/>
		<seealso cref="System.String.Join"/>
	</doc>
	<doc for="String.Concat2">
		<summary>
			<para>Concatenates the <see cref="System.String"/> representations of three specified objects.</para>
		</summary>
		<param name="arg0">The first <see cref="System.Object"/>.</param>
		<param name="arg1">The second <see cref="System.Object"/>.</param>
		<param name="arg2">The third <see cref="System.Object"/>.</param>
		<returns>
			<para>The concatenated <see cref="System.String"/> representations of the values of
<paramref name="arg0"/>, <paramref name="arg1"/>, and <paramref name="arg2"/>.</para>
		</returns>
		<remarks>
			<para>An <see cref="System.String.Empty"/> string is used in place of any null argument.</para>
		</remarks>
		<example>
			<para>The following example demonstrates the <see cref="System.String.Concat"/> method.</para>
			<codelink SampleID="string.concat5" SnippetID="1"/>
		</example>
		<seealso cref="System.Object"/>
		<seealso cref="System.String.Join"/>
	</doc>
	<doc for="String.Concat3">
		<summary>
			<para>Concatenates the <see cref="System.String"/> representations of three specified objects
   and a variable-length parameter list.</para>
		</summary>
		<param name="arg0">The first <see cref="System.Object"/>.</param>
		<param name=" arg1">The second <see cref="System.Object"/>.</param>
		<param name=" arg2">The third <see cref="System.Object"/>.</param>
		<param name=" arg3">The fourth <see cref="System.Object"/>.</param>
		<returns>
			<para>The concatenated <see cref="System.String"/> representations of the values of <paramref name="arg0"/>, <paramref name="arg1"/>, <paramref name="arg2"/>,
<paramref name="arg3"/>, and zero or 
   more objects specified in a variable-length parameter list.</para>
		</returns>
		<remarks>
			<para>Additional arguments can be included in a variable-length parameter list.</para>
			<para> An <see cref="System.String.Empty"/> string is used in
   place of any null argument.</para>
		</remarks>
		<example>
			<para>The following example demonstrates the <see cref="System.String.Concat"/> method.</para>
			<codelink SampleID="string.concat5" SnippetID="1"/>
		</example>
		<seealso cref="System.Object"/>
		<seealso cref="System.String.Join"/>
	</doc>
	<doc for="String.Compare2">
		<summary>
			<para> Compares two specified <see cref="System.String"/> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison.</para>
		</summary>
		<param name="strA">The first <see cref="System.String"/>.</param>
		<param name="strB">The second <see cref="System.String"/>.</param>
		<param name="ignoreCase">A <see cref="System.Boolean"/> indicating a case-sensitive or insensitive comparison. (<see langword="true"/> indicates a case-insensitive comparison.)</param>
		<param name="culture">A <see cref="System.Globalization.CultureInfo"/> object that supplies culture-specific comparison information.</param>
		<returns>
			<para>A 32-bit signed integer indicating the lexical relationship between the two
      comparands.</para>
			<list type="table">
				<listheader>
					<term> Value</term>
					<description>Meaning</description>
				</listheader>
				<item>
					<term> Less than zero</term>
					<description><paramref name="strA"/> is less than <paramref name="strB"/>.</description>
				</item>
				<item>
					<term> Zero</term>
					<description><paramref name="strA"/> equals <paramref name="strB"/>.</description>
				</item>
				<item>
					<term> Greater than zero</term>
					<description><paramref name="strA"/> is greater than <paramref name="strB"/>.</description>
				</item>
			</list>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/>.</exception>
		<remarks>
			<para> The comparison uses the <paramref name="culture"/> parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it. </para>
			<para>The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <see cref="System.Globalization.CompareOptions" qualify="true"/>.</para>
			<para>One or both comparands can be <see langword="null"/>. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</para>
			<para>The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed. </para>
			<para>Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter 'i' in "file". </para>
			<code>
static String IsFileURI(String path) { 
   return (String.Compare(path, 0, "file:", 0, 5, true)== 0); }
</code>
			<para>The path name needs to be compared in an invariant manner. The correct code to do this is as follows. </para>
			<code>
static String IsFileURI(String path) { 
   return (String.Compare(path, 0, "file:", 0, 5, true, CultureInfo.InvariantCulture)== 0); }
</code>
		</remarks>
		<example>
			<para>The following example demonstrates how culture can affect a comparison. In 
      Czech - Czech Republic culture, 'ch' is a single character that is greater than
      'd'. However, in English - United States culture, "ch" consists of two
      characters, and 'c' is less than 'd'. </para>
			<codelink SampleID="string.comp4" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.CompareOrdinal"/>
		<seealso cref="System.String.CompareTo"/>
		<seealso cref="System.Globalization.CompareInfo.IsPrefix"/>
		<seealso cref="System.Boolean"/>
	</doc>
	<doc for="String.Replace1">
		<summary>
			<para>Replaces all occurrences of a specified
   <see cref="System.String"/> in this instance,
      with another specified <see cref="System.String"/>. </para>
		</summary>
		<param name="oldValue">A <see cref="System.String"/> to be replaced. </param>
		<param name="newValue">A <see cref="System.String"/> to replace all occurrences of <paramref name="oldValue"/>. </param>
		<returns>
			<para> A <see cref="System.String"/> equivalent to this instance but
   with all instances of <paramref name="oldValue"/> replaced with <paramref name="newValue"/>.
   </para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="oldValue"/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException"><paramref name="oldValue"/> is the empty string ("").</exception>
		<remarks>
			<para>If <paramref name="newValue"/> is <see langword="null"/>, all occurrences of <paramref name="oldValue"/> are removed.</para>
			<para>This method performs a word (case-sensitive and culture-sensitive) search to
   find <paramref name="oldValue"/>.</para>
		</remarks>
		<example>
			<para>The following code example demonstrates how you can use the <see cref="System.String.Replace"/> method to
   correct a spelling error.</para>
			<codelink SampleID="stringreplace" SnippetID="1"/>
		</example>
		<seealso cref="System.String.Concat"/>
		<seealso cref="System.String.Insert"/>
		<seealso cref="System.String.Join"/>
		<seealso cref="System.String.Remove"/>
		<seealso cref="System.String.Split"/>
		<seealso cref="System.String.Substring"/>
		<seealso cref="System.String.Trim"/>
	</doc>
	<doc for="String.Compare1">
		<summary>
			<para> Compares two specified <see cref="System.String"/> objects, ignoring or honoring their
   case.</para>
		</summary>
		<param name="strA">The first <see cref="System.String"/>.</param>
		<param name="strB">The second <see cref="System.String"/>.</param>
		<param name="ignoreCase">A <see cref="System.Boolean"/> indicating a case-sensitive or insensitive comparison. (<see langword="true"/> indicates a case-insensitive comparison.)</param>
		<returns>
			<para>A 32-bit signed integer indicating the lexical relationship between the two
      comparands.</para>
			<list type="table">
				<listheader>
					<term> Value</term>
					<description>Meaning</description>
				</listheader>
				<item>
					<term> Less than zero</term>
					<description><paramref name="strA"/> is less than <paramref name="strB"/>.</description>
				</item>
				<item>
					<term> Zero</term>
					<description><paramref name="strA"/> equals <paramref name="strB"/>.</description>
				</item>
				<item>
					<term> Greater than zero</term>
					<description><paramref name="strA"/> is greater than <paramref name="strB"/>.</description>
				</item>
			</list>
		</returns>
		<remarks>
			<para>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it. </para>
			<para>The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <see cref="System.Globalization.CompareOptions" qualify="true"/>.</para>
			<para>One or both comparands can be <see langword="null"/>. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</para>
			<para>The comparison terminates when an inequality is discovered or both strings have been compared. However, if the two strings compare equal to the end of one string, and other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed. </para>
			<para>Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter 'i' in "file". </para>
			<code>
static String IsFileURI(String path) { 
   return (String.Compare(path, 0, "file:", 0, 5, true)== 0); }
</code>
			<para>The path name needs to be compared in an invariant manner. The correct code to do this is as follows. </para>
			<code>
static String IsFileURI(String path) { 
   return (String.Compare(path, 0, "file:", 0, 5, true, CultureInfo.InvariantCulture)== 0); }
</code>
		</remarks>
		<example>
			<para>The following code example demonstrates how this <see cref="System.String.Compare"/> method
   is equivalent to using <see cref="System.String.ToUpper"/> or <see cref="System.String.ToLower"/> when
   comparing strings.</para>
			<codelink SampleID="stringexample1" SnippetID="2"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.CompareOrdinal"/>
		<seealso cref="System.String.CompareTo"/>
		<seealso cref="System.Globalization.CompareInfo.IsPrefix"/>
	</doc>
	<doc for="String.String1">
		<summary>
			<para>Initializes a new instance of the <see cref="System.String"/> class to the value indicated by a specified pointer to an array of Unicode characters,
   a starting character position within that array,
   and a length.</para>
		</summary>
		<param name="value">A pointer to an array of Unicode characters.</param>
		<param name="startIndex">The starting position within <paramref name="value"/>.</param>
		<param name="length">The number of characters within <paramref name="value"/> to use.</param>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="startIndex"/> or <paramref name="length"/> is less than zero.</para>
			<para>-or-</para>
			<para><paramref name="value"/> is a null pointer and <paramref name="length"/> is not zero.</para></exception>
		<remarks>
			<para>If <paramref name="length"/> is zero, an <see cref="System.String.Empty"/> instance is initialized.</para>
			<para>This constructor copies Unicode characters from
<paramref name="value"/>, starting at <paramref name="startIndex"/> and ending at 
   (<paramref name="startIndex"/> + <paramref name="length"/>
   - 1).</para>
			<para>If the specified range is outside of the memory
   allocated for the sequence of characters, the behavior of this constructor is
   system dependent. For example, such a situation might cause an access violation.</para>
			<para>In C#, this constructor is defined only in the context
   of unmanaged code.</para>
		</remarks>
		<example>
			<para>
			</para>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
	</doc>
	<doc for="String.Compare3">
		<summary>
			<para>Compares substrings of two specified <see cref="System.String"/>
objects.</para>
		</summary>
		<param name="strA">The first <see cref="System.String"/>.</param>
		<param name="indexA">The position of the substring within <paramref name="strA"/>.</param>
		<param name="strB">The second <see cref="System.String"/>.</param>
		<param name="indexB">The position of the substring within <paramref name="strB"/>.</param>
		<param name="length">The maximum number of characters in the substrings to compare.</param>
		<returns>
			<para>A 32-bit signed integer indicating the lexical relationship between the two
      comparands.</para>
			<list type="table">
				<listheader>
					<term> Value</term>
					<description>Meaning</description>
				</listheader>
				<item>
					<term> Less than zero</term>
					<description>The substring in <paramref name="strA"/> is minus than the substring
         in <paramref name="strB"/>.</description>
				</item>
				<item>
					<term> Zero</term>
					<description> The substrings are equal, or <paramref name="length"/> is zero.</description>
				</item>
				<item>
					<term> Greater than zero</term>
					<description>The substring in
   <paramref name="strA"/> is greater than the substring in
   <paramref name="strB"/>.</description>
				</item>
			</list>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException"><para>
				<paramref name="indexA"/> is greater than <paramref name="strA"/>.<see cref="System.String.Length"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="indexB"/> is greater than <paramref name="strB"/>.<see cref="System.String.Length"/>.</para>
			<para>-or-</para>
			<para><paramref name="indexA"/>, <paramref name="indexB"/>, or <paramref name="length"/> is negative.</para></exception>
		<remarks>
			<para> The substrings to compare start at <paramref name="strA"/> plus <paramref name="indexA"/>, and <paramref name="strB"/> plus <paramref name="indexB"/>. The length of the first substring is the length of <paramref name="strA"/> minus <paramref name="indexA"/>, and the length of the second substring is the length of <paramref name="strB"/> minus <paramref name="indexB"/>. </para>
			<para>The number of characters to compare is the lesser of the lengths of the two substrings, and <paramref name="length"/>. The <paramref name="indexA"/>, <paramref name="indexB"/>, and <paramref name="length"/> parameters must be nonnegative. </para>
			<para>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it. </para>
			<para>The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <see cref="System.Globalization.CompareOptions" qualify="true"/>.</para>
			<para>One or both comparands can be <see langword="null"/>. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</para>
			<para>The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed. </para>
			<para>Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter 'i' in "file". </para>
			<code>
static String IsFileURI(String path) { 
   return (String.Compare(path, 0, "file:", 0, 5, true)== 0); }
</code>
			<para>The path name needs to be compared in an invariant manner. The correct code to do this is as follows. </para>
			<code>
static String IsFileURI(String path) { 
   return (String.Compare(path, 0, "file:", 0, 5, true, CultureInfo.InvariantCulture)== 0); }
</code>
		</remarks>
		<example>
			<codelink SampleID="string.compare3" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.CompareOrdinal"/>
		<seealso cref="System.String.CompareTo"/>
	</doc>
	<doc for="String.Compare4">
		<summary>
			<para>Compares substrings of two specified <see cref="System.String"/> objects, ignoring or honoring their case.</para>
		</summary>
		<param name="strA">The first <see cref="System.String"/>.</param>
		<param name="indexA">The position of the substring within <paramref name="strA"/>.</param>
		<param name="strB">The second <see cref="System.String"/>.</param>
		<param name="indexB">The position of the substring within <paramref name="strB"/>.</param>
		<param name="length">The maximum number of characters in the substrings to compare.</param>
		<param name=" ignoreCase">A <see cref="System.Boolean"/> indicating a case-sensitive or insensitive comparison. (<see langword="true"/> indicates a case-insensitive comparison.) </param>
		<returns>
			<para>A 32-bit signed integer indicating the lexical relationship between the two
      comparands.</para>
			<list type="table">
				<listheader>
					<term>Value Type</term>
					<description>Condition</description>
				</listheader>
				<item>
					<term> Less than zero</term>
					<description>The substring in <paramref name="strA"/> is less than the substring in <paramref name="strB"/>.</description>
				</item>
				<item>
					<term> Zero</term>
					<description>The substrings are equal, or <paramref name="length"/> is zero.</description>
				</item>
				<item>
					<term> Greater than zero</term>
					<description>The substring in <paramref name="strA"/> is greater than the substring in <paramref name="strB"/>.</description>
				</item>
			</list>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="indexA"/> is greater than <paramref name="strA"/>.<see cref="System.String.Length"/>.</para><para>-or-</para><para><paramref name="indexB"/> is greater than <paramref name="strB"/>.<see cref="System.String.Length"/>.</para><para>-or-</para><para><paramref name="indexA"/>, <paramref name="indexB"/>, or <paramref name="length"/> is negative.</para></exception>
		<remarks>
			<para> The substrings to compare start at <paramref name="strA"/> plus <paramref name="indexA"/>, and <paramref name="strB"/> plus <paramref name="indexB"/>. The length of the first substring is the length of <paramref name="strA"/> minus <paramref name="indexA"/>, and the length of the second substring is the length of <paramref name="strB"/> minus <paramref name="indexB"/>. </para>
			<para>The number of characters to compare is the lesser of the lengths of the two substrings, and <paramref name="length"/>. The <paramref name="indexA"/>, <paramref name="indexB"/>, and <paramref name="length"/> parameters must be nonnegative. </para>
			<para>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters. For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it. </para>
			<para>The comparison is performed using word sort rules. For more information about word, string, and ordinal sorts, see <see cref="System.Globalization.CompareOptions" qualify="true"/>.</para>
			<para>One or both comparands can be <see langword="null"/>. By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</para>
			<para>The comparison terminates when an inequality is discovered or both substrings have been compared. However, if the two strings compare equal to the end of one string, and other string has characters remaining, then the string with remaining characters is considered greater. The return value is the result of the last comparison performed. </para>
			<para>Unexpected results can occur when comparisons are affected by culture-specific casing rules. For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter 'i' in "file". </para>
			<code>
static String IsFileURI(String path) { 
   return (String.Compare(path, 0, "file:", 0, 5, true)== 0); }
</code>
			<para>The path name needs to be compared in an invariant manner. The correct code to do this is as follows. </para>
			<code>
static String IsFileURI(String path) { 
   return (String.Compare(path, 0, "file:", 0, 5, true, CultureInfo.InvariantCulture)== 0); }
</code>
		</remarks>
		<example>
			<codelink SampleID="string.compare4" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.CompareOrdinal"/>
		<seealso cref="System.String.CompareTo"/>
	</doc>
	<doc for="String.Compare5">
		<summary>
			<para>Compares substrings of two specified <see cref="System.String"/> objects, ignoring or honoring their case,
   and using culture-specific information to influence
   the comparison.</para>
		</summary>
		<param name="strA">The first <see cref="System.String"/>.</param>
		<param name="indexA">The position of the substring within <paramref name="strA"/>.</param>
		<param name="strB">The second <see cref="System.String"/>.</param>
		<param name="indexB">The position of the substring within the <paramref name="strB"/>.</param>
		<param name="length">The maximum number of characters in the substrings to compare.</param>
		<param name="ignoreCase">A <see cref="System.Boolean"/> indicating a case-sensitive or insensitive comparison. (<see langword="true"/> indicates a case-insensitive comparison.) </param>
		<param name=" culture">A <see cref="System.Globalization.CultureInfo"/> object that supplies culture-specific comparison information.</param>
		<returns>
			<para>An integer indicating the lexical relationship between the two comparands.</para>
			<list type="table">
				<listheader>
					<term>Value Type</term>
					<description>Condition</description>
				</listheader>
				<item>
					<term> Less than zero</term>
					<description>The substring in <paramref name="strA"/> is less than the substring in <paramref name="strB"/>.</description>
				</item>
				<item>
					<term> Zero</term>
					<description>The substrings are equal, or <paramref name="length"/> is zero.</description>
				</item>
				<item>
					<term> Greater than zero</term>
					<description>The substring in <paramref name="strA"/> is greater than the substring in <paramref name="strB"/>.</description>
				</item>
			</list>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException"><para>
				<paramref name="indexA"/> is greater than <paramref name="strA"/>.<see cref="System.String.Length"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="indexB"/> is greater than <paramref name="strB"/>.<see cref="System.String.Length"/>.</para>
			<para>-or-</para>
			<para><paramref name="indexA"/>, <paramref name="indexB"/>, or <paramref name="length"/> is negative.</para></exception>
		<exception cref="System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/>.</exception>
		<remarks>
			<para> The substrings to compare start at <paramref name="strA"/> plus
<paramref name="indexA"/>, and <paramref name="strB"/> plus <paramref name="indexB"/>. The length of the first 
   substring is the length of <paramref name="strA"/> minus <paramref name="indexA"/>, and the length of
   the second substring is the length of <paramref name="strB"/> minus <paramref name="indexB"/>. </para>
			<para> The number of characters to compare is the
   lesser of the lengths of the two substrings, and <paramref name="length"/>. The
<paramref name="indexA"/>, <paramref name="indexB"/>, and <paramref name="length"/> 
parameters must be nonnegative. </para>
			<para> The comparison uses the
<paramref name="culture"/> parameter to obtain culture-specific 
   information such as casing rules and the alphabetic order of individual
   characters. For example, a culture could specify that certain combinations of
   characters be treated as a single character, or uppercase and lowercase characters be compared
   in a particular way, or that the sorting order of a character
   depends on the characters that precede or follow it. </para>
			<para>The comparison is performed using word sort rules. For
   more information about word, string, and ordinal sorts, see <see cref="System.Globalization.CompareOptions" qualify="true"/>.</para>
			<para>One or both comparands can be <see langword="null"/>. By definition, any string, including the
empty string (""), compares greater than a null reference; and two null
references compare equal to each other.</para>
			<para>The comparison terminates when an inequality is discovered or both
   substrings have been compared. However, if the two strings compare equal to the
   end of one string, and other string has characters remaining, then the string
   with remaining characters is considered greater. The return value is the result
   of the last comparison performed. </para>
			<para>Unexpected results can occur when comparisons are affected by
   culture-specific casing rules. For example, in Turkish, the following example
   yields the wrong results because the file system in Turkish does not use
   linguistic casing rules for the letter 'i' in "file". </para>
			<code>
static String IsFileURI(String path) { 
   return (String.Compare(path, 0, "file:", 0, 5, true)== 0); }
</code>
			<para>The path name needs to be compared in an invariant manner. The correct code
   to do this is as follows. </para>
			<code>
static String IsFileURI(String path) { 
   return (String.Compare(path, 0, "file:", 0, 5, true, CultureInfo.InvariantCulture)== 0); }
</code>
		</remarks>
		<example>
			<codelink SampleID="string.compare5" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.CompareOrdinal"/>
		<seealso cref="System.String.CompareTo"/>
	</doc>
	<doc for="String.CompareOrdinal">
		<overload>
			<para>Compares two <see cref="System.String"/> objects by evaluating the numeric values of the
   corresponding <see cref="System.Char"/> objects in
   each string.</para>
		</overload>
		<summary>
			<para>Compares two specified <see cref="System.String"/> objects by evaluating the numeric
   values of the corresponding <see cref="System.Char"/> objects in each string.</para>
		</summary>
		<param name="strA">The first <see cref="System.String"/>.</param>
		<param name="strB">The second <see cref="System.String"/>.</param>
		<returns>
			<para>An integer indicating the lexical relationship between the two comparands.</para>
			<list type="table">
				<listheader>
					<term>Permission</term>
					<description>Description</description>
				</listheader>
				<item>
					<term> Less than zero</term>
					<description><paramref name="strA"/> is less than
      <paramref name="strB"/>.</description>
				</item>
				<item>
					<term> Zero</term>
					<description><paramref name="strA"/> and <paramref name="strB"/> are equal.</description>
				</item>
				<item>
					<term> Greater than zero</term>
					<description><paramref name="strA"/> is greater than
<paramref name="strB"/>.</description>
				</item>
			</list>
		</returns>
		<remarks>
			<para>This method performs a comparison using ordinal sort rules. For more information
      about word, string, and ordinal sorts, see <see cref="System.Globalization.CompareOptions" qualify="true"/>.</para>
		</remarks>
		<example>
			<codelink SampleID="string.compareordinal" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.Compare"/>
		<seealso cref="System.String.CompareTo"/>
	</doc>
	<doc for="String.Copy">
		<summary>
			<para>Creates a new instance of <see cref="System.String"/> with the same value as
   a specified <see cref="System.String"/>.</para>
		</summary>
		<param name="str">The <see cref="System.String"/> to copy.</param>
		<returns>
			<para>A new <see cref="System.String"/> with the same value as
<paramref name="str"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="str"/> is <see langword="null"/>.</exception>
		<example>
			<codelink SampleID="string.copy" SnippetID="1"/>
		</example>
		<seealso cref="System.String.Empty"/>
		<seealso cref="System.DBNull"/>
	</doc>
	<doc for="String.Equals">
		<overload>
			<para>Determines whether two <see cref="System.String"/> objects have the same value.</para>
		</overload>
		<summary>
			<para>Determines whether this instance of <see cref="System.String"/> and a specified object, which must be a
<see cref="System.String"/>, have the
   same value.</para>
		</summary>
		<param name="obj">An <see cref="System.Object"/>.</param>
		<returns>
			<para><see langword="true"/> if <paramref name="obj"/> is a <see cref="System.String"/>
and its value is
the same as this instance; otherwise, <see langword="false"/>.</para>
		</returns>
		<exception cref="System.NullReferenceException">This instance is <see langword="null"/>.</exception>
		<remarks>
			<para>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</para>
		</remarks>
		<example>
			<codelink SampleID="string.equals" SnippetID="1"/>
		</example>
		<seealso cref="System.Object"/>
		<seealso cref="System.String.CompareOrdinal"/>
	</doc>
	<doc for="String.Equals2">
		<summary>
			<para> Determines whether two specified <see cref="System.String"/> objects have the
   same value.</para>
		</summary>
		<param name="a">A <see cref="System.String"/> or <see langword="null"/>.</param>
		<param name="b">A <see cref="System.String"/> or <see langword="null"/>.</param>
		<returns>
			<para><see langword="true"/> if the value of <paramref name="a"/> is the same as the value of <paramref name="b"/>; otherwise, <see langword="false"/>.</para>
		</returns>
		<remarks>
			<para>This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</para>
		</remarks>
		<example>
			<codelink SampleID="string.equals" SnippetID="1"/>
		</example>
		<seealso cref="System.String.CompareOrdinal"/>
	</doc>
	<doc for="String.GetTypeCode">
		<summary>
			<para>Returns the <see cref="System.TypeCode"/> for class <see cref="System.String"/>.</para>
		</summary>
		<returns>
			<para>The enumerated constant, <see cref="System.TypeCode.String" qualify="true"/>.</para>
		</returns>
		<example>
			<codelink SampleID="string.gettypecode" SnippetID="1"/>
		</example>
	</doc>
	<doc for="String.IndexOf1">
		<summary>
			<para>Reports the index of the first occurrence of the specified Unicode
      character in this instance. The search starts at a specified character position.</para>
		</summary>
		<param name="value">A Unicode character to seek.</param>
		<param name="startIndex">The search starting position.</param>
		<returns>
			<para>The index position of <paramref name="value"/> if that character is found, or -1 if it is not.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero or specifies a position beyond the end of this instance.</exception>
		<remarks>
			<para>Index numbering starts from zero. </para>
			<para>The search ranges from <paramref name="startIndex"/> to the end of the string.</para>
			<para>The search for <paramref name="value"/> is case-sensitive.</para>
			<para>This method performs an ordinal (culture-insensitive) search, where a
   character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <see cref="System.Globalization.CompareInfo.IndexOf" qualify="true"/> method, where a Unicode scalar value representing
   a precomposed character, such as the ligature 'Æ' (U+00C6), might be considered
   equivalent to any occurrence of the character's components in the correct
   sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
		</remarks>
		<example>
			<codelink SampleID="string.indexof1" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.Char"/>
		<seealso cref="System.String.IndexOfAny"/>
		<seealso cref="System.String.LastIndexOf"/>
		<seealso cref="System.String.LastIndexOfAny"/>
	</doc>
	<doc for="String.IndexOf8">
		<summary>
			<para>Reports the index of the first occurrence of the
      specified <see cref="System.String"/> in this instance. The search starts
      at a specified character position and examines a specified number of character positions.</para>
		</summary>
		<param name="value">The <see cref="System.String"/> to seek.</param>
		<param name="startIndex">The search starting position.</param>
		<param name="count">The number of character positions to examine.</param>
		<returns>
			<para>The index position of <paramref name="value"/> if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="System.String.Empty"/>, the return value is
<paramref name="startIndex"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="value "/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para>
				<paramref name="count"/> or <paramref name="startIndex"/> is negative.</para>
			<para>-or-</para>
			<para>
				<paramref name="count"/> plus <paramref name="startIndex"/> specify a position not within this instance.</para></exception>
		<remarks>
			<para>Index numbering starts from zero.</para>
			<para>This method performs a word (case-sensitive and
      culture-sensitive) search using the current culture. The search begins at <paramref name="startIndex"/> and continues to <paramref name="startIndex"/> +
   <paramref name="count"/> -1. The character at <paramref name="startIndex"/> + <paramref name="count"/> is not included in the search.</para>
		</remarks>
		<example>
			<codelink SampleID="string.indexof8" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.Globalization.CultureInfo"/>
		<seealso cref="System.String.IndexOfAny"/>
		<seealso cref="System.String.LastIndexOf"/>
		<seealso cref="System.String.LastIndexOfAny"/>
	</doc>
	<doc for="String.Intern">
		<summary>
			<para> Retrieves the system's reference to the specified
   <see cref="System.String"/>.
      </para>
		</summary>
		<param name="str">A <see cref="System.String"/>.</param>
		<returns>
			<para> If the value of <paramref name="str"/> is already
   interned, the system's reference is returned;
   otherwise, a new reference to a string with the value of
<paramref name="str"/> is returned.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="str"/> is <see langword="null"/>.</exception>
		<remarks>
			<para> The common language runtime conserves string storage by
      maintaining a table, called the intern pool, that contains a single reference to
      each unique literal string declared or created programmatically in your program.
      Consequently, an instance of a literal string with a particular value only
      exists once in the system.
      </para>
			<para>For example, if you assign the same literal string to several variables, the
      runtime retrieves the same reference to the literal string from the intern pool
      and assigns it to each variable. </para>
			<para>The <see cref="System.String.Intern"/> method uses the intern pool to search for a string equal
   to the value of <paramref name="str"/>. If such a string exists, its reference in the
   intern pool is returned. If the string does not exist, a reference to
<paramref name="str"/> is added to the intern pool, then that reference is returned. </para>
			<para>In the C# example that follows, the string, s1, which has a value of "MyTest",
   is already interned because it is a literal in the program. </para>
			<para>The <see cref="System.Text.StringBuilder" qualify="true"/> class generates a new string object that has the
same value as s1. A reference to that string is assigned to s2. </para>
			<para>The <see cref="System.String.Intern"/> method searches for a string that has the same value as
s2. Since such a string exists, the method returns the same reference that is
assigned to s1, then that reference is assigned to s3. </para>
			<para>References s1 and s2 compare unequal because they refer to different objects,
   while references s1 and s3 compare equal because they refer to the same string. </para>
			<code>
String s1 = "MyTest"; 
String s2 = new StringBuilder().Append("My").Append("Test").ToString(); 
String s3 = String.Intern(s2); 
Console.WriteLine((Object)s2==(Object)s1); // Different references. 
Console.WriteLine((Object)s3==(Object)s1); // The same reference.
</code>
			<para> Compare this method to the <see cref="System.String.IsInterned"/> method.</para>
		</remarks>
		<example>
			<codelink SampleID="string.intern" SnippetID="1"/>
		</example>
		<seealso cref="System.String.IsInterned"/>
	</doc>
	<doc for="String.IsInterned">
		<summary>
			<para> Retrieves a reference to a specified <see cref="System.String"/>.
   </para>
		</summary>
		<param name="str">A <see cref="System.String"/>. </param>
		<returns>
			<para> A <see cref="System.String"/> reference to <paramref name="str"/> if it is in the common language runtime "intern pool"; otherwise <see langword="null"/>.
   </para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="str"/> is <see langword="null"/>. </exception>
		<remarks>
			<para>The common language runtime automatically maintains a
      table, called the "intern pool", which contains a single instance of each unique
      literal string constant declared in a program, as well as any unique instance of
   <see cref="System.String"/> you add programmatically. </para>
			<para>The intern pool conserves string storage. If you assign
      a literal string constant to several variables, each variable is set to
      reference the same constant in the intern pool instead of referencing several
      different instances of <see cref="System.String"/> that have identical values. </para>
			<para>This method looks up <paramref name="str"/>
in the intern pool. If <paramref name="str"/> has already been interned, a reference to that
instance is returned; otherwise, <see langword="null"/> is returned. </para>
			<para> Compare this method to the <see cref="System.String.Intern"/> method.</para>
			<para> This method does not return a Boolean value, but can
   still be used where a Boolean is needed.</para>
		</remarks>
		<example>
			<codelink SampleID="string.isinterned" SnippetID="1"/>
		</example>
		<seealso cref="System.String.Intern"/>
	</doc>
	<doc for="String.LastIndexOf1">
		<summary>
			<para>Reports the index position of the last occurrence of a specified Unicode character within this instance. The search starts at a specified character position.</para>
		</summary>
		<param name="value">A Unicode character to seek.</param>
		<param name="startIndex">The starting position of a substring within this instance.</param>
		<returns>
			<para> The index position of <paramref name="value"/> if that character is found, or -1 if it is not.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero or greater than the length of this instance.</exception>
		<remarks>
			<para>Index numbering starts from zero.</para>
			<para>This method begins searching at the <paramref name="startIndex"/> character position of this instance and precedes backwards towards the beginning until either <paramref name="value"/> is found or the first character
   position has been examined. The search is case-sensitive.</para>
			<para>This method performs an ordinal (culture-insensitive) search, where a
   character is considered equivalent to another character only if their Unicode scalar values are the same. To perform a culture-sensitive search, use the <see cref="System.Globalization.CompareInfo.LastIndexOf" qualify="true"/> method, where a Unicode scalar value
   representing a precomposed character, such as the ligature 'Æ' (U+00C6), might
   be considered equivalent to any occurrence of the character's components in the
   correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
		</remarks>
		<example>
			<codelink SampleID="string.lastindexof1" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.IndexOf"/>
		<seealso cref="System.String.IndexOfAny"/>
		<seealso cref="System.String.LastIndexOfAny"/>
	</doc>
	<doc for="String.LastIndexOf2">
		<summary>
			<para>Reports the index position of the last occurrence of the specified Unicode character in a
      substring within this instance. The search starts at a specified character position and examines a specified number of character positions.</para>
		</summary>
		<param name="value">A Unicode character to seek.</param>
		<param name="startIndex">The starting position of a substring within this instance.</param>
		<param name="count">The number of character positions to examine.</param>
		<returns>
			<para> The index position of <paramref name="value"/> if that character is found, or -1 if it is not.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para>
				<paramref name="startIndex"/> or <paramref name="count"/> is less than zero or greater than the length of this instance.</para></exception>
		<remarks>
			<para>Index numbering starts from zero.</para>
			<para>This method begins searching at the <paramref name="startIndex"/> character position of
   this instance and precedes backwards towards the beginning until either
<paramref name="value"/> is found or <paramref name="count"/> character positions have been examined. The 
   search is case-sensitive.</para>
			<para>This method performs an ordinal (culture-insensitive) search, where a
   character is considered equivalent to another character only if their Unicode scalar value are the same. To perform a culture-sensitive search, use the <see cref="System.Globalization.CompareInfo.LastIndexOf" qualify="true"/> method, where a Unicode scalar value
   representing a precomposed character, such as the ligature 'Æ' (U+00C6), might
   be considered equivalent to any occurrence of the character's components in the
   correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
		</remarks>
		<example>
			<codelink SampleID="string.lastindexof2" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.IndexOf"/>
		<seealso cref="System.String.IndexOfAny"/>
		<seealso cref="System.String.LastIndexOfAny"/>
	</doc>
	<doc for="String.LastIndexOf7">
		<summary>
			<para>Reports the index position of the last occurrence of a
      specified <see cref="System.String"/> within this
      instance. The search starts at a specified character position.</para>
		</summary>
		<param name="value">The <see cref="System.String"/> to seek.</param>
		<param name="startIndex">The search starting position.</param>
		<returns>
			<para>The index position of <paramref name="value"/> if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="System.String.Empty"/>, the return value is
<paramref name="startIndex"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero or specifies a position not within this instance. </exception>
		<remarks>
			<para>Index numbering starts from zero.</para>
			<para>This method performs a word (case-sensitive and
      culture-sensitive) search using the current culture. The search begins at the <paramref name="startIndex"/> character position of this instance and precedes backwards towards the beginning until either <paramref name="value"/> is found or the first character position has been
      examined.</para>
		</remarks>
		<example>
			<codelink SampleID="string.lastindexof7" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.IndexOf"/>
		<seealso cref="System.String.IndexOfAny"/>
		<seealso cref="System.String.LastIndexOfAny"/>
	</doc>
	<doc for="String.LastIndexOf8">
		<summary>
			<para>Reports the index position of the last occurrence of a
      specified <see cref="System.String"/> within this instance. The
      search starts at a specified character position and examines a specified number
      of character positions.</para>
		</summary>
		<param name="value">The <see cref="System.String"/> to seek.</param>
		<param name="startIndex">The search starting position.</param>
		<param name="count">The number of character positions to examine.</param>
		<returns>
			<para>The index position of <paramref name="value"/> if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="System.String.Empty"/>, the return value is <paramref name="startIndex"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="count"/> or <paramref name="startIndex"/> is negative.</para><para>-or-</para><para><paramref name="count"/> plus <paramref name="startIndex"/> specify a position not within this instance.</para></exception>
		<remarks>
			<para>Index numbering starts from zero.</para>
			<para>This method performs a word (case-sensitive and
      culture-sensitive) search using the current culture. The search begins at the <paramref name="startIndex"/> character
      position of this instance and precedes backwards towards the beginning until
      either <paramref name="value"/> is found or <paramref name="count"/>
      character positions have been examined.</para>
		</remarks>
		<example>
			<codelink SampleID="string.lastindexof8" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.IndexOf"/>
		<seealso cref="System.String.IndexOfAny"/>
		<seealso cref="System.String.LastIndexOfAny"/>
	</doc>
	<doc for="String.LastIndexOfAny1">
		<overload>
			<para>Reports the index position of the last occurrence in this instance of one or
      more characters specified in a Unicode array.</para>
		</overload>
		<summary>
			<para>Reports the index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</para>
		</summary>
		<param name="anyOf">A Unicode character array containing one or more characters to seek. </param>
		<returns>
			<para> The index position of the last occurrence in this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if no character in <paramref name="anyOf"/> was found.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="anyOf"/> is <see langword="null"/>. </exception>
		<remarks>
			<para>Index numbering starts from zero.</para>
			<para>This method begins searching at the last character
      position of this instance and precedes backwards towards the beginning until
      either a character in <paramref name="anyOf"/> is found or the first character position has been
      examined. The search is case-sensitive.</para>
			<para>This method performs an ordinal (culture-insensitive)
      search, where a character is considered equivalent to another character only if
      their Unicode scalar values are the same. To perform a culture-sensitive search, use the
   <see cref="System.Globalization.CompareInfo.LastIndexOf" qualify="true"/> method, where a Unicode scalar value representing
      a precomposed character, such as the ligature 'Æ' (U+00C6), might be considered
      equivalent to any occurrence of the character's components in the correct
      sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
		</remarks>
		<example>
			<codelink SampleID="string.lastindexofany1" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
		<seealso cref="System.Array"/>
		<seealso cref="System.String.IndexOf"/>
		<seealso cref="System.String.IndexOfAny"/>
		<seealso cref="System.String.LastIndexOf"/>
	</doc>
	<doc for="String.LastIndexOfAny2">
		<summary>
			<para> Reports the index position of the last occurrence in this instance of one or more characters specified in a Unicode array. The search starts at a specified character position.</para>
		</summary>
		<param name="anyOf">A Unicode character array containing one or more characters to seek. </param>
		<param name="startIndex">The search starting position. </param>
		<returns>
			<para> The index position of the last occurrence in this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if no character in <paramref name="anyOf"/> was found.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="anyOf"/> is <see langword="null"/>.<paramref name=""/></exception>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="startIndex"/> specifies a position not within this instance.</para></exception>
		<remarks>
			<para>Index numbering starts from zero.</para>
			<para>This method begins searching at the <paramref name="startIndex"/> character position of this instance
   and precedes backwards towards the beginning until either a character in
<paramref name="anyOf"/> is found or the 
   first character position has been examined. The search is case-sensitive.</para>
			<para>This method performs an ordinal (culture-insensitive)
   search, where a character is considered equivalent to another character only if
   their Unicode scalar values are the same. To perform a culture-sensitive search, use the
<see cref="System.Globalization.CompareInfo.LastIndexOf" qualify="true"/> method, where a Unicode scalar value representing
   a precomposed character, such as the ligature 'Æ' (U+00C6), might be considered
   equivalent to any occurrence of the character's components in the correct
   sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
		</remarks>
		<example>
			<codelink SampleID="string.lastindexofany2" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
		<seealso cref="System.Array"/>
		<seealso cref="System.String.IndexOf"/>
		<seealso cref="System.String.IndexOfAny"/>
		<seealso cref="System.String.LastIndexOf"/>
	</doc>
	<doc for="String.LastIndexOfAny3">
		<summary>
			<para>Reports the index position of the last occurrence in this instance of one or more characters specified in a Unicode array. The search starts at a specified character position and examines a specified number of character positions.</para>
		</summary>
		<param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
		<param name="startIndex">The search starting position.</param>
		<param name="count">The number of character positions to examine.</param>
		<returns>
			<para> The index position of the last occurrence in this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if no character in <paramref name="anyOf"/> was found.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="anyOf"/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para>
				<paramref name="count"/> or <paramref name="startIndex "/>is negative.</para>
			<para>-or-</para>
			<para><paramref name="count"/> plus <paramref name="startIndex"/> specify a position not within this instance.</para></exception>
		<remarks>
			<para>Index numbering starts from zero.</para>
			<para>This method begins searching at the <paramref name="startIndex"/> character position of this instance
   and precedes backwards towards the beginning until either a character in
<paramref name="anyOf"/> is found or 
<paramref name="count"/> character positions have been examined. The 
   search is case-sensitive.</para>
			<para>This method performs an ordinal (culture-insensitive)
   search, where a character is considered equivalent to another character only if
   their Unicode scalar values are the same. To perform a culture-sensitive search, use the
<see cref="System.Globalization.CompareInfo.LastIndexOf" qualify="true"/> method, where a Unicode scalar value representing
   a precomposed character, such as the ligature 'Æ' (U+00C6), might be considered
   equivalent to any occurrence of the character's components in the correct
   sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
		</remarks>
		<example>
			<codelink SampleID="string.lastindexofany3" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
		<seealso cref="System.Array"/>
		<seealso cref="System.String.IndexOf"/>
		<seealso cref="System.String.IndexOfAny"/>
		<seealso cref="System.String.LastIndexOf"/>
	</doc>
	<doc for="String.ToCharArray1">
		<summary>
			<para>Copies the characters in a specified substring in this instance to a Unicode character array. </para>
		</summary>
		<param name="startIndex">The starting position of a substring in this instance. </param>
		<param name="length">The length of the substring in this instance. </param>
		<returns>
			<para>A Unicode character array whose elements are
      the <paramref name="length"/> number of characters in this instance starting from
      character position <paramref name="startIndex"/>.</para>
		</returns>
		<exception cref="System.ArgumentOutOfRangeException"><para>
				<paramref name="startIndex"/> or <paramref name="length"/> is less than zero. </para>
			<para>-or-</para>
			<para>
				<paramref name="startIndex"/> plus <paramref name="length"/> is greater than the length of this instance.</para></exception>
		<remarks>
			<para>If <paramref name="length"/> is zero, the entire string is copied starting from the
   beginning of this instance, and ignoring the value of <paramref name="startIndex"/>. If
   this instance is an empty string, the returned array is empty and has a zero
   length.</para>
		</remarks>
		<example>
			<codelink SampleID="string.tochararray1" SnippetID="1"/>
		</example>
		<seealso cref="System.Array"/>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
	</doc>
	<doc for="String.ToLower1">
		<summary>
			<para>Returns a copy of this <see cref="System.String"/> in lowercase, using the casing rules of the specified
   culture.</para>
		</summary>
		<param name="culture">A <see cref="System.Globalization.CultureInfo"/> object that supplies culture-specific casing rules.</param>
		<returns>
			<para> A <see cref="System.String"/> in
   lowercase.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="culture "/>is <see langword="null"/>.</exception>
		<remarks>
			<para>The casing rules of the culture that is currently in effect determines the way the case of a
      string is changed. If your application depends on the case of a
      string changing in a predictable way, and the effective culture changes unexpectedly, then you
      can get invalid results. Consider the following lookup routine where the lookup key
      is a text string, the key is forced to a standard case to simplify comparisons, and the effective culture is the
      culture associated with the current thread. </para>
			<para><c>static object LookupKey(string
      key) { return internalHashtable[key.ToLower()]; }</c></para>
			<para> If it is possible for the current thread
      and its associated culture to change unexpectedly, it is advisable to specify the invariant
      culture instead of defaulting to the current thread culture. The following
      example demonstrates the preferred technique. </para>
			<para><c>static object LookupKey(string
      key) { return internalHashtable[key.ToLower(CultureInfo.InvariantCulture)];
      }</c></para>
		</remarks>
		<example>
			<codelink SampleID="string.tolower1" SnippetID="1"/>
		</example>
		<seealso cref="System.Globalization.CultureInfo"/>
		<seealso cref="System.String.ToUpper"/>
	</doc>
	<doc for="String.ToUpper1">
		<summary>
			<para>Returns a copy of this <see cref="System.String"/> in uppercase, using the casing rules of the
   specified culture.</para>
		</summary>
		<param name="culture">A <see cref="System.Globalization.CultureInfo"/> object that supplies culture-specific casing rules.</param>
		<returns>
			<para>A <see cref="System.String"/>
in uppercase.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="culture"/> is <see langword="null"/>.</exception>
		<remarks>
			<para>The casing rules of the culture that is currently in effect determines the way the case of a string is changed. If your application depends on the case of a string changing in a predictable way, and the effective culture changes unexpectedly, then you can get invalid results. Consider the following lookup routine where the lookup key is a text string, the key is forced to a standard case to simplify comparisons, and the effective culture is the culture associated with the current thread. </para>
			<para><c>static object LookupKey(string key) { return internalHashtable[key.ToUpper()]; }</c></para>
			<para>If it is possible for the current thread and its associated culture to change unexpectedly, it is advisable to specify the invariant culture instead of defaulting to the current thread culture. The following example demonstrates the preferred technique. </para>
			<para><c>static object LookupKey(string key) { return internalHashtable[key.ToUpper(CultureInfo.InvariantCulture)]; }</c></para>
		</remarks>
		<example>
			<codelink SampleID="string.toupper1" SnippetID="1"/>
		</example>
		<seealso cref="System.String.ToLower"/>
	</doc>
	<doc for="String.IndexOfAny2">
		<summary>
			<para>Reports the index of the first occurrence in this instance of
      any character in a specified array of
      Unicode characters. The search starts at a specified character
      position.</para>
		</summary>
		<param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
		<param name="startIndex">The search starting position.</param>
		<returns>
			<para> The index position of the first occurrence in this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if no character in <paramref name="anyOf"/> was found.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="anyOf"/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para>
				<paramref name="startIndex "/>is negative.</para><para>-or-</para><para>
				<paramref name="startIndex "/>is greater than the number of characters in this instance.</para></exception>
		<remarks>
			<para>Index numbering starts from zero. </para>
			<para>The search ranges from <paramref name="startIndex"/> to the end of the string.</para>
			<para>The search for <paramref name="anyOf"/> is case-sensitive.</para>
			<para>This method performs an ordinal (culture-insensitive) search, where a
   character is considered equivalent to another character only if their Unicode scalar value are the same. To perform a culture-sensitive search, use the <see cref="System.Globalization.CompareInfo.IndexOf" qualify="true"/> method, where a Unicode scalar value representing
   a precomposed character, such as the ligature 'Æ' (U+00C6), might be considered
   equivalent to any occurrence of the character's components in the correct
   sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
		</remarks>
		<example>
			<codelink SampleID="string.indexofany2" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
		<seealso cref="System.Array"/>
		<seealso cref="System.String.IndexOf"/>
		<seealso cref="System.String.LastIndexOf"/>
		<seealso cref="System.String.LastIndexOfAny"/>
	</doc>
	<doc for="String.IndexOfAny3">
		<summary>
			<para>Reports the index of the first occurrence in this instance of any character in a specified
      array of Unicode characters. The search starts
      at a specified character position and examines a specified number of character positions.</para>
		</summary>
		<param name="anyOf">A Unicode character array containing one or more characters to seek.</param>
		<param name="startIndex">The search starting position.</param>
		<param name="count">The number of character positions to examine.</param>
		<returns>
			<para> The index position of the first occurrence in this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if no character in <paramref name="anyOf"/> was found.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="anyOf"/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para>
				<paramref name="count"/> or <paramref name="startIndex "/>is negative.</para>
			<para>-or-</para>
			<para>
				<paramref name="count"/> + <paramref name="startIndex "/>is greater than the number of characters in this instance.</para></exception>
		<remarks>
			<para>The search begins at <paramref name="startIndex"/> and continues to <paramref name="startIndex"/> + <paramref name="count"/> -1. The character at <paramref name="startIndex"/> + <paramref name="count"/> is not included in the search.</para>
			<para>Index numbering starts from zero.</para>
			<para>The search for <paramref name="anyOf"/> is case-sensitive.</para>
			<para>This method performs an ordinal (culture-insensitive) search, where a
   character is considered equivalent to another character only if their Unicode scalar value are the same. To perform a culture-sensitive search, use the <see cref="System.Globalization.CompareInfo.IndexOf" qualify="true"/> method, where a Unicode scalar value representing
   a precomposed character, such as the ligature 'Æ' (U+00C6), might be considered
   equivalent to any occurrence of the character's components in the correct
   sequence, such as "AE" (U+0041, U+0045), depending on the culture.</para>
		</remarks>
		<example>
			<codelink SampleID="string.indexofany3" SnippetID="1"/>
		</example>
		<seealso cref="System.Char"/>
		<seealso cref="System.Int32"/>
		<seealso cref="System.Array"/>
		<seealso cref="System.String.IndexOf"/>
		<seealso cref="System.String.LastIndexOf"/>
		<seealso cref="System.String.LastIndexOfAny"/>
	</doc>
	<doc for="String.Join1">
		<summary>
			<para>Concatenates a specified separator <see cref="System.String"/> between each element of a specified
<see cref="System.String"/> array, yielding a single
   concatenated string. Parameters specify the first array element and number of
   elements to use.</para>
		</summary>
		<param name="separator">A <see cref="System.String"/>. </param>
		<param name="value">An array of <see cref="System.String"/>. </param>
		<param name="startIndex">The first array element in <paramref name="value"/> to use. </param>
		<param name="count">The number of elements of <paramref name="value"/> to use. </param>
		<returns>
			<para> A <see cref="System.String"/>
consisting of the strings in <paramref name="value"/> joined by <paramref name="separator"/>.</para>
			<para>-or-</para>
			<para><see cref="System.String.Empty"/>
if <paramref name="count"/> is zero, <paramref name="value"/> has no elements, or
<paramref name="separator"/> and all the elements of <paramref name="value"/> are 
<see cref="System.String.Empty"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="value"/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="startIndex"/> or <paramref name="count"/> is less than 0.</para>
			<para>-or-</para>
			<para><paramref name="startIndex"/> plus <paramref name="count"/> is greater than the number of elements in <paramref name="value"/>.</para></exception>
		<remarks>
			<para>For example if <paramref name="separator"/> is ", " and the elements of <paramref name="value"/> are "apple", "orange", "grape", and "pear", <c>Join(separator, value, 1, 2)</c> returns "orange, grape".</para>
			<para>If <paramref name="separator"/> is <see langword="null"/>, the empty string (<see cref="System.String.Empty"/>) is used
instead.</para>
		</remarks>
		<example>
			<codelink SampleID="string.join2" SnippetID="1"/>
		</example>
		<seealso cref="System.Int32"/>
		<seealso cref="System.String.Concat"/>
	</doc>
</docs>
