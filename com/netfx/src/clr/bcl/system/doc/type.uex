<docs>
	<doc for="Type.UnderlyingSystemType">
		<summary>
			<para>Indicates the type provided by the common language 
      runtime that represents this type.</para>
		</summary>
		<value>
			<para>The underlying system type for the <see cref="System.Type"/>.</para>
		</value>
		<seealso cref="System.Type.BaseType"/>
	</doc>
	<doc for="Type.EmptyTypes">
		<summary>
			<para> Represents an empty array of type <see cref="System.Type"/>. This field is read-only.</para>
		</summary>
		<example>
			<para>The following code example shows the <see langword="EmptyTypes"/> field used in one of the 
<see langword="GetConstructor"/> 
methods to get a constructor that takes
no parameters.</para>
			<codelink SampleID="Classic Type.EmptyTypes Example" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Type.MemberType">
		<summary>
			<para>Gets a bitmask indicating the member type.</para>
		</summary>
		<value>
			<para>A <see cref="System.Reflection.MemberTypes"/> bitmask
   indicating the member type, which can be one of the following: Constructor,
   Event, Field, Method, Property, TypeInfo, Custom, NestedType or All.</para>
		</value>
		<example>
			<para>The following code example shows the <see langword="MemberType"/> field as a parameter
   to the <see langword="GetMember"/> method:</para>
			<codelink SampleID="Classic Type.MemberType Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.MemberTypes"/>
	</doc>
	<doc for="Type.IsNotPublic">
		<summary>
			<para> Gets a value indicating whether the top-level <see cref="System.Type"/> is not declared public.</para>
		</summary>
		<value>
			<para>
				<see langword="true"/> if the
   top-level <see cref="System.Type"/> is not declared public; otherwise, <see langword="false"/>. </para>
		</value>
		<remarks>
			<para>
				<see langword="IsPublic"/> and <see langword="IsNotPublic"/> get the visibility
   of the top-level type only.</para>
			<para>
				<see cref="System.Reflection.TypeAttributes.VisibilityMask"/> selects the visibility
attributes.</para>
		</remarks>
		<example>
			<para>This example shows the use of <see langword="IsNotPublic"/> to get the visibility of the top-level type.</para>
			<codelink SampleID="Classic Type.IsNotPublic Example" SnippetID="1"/>
			<para>This code produces the following output:</para>
			<para>There are 27 members in System.IO.File.</para>
			<para>Is System.IO.File public? False</para>
			<para>The following code example demonstrates why you cannot use <see langword="IsPublic"/> and <see langword="IsNotPublic"/> for nested classes.</para>
			<codelink SampleID="Classic Type.IsNotPublic Example" SnippetID="2"/>
			<para>For nested classes, ignore the results of <see langword="IsPublic"/> and <see langword="IsNotPublic"/> and pay attention only to the results of <see langword="IsNestedPublic"/> and <see langword="IsNestedPrivate"/>. The reflection output for this code fragment would be as follows:</para>
			<list type="table">
				<listheader>
					<term>Class</term>
					<description>IsNotPublic</description>
					<description>IsPublic</description>
					<description>IsNestedPublic</description>
					<description>IsNestedPrivate</description>
				</listheader>
				<item>
					<term> A</term>
					<description>FALSE</description>
					<description>TRUE</description>
					<description>FALSE</description>
					<description>FALSE</description>
				</item>
				<item>
					<term> B</term>
					<description>FALSE</description>
					<description>FALSE</description>
					<description>TRUE</description>
					<description>FALSE</description>
				</item>
				<item>
					<term> C</term>
					<description>FALSE</description>
					<description>FALSE</description>
					<description>FALSE</description>
					<description>TRUE</description>
				</item>
			</list>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
	</doc>
	<doc for="Type.IsSpecialName">
		<summary>
			<para> Gets a value indicating whether the <see cref="System.Type"/> has a name that requires special handling.</para>
		</summary>
		<value>
			<para>
				<see langword="true"/> if the <see cref="System.Type"/> has a name that requires special handling; otherwise, <see langword="false"/>. </para>
		</value>
		<remarks>
			<para>Names that begin with or contain an underscore character (_), property
      accessors, and operator overloading methods are examples of types
      that might require special treatment by some compilers. </para>
		</remarks>
		<example>
			<para>This example shows a use of <see langword="IsSpecialName"/> to filter internal
   or private members out of a list.</para>
			<codelink SampleID="Classic Type.IsSpecialName Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
	</doc>
	<doc for="Type.IsUnicodeClass">
		<summary>
			<para> Gets a value indicating whether the string format
      attribute <see langword="UnicodeClass"/> is selected for the <see cref="System.Type"/>.</para>
		</summary>
		<value>
			<para>
				<see langword="true"/> if the string
   format attribute <see langword="UnicodeClass "/> is selected for the <see cref="System.Type"/>; otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The <see cref="System.Reflection.TypeAttributes.StringFormatMask"/> is used to select the
   string format attributes. The string format attributes enhance interoperability by
   defining how strings should be interpreted.</para>
		</remarks>
		<seealso cref="System.Reflection.TypeAttributes"/>
		<seealso cref="System.Type.IsAnsiClass"/>
		<seealso cref="System.Type.IsAutoClass"/>
	</doc>
	<doc for="Type.Missing">
		<summary>
			<para> Represents a missing value in the <see cref="System.Type"/> information. This field is read-only.</para>
		</summary>
		<remarks>
			<para>Use the <see langword="Missing"/> 
field for invocation through
reflection to obtain the default value
of a parameter. If the <see langword="Missing"/> field is passed in for a
parameter value and there is no default value for that parameter, an <see cref="System.ArgumentException"/> is
thrown.</para>
		</remarks>
		<example>
			<para>The following code example shows the use of the
   <see langword="Missing"/> field to invoke a method with its default
      arguments.</para>
			<codelink SampleID="Classic Type.Missing Example" SnippetID="1"/>
			<para> 

 This code
 produces the following output:</para>
			<para>a = 10 b = 55.3 c = 12 </para>
			<para>a = 10 b = 1.3 c = 1 </para>
			<para>a = 10 b = 1.2 c = 1</para>
		</example>
		<seealso cref="System.Reflection.Missing"/>
		<seealso topic="cpconaccessingdefaultargumentvalues"/>
	</doc>
	<doc for="Type.TypeInitializer">
		<summary>
			<para> Gets the initializer for the <see cref="System.Type"/>.</para>
		</summary>
		<value>
			<para>A <see cref="System.Reflection.ConstructorInfo"/> containing the name of the class constructor
   for the <see cref="System.Type"/>.</para>
		</value>
		<remarks>
			<para>Class initializers are available through <see cref="System.Type.GetMember"/>,
<see cref="System.Type.GetMembers"/>, <see cref="System.Type.FindMembers"/>, and <see cref="System.Type.GetConstructors"/>.</para>
		</remarks>
		<seealso cref="System.Reflection.ConstructorInfo"/>
	</doc>
	<doc for="Type.IsEnum">
		<summary>
			<para> Gets a value indicating whether the current <see cref="System.Type"/> represents an enumeration.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the current <see cref="System.Type"/> represents
   an enumeration; otherwise, <see langword="false"/>. </para>
		</value>
		<remarks>
			<para>This property returns <see langword="true"/> for an
   enumeration, but not for the <see cref="System.Enum"/> type itself, which is a class. </para>
			<para>This property is read-only.</para>
		</remarks>
		<example>
			<para>The following example demonstrates using the
   <see langword="IsEnum"/> property.</para>
			<codelink SampleID="TestIsEnum" SnippetID="1"/>
			<para>This code produces the following output:</para>
			<code>
				Color is enum? True
				Color is valueType? True
				Enum is enum Type? False
				Enum is value? False
			</code>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
	</doc><doc for="Type.IsNestedFamily">
		<summary>
			<para> Gets a value indicating whether the <see cref="System.Type"/> is nested and visible only within its
   own family.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is nested
   and visible only within its own family; otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The <see cref="System.Reflection.TypeAttributes.VisibilityMask"/> selects the visibility attributes.</para>
			<para>A <see cref="System.Type"/> object's family is defined as all objects of the exact
same <see cref="System.Type"/> and of its subtypes.</para>
		</remarks>
		<example>
			<codelink SampleID="Type_IsNestedFamily" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
	</doc><doc for="Type.IsAutoClass">
		<summary>
			<para> Gets a value indicating whether the string format
      attribute <see langword="AutoClass"/> is selected for the <see cref="System.Type"/>.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the string
   format attribute <see langword="AutoClass"/> is selected for the <see cref="System.Type"/>; otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The <see cref="System.Reflection.TypeAttributes.StringFormatMask"/> selects the
   string format attributes. The string format attributes enhance interoperability by
   defining how strings should be interpreted.</para>
		</remarks>
		<seealso cref="System.Reflection.TypeAttributes"/>
		<seealso cref="System.Type.IsAnsiClass"/>
		<seealso cref="System.Type.IsUnicodeClass"/>
	</doc><doc for="Type.IsArray">
		<summary>
			<para>Gets a value indicating whether the <see cref="System.Type"/> is an array.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is an array; otherwise, <see langword="false"/>. </para>
		</value>
		<remarks>
			<para> The <see cref="System.Array"/> class returns <see langword="false"/>
because it is not an array.</para>
			<para>To check for an array, use code such as <c>typeof(Array).IsAssignableFrom(type)</c>.</para>
			<para>This property is read-only.</para>
		</remarks>
		<example>
			<para>The following example demonstrates using the <see langword="IsArray "/>property.</para>
			<codelink SampleID="TestIsArray" SnippetID="1"/>
			<para>This code produces the following output: </para>
			<code>
Type is System.Array. IsArray? False
    Type is System.Int32[]. IsArray? True
</code>
		</example>
		<seealso cref="System.Type.IsArrayImpl"/>
	</doc>
	<doc for="Type.Assembly">
		<summary>
			<para>Gets the <see cref="System.Reflection.Assembly"/> that the type is declared in. </para>
		</summary>
		<value>
			<para>An <see cref="System.Reflection.Assembly"/> instance that describes assembly containing the current type.</para>
		</value>
		<remarks>
			<para>This property is read-only.</para>
		</remarks>
		<example>
			<para>The following example displays the assembly name associated with 
      the class and the fully qualified name of the type.</para>
			<codelink SampleID="Type_Assembly" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Type.Attributes">
		<summary>
			<para> Gets the attributes associated with the <see cref="System.Type"/>.</para>
		</summary>
		<value>
			<para>A <see cref="System.Reflection.TypeAttributes"/> object representing the attribute set of the <see cref="System.Type"/>.</para>
		</value>
		<example>
			<para>The following example shows the use of the <see langword="Type.Attributes"/> 
property.</para>
			<codelink SampleID="Classic Type.Attributes Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.GetAttributeFlagsImpl"/>
		<seealso cref="System.Reflection.TypeAttributes"/>
	</doc>
	<doc for="Type.FilterAttribute">
		<summary>
			<para>Represents the member filter used on attributes. This field is read-only.</para>
		</summary>
		<remarks>
			<para>This field holds a reference to the delegate used by the
   <see cref="System.Type.FindMembers"/> method. The method
      encapsulated by this delegate takes two parameters: the first is a <see cref="System.Reflection.MemberInfo"/>
      object and the second is an <see langword="Object"/>. The method determines
      whether the <see langword="MemberInfo "/>object matches the criteria specified by
      the <see langword="Object"/>. The <see langword="Object "/>may be assigned the
      value of any one of the fields on the classes <see cref="System.Reflection.FieldAttributes"/>, <see cref="System.Reflection.MethodAttributes"/>, or <see cref="System.Reflection.MethodImplAttributes"/>
      .</para>
			<para>For example, the <see langword="Object "/>can be assigned
   the value of a field from <see langword="FieldAttributes "/>such as Public. In
   that case, when the <see langword="FilterAttribute "/>delegate is invoked, it
   will return <see langword="true "/>only if the method represented by the
<see langword="MemberInfo "/>
object is decorated
with the public field attribute in metadata.</para>
		</remarks>
		<example>
			<para>The following example gets the <see langword="FilterAttribute"/> delegate, 
   passes it as a parameter to the <see cref="System.Type.FindMembers"/> method, and displays the specified
   members and their attributes.</para>
			<codelink SampleID="Type_FilterAttribute" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.FindMembers"/>
		<seealso cref="System.Reflection.MemberFilter"/>
	</doc>
	<doc for="Type.FilterName">
		<summary>
			<para>Represents the case-sensitive member filter used on names. This field is read-only.</para>
		</summary>
		<remarks>
			<para>This field holds a reference to the delegate used by the
   <see cref="System.Type.FindMembers"/> method. The method encapsulated by this delegate takes
      two parameters: the first is a <see cref="System.Reflection.MemberInfo"/> object and the second is an
   <see langword="Object"/>. The method determines whether the <see langword="MemberInfo "/>object matches the criteria specified by the <see langword="Object"/>.
      The <see langword="Object"/> is assigned a string value, which
      may include a trailing "*"
      wildcard character. Only wildcard end string matching is supported.</para>
			<para>For example, the <see langword="Object "/>may be assigned
   the value "Byte*". In that case, when the <see langword="FilterName "/>delegate is invoked, it will return
<see langword="true"/>
only if the method represented by the
<see langword="MemberInfo "/>
object has a name that begins with
"Byte".</para>
		</remarks>
		<example>
			<para> The following code example gets the methods associated with the user-defined
   <see langword="Application"/> type.</para>
			<codelink SampleID="Classic Type.FilterName Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.FindMembers"/>
		<seealso cref="System.Reflection.MemberFilter"/>
	</doc>
	<doc for="Type.FilterNameIgnoreCase">
		<summary>
			<para>Represents the case-insensitive member filter used on names. This field is read-only.</para>
		</summary>
		<remarks>
			<para>This field holds a reference to the delegate used by the
   <see cref="System.Type.FindMembers"/> method. The method encapsulated by this delegate takes
      two parameters: the first is a <see cref="System.Reflection.MemberInfo"/> object and the second is an
   <see langword="Object"/>. The method determines whether the <see langword="MemberInfo "/>object matches the criteria specified by the <see langword="Object"/>.
      The <see langword="Object"/> is assigned a string value, which
      may include a trailing "*"
      wildcard character. Only wildcard end string matching is supported.</para>
			<para>For example, the <see langword="Object "/>may be assigned
   the value "ByTe*". In that case, when the <see langword="FilterName "/>delegate
   is invoked, it will return true only if the method represented by the
<see langword="MemberInfo "/>
object has a name that begins with
"byte", ignoring case.</para>
		</remarks>
		<example>
			<para>The following example gets the <see langword="MemberFilter"/> delegate, passes 
   it as a parameter to the <see cref="System.Type.FindMembers"/> method, and displays
   the methods and their attributes of the <see langword="String"/> class that begin with the letter "c",
   disregarding the case.</para>
			<codelink SampleID="Type_FilterNameIgnoreCase" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.FindMembers"/>
		<seealso cref="System.Reflection.MemberFilter"/>
	</doc>
	<doc for="Type.GUID">
		<summary>
			<para> Gets the GUID associated with the <see cref="System.Type"/>.</para>
		</summary>
		<value>
			<para>The GUID associated with the <see cref="System.Type"/>.</para>
		</value>
		<example>
			<para>The following example creates the class <see langword="MyClass1"/> with a 
   public method, creates a <see langword="Type"/> object corresponding to
<see langword="MyClass1"/>, and gets the Guid object using the 
<see langword="GUID"/> property of the <see langword="Type"/> class.</para>
			<codelink SampleID="Type_Guid" SnippetID="1"/>
		</example>
		<seealso cref="System.Guid"/>
	</doc>
	<doc for="Type.FullName">
		<summary>
			<para>Gets the fully qualified name of the <see cref="System.Type"/>, including the namespace of the <see cref="System.Type"/>.</para>
		</summary>
		<value>
			<para>A string containing the fully qualified name of the <see cref="System.Type"/>, including the namespace of the <see cref="System.Type"/>.</para>
		</value>
		<remarks>
			<para>For example, the fully qualified name of the C# string type is
      System.String.</para>
			<para>This property is read-only.</para>
		</remarks>
		<example>
			<para>The following example displays the full name of the 
      specified type.</para>
			<codelink SampleID="TestFullName" SnippetID="1"/>
			<para>This code produces the following output:</para>
			<para><c>The full name of the Array type is
 System.Array</c></para>
		</example>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.Namespace"/>
		<seealso cref="System.Type.AssemblyQualifiedName"/>
		<seealso topic="cpconSpecifyingFullyQualifiedTypeNames"/>
		<seealso cref="System.Reflection.AssemblyName"/>
	</doc>
	<doc for="Type.HasElementType">
		<summary>
			<para>Gets a value indicating whether the current <see cref="System.Type"/> encompasses or refers
   to another type; that is, whether the current <see cref="System.Type"/> is an array, a pointer, or is passed by reference.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is an array, a pointer, or is passed by reference; otherwise, <see langword="false"/>. </para>
		</value>
		<remarks>
			<para>For example, Type.GetType("Int32[]").HasElementType returns
   <see langword="true"/>, but Type.GetType("Int32").HasElementType returns
   <see langword="false"/>. HasElementType also returns
   <see langword="true"/> for "Int32*" and "Int32&amp;".</para>
		</remarks>
		<example>
			<para>The following example returns <see langword="true"/> or<see langword=" false"/> 
depending on whether or not the object is an array, a reference type, or a
pointer.</para>
			<codelink SampleID="Type_HasElementType" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.HasElementTypeImpl"/>
		<seealso cref="System.Type.IsArray"/>
		<seealso cref="System.Type.IsPointer"/>
		<seealso cref="System.Type.IsByRef"/>
		<seealso cref="System.Type.GetElementType"/>
		<seealso cref="System.Type.GetType"/>
	</doc>
	<doc for="Type.IsAbstract">
		<summary>
			<para> Gets a value indicating whether the <see cref="System.Type"/> is abstract and must be overridden.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is abstract; otherwise, <see langword="false"/>.</para>
		</value>
		<example>
			<para>The following example returns <see langword="true"/> if the specified object 
   is <see langword="abstract"/>; otherwise, it returns <see langword="false"/>.</para>
			<codelink SampleID="Type_IsAbstract" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
	</doc>
	<doc for="Type.IsAnsiClass">
		<summary>
			<para> Gets a value indicating whether the string format
      attribute <see langword="AnsiClass"/> is selected for the <see cref="System.Type"/>.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the string
   format attribute <see langword="AnsiClass"/> is selected for the <see cref="System.Type"/>; otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The <see cref="System.Reflection.TypeAttributes.StringFormatMask"/> selects the string format attributes.
   The string format attributes enhance interoperability by defining how strings should be interpreted.</para>
		</remarks>
		<example>
			<para>The following example gets the field information and checks for the 
   <see langword="AnsiClass"/> attribute.</para>
			<codelink SampleID="Type_IsAnsiClass" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
		<seealso cref="System.Type.IsUnicodeClass"/>
		<seealso cref="System.Type.IsAutoClass"/>
	</doc>
	<doc for="Type.IsAutoLayout">
		<summary>
			<para> Gets a value indicating whether the class layout
      attribute <see langword="AutoLayout"/> is selected for the <see cref="System.Type"/>.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the class
   layout attribute <see langword="AutoLayout"/> is selected for the <see cref="System.Type"/>; otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The <see cref="System.Reflection.TypeAttributes.LayoutMask"/> is used to select the class
   layout attributes. The class layout attributes
   (<see langword="AutoLayout"/>, <see langword="SequentialLayout"/> and
<see langword="ExplicitLayout"/>) define how the
   fields of the class instance are laid out in memory.</para>
			<para>Use the <see langword="AutoLayout"/> attribute to let the
runtime engine decide the best way to layout the objects of the class. Classes marked with the <see langword="AutoLayout"/> attribute indicate that the
loader will choose the appropriate way to lay out the class; any layout information
that may have been specified is ignored. </para>
		</remarks>
		<example>
			<para>The following example creates an instance of the type and displays the 
   <see langword="IsAutoLayout"/> property.</para>
			<codelink SampleID="Type_IsAutoLayout" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
		<seealso cref="System.Type.IsLayoutSequential"/>
		<seealso cref="System.Type.IsExplicitLayout"/>
		<seealso topic="cpconmetadataoverview"/>
	</doc>
	<doc for="Type.IsClass">
		<summary>
			<para> Gets a value indicating whether the <see cref="System.Type"/> is a class; that is, not a value type or interface.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is a class; otherwise, <see langword="false"/>. </para>
		</value>
		<remarks>
			<para>This property returns <see langword="true "/>for
<see langword="Type "/>instances representing <see cref="System.Enum"/> and <see cref="System.ValueType"/> .</para>
			<para>The <see cref="System.Reflection.TypeAttributes.ClassSemanticsMask"/>
distinguishes a type declaration as class, interface, or value type.</para>
			<para>This property is read-only.</para>
		</remarks>
		<example>
			<para>The following example creates an instance of a type and indicates 
      whether the type is a class.</para>
			<codelink SampleID="Type_IsClass" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
		<seealso cref="System.Type.IsInterface"/>
		<seealso cref="System.Type.IsValueType"/>
	</doc>
	<doc for="Type.IsByRef">
		<summary>
			<para>Gets a value indicating whether the <see cref="System.Type"/> is
   passed by reference.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is passed by reference; otherwise, <see langword="false"/>. </para>
		</value>
		<remarks>
			<para>To get to the actual type, dereference the type that was passed by reference, and then call <see cref="System.Type.GetElementType"/> on that type. </para>
		</remarks>
		<example>
			<para>The following example demonstrates a use of the 
   <see langword="IsByRef"/> property to check whether a specified type is passed by 
      reference. The example defines the class <see langword="MyTypeDelegator"/>, which overrides the <see langword="HasElementTypeImpl"/> method. The main class checks for the <see langword="HasElementType"/> property and displays the element type.</para>
			<codelink SampleID="Type_HasElementTypeImpl" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.IsByRefImpl"/>
	</doc>
	<doc for="Type.IsCOMObject">
		<summary>
			<para>Gets a value indicating whether the <see cref="System.Type"/> is a COM object.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is a COM object; otherwise, <see langword="false"/>. </para>
		</value>
		<remarks>
			<para>This method returns <see langword="false"/> for COM interfaces because they are not
   objects. COM interfaces can be implemented by Microsoft .NET Framework objects.</para>
			<para>You can also load a COM class and get a
<see langword="Type"/> object for that COM class by using the <see topic="cpgrftypelibraryimportertlbimpexe"/>
tool.</para>
		</remarks>
		<example>
			<para>The following example shows a use of the 
   <see langword="IsCOMObject"/> property.</para>
			<codelink SampleID="GaryMacInterop" SnippetID="4"/>
		</example>
		<seealso cref="System.Type.IsCOMObjectImpl"/>
	</doc>
	<doc for="Type.IsContextful">
		<summary>
			<para>Gets a value indicating whether the <see cref="System.Type"/> can be hosted in a context.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> can be hosted in a context; otherwise, <see langword="false"/>. </para>
		</value>
		<remarks>
			<para>A context intercepts calls to the class members and
      enforces policies that are applied to the class, such as synchronization. For
      more detailed information on remoting contexts, see <see cref="System.Runtime.Remoting.Contexts.Context"/>
      .</para>
		</remarks>
		<example>
			<para>The following example demonstrates the <see langword="IsContextful"/>, <see cref="System.Type.IsMarshalByRef"/>, and 
<see cref="System.Type.IsPrimitive"/> 
properties of the <see cref="System.Type"/> class. It checks whether the given type can be
hosted in the context, whether it can be marshalled by reference,
and whether the type is a primitive data type.</para>
			<codelink SampleID="Type_IsContextful" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.IsContextfulImpl"/>
	</doc>
	<doc for="Type.IsMarshalByRef">
		<summary>
			<para>Gets a value indicating whether the Type is marshaled by reference.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is marshaled by reference; otherwise, <see langword="false"/>. </para>
		</value>
		<example>
			<para>The following example demonstrates the <see langword="IsContextful"/>, <see cref="System.Type.IsMarshalByRef"/>, and 
<see cref="System.Type.IsPrimitive"/> 
properties of the <see cref="System.Type"/> class. It checks whether the given type can be
hosted in the context, whether it can be marshalled by reference,
and whether the type is a primitive data type.</para>
			<codelink SampleID="Type_IsContextful" SnippetID="2"/>
		</example>
		<seealso cref="System.Type.IsMarshalByRefImpl"/>
	</doc>
	<doc for="Type.IsExplicitLayout">
		<summary>
			<para> Gets a value indicating whether the class layout
      attribute <see langword="ExplicitLayout"/> is selected for the <see cref="System.Type"/>.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the class
   layout attribute <see langword="ExplicitLayout"/> is selected for the <see cref="System.Type"/>; otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The <see cref="System.Reflection.TypeAttributes.LayoutMask"/> is used to select the class
   layout attributes. The class layout attributes
   (<see langword="AutoLayout"/>, <see langword="SequentialLayout"/> and
<see langword="ExplicitLayout"/>) define how the
   fields of the class instance are laid out in memory.</para>
			<para>Classes marked with the <see langword="ExplicitLayout"/> attribute cause the loader to ignore
field sequence and to use the explicit layout rules provided, in the form of
field offsets, overall class size and alignment, or all of these. </para>
			<para>Use the <see langword="ExplicitLayout"/> attribute to
specify the offsets at which each field starts, or to specify the overall size
and, optionally, the packing size of the objects of the class. The packing size
is the empty memory space between fields and must be 1, 2, 4, 8 or 16 bytes.</para>
		</remarks>
		<example>
			<para>The following example creates an instance of the specified type and 
      displays the <see langword="IsExplicitLayout "/>property of the
   <see langword="MyDemoAttribute "/>class.</para>
			<codelink SampleID="Type_IsExplicitLayout" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
		<seealso cref="System.Type.IsAutoLayout"/>
		<seealso cref="System.Type.IsLayoutSequential"/>
		<seealso topic="cpconmetadataoverview"/>
	</doc>
	<doc for="Type.IsInterface">
		<summary>
			<para>Gets a value indicating whether the <see cref="System.Type"/> is an interface; that is, not a class or a value type.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is an interface; otherwise, <see langword="false"/>. </para>
		</value>
		<remarks>
			<para>The <see cref="System.Reflection.TypeAttributes.ClassSemanticsMask"/> distinguishes a type declaration as class, interface or value type.</para>
			<para>This property is read-only.</para>
		</remarks>
		<example>
			<para>The following example creates an interface, checks for the interface type, 
      and indicates whether a class has the <see langword="IsInterface"/> property
      set.</para>
			<codelink SampleID="Type_IsInterface" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
		<seealso cref="System.Type.IsClass"/>
		<seealso cref="System.Type.IsValueType"/>
	</doc>
	<doc for="Type.IsImport">
		<summary>
			<para> Gets a value indicating whether the <see cref="System.Type"/> was imported from another class.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> was imported from another class; otherwise, <see langword="false"/>. </para>
		</value>
		<seealso cref="System.Reflection.TypeAttributes"/>
	</doc>
	<doc for="Type.IsLayoutSequential">
		<summary>
			<para> Gets a value indicating whether the class layout
      attribute <see langword="SequentialLayout"/> is selected for the <see cref="System.Type"/>.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the class
   layout attribute <see langword="SequentialLayout"/> is selected for the <see cref="System.Type"/>; otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The <see cref="System.Reflection.TypeAttributes.LayoutMask"/> is used to select the class
   layout attributes. The class layout attributes
   (<see langword="AutoLayout"/>, <see langword="SequentialLayout"/> and
<see langword="ExplicitLayout"/>) define how the
   fields of the class instance are laid out in memory.</para>
			<para> For more information, see section 9.1.2 of the
   specification
   for the Common Language Infrastructure, Partition II, located in
   the Tool Developers Guide directory installed with the .NET Framework SDK.</para>
		</remarks>
		<example>
			<para>The following example creates an instance of a class for which the 
   <see langword="Sequential"/> member of the <see langword="LayoutKind"/> enum in 
      the <see langword="StructLayoutAttribute"/> class has been set, checks for the
      property IsLayoutSequential, and displays the result.</para>
			<codelink SampleID="Type_IsLayoutSequential" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
		<seealso cref="System.Type.IsAutoLayout"/>
		<seealso cref="System.Type.IsExplicitLayout"/>
		<seealso topic="cpconmetadataoverview"/>
	</doc>
	<doc for="Type.IsNestedPrivate">
		<summary>
			<para> Gets a value indicating whether the <see cref="System.Type"/> is nested and declared private.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is nested and declared private; otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The <see cref="System.Reflection.TypeAttributes.VisibilityMask"/> selects the visibility attributes.</para>
		</remarks>
		<example>
			<para>The following example declares a nested class as private and displays 
      the <see langword="IsNestedPrivate"/> property value of the nested class.</para>
			<codelink SampleID="Type_IsNestedPrivate" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
	</doc>
	<doc for="Type.IsNestedAssembly">
		<summary>
			<para>Gets a value indicating whether the <see cref="System.Type"/> is nested and visible only within its own assembly.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is nested and visible only within its own assembly; otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The <see cref="System.Reflection.TypeAttributes.VisibilityMask"/> selects the visibility attributes.</para>
		</remarks>
		<example>
			<para>The following example declares a nested class with visibility in its own 
      assembly, and displays its <see langword="IsNestedAssembly "/>property value.</para>
			<codelink SampleID="Type_IsNestedAssembly" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
	</doc>
	<doc for="Type.IsNestedFamORAssem">
		<summary>
			<para> Gets a value indicating whether the <see cref="System.Type"/> is nested and visible only to classes that belong to either its
   own family or to its own assembly.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is nested
   and visible only to classes that belong to its own family or to its own assembly; otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The <see cref="System.Reflection.TypeAttributes.VisibilityMask"/> selects the visibility attributes.</para>
			<para>A <see cref="System.Type"/> object's family is defined as all objects of the exact
same <see cref="System.Type"/> and of its subtypes.</para>
		</remarks>
		<example>
			<para>The following example declares a nested class with visibility in its own 
      family or in its own assembly and displays <see langword="IsNestedFamORAssem"/>
      property value of the nested class.</para>
			<codelink SampleID="Type_IsNestedFamORAssem" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
	</doc>
	<doc for="Type.IsNestedPublic">
		<summary>
			<para> Gets a value indicating whether a class is nested and declared public.</para>
		</summary>
		<value>
			<para><see langword="true"/> if
   the class is nested and declared public; otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The <see cref="System.Reflection.TypeAttributes.VisibilityMask"/> selects the visibility attributes.</para>
		</remarks>
		<example>
			<para>The following example declares a public nested class and displays its
   <see langword="IsNestedPublic"/> property value. </para>
			<codelink SampleID="Type.IsNestedPublic" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
	</doc>
	<doc for="Type.IsPointer">
		<summary>
			<para>Gets a value indicating whether the <see cref="System.Type"/> is a pointer.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is a pointer; otherwise, <see langword="false"/>. </para>
		</value>
		<remarks>
			<para>This property is read-only.</para>
		</remarks>
		<example>
			<para>The following example shows a use of the 
   <see langword="IsPointer "/>property.</para>
			<codelink SampleID="Type_HasElementTypeImpl" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.IsPointerImpl"/>
	</doc>
	<doc for="Type.IsPublic">
		<summary>
			<para> Gets a value indicating whether the top-level <see cref="System.Type"/> is declared public.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the top-level <see cref="System.Type"/> is declared public; otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para><see langword="IsPublic"/> and
<see langword="IsNotPublic"/> get the visibility of the top-level type only.</para>
			<para><see cref="System.Reflection.TypeAttributes.VisibilityMask"/> selects the
visibility attributes.</para>
		</remarks>
		<example>
			<para>The following example creates an instance of 
   <see langword="MyTestClass"/>, checks for the <see langword="IsPublic"/> 
   property, and displays the result.</para>
			<codelink SampleID="Type.IsPublic" SnippetID="1"/>
			<para>For nested classes, ignore the results of 
<see langword="IsPublic"/> and <see langword="IsNotPublic"/> and pay attention only to the results 
of <see cref="System.Type.IsNestedPublic"/> and <see cref="System.Type.IsNestedPrivate"/>.</para>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
	</doc>
	<doc for="Type.IsSealed">
		<summary>
			<para> Gets a value indicating whether the <see cref="System.Type"/> is declared sealed.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is declared sealed; otherwise, <see langword="false"/>. </para>
		</value>
		<example>
			<para>The following example creates an instance of a 
   <see langword="sealed "/>class, checks for the <see langword="IsSealed "/>property, and displays the result.</para>
			<codelink SampleID="Type_IsSealed" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
	</doc>
	<doc for="Type.IsSerializable">
		<summary>
			<para> Gets a value indicating whether the <see cref="System.Type"/> is serializable.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is serializable; otherwise, <see langword="false"/>. </para>
		</value>
		<example>
			<para>The following example creates an instance of <see langword="MyTestClass"/> 
class, sets the [Serializable] attribute, and checks the
<see langword="IsSerializable"/> property for <see langword="true"/> or 
<see langword="false"/>. </para>
			<codelink SampleID="Type_IsSerializable" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
		<seealso cref="System.Runtime.Serialization.ISerializable"/>
	</doc>
	<doc for="Type.Delimiter">
		<summary>
			<para> Separates names in the
      namespace of the <see cref="System.Type"/>. This field is
      read-only.</para>
		</summary>
	</doc>
	<doc for="Type.ReflectedType">
		<summary>
			<para>Gets the class object that was used to obtain this
      member.</para>
		</summary>
		<value>
			<para>The <see langword="Type"/> object through which this
<see langword="MemberInfo"/> object was obtained.</para>
		</value>
		<remarks>
			<para>This property implements the abstract property inherited
      from <see cref="System.Reflection.MemberInfo"/>.</para>
		</remarks>
		<example>
			<para>This example displays the reflected type of a method in
      a derived class. Although the method <see langword="m"/> is declared in
   <see langword="MyClassA"/>, its reflected type is obtained from
   <see langword="MyClassB"/> . </para>
			<codelink SampleID="Classic Type.ReflectedType Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.MemberInfo"/>
		<seealso cref="System.Type.DeclaringType"/>
	</doc>
	<doc for="Type.Module">
		<summary>
			<para>Gets the module (the DLL) in which the current <see cref="System.Type"/> is defined.</para>
		</summary>
		<value>
			<para>The name of the module in which the current <see cref="System.Type"/> is defined.</para>
		</value>
		<example>
			<para>This following example demonstrates a use of the <see cref="System.Type.Namespace"/> and <see langword="Module"/> properties and the <see cref="System.Type.ToString"/> method of <see cref="System.Type"/>.</para>
			<codelink SampleID="Type_ToString" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.Module"/>
	</doc>
	<doc for="Type.TypeHandle">
		<summary>
			<para>Gets the handle for the current <see cref="System.Type"/>.</para>
		</summary>
		<value>
			<para>The handle for the current <see cref="System.Type"/>.</para>
		</value>
		<remarks>
			<para><see langword="TypeHandle "/>encapsulates a pointer to an internal data structure that represents the type. This
   handle is unique during the process lifetime. The handle is valid only in
   the application domain in which it was obtained.</para>
		</remarks>
		<example>
			<para>The following example returns the handle of the corresponding type and passes 
      the handle to a method that gets the type from the handle and displays it.</para>
			<codelink SampleID="Type_TypeHandle" SnippetID="1"/>
		</example>
		<seealso cref="System.RuntimeTypeHandle"/>
		<seealso cref="System.Type.GetTypeHandle"/>
		<seealso cref="System.Type.GetTypeFromHandle"/>
	</doc>
	<doc for="Type.Namespace">
		<summary>
			<para>Gets the namespace of the <see cref="System.Type"/>.</para>
		</summary>
		<value>
			<para>The namespace of the <see cref="System.Type"/>.</para>
		</value>
		<remarks>
			<para>A namespace is a logical design-time naming convenience, used mainly to
      define scope in an application and organize classes and other types in a single
      hierarchical structure. From the viewpoint of the runtime, there are no
      namespaces.</para>
		</remarks>
		<example>
			<para>This following example demonstrates a use of the <see langword="Namespace"/> and <see cref="System.Type.Module"/> properties and the <see cref="System.Type.ToString"/> method of <see cref="System.Type"/>.</para>
			<codelink SampleID="Type_ToString" SnippetID="1"/>
		</example>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.FullName"/>
		<seealso cref="System.Type.AssemblyQualifiedName"/>
		<seealso topic="cpconSpecifyingFullyQualifiedTypeNames"/>
	</doc>
	<doc for="Type.IsValueType">
		<summary>
			<para>Gets a value indicating whether the <see cref="System.Type"/> is a value type.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is a value type; otherwise, <see langword="false"/>. </para>
		</value>
		<remarks>
			<para>Value types are those that are represented as sequences of bits; value types are not classes
      or interfaces. These are referred to as "structs" in some programming languages.
      Enums are a special case of value types.</para>
			<para>This property returns true for enumerations, but not for
      the <see cref="System.Enum"/> type
      itself, which is a class. For an example that demonstrates this behavior, see
   <see cref="System.Type.IsEnum"/>.</para>
			<para>This property is read-only.</para>
		</remarks>
		<example>
			<para>The following example creates a variable of type <see langword="MyEnum"/>, 
   checks for the <see langword="IsValueType "/>property, and displays the
   result.</para>
			<codelink SampleID="Type_IsValueType" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
		<seealso cref="System.Type.IsClass"/>
		<seealso cref="System.Type.IsInterface"/>
		<seealso cref="System.ValueType"/>
		<seealso cref="System.Type.IsValueTypeImpl"/>
		<seealso cref="System.Reflection.TypeAttributes"/>
		<seealso cref="System.Type.IsClass"/>
		<seealso cref="System.Type.IsInterface"/>
		<seealso cref="System.ValueType"/>
		<seealso cref="System.Type.IsValueTypeImpl"/>
	</doc>
	<doc for="Type.Type">
		<summary>
			<para> Initializes a new instance of the <see cref="System.Type"/> class.
   </para>
		</summary>
		<remarks>
			<para> This constructor is invoked by derived classes during the construction of type objects.
      </para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
	</doc>
	<doc for="Type.DeclaringType">
		<summary>
			<para>Gets the class that declares this member.</para>
		</summary>
		<value>
			<para>The <see langword="Type "/>object for
   the class that declares this member. If the type is a nested type, this property returns
   the enclosing type.</para>
		</value>
		<remarks>
			<para>This property implements the abstract property inherited
      from <see cref="System.Reflection.MemberInfo"/>.</para>
		</remarks>
		<example>
			<para>This example displays the declaring type of a method in
      a derived class.</para>
			<codelink SampleID="Classic Type.DeclaringType Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.MemberInfo"/>
		<seealso cref="System.Type.ReflectedType"/>
	</doc>
	<doc for="Type.GetType">
		<overload>
			<para>Gets the <see cref="System.Type"/> with the specified name.</para>
		</overload>
		<summary>
			<para>Gets the <see cref="System.Type"/> with
   the specified name, specifying whether to perform a case-sensitive search and whether
   to throw an exception if an error occurs while loading the <see cref="System.Type"/>.</para>
		</summary>
		<param name="typeName">The name of the <see cref="System.Type"/> to get.</param>
		<param name="throwOnError"><para><see langword="true"/> to throw any exception that occurs.</para>
			<para>-or-</para>
			<para><see langword="false"/> to ignore any exception that occurs.</para></param>
		<param name="ignoreCase"><para>
				<see langword="true"/> to perform a case-insensitive search for <paramref name="typeName"/>,<see langword="false"/> to perform a case-sensitive search for <paramref name="typeName"/>.</para></param>
		<returns>
			<para>The <see cref="System.Type"/> with the specified name, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="typeName"/> is <see langword="null"/>.</exception>
		<exception cref="System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
		<exception cref="System.TypeLoadException"><paramref name="throwOnError"/> is <see langword="true"/> and an error is encountered while loading the <see cref="System.Type"/>.</exception>
		<remarks>
			<para><see langword="GetType "/>only works on assemblies
   loaded from disk. If you call <see langword="GetType "/>to look up a type
   defined in a dynamic assembly defined using the <see cref="System.Reflection.Emit"/> services,
   you might get inconsistent behavior. The behavior depends on whether the
   dynamic assembly is persistent, that is, created using the
<see langword="RunAndSave"/> or <see langword="Save"/> access modes of the <see cref="System.Reflection.Emit.AssemblyBuilderAccess" qualify="true"/> enumeration. If the dynamic assembly is 
   persistent and has been written to disk before <see langword="GetType"/> is
   called, the loader finds the saved assembly on disk, loads that assembly, and
   retrieves the type from that assembly. If the assembly has not been saved to
   disk when <see langword="GetType"/> is called, the method returns
<see langword="null"/>. <see langword="GetType"/> does not understand transient 
   dynamic assemblies; therefore, calling <see langword="GetType"/> to retrieve
   a type in a transient dynamic assembly returns <see langword="null"/>
   .</para>
			<para>To use <see langword="GetType "/>on a dynamic module,
subscribe to the <see cref="System.AppDomain.AssemblyResolve" qualify="true"/> event and call <see langword="GetType "/>before saving. Otherwise, you will get two
copies of the assembly in memory.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
			<para>The following table shows what members of a base class
   are returned by the <see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the inheritance is the
         same as that of the methods that implement the property. Reflection treats
         properties as hide-by-name-and-signature. See note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual) can be hide-by-name or
         hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the inheritance is the
         same as that of the methods that implement the property. Reflection treats
         properties as hide-by-name-and-signature. See note 2
         below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
      
      Hide-by-name-and-signature considers all of the parts
      of the signature, including custom modifiers, return types, parameter types,
      sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
      
      For reflection, properties and events are
      hide-by-name-and-signature. If you have a property with both a get and a set
      accessor in the base class, but the derived class has only a get accessor, the
      derived class property hides the base class property, and you will not be able
      to access the setter on the base class.</term>
				</item>
				<item>
					<term>
      
      Custom attributes are not part of the common type
      system.</term>
				</item>
			</list>
			<para>Arrays or COM types are not searched for unless they have already been loaded
   into the table of available classes.</para>
			<para><paramref name="typeName"/> can be a simple
type name, a type name that includes a namespace, or a complex name that
includes an assembly name specification.</para>
			<para>If <paramref name="typeName"/> includes only the name of the <see cref="System.Type"/>, this method
searches in the calling object's assembly, then in the mscorlib.dll assembly. If
typeName is fully qualified with the partial or complete assembly name, this
method searches in the specified assembly.</para>
			<para><see langword=""/>
			</para>
			<para><see cref="System.Type.AssemblyQualifiedName"/> can return a fully
qualified type name including nested types and the assembly name. All compilers
that support the common language runtime will emit the simple name of a nested
class, and reflection constructs a mangled name when queried, in accordance with
the following conventions.</para>
			<list type="table">
				<listheader>
					<term>Delimiter</term>
					<description>Meaning</description>
				</listheader>
				<item>
					<term> Backslash (\)</term>
					<description>Escape character.</description>
				</item>
				<item>
					<term> Comma (,)</term>
					<description>Precedes the Assembly name.</description>
				</item>
				<item>
					<term> Plus sign (+)</term>
					<description>Precedes a nested class.</description>
				</item>
				<item>
					<term> Period (.)</term>
					<description>Denotes namespace identifiers. </description>
				</item>
			</list>
			<para>For example, the fully qualified name for a class might look like this: </para>
			<para><c>TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly</c>
			</para>
			<para>If the namespace were TopNamespace.Sub+Namespace, then the string would have
   to precede the plus sign (+) with an escape character (\) to prevent it from
   being interpreted as a nesting separator. Reflection emits this string as
   follows:</para>
			<para><c>TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly</c></para>
			<para>A "++" becomes "\+\+", and a "\" becomes "\\".</para>
			<para>This qualified name can be persisted and later used to load the <see cref="System.Type"/>. To search for and
load a <see cref="System.Type"/>, use
<see cref="System.Type.GetType"/> 
either with the type name only or with the assembly qualified type name. <see cref="System.Type.GetType"/> with the
type name only will look for the <see cref="System.Type"/> in the caller's assembly and then in the System
assembly. <see cref="System.Type.GetType"/> with the assembly qualified type name will look for
the <see cref="System.Type"/> in any
assembly.</para>
			<para>Type names may include trailing characters that denote additional information
   about the type, such as whether the type is a reference type, a pointer type or
   an array type. To retrieve the type name without these trailing characters, use
<c>t.GetElementType().ToString()</c>, where <paramref name="t"/> is the type.</para>
			<para>Spaces are relevant in all type name components except the assembly
   name. In the assembly name, spaces before the ',' separator are relevant, but
   spaces after the ',' separator are ignored.</para>
			<para>The following table shows the syntax you use with
<see langword="GetType"/> for various types.</para>
			<list type="table">
				<listheader>
					<term>To Get</term>
					<description>Use</description>
				</listheader>
				<item>
					<term> An
         unmanaged pointer to <see langword="MyType"/></term>
					<description><c>Type.GetType("MyType*")</c></description>
				</item>
				<item>
					<term> An
         unmanaged pointer to a pointer to <see langword="MyType"/></term>
					<description><c>Type.GetType("MyType**")</c></description>
				</item>
				<item>
					<term> A
         managed pointer
         or
         reference to <see langword="MyType"/></term>
					<description><c>Type.GetType("MyType&amp;")</c>. Note that unlike pointers, references are
      limited to one level.</description>
				</item>
				<item>
					<term> A parent class and a nested class</term>
					<description><c>Type.GetType("MyParentClass+MyNestedClass")</c></description>
				</item>
				<item>
					<term> A one-dimensional array with a lower bound of 0</term>
					<description><c>Type.GetType("MyArray[]")</c></description>
				</item>
				<item>
					<term> A one-dimensional array with an unknown lower bound</term>
					<description><c>Type.GetType("MyArray[*]")</c></description>
				</item>
				<item>
					<term> An n-dimensional array</term>
					<description>A comma (,) inside the brackets a total of n-1
      times. For example, <c>System.Object[,,]</c> represents a three-dimensional
<see langword="Object"/> 
array.</description>
				</item>
				<item>
					<term> A
      two-dimensional array's array</term>
					<description><c>Type.GetType("MyArray[][]")</c></description>
				</item>
				<item>
					<term> A rectangular two-dimensional array with unknown lower bounds</term>
					<description><c>Type.GetType("MyArray[*,*]")</c>or <c>Type.GetType("MyArray[,]")</c></description>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<seealso cref="System.String"/>
		<seealso cref="System.TypeLoadException"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.AssemblyQualifiedName"/>
		<seealso cref="System.Reflection.Assembly.GetAssembly"/>
		<seealso cref="System.Reflection.Assembly.GetType"/>
		<seealso cref="System.Reflection.AssemblyName"/>
		<seealso topic="cpconSpecifyingFullyQualifiedTypeNames"/>
	</doc>
	<doc for="Type.GetType1">
		<summary>
			<para>Gets the <see cref="System.Type"/> with the
   specified name, performing a case-sensitive search and specifying whether to throw
   an exception if an error occurs while loading the <see cref="System.Type"/> .</para>
		</summary>
		<param name="typeName">The name of the <see cref="System.Type"/> to get.</param>
		<param name="throwOnError"><para><see langword="true"/> to throw any exception that occurs.</para>
			<para>-or-</para>
			<para><see langword="false"/> to ignore any exception that occurs.</para></param>
		<returns>
			<para>The <see cref="System.Type"/> with the specified name, if found; otherwise, <see langword="null"/> .</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="typeName"/> is <see langword="null"/>. </exception>
		<exception cref="System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
		<exception cref="System.TypeLoadException"><paramref name="throwOnError"/> is <see langword="true"/> and an error is encountered while loading the <see cref="System.Type"/>.</exception>
		<remarks>
			<para><see langword="GetType "/>only works on assemblies
   loaded from disk. If you call <see langword="GetType "/>to look up a type
   defined in a dynamic assembly defined using the <see cref="System.Reflection.Emit"/> services,
   you might get inconsistent behavior. The behavior depends on whether the
   dynamic assembly is persistent, that is, created using the
<see langword="RunAndSave"/> or <see langword="Save"/> access modes of the <see cref="System.Reflection.Emit.AssemblyBuilderAccess" qualify="true"/> enumeration. If the dynamic assembly is 
   persistent and has been written to disk before <see langword="GetType"/> is
   called, the loader finds the saved assembly on disk, loads that assembly, and
   retrieves the type from that assembly. If the assembly has not been saved to
   disk when <see langword="GetType"/> is called, the method returns
<see langword="null"/>. <see langword="GetType"/> does not understand transient 
   dynamic assemblies; therefore, calling <see langword="GetType"/> to retrieve
   a type in a transient dynamic assembly returns <see langword="null"/>
   .</para>
			<para>To use <see langword="GetType "/>on a dynamic module,
subscribe to the <see cref="System.AppDomain.AssemblyResolve" qualify="true"/> event and call <see langword="GetType "/>before saving. Otherwise, you will get two
copies of the assembly in memory.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
			<para>The following table shows what members of a base class
   are returned by the <see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the inheritance is the
         same as that of the methods that implement the property. Reflection treats
         properties as hide-by-name-and-signature. See note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual) can be hide-by-name or
         hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the inheritance is the
         same as that of the methods that implement the property. Reflection treats
         properties as hide-by-name-and-signature. See note 2
         below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
      
      Hide-by-name-and-signature considers all of the parts
      of the signature, including custom modifiers, return types, parameter types,
      sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
      
      For reflection, properties and events are
      hide-by-name-and-signature. If you have a property with both a get and a set
      accessor in the base class, but the derived class has only a get accessor, the
      derived class property hides the base class property, and you will not be able
      to access the setter on the base class.</term>
				</item>
				<item>
					<term>
      
      Custom attributes are not part of the common type
      system.</term>
				</item>
			</list>
			<para>Arrays or COM types are not searched for unless they have already been loaded
   into the table of available classes.</para>
			<para><paramref name="typeName"/> can be a simple
type name, a type name that includes a namespace, or a complex name that
includes an assembly name specification.</para>
			<para>If <paramref name="typeName"/> includes only the name of the <see cref="System.Type"/>, this method
searches in the calling object's assembly, then in the mscorlib.dll assembly. If
typeName is fully qualified with the partial or complete assembly name, this
method searches in the specified assembly.</para>
			<para><see cref="System.Type.AssemblyQualifiedName"/> can return a fully
qualified type name including nested types and the assembly name. All compilers
that support the common language runtime will emit the simple name of a nested
class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</para>
			<list type="table">
				<listheader>
					<term>Delimiter</term>
					<description>Meaning</description>
				</listheader>
				<item>
					<term> Backslash (\)</term>
					<description>Escape character.</description>
				</item>
				<item>
					<term> Comma (,)</term>
					<description>Precedes the Assembly name.</description>
				</item>
				<item>
					<term> Plus sign (+)</term>
					<description>Precedes a nested class.</description>
				</item>
				<item>
					<term> Period (.)</term>
					<description>Denotes namespace identifiers. </description>
				</item>
			</list>
			<para>For example, the fully qualified name for a class might look like this: </para>
			<para><c>TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly</c>
			</para>
			<para>If the namespace were TopNamespace.Sub+Namespace, then the string would have
   to precede the plus sign (+) with an escape character (\) to prevent it from
   being interpreted as a nesting separator. Reflection emits this string as
   follows:</para>
			<para><c>TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly</c></para>
			<para>A "++" becomes "\+\+", and a "\" becomes "\\".</para>
			<para>This qualified name can be persisted and later used to load the <see cref="System.Type"/>. To search for and
load a <see cref="System.Type"/>, use
<see cref="System.Type.GetType"/> 
either with the type name only or with the assembly qualified type name. <see cref="System.Type.GetType"/> with the
type name only will look for the <see cref="System.Type"/> in the caller's assembly and then in the System
assembly. <see cref="System.Type.GetType"/> with the assembly qualified type name will look for
the <see cref="System.Type"/> in any
assembly.</para>
			<para>Type names may include trailing characters that denote additional information
   about the type, such as whether the type is a reference type, a pointer type or
   an array type. To retrieve the type name without these trailing characters, use
<c>t.GetElementType().ToString()</c>, where <paramref name="t"/> is the type.</para>
			<para>Spaces are relevant in all type name components except the assembly
   name. In the assembly name, spaces before the ',' separator are relevant, but
   spaces after the ',' separator are ignored.</para>
			<para>The following table shows the syntax you use with
<see langword="GetType"/> for various types.</para>
			<list type="table">
				<listheader>
					<term>To Get</term>
					<description>Use</description>
				</listheader>
				<item>
					<term> An
         unmanaged pointer to <see langword="MyType"/></term>
					<description><c>Type.GetType("MyType*")</c></description>
				</item>
				<item>
					<term> An
         unmanaged pointer to a pointer to <see langword="MyType"/></term>
					<description><c>Type.GetType("MyType**")</c></description>
				</item>
				<item>
					<term> A
         managed pointer
         or
         reference to <see langword="MyType"/></term>
					<description><c>Type.GetType("MyType&amp;")</c>. Note that unlike pointers, references are
      limited to one level.</description>
				</item>
				<item>
					<term> A parent class and a nested class</term>
					<description><c>Type.GetType("MyParentClass+MyNestedClass")</c></description>
				</item>
				<item>
					<term> A one-dimensional array with a lower bound of 0</term>
					<description><c>Type.GetType("MyArray[]")</c></description>
				</item>
				<item>
					<term> A one-dimensional array with an unknown lower bound</term>
					<description><c>Type.GetType("MyArray[*]")</c></description>
				</item>
				<item>
					<term> An n-dimensional array</term>
					<description>A comma (,) inside the brackets a total of n-1
      times. For example, <c>System.Object[,,]</c> represents a three-dimensional
<see langword="Object"/> 
array.</description>
				</item>
				<item>
					<term> A
      two-dimensional array's array</term>
					<description><c>Type.GetType("MyArray[][]")</c></description>
				</item>
				<item>
					<term> A rectangular two-dimensional array with unknown lower bounds</term>
					<description><c>Type.GetType("MyArray[*,*]")</c>or <c>Type.GetType("MyArray[,]")</c></description>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example retrieves the type of <see langword="System.Int32 "/>and uses that type object to display the <see cref="System.Type.FullName"/> property
   of <see langword="System.Int32"/>. If a type object refers to an assembly that
   does not exist, this example throws an exception.</para>
			<codelink SampleID="Type_GetType" SnippetID="1"/>
		</example>
		<seealso cref="System.String"/>
		<seealso cref="System.TypeLoadException"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.AssemblyQualifiedName"/>
		<seealso cref="System.Reflection.Assembly.GetAssembly"/>
		<seealso cref="System.Reflection.Assembly.GetType"/>
		<seealso cref="System.Reflection.AssemblyName"/>
		<seealso topic="cpconSpecifyingFullyQualifiedTypeNames"/>
	</doc>
	<doc for="Type.GetType2">
		<summary>
			<para>Gets the <see cref="System.Type"/> with the specified name, performing a case-sensitive
   search.</para>
		</summary>
		<param name="typeName">The name of the <see cref="System.Type"/> to get.</param>
		<returns>
			<para>The <see cref="System.Type"/> with the specified name, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="typeName"/> is <see langword="null"/>. </exception>
		<exception cref="System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
		<remarks>
			<para><see langword="GetType "/>only works on assemblies
   loaded from disk. If you call <see langword="GetType "/>to look up a type
   defined in a dynamic assembly defined using the <see cref="System.Reflection.Emit"/> services,
   you might get inconsistent behavior. The behavior depends on whether the
   dynamic assembly is persistent, that is, created using the
<see langword="RunAndSave"/> or <see langword="Save"/> access modes of the <see cref="System.Reflection.Emit.AssemblyBuilderAccess" qualify="true"/> enumeration. If the dynamic assembly is 
   persistent and has been written to disk before <see langword="GetType"/> is
   called, the loader finds the saved assembly on disk, loads that assembly, and
   retrieves the type from that assembly. If the assembly has not been saved to
   disk when <see langword="GetType"/> is called, the method returns
<see langword="null"/>. <see langword="GetType"/> does not understand transient 
   dynamic assemblies; therefore, calling <see langword="GetType"/> to retrieve
   a type in a transient dynamic assembly returns <see langword="null"/>
   .</para>
			<para>To use <see langword="GetType "/>on a dynamic module,
subscribe to the <see cref="System.AppDomain.AssemblyResolve" qualify="true"/> event and call <see langword="GetType "/>before saving. Otherwise, you will get two
copies of the assembly in memory.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
			<para>The following table shows what members of a base class
   are returned by the <see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the inheritance is the
         same as that of the methods that implement the property. Reflection treats
         properties as hide-by-name-and-signature. See note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual) can be hide-by-name or
         hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the inheritance is the
         same as that of the methods that implement the property. Reflection treats
         properties as hide-by-name-and-signature. See note 2
         below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
      
      Hide-by-name-and-signature considers all of the parts
      of the signature, including custom modifiers, return types, parameter types,
      sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
      
      For reflection, properties and events are
      hide-by-name-and-signature. If you have a property with both a get and a set
      accessor in the base class, but the derived class has only a get accessor, the
      derived class property hides the base class property, and you will not be able
      to access the setter on the base class.</term>
				</item>
				<item>
					<term>
      
      Custom attributes are not part of the common type
      system.</term>
				</item>
			</list>
			<para>Arrays or COM types are not searched for unless they have already been loaded
   into the table of available classes.</para>
			<para><paramref name="typeName"/> can be a simple
type name, a type name that includes a namespace, or a complex name that
includes an assembly name specification.</para>
			<para>If <paramref name="typeName"/> includes only the name of the <see cref="System.Type"/>, this method
searches in the calling object's assembly, then in the mscorlib.dll assembly. If
typeName is fully qualified with the partial or complete assembly name, this
method searches in the specified assembly.</para>
			<para><see cref="System.Type.AssemblyQualifiedName"/> can return a fully
qualified type name including nested types and the assembly name. All compilers
that support the common language runtime will emit the simple name of a nested
class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</para>
			<list type="table">
				<listheader>
					<term>Delimiter</term>
					<description>Meaning</description>
				</listheader>
				<item>
					<term> Backslash (\)</term>
					<description>Escape character.</description>
				</item>
				<item>
					<term> Comma (,)</term>
					<description>Precedes the Assembly name.</description>
				</item>
				<item>
					<term> Plus sign (+)</term>
					<description>Precedes a nested class.</description>
				</item>
				<item>
					<term> Period (.)</term>
					<description>Denotes namespace identifiers. </description>
				</item>
			</list>
			<para>For example, the fully qualified name for a class might look like this: </para>
			<para><c>TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly</c>
			</para>
			<para>If the namespace were TopNamespace.Sub+Namespace, then the string would have
   to precede the plus sign (+) with an escape character (\) to prevent it from
   being interpreted as a nesting separator. Reflection emits this string as
   follows:</para>
			<para><c>TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly</c></para>
			<para>A "++" becomes "\+\+", and a "\" becomes "\\".</para>
			<para>This qualified name can be persisted and later used to load the <see cref="System.Type"/>. To search for and
load a <see cref="System.Type"/>, use
<see cref="System.Type.GetType"/> 
either with the type name only or with the assembly qualified type name. <see cref="System.Type.GetType"/> with the
type name only will look for the <see cref="System.Type"/> in the caller's assembly and then in the System
assembly. <see cref="System.Type.GetType"/> with the assembly qualified type name will look for
the <see cref="System.Type"/> in any
assembly.</para>
			<para>Type names may include trailing characters that denote additional information
   about the type, such as whether the type is a reference type, a pointer type or
   an array type. To retrieve the type name without these trailing characters, use
<c>t.GetElementType().ToString()</c>, where <paramref name="t"/> is the type.</para>
			<para>Spaces are relevant in all type name components except the assembly
   name. In the assembly name, spaces before the ',' separator are relevant, but
   spaces after the ',' separator are ignored.</para>
			<para>The following table shows the syntax you use with
<see langword="GetType"/> for various types.</para>
			<list type="table">
				<listheader>
					<term>To Get</term>
					<description>Use</description>
				</listheader>
				<item>
					<term> An
         unmanaged pointer to <see langword="MyType"/></term>
					<description><c>Type.GetType("MyType*")</c></description>
				</item>
				<item>
					<term> An unmanaged pointer to a pointer to <see langword="MyType"/></term>
					<description><c>Type.GetType("MyType**")</c></description>
				</item>
				<item>
					<term> A
      managed pointer
      or
      reference to <see langword="MyType"/></term>
					<description><c>Type.GetType("MyType&amp;")</c>. Note that unlike pointers, references are
   limited to one level.</description>
				</item>
				<item>
					<term> A parent class and a nested class</term>
					<description><c>Type.GetType("MyParentClass+MyNestedClass")</c></description>
				</item>
				<item>
					<term> A one-dimensional array with a lower bound of 0</term>
					<description><c>Type.GetType("MyArray[]")</c></description>
				</item>
				<item>
					<term> A one-dimensional array with an unknown lower bound</term>
					<description><c>Type.GetType("MyArray[*]")</c></description>
				</item>
				<item>
					<term> An n-dimensional array</term>
					<description>A comma (,) inside the brackets a total of n-1
      times. For example, <c>System.Object[,,]</c> represents a three-dimensional
<see langword="Object"/> 
array.</description>
				</item>
				<item>
					<term> A
      two-dimensional array's array</term>
					<description><c>Type.GetType("MyArray[][]")</c></description>
				</item>
				<item>
					<term> A rectangular two-dimensional array with unknown lower bounds</term>
					<description><c>Type.GetType("MyArray[*,*]")</c>or <c>Type.GetType("MyArray[,]")</c></description>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example retrieves the type of <see langword="System.Int32 "/>and
   uses that type object to display the <see cref="System.Type.FullName"/> property of
<see langword="System.Int32"/>.</para>
			<codelink SampleID="Type_GetType" SnippetID="1"/>
		</example>
		<seealso cref="System.String"/>
		<seealso cref="System.TypeLoadException"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.AssemblyQualifiedName"/>
		<seealso cref="System.Reflection.Assembly.GetAssembly"/>
		<seealso cref="System.Reflection.Assembly.GetType"/>
		<seealso cref="System.Reflection.AssemblyName"/>
		<seealso topic="cpconSpecifyingFullyQualifiedTypeNames"/>
	</doc>
	<doc for="Type.GetTypeCode">
		<summary>
			<para> Gets the underlying type code of the specified <see cref="System.Type"/>.
   </para>
		</summary>
		<param name="type">The <see cref="System.Type"/> whose underlying type code to get. </param>
		<returns>
			<para> The <see cref="System.TypeCode"/> value of the underlying type.
   </para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<codelink SampleID="Type_GetTypeCode" SnippetID="1"/>
		</example>
		<seealso cref="System.TypeCode"/>
	</doc>
	<doc for="Type.GetTypeHandle">
		<summary>
			<para>Gets the handle for the <see cref="System.Type"/> of a specified object.</para>
		</summary>
		<param name="o">The <see cref="System.Object"/> for which to get the Type handle.</param>
		<returns>
			<para>The handle for the <see cref="System.Type"/> of the specified <see cref="System.Object"/>.</para>
		</returns>
		<remarks>
			<para>The handles are valid only in the application domain in which they were obtained. </para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example defines the class
   <see langword="MyClass1"/>, gets an instance of it, and retrieves the runtime
      handle of the object.</para>
			<codelink SampleID="Type_GetTypeHandle" SnippetID="1"/>
		</example>
		<seealso cref="System.RuntimeTypeHandle"/>
		<seealso cref="System.Type.TypeHandle"/>
		<seealso cref="System.Type.GetTypeFromHandle"/>
	</doc>
	<doc for="Type.GetArrayRank">
		<summary>
			<para> Gets the number of dimensions in an <see cref="System.Array"/>.</para>
		</summary>
		<returns>
			<para>An <see cref="System.Int32"/> containing the number of dimensions in the current
<see langword="Type"/>.</para>
		</returns>
		<exception cref="System.NotSupportedException">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead. </exception>
		<exception cref="System.ArgumentException">The current <see langword="Type"/> is not an array.</exception>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example displays the number of dimensions in an array.</para>
			<codelink SampleID="Type_GetArrayRank" SnippetID="1"/>
		</example>
		<seealso cref="System.Array"/>
		<seealso cref="System.Array.Rank"/>
	</doc>
	<doc for="Type.BaseType">
		<summary>
			<para>Gets the type from which the current <see cref="System.Type"/> directly inherits.</para>
		</summary>
		<value>
			<para>The <see cref="System.Type"/> from which the current <see cref="System.Type"/> directly inherits, or
<see langword="null"/> if the current <see langword="Type"/> represents the 
<see cref="System.Object"/> class.</para>
		</value>
		<remarks>
			<para>The base type is the type from which the current type
      directly inherits. <see cref="System.Object"/> is the only type that does not have a base type,
      therefore <see langword="null"/> is returned as the base type of <see cref="System.Object"/>.</para>
			<para>Interfaces inherit from <see cref="System.Object"/> and from zero or
   more base interfaces; therefore, the base type of an interface is considered to
   be <see cref="System.Object"/>. The base interfaces can be determined
   with <see cref="System.Type.GetInterfaces"/> or <see cref="System.Type.FindInterfaces"/>.</para>
			<para>This property is read-only.</para>
		</remarks>
		<example>
			<para>The following example demonstrates using the
   <see langword="BaseType"/> property.</para>
			<codelink SampleID="TestBaseType" SnippetID="1"/>
		</example>
		<seealso cref="System.Object"/>
		<seealso cref="System.Type.GetInterfaces"/>
		<seealso cref="System.Type.FindInterfaces"/>
		<seealso cref="System.Type.UnderlyingSystemType"/>
		<seealso cref="System.Type.IsSubclassOf"/>
	</doc>
	<doc for="Type.GetConstructorImpl">
		<summary>
			<para>When overridden in a derived class, searches for a constructor whose parameters match the
      specified argument types and modifiers, using the specified binding constraints
      and the specified calling convention.</para>
		</summary>
		<param name="bindingAttr"><para> A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<param name="binder"><para>A <see cref="System.Reflection.Binder"/> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
			<para>-or-</para>
			<para>
				<see langword="null"/>, to use the <see cref="System.Type.DefaultBinder"/>.</para></param>
		<param name="callConvention">The <see cref="System.Reflection.CallingConventions"/> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the constructor to get.</para>
			<para>-or-</para>
			<para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</para></param>
		<param name="modifiers">An array of <see cref="System.Reflection.ParameterModifier"/> objects representing the attributes associated with the corresponding element in the <paramref name="types"/> array. The default binder does not process this parameter.</param>
		<returns>
			<para>A <see cref="System.Reflection.ConstructorInfo"/> object representing the constructor that
   matches the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="types"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>One of the elements in <paramref name="types"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="types"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="modifiers"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> and <paramref name="modifiers"/> do not have the same length.</para></exception>
		<remarks>
			<para>Although the default binder does not process <see cref="System.Reflection.ParameterModifier"/> (the <paramref name="modifiers"/> parameter), you can
   use the abstract <see cref="System.Reflection.Binder" qualify="true"/> class to write a custom binder that does
   process <paramref name="modifiers"/>. <see langword="ParameterModifier"/>
   is only used
   when calling through COM interop, and only parameters that are passed by
   reference are handled.</para>
			<para>The <paramref name="types"/> array and the <paramref name="modifiers"/> array have the same length. A
parameter specified in the <paramref name="types"/> array can have the following attributes,
which are specified in the <paramref name="modifiers"/>
array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which
represent [In], [Out], [lcid], [retval], [optional], and a value specifying
whether the parameter has a default value. A parameter's associated attributes
are stored in the metadata and are used for interoperability.</para>
			<para>If an exact match does not exist, the <paramref name="binder"/> will attempt to coerce
the parameter types specified in the <paramref name="types"/> array in order to select a
match. If the <paramref name="binder"/> is unable to select a match, then
<see langword="null"/> is returned.</para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
constructors to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public
      constructors in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      constructors (that is, private and protected constructors) in the search.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>This method implements <see cref="System.Type.GetConstructor"/>.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
			<para><see cref="System.Type.GetConstructor"/> and <see cref="System.Type.GetConstructorImpl"/>
cannot be used to obtain a class initializer. Class initializers are available
only through <see cref="System.Type.GetMember"/>, <see cref="System.Type.GetMembers"/>, <see cref="System.Type.FindMembers"/>, and
<see cref="System.Type.GetConstructors"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<seealso cref="System.Reflection.ConstructorInfo"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Reflection.Binder"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Reflection.CallingConventions"/>
		<seealso cref="System.Reflection.ParameterModifier"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetConstructor"/>
		<seealso cref="System.Type.GetConstructors"/>
	</doc>
	<doc for="Type.GetConstructors">
		<overload>
			<para>Gets the constructors of the current <see cref="System.Type"/>.</para>
		</overload>
		<summary>
			<para>Returns all the public constructors defined for the current <see cref="System.Type"/>.</para>
		</summary>
		<returns>
			<para>An array of <see cref="System.Reflection.ConstructorInfo"/> objects representing
   all the public constructors defined for the current <see cref="System.Type"/>,
   including the type initializer if it is defined.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Reflection.ConstructorInfo"/>, if no public constructors are defined
for the current <see cref="System.Type"/>.</para>
		</returns>
		<remarks>
			<para>The following table shows what members of a base class are returned by the
   <see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always
            hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual)
            can be hide-by-name or hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
         
         Hide-by-name-and-signature considers all of the parts
         of the signature, including custom modifiers, return types, parameter types,
         sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
         
         For reflection, properties and events are
         hide-by-name-and-signature. If you have a property with both a get and a set
         accessor in the base class, but the derived class has only a get accessor, the
         derived class property hides the base class property, and you will not be able
         to access the setter on the base class.</term>
				</item>
				<item>
					<term>
         
         Custom attributes are not part of the common type system.</term>
				</item>
			</list>
			<para> This method calls <see topic="frlrfSystemTypeClassGetConstructorsTopic2" title="GetConstructors(BindingFlags.Public | BindingFlags.Instance)"/> .
It will not find static constructors unless you explicitly pass
<see langword="BindingFlags.Static"/>, as shown in the examples.</para>
			<para>Class initializers are available through <see cref="System.Type.GetMember"/>,
<see cref="System.Type.GetMembers"/>, <see cref="System.Type.FindMembers"/>, and <see cref="System.Type.GetConstructors"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>This example shows the output of
   <see langword="GetConstructors()"/> from a class that has two instance
      constructors and one static constructor.</para>
			<codelink SampleID="Classic Type.GetConstructors Example" SnippetID="1"/>
			<para>The output of this code is:</para>
			<para>2</para>
			<para>False </para>
			<para>False </para>
			<para>Because <see langword="GetConstructors"/>() only calls the Public and Instance
<see langword="BindingFlags"/>, the static constructor is neither counted by the
<see langword="for"/> expression nor evaluated by <see langword="IsStatic"/>.</para>
			<para>Use <see langword="GetConstructors"/>(BindingFlags) and pass 
it <see langword="BindingFlags.Public "/>| <see langword="BindingFlags.Static"/> |
<see langword="BindingFlags.NonPublic"/> | <see langword="BindingFlags.Instance"/>
to find static constructors, as follows:</para>
			<codelink SampleID="Classic Type.GetConstructors Example" SnippetID="2"/>
			<para>Now the output is:</para>
			<para>3</para>
			<para>False</para>
			<para>True</para>
			<para>False</para>
		</example>
		<seealso cref="System.Reflection.ConstructorInfo"/>
		<seealso cref="System.Type.GetConstructor"/>
	</doc>
	<doc for="Type.GetConstructors1">
		<summary>
			<para>When overridden in a derived class, searches for the constructors defined
      for the current <see cref="System.Type"/>, using the specified <see langword="BindingFlags"/> .</para>
		</summary>
		<param name="bindingAttr"><para> A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<returns>
			<para>An array of <see cref="System.Reflection.ConstructorInfo"/> objects representing all constructors defined
   for the current <see cref="System.Type"/> that match the specified binding constraints, including
   the type initializer if it is defined.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Reflection.ConstructorInfo"/>, if no constructors are
defined for the current <see cref="System.Type"/>, or if none of the defined constructors match the
binding constraints.</para>
		</returns>
		<remarks>
			<para><paramref name="bindingAttr"/> can be used to specify whether to return only public constructors or both public and
   non-public constructors.</para>
			<para>If an exact match does not exist, the <paramref name="binder"/> will attempt to coerce
the parameter types specified in the <paramref name="types"/> array in order to select a
match. If the <paramref name="binder"/> is unable to select a match, then
<see langword="null"/> is returned. </para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
constructors to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public
      constructors in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      constructors (that is, private and protected constructors) in the search.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
			<para>Class initializers are available through <see cref="System.Type.GetMember"/>, <see cref="System.Type.GetMembers"/>,
<see cref="System.Type.FindMembers"/>, and <see cref="System.Type.GetConstructors"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>This example shows the output of
   <see langword="GetConstructors()"/> from a class that has two instance constructors and one static constructor.</para>
			<codelink SampleID="Classic Type.GetConstructors Example" SnippetID="1"/>
			<para>The output of this code is:</para>
			<para>2</para>
			<para>False </para>
			<para>False </para>
			<para>Because <see langword="GetConstructors()"/> only calls 
the <see langword="Public"/> and <see langword="Instance"/>
				<see cref="System.Reflection.BindingFlags"/>, the static constructor is neither counted by the <see langword="for"/> expression nor evaluated by <see langword="IsStatic"/>.</para>
			<para>Use <see langword="GetConstructors"/>(BindingFlags) and pass it <see langword="BindingFlags.Public "/>| <see langword="BindingFlags.Static"/> | <see langword="BindingFlags.NonPublic"/> | <see langword="BindingFlags.Instance"/> to find static constructors, as follows:</para>
			<codelink SampleID="Classic Type.GetConstructors Example" SnippetID="2"/>
			<para>Now the output is:</para>
			<para>3</para>
			<para>False</para>
			<para>True</para>
			<para>False</para>
		</example>
		<seealso cref="System.Reflection.ConstructorInfo"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetConstructor"/>
	</doc>
	<doc for="Type.GetMethod">
		<overload>
			<para>Gets a specific method of the current <see cref="System.Type"/>.</para>
		</overload>
		<summary>
			<para>Searches for the specified method whose parameters match the specified
      argument types and modifiers, using the specified binding constraints and the
      specified calling convention.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the method to get.</param>
		<param name="bindingAttr"><para> A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<param name="binder"><para>A <see cref="System.Reflection.Binder"/> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
			<para>-or-</para>
			<para>
				<see langword="null"/>, to use the <see cref="System.Type.DefaultBinder"/>.</para></param>
		<param name="callConvention">The <see cref="System.Reflection.CallingConventions"/> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the method to get.</para>
			<para>-or-</para>
			<para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</para></param>
		<param name="modifiers">An array of <see cref="System.Reflection.ParameterModifier"/> objects representing the attributes associated with the corresponding element in the <paramref name="types"/> array. The default binder does not process this parameter.</param>
		<returns>
			<para>A <see cref="System.Reflection.MethodInfo"/> object
   representing the method that matches the specified requirements, if found;
   otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and matching the specified binding constraints.</exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>One of the elements in <paramref name="types"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="types"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="modifiers"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> and <paramref name="modifiers"/> do not have the same length.</para></exception>
		<remarks>
			<para>Although the default binder does not process <see cref="System.Reflection.ParameterModifier"/> (the <paramref name="modifiers"/> parameter), you can
   use the abstract <see cref="System.Reflection.Binder" qualify="true"/> class to write a custom binder that does
   process <paramref name="modifiers"/>. <see langword="ParameterModifier"/> is
   only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
			<para>The following table shows what members of a base class are returned by the
<see langword="GetXXX"/> methods when reflecting on a 
   type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always
         hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
         inheritance is the same as that of the methods that implement the
         property. Reflection treats properties as hide-by-name-and-signature. See
         note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual)
         can be hide-by-name or hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
         inheritance is the same as that of the methods that implement the
         property. Reflection treats properties as hide-by-name-and-signature. See
         note 2 below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
      
      Hide-by-name-and-signature considers all of the parts
      of the signature, including custom modifiers, return types, parameter types,
      sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
      
      For reflection, properties and events are
      hide-by-name-and-signature. If you have a property with both a get and a set
      accessor in the base class, but the derived class has only a get accessor, the
      derived class property hides the base class property, and you will not be able
      to access the setter on the base class.</term>
				</item>
				<item>
					<term>
      
      Custom attributes are not part of the common type system.</term>
				</item>
			</list>
			<para>The <paramref name="types"/> array and the <paramref name="modifiers"/> array have the same length. A
parameter specified in the <paramref name="types"/> array can have the following attributes,
which are specified in the <paramref name="modifiers"/>
array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which
represent [In], [Out], [lcid], [retval], [optional], and a value specifying
whether the parameter has a default value. A parameter's associated attributes
are stored in the metadata and enhance interoperability.</para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
methods to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public methods in
      the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      methods (that is, private and protected members) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      methods up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.IgnoreCase"/> to ignore the case of
   <paramref name="name"/>.</term>
				</item>
				<item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the methods
      declared on the <see cref="System.Type"/>, not methods that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
			<note type="note">
   You cannot omit parameters when looking
   up constructors and methods. You can only omit parameters when invoking.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example displays information about a method named
   <see langword="MyFunc "/>in the class <see langword="MyClass"/>.</para>
			<codelink SampleID="Type_GetMethod3" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.MethodInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Reflection.Binder"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Reflection.CallingConventions"/>
		<seealso cref="System.Reflection.ParameterModifier"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetMethodImpl"/>
		<seealso cref="System.Type.GetMethods"/>
	</doc>
	<doc for="Type.GetMethod1">
		<summary>
			<para>Searches for the specified method whose parameters match the specified argument types and modifiers, using the
      specified binding constraints.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the method to get.</param>
		<param name="bindingAttr"><para> A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<param name="binder"><para>A <see cref="System.Reflection.Binder"/> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
			<para>-or-</para>
			<para>
				<see langword="null"/>, to use the <see cref="System.Type.DefaultBinder"/>.</para></param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the method to get.</para>
			<para>-or-</para>
			<para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</para></param>
		<param name="modifiers">An array of <see cref="System.Reflection.ParameterModifier"/> objects representing the attributes associated with the corresponding element in the <paramref name="types"/> array. The default binder does not process this parameter.</param>
		<returns>
			<para>A <see cref="System.Reflection.MethodInfo"/> object representing the method that matches
   the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and matching the specified binding constraints.</exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>One of the elements in <paramref name="types"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="types"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="modifiers"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> and <paramref name="modifiers"/> do not have the same length.</para></exception>
		<remarks>
			<para>Although the default binder does not process <see cref="System.Reflection.ParameterModifier"/> (the <paramref name="modifiers"/> parameter), you can
   use the abstract <see cref="System.Reflection.Binder" qualify="true"/> class to write a custom binder that does
   process <paramref name="modifiers"/>. <see langword="ParameterModifier"/>
   
   is only used when calling through COM interop, and only
   parameters that are passed by reference are handled.</para>
			<para>The <paramref name="types"/> array and the <paramref name="modifiers"/> array have the same length. A
parameter specified in the <paramref name="types"/> array can have the following attributes,
which are specified in the <paramref name="modifiers"/>
array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which
represent [In], [Out], [lcid], [retval], [optional], and a value specifying
whether the parameter has a default value. A parameter's associated attributes
are stored in the metadata and enhance interoperability.</para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
methods to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public methods in
      the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      methods (that is, private and protected members) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      methods up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.IgnoreCase"/> to ignore the case of
   <paramref name="name"/>.</term>
				</item>
				<item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the methods
      declared on the <see cref="System.Type"/>, not methods that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
			<note type="note">
   You cannot omit parameters when looking
   up constructors and methods. You can only omit parameters when invoking.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example gets method information and displays the signature
      and declaring type.</para>
			<codelink SampleID="Type_GetMethod" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.MethodInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Reflection.Binder"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Reflection.ParameterModifier"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetMethodImpl"/>
		<seealso cref="System.Type.GetMethods"/>
	</doc>
	<doc for="Type.GetMethod2">
		<summary>
			<para>Searches for the specified public method whose parameters match the specified argument
      types and modifiers.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the public method to get.</param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the method to get.</para>
			<para>-or-</para>
			<para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</para></param>
		<param name="modifiers">An array of <see cref="System.Reflection.ParameterModifier"/> objects representing the attributes associated with the corresponding element in the <paramref name="types"/> array. The default binder does not process this parameter.</param>
		<returns>
			<para>A <see cref="System.Reflection.MethodInfo"/> object
   representing the public method that matches
   the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and specified parameters.</exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>One of the elements in <paramref name="types"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="types"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="modifiers"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> and <paramref name="modifiers"/> do not have the same length.</para></exception>
		<remarks>
			<para>Although the default binder does not process <see cref="System.Reflection.ParameterModifier"/> (the <paramref name="modifiers"/> parameter), you can
   use the abstract <see cref="System.Reflection.Binder" qualify="true"/> class to write a custom binder that does
   process <paramref name="modifiers"/>. <see langword="ParameterModifier"/>
   is only used
   when calling through COM interop, and only parameters that are passed by
   reference are handled.</para>
			<para>The <paramref name="types"/> array and the <paramref name="modifiers"/> array have the same length. A
parameter specified in the <paramref name="types"/> array can have the following attributes,
which are specified in the <paramref name="modifiers"/>
array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which
represent [In], [Out], [lcid], [retval], [optional], and a value specifying
whether the parameter has a default value. A parameter's associated attributes
are stored in the metadata and are used for interoperability.</para>
			<para>The search for <paramref name="name"/> is case-sensitive.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
			<note type="note">
   You cannot omit parameters when looking
   up constructors and methods. You can only omit parameters when invoking.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<seealso cref="System.Reflection.MethodInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Reflection.ParameterModifier"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetMethodImpl"/>
		<seealso cref="System.Type.GetMethods"/>
	</doc>
	<doc for="Type.GetMethod3">
		<summary>
			<para>Searches for the specified public method whose parameters match the specified argument types.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the public method to get.</param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the method to get.</para>
			<para>-or-</para>
			<para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</para></param>
		<returns>
			<para>A <see cref="System.Reflection.MethodInfo"/> object representing the public method whose
   parameters match the specified argument types, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and specified parameters.</exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>One of the elements in <paramref name="types"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="types"/> is multidimensional.</para></exception>
		<remarks>
			<para>The search for <paramref name="name"/> is case-sensitive.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
			<note type="note">
   You cannot omit parameters when looking up
   constructors and methods. You can only omit parameters when invoking.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example contains a class with an overloaded method. It
      obtains a <see langword="Type"/> object corresponding to
   <see langword="MyClass1"/> and calls <see langword="GetMethod"/>. The method whose
      parameters match the arguments specified in the type array is returned by the
      method call.</para>
			<codelink SampleID="Type_GetMethod4" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.MethodInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetMethodImpl"/>
		<seealso cref="System.Type.GetMethods"/>
	</doc>
	<doc for="Type.GetMethod4">
		<summary>
			<para>Searches for the specified method, using the specified binding constraints.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the method to get.</param>
		<param name="bindingAttr"><para> A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<returns>
			<para>A <see cref="System.Reflection.MethodInfo"/> object representing the method that matches
   the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and matching the specified binding constraints.</exception>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
		<remarks>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
   methods to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public methods in
      the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      methods (that is, private and protected members) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      methods up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.IgnoreCase"/> to ignore the case of
   <paramref name="name"/>.</term>
				</item>
				<item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the methods
      declared on the <see cref="System.Type"/>, not methods that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
			<note type="note">
   You cannot omit parameters when looking up
   constructors and methods. You can only omit parameters when invoking.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example gets the method that matches the specified binding
      flags and displays its signature.</para>
			<codelink SampleID="Type_GetMethod2" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.MethodInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetMethodImpl"/>
		<seealso cref="System.Type.GetMethods"/>
	</doc>
	<doc for="Type.GetMethodImpl">
		<summary>
			<para>When overridden in a derived class, searches for the specified method whose parameters match the specified
      argument types and modifiers, using the specified binding constraints and the
      specified calling convention.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the method to get.</param>
		<param name="bindingAttr"><para> A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<param name="binder"><para>A <see cref="System.Reflection.Binder"/> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
			<para>-or-</para>
			<para>
				<see langword="null"/>, to use the <see cref="System.Type.DefaultBinder"/>.</para></param>
		<param name="callConvention">The <see cref="System.Reflection.CallingConventions"/> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the method to get.</para>
			<para>-or-</para>
			<para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</para>
			<para>-or-</para>
			<para><see langword="null"/>. If <paramref name="types"/> is <see langword="null"/>, arguments are not matched.</para></param>
		<param name="modifiers">An array of <see cref="System.Reflection.ParameterModifier"/> objects representing the attributes associated with the corresponding element in the <paramref name="types"/> array. The default binder does not process this parameter.</param>
		<returns>
			<para>A <see cref="System.Reflection.MethodInfo"/> object representing the method that matches
   the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one method is found with the specified name and matching the specified binding constraints.</exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="types"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="modifiers"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> and <paramref name="modifiers"/> do not have the same length.</para></exception>
		<remarks>
			<para>Although the default binder does not process <see cref="System.Reflection.ParameterModifier"/> (the <paramref name="modifiers"/> parameter), you can
   use the abstract <see cref="System.Reflection.Binder" qualify="true"/> class to write a custom binder that does
   process <paramref name="modifiers"/>. <see langword="ParameterModifier"/> is
   only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
			<para>If <paramref name="types"/> is <see langword="null"/> , arguments are not matched.</para>
			<para>The <paramref name="types"/> array and the <paramref name="modifiers"/> array have the same length. A
parameter specified in the <paramref name="types"/> array can have the following attributes,
which are specified in the <paramref name="modifiers"/>
array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which
represent [In], [Out], [lcid], [retval], [optional], and a value specifying
whether the parameter has a default value. A parameter's associated attributes
are stored in the metadata and enhance interoperability.</para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
methods to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public methods in
      the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      methods (that is, private and protected members) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      methods up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.IgnoreCase"/> to ignore the case of
   <paramref name="name"/>.</term>
				</item>
				<item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the methods
      declared on the <see cref="System.Type"/>, not methods that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<seealso cref="System.Reflection.MethodInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Reflection.Binder"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Reflection.CallingConventions"/>
		<seealso cref="System.Reflection.ParameterModifier"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetMethod"/>
		<seealso cref="System.Type.GetMethods"/>
	</doc>
	<doc for="Type.GetMethods">
		<overload>
			<para>Gets the methods of the current <see cref="System.Type"/>.</para>
		</overload>
		<summary>
			<para>Returns all the public methods of the current <see cref="System.Type"/>.</para>
		</summary>
		<returns>
			<para>An array of <see cref="System.Reflection.MethodInfo"/> objects representing all the public
   methods defined for the current <see cref="System.Type"/>.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Reflection.MethodInfo"/>, if no public methods
are defined for the current <see cref="System.Type"/>.</para>
		</returns>
		<remarks>
			<para>Constructors are not included in the array of methods
      returned by this call. Make a separate call to
   <see langword="GetConstructors()"/> to get the constructor methods.</para>
			<para>The following table shows what members of a base class are returned by the
   <see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always
            hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual)
            can be hide-by-name or hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
         
         Hide-by-name-and-signature considers all of the parts
         of the signature, including custom modifiers, return types, parameter types,
         sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
         
         For reflection, properties and events are
         hide-by-name-and-signature. If you have a property with both a get and a set
         accessor in the base class, but the derived class has only a get accessor, the
         derived class property hides the base class property, and you will not be able
         to access the setter on the base class.</term>
				</item>
				<item>
					<term>
         
         Custom attributes are not part of the common type system.</term>
				</item>
			</list>
			<note type="note">
   You cannot omit parameters when looking up
   constructors and methods. You can only omit parameters when invoking.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<seealso cref="System.Reflection.MethodInfo"/>
		<seealso cref="System.Type.GetMethod"/>
	</doc>
	<doc for="Type.GetMethods1">
		<summary>
			<para>When overridden in a derived class,
      searches for the methods defined for the current <see cref="System.Type"/>, using the specified binding constraints.</para>
		</summary>
		<param name="bindingAttr"><para>A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<returns>
			<para>An array of <see cref="System.Reflection.MethodInfo"/> objects representing all methods defined
   for the current <see cref="System.Type"/>
   that match the specified binding constraints.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Reflection.MethodInfo"/>, if no methods are
defined for the current <see cref="System.Type"/>, or if none of the defined methods match the
binding constraints.</para>
		</returns>
		<remarks>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
   methods to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public methods in
      the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      methods (that is, private and protected members) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      methods up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the methods
      declared on the <see cref="System.Type"/>, not methods that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
			<note type="note">
   You cannot omit parameters when looking up
   constructors and methods. You can only omit parameters when invoking.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example creates a class with two public methods and one
      protected method, creates a <see langword="Type"/> object corresponding to
   <see langword="MyTypeClass"/>, gets all the public and nonpublic methods,
      and displays their number and names.</para>
			<codelink SampleID="Type_GetMethods2" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.MethodInfo"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetMethod"/>
	</doc>
	<doc for="Type.GetField1">
		<summary>
			<para>Searches for the field with the specified name.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the data field to get.</param>
		<returns>
			<para>A <see cref="System.Reflection.FieldInfo"/> object representing the field with the
   specified name, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>. </exception>
		<remarks>
			<para>The search for <paramref name="name"/> is case-sensitive.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example gets the <see langword="Type"/> object for the specified
   class, obtains the <see cref="System.Reflection.FieldInfo"/> object for the field, and displays the
   value of the field.</para>
			<codelink SampleID="Type_GetField" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.FieldInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetFields"/>
	</doc>
	<doc for="Type.GetInterface">
		<overload>
			<para> Gets a specific interface implemented or inherited by the current <see cref="System.Type"/>.
   </para>
		</overload>
		<summary>
			<para> Searches for the interface with the specified name.
      </para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the interface to get. </param>
		<returns>
			<para> A <see cref="System.Type"/> object
   representing the interface with the specified name, implemented or inherited by
   the current <see cref="System.Type"/>, if found; otherwise, <see langword="null"/>.
   </para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>. </exception>
		<remarks>
			<para> The search for <paramref name="name"/> is case-sensitive.
   </para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<codelink SampleID="Type_GetInterface" SnippetID="1"/>
		</example>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.GetInterfaces"/>
		<seealso cref="System.Type.FindInterfaces"/>
	</doc>
	<doc for="Type.GetInterface1">
		<summary>
			<para>When overridden in a derived class, searches for the specified interface,
      specifying whether to do a case-sensitive search.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the interface to get.</param>
		<param name="ignoreCase"><para>
				<see langword="true"/> to perform a case-insensitive search for <paramref name="name"/>.</para>
			<para>-or-</para>
			<para>
				<see langword="false"/> to perform a case-sensitive search for <paramref name="name"/>.</para></param>
		<returns>
			<para>A <see cref="System.Type"/> object representing the interface with the specified name, implemented or inherited by
   the current <see cref="System.Type"/>, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>. </exception>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<codelink SampleID="Type_GetInterface" SnippetID="2"/>
		</example>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.GetInterfaces"/>
		<seealso cref="System.Type.FindInterfaces"/>
	</doc>
	<doc for="Type.FindInterfaces">
		<summary>
			<para>Returns an array of <see cref="System.Type"/> objects representing a filtered list of interfaces
   implemented or inherited by the current <see cref="System.Type"/>.</para>
		</summary>
		<param name="filter"><para>The <see cref="System.Reflection.TypeFilter"/> delegate that compares the interfaces against <paramref name="filterCriteria"/>.</para></param>
		<param name="filterCriteria">The search criteria that determines whether an interface should be included in the returned array.</param>
		<returns>
			<para>An array of <see cref="System.Type"/> objects representing a filtered list of the interfaces
   implemented or inherited by the current <see cref="System.Type"/>.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Type"/>, if no interfaces matching the filter are implemented or inherited by the
current <see cref="System.Type"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="filter"/> is <see langword="null"/>.</exception>
		<exception cref="System.Reflection.TargetInvocationException">A static initializer is invoked and throws an exception.</exception>
		<remarks>
			<para>This method can be overridden by a derived class.</para>
			<para>The <see cref="System.Reflection.Module.FilterTypeName" qualify="true"/> and <see cref="System.Reflection.Module.FilterTypeNameIgnoreCase" qualify="true"/> delegates supplied by the <see cref="System.Reflection.Module" qualify="true"/>
class may also be used, in lieu of the <see cref="System.Reflection.TypeFilter" qualify="true"/> delegate.</para>
			<para>All of the interfaces implemented by this class are considered during the
   search, whether declared by a base class or this class itself.</para>
			<para> This method searches the base class hierarchy, returning each of the matching interfaces
   each class implements as well as all the matching interfaces each of those
   interfaces implements (that is, the transitive closure of the matching
   interfaces is returned). No duplicate interfaces are returned.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example finds the specified interface implemented or inherited
      by the specified type, and then displays the interface names.</para>
			<codelink SampleID="Type_FindInterfaces" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.Module"/>
		<seealso cref="System.Reflection.TypeFilter"/>
		<seealso cref="System.Type.GetInterface"/>
		<seealso cref="System.Type.GetInterfaces"/>
	</doc>
	<doc for="Type.GetEvent">
		<overload>
			<para>Gets a specific event declared or inherited by the current <see cref="System.Type"/>.</para>
		</overload>
		<summary>
			<para>Returns the <see cref="System.Reflection.EventInfo"/> object representing the specified event.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of an event which is declared or inherited by the current <see cref="System.Type"/>.</param>
		<returns>
			<para>The <see cref="System.Reflection.EventInfo"/> object
   representing the specified event which is declared or inherited by the current
<see cref="System.Type"/>, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>.</exception>
		<remarks>
			<para>The search for <paramref name="name"/> is case-sensitive.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
			<para>The following table shows what members of a base class are returned by the
<see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always
         hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
         inheritance is the same as that of the methods that implement the
         property. Reflection treats properties as hide-by-name-and-signature. See
         note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual)
         can be hide-by-name or hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
         inheritance is the same as that of the methods that implement the
         property. Reflection treats properties as hide-by-name-and-signature. See
         note 2 below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
      
      Hide-by-name-and-signature considers all of the parts
      of the signature, including custom modifiers, return types, parameter types,
      sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
      
      For reflection, properties and events are
      hide-by-name-and-signature. If you have a property with both a get and a set
      accessor in the base class, but the derived class has only a get accessor, the
      derived class property hides the base class property, and you will not be able
      to access the setter on the base class.</term>
				</item>
				<item>
					<term>
      
      Custom attributes are not part of the common type system.</term>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example creates an <see cref="System.Reflection.EventInfo"/> object and gets the event
   for a button class for the specified event.</para>
			<codelink SampleID="Type_GetEvent" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.EventInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Type.GetEvents"/>
	</doc>
	<doc for="Type.GetProperty">
		<overload>
			<para>Gets a specific property of the current <see cref="System.Type"/>.</para>
		</overload>
		<summary>
			<para>Searches for the specified property whose parameters match the specified
      argument types and modifiers, using the specified binding constraints.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the property to get.</param>
		<param name="bindingAttr"><para> A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<param name="binder"><para>A <see cref="System.Reflection.Binder"/> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
			<para>-or-</para>
			<para>
				<see langword="null"/>, to use the <see cref="System.Type.DefaultBinder"/>.</para></param>
		<param name=" returnType">The return type of the property.</param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the indexed property to get.</para>
			<para>-or-</para>
			<para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</para></param>
		<param name="modifiers">An array of <see cref="System.Reflection.ParameterModifier"/> objects representing the attributes associated with the corresponding element in the <paramref name="types"/> array. The default binder does not process this parameter.</param>
		<returns>
			<para>A <see cref="System.Reflection.PropertyInfo"/> object representing the property that matches
   the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified binding constraints.</exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>One of the elements in <paramref name="types"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="types"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="modifiers"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> and <paramref name="modifiers"/> do not have the same length.</para></exception>
		<remarks>
			<para>Although the default binder does not process <see cref="System.Reflection.ParameterModifier"/> (the <paramref name="modifiers"/> parameter), you can
   use the abstract <see cref="System.Reflection.Binder" qualify="true"/> class to write a custom binder that does
   process <paramref name="modifiers"/>. <see langword="ParameterModifier"/> is
   only used when calling through COM interop, and only parameters that are passed by reference are handled.</para>
			<para>The following table shows what members of a base class are returned by the
<see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always
         hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
         inheritance is the same as that of the methods that implement the
         property. Reflection treats properties as hide-by-name-and-signature. See
         note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual)
         can be hide-by-name or hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
         inheritance is the same as that of the methods that implement the
         property. Reflection treats properties as hide-by-name-and-signature. See
         note 2 below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
      
      Hide-by-name-and-signature considers all of the parts
      of the signature, including custom modifiers, return types, parameter types,
      sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
      
      For reflection, properties and events are
      hide-by-name-and-signature. If you have a property with both a get and a set
      accessor in the base class, but the derived class has only a get accessor, the
      derived class property hides the base class property, and you will not be able
      to access the setter on the base class.</term>
				</item>
				<item>
					<term>
      
      Custom attributes are not part of the common type system.</term>
				</item>
			</list>
			<para>The <paramref name="types"/> array and the <paramref name="modifiers"/> array have the same length. A
parameter specified in the <paramref name="types"/> array can have the following attributes,
which are specified in the <paramref name="modifiers"/>
array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which
represent [In], [Out], [lcid], [retval], [optional], and a value specifying
whether the parameter has a default value. A parameter's associated attributes
are stored in the metadata and enhance interoperability.</para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
properties to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public properties
      in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      properties (that is, private and protected properties ) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      properties up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.IgnoreCase"/> to ignore the case of
   <paramref name="name"/>.</term>
				</item>
				<item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the properties
      declared on the <see cref="System.Type"/>, not properties that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<seealso cref="System.Reflection.PropertyInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Reflection.Binder"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Reflection.ParameterModifier"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetPropertyImpl"/>
		<seealso cref="System.Type.GetProperties"/>
	</doc>
	<doc for="Type.GetProperty1">
		<summary>
			<para>Searches for the specified public property whose parameters match the specified argument types and modifiers.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the public property to get.</param>
		<param name=" returnType">The return type of the property.</param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the indexed property to get.</para>
			<para>-or-</para>
			<para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</para></param>
		<param name="modifiers">An array of <see cref="System.Reflection.ParameterModifier"/> objects representing the attributes associated with the corresponding element in the <paramref name="types"/> array. The default binder does not process this parameter.</param>
		<returns>
			<para>A <see cref="System.Reflection.PropertyInfo"/> object representing the public property that matches
   the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified argument types and modifiers.</exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>One of the elements in <paramref name="types"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="types"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="modifiers"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> and <paramref name="modifiers"/> do not have the same length.</para></exception>
		<remarks>
			<para>Although the default binder does not process <see cref="System.Reflection.ParameterModifier"/> (the <paramref name="modifiers"/> parameter), you can
   use the abstract <see cref="System.Reflection.Binder" qualify="true"/> class to write a custom binder that does
   process <paramref name="modifiers"/>. <see langword="ParameterModifier"/>
   
   is only used when calling through COM interop, and only
   parameters that are passed by reference are handled.</para>
			<para>The <paramref name="types"/> array and the <paramref name="modifiers"/> array have the same length. A
parameter specified in the <paramref name="types"/> array can have the following attributes,
which are specified in the <paramref name="modifiers"/>
array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which
represent [In], [Out], [lcid], [retval], [optional], and a value specifying
whether the parameter has a default value. A parameter's associated attributes
are stored in the metadata and enhance interoperability.</para>
			<para>The search for <paramref name="name"/> is case-sensitive.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example obtains a <see langword="Type "/>object corresponding to <see langword="MyPropertyClass"/>, and the
   indexed property of this class is retrieved using the arguments passed to the
<see langword="GetProperty"/> method. </para>
			<codelink SampleID="Type_GetProperty5" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.PropertyInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Reflection.ParameterModifier"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetPropertyImpl"/>
		<seealso cref="System.Type.GetProperties"/>
	</doc>
	<doc for="Type.GetProperty2">
		<summary>
			<para>Searches for the specified property, using the specified binding constraints.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the property to get.</param>
		<param name="bindingAttr"><para>A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<returns>
			<para>A <see cref="System.Reflection.PropertyInfo"/> object representing the property that matches
   the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified binding constraints.</exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para></exception>
		<remarks>
			<para>The <paramref name="types"/> array and the <paramref name="modifiers"/> array have the same length. A
   parameter specified in the <paramref name="types"/> array can have the following attributes,
   which are specified in the <paramref name="modifiers"/>
   array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which
   represent [In], [Out], [lcid], [retval], [optional], and a value specifying
   whether the parameter has a default value. A parameter's associated attributes
   are stored in the metadata and enhance interoperability.</para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
properties to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public properties
      in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      properties (that is, private and protected properties ) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      properties up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.IgnoreCase"/> to ignore the case of
   <paramref name="name"/>.</term>
				</item>
				<item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the properties
      declared on the <see cref="System.Type"/>, not properties that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example retrieves the type object of a
      user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints. </para>
			<codelink SampleID="Type_GetProperty2" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.PropertyInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetPropertyImpl"/>
		<seealso cref="System.Type.GetProperties"/>
	</doc>
	<doc for="Type.GetProperty3">
		<summary>
			<para>Searches for the specified public property whose parameters match the specified argument types.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the public property to get.</param>
		<param name=" returnType">The return type of the property.</param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the indexed property to get.</para>
			<para>-or-</para>
			<para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</para></param>
		<returns>
			<para>A <see cref="System.Reflection.PropertyInfo"/> object representing the public
   property whose parameters match the specified argument types, if found;
   otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified argument types.</exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>One of the elements in <paramref name="types"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="types"/> is multidimensional.</para></exception>
		<remarks>
			<para>The search for <paramref name="name"/> is case-sensitive.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<seealso cref="System.Reflection.PropertyInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetPropertyImpl"/>
		<seealso cref="System.Type.GetProperties"/>
	</doc>
	<doc for="Type.GetProperty4">
		<summary>
			<para>Searches for the specified public property whose parameters match the specified argument types.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the public property to get.</param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the indexed property to get.</para>
			<para>-or-</para>
			<para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</para></param>
		<returns>
			<para>A <see cref="System.Reflection.PropertyInfo"/> object representing the public
   property whose parameters match the specified argument types, if found;
   otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified argument types.</exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>One of the elements in <paramref name="types"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="types"/> is multidimensional.</para></exception>
		<remarks>
			<para>The search for <paramref name="name"/> is case-sensitive.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example retrieves the <see langword="Type "/>object of a user-defined class, retrieves the property of that
   class, and displays the property name and type of the property as specified by
   the arguments passed to <see langword="GetProperty"/> . </para>
			<codelink SampleID="Type_GetProperty3" SnippetID="1"/>
			<para>Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <see langword="PropertyInfo"/> using reflection must specify this internal name in order for the <see langword="PropertyInfo"/> to be returned correctly. </para>
		</example>
		<seealso cref="System.Reflection.PropertyInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetPropertyImpl"/>
		<seealso cref="System.Type.GetProperties"/>
	</doc>
	<doc for="Type.GetProperty5">
		<summary>
			<para>Searches for the public property with the specified name and return type.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the public property to get.</param>
		<param name=" returnType">The return type of the property.</param>
		<returns>
			<para>A <see cref="System.Reflection.PropertyInfo"/> object representing the public
   property with the specified name, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one property is found with the specified name.</exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para></exception>
		<remarks>
			<para>The search for <paramref name="name"/> is case-sensitive.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para> 
      The following example defines a class with one property and retrieves the name and type of the property. </para>
			<codelink SampleID="Type_GetProperty_Types" SnippetID="2"/>
		</example>
		<seealso cref="System.Reflection.PropertyInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetPropertyImpl"/>
		<seealso cref="System.Type.GetProperties"/>
	</doc>
	<doc for="Type.GetProperty6">
		<summary>
			<para> Searches for the public property with the specified name.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the public property to get.</param>
		<returns>
			<para>A <see cref="System.Reflection.PropertyInfo"/> object representing the public
   property with the specified name, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one property is found with the specified name.</exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para></exception>
		<remarks>
			<para>The search for <paramref name="name"/> is case-sensitive.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example retrieves the
   <see langword="Type"/> object of a user-defined class, retrieves a property of that class, and displays the property name. </para>
			<codelink SampleID="Type_GetProperty1" SnippetID="1"/>
			<para>Internally, this property is referred to by the name "Item" in the metadata. Therefore, any attempt to get <see langword="PropertyInfo"/> using reflection must specify this internal name in order for the <see langword="PropertyInfo"/> to be returned correctly. </para>
		</example>
		<seealso cref="System.Reflection.PropertyInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetPropertyImpl"/>
		<seealso cref="System.Type.GetProperties"/>
	</doc>
	<doc for="Type.GetPropertyImpl">
		<summary>
			<para>When overridden in a derived class, searches for the specified property whose
      parameters match the specified argument types and modifiers, using the specified
      binding constraints.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the property to get.</param>
		<param name="bindingAttr"><para> A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<param name="binder"><para>A <see cref="System.Reflection.Binder"/> object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</para>
			<para>-or-</para>
			<para>
				<see langword="null"/>, to use the <see cref="System.Type.DefaultBinder"/>.</para></param>
		<param name=" returnType">The return type of the property.</param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the indexed property to get.</para>
			<para>-or-</para>
			<para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</para></param>
		<param name="modifiers">An array of <see cref="System.Reflection.ParameterModifier"/> objects representing the attributes associated with the corresponding element in the <paramref name="types"/> array. The default binder does not process this parameter.</param>
		<returns>
			<para>A <see cref="System.Reflection.PropertyInfo"/> object representing the property that matches
   the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one property is found with the specified name and matching the specified binding constraints.</exception>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="name"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>One of the elements in <paramref name="types"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="types"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="modifiers"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> and <paramref name="modifiers"/> do not have the same length.</para></exception>
		<remarks>
			<para>Although the default binder does not process <see cref="System.Reflection.ParameterModifier"/> (the <paramref name="modifiers"/> parameter), you can
   use the abstract <see cref="System.Reflection.Binder" qualify="true"/> class to write a custom binder that does
   process <paramref name="modifiers"/>. <see langword="ParameterModifier"/>
   is only used
   when calling through COM interop, and only parameters that are passed by
   reference are handled.</para>
			<para>The <paramref name="types"/> array and the <paramref name="modifiers"/> array have the same length. A
parameter specified in the <paramref name="types"/> array can have the following attributes,
which are specified in the <paramref name="modifiers"/>
array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which
represent [In], [Out], [lcid], [retval], [optional], and a value specifying
whether the parameter has a default value. A parameter's associated attributes
are stored in the metadata and are used for interoperability.</para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
properties to include in the search:</para>
			<list type="bullet"><item>
					<term>
						<paramref name="Instance"/> to include 
      instance properties in the search.</term>
				</item>
				<item>
					<term>
						<paramref name="Static"/> to include static 
      properties in the search.</term>
				</item>
				<item>
					<term>
						<paramref name="Public"/> to include public 
      properties in the search.</term>
				</item>
				<item>
					<term>
						<paramref name="NonPublic"/> to include non-public properties (that is, private and
      protected properties) in the search.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<paramref name="IgnoreCase"/> to ignore the case of <paramref name="name"/>.</term>
				</item>
				<item>
					<term>
						<paramref name="DeclaredOnly"/> to search only the properties declared on the <see cref="System.Type"/>, not properties
      that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<seealso cref="System.Reflection.PropertyInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Reflection.Binder"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Reflection.ParameterModifier"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetProperty"/>
		<seealso cref="System.Type.GetProperties"/>
	</doc>
	<doc for="Type.GetProperties">
		<overload>
			<para>Gets the properties of the current <see cref="System.Type"/>.</para>
		</overload>
		<summary>
			<para>When overridden in a derived class, searches for the properties of the current
   <see cref="System.Type"/>, using the specified binding constraints.</para>
		</summary>
		<param name="bindingAttr"><para> A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<returns>
			<para>An array of <see cref="System.Reflection.PropertyInfo"/> objects representing all properties of
   the current <see cref="System.Type"/> that match the specified binding constraints.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Reflection.PropertyInfo"/>, if the current
<see cref="System.Type"/> does not have properties, or if none of the properties match the binding constraints.</para>
		</returns>
		<remarks>
			<para>A property is considered public to reflection if it
      has at least one accessor that is public. That is, you can call
      type.GetProperty("propertyname", BindingFlags.Public
      | BindingFlags.Instance | BindingFlags.Static) to get it.</para>
			<para>Otherwise, the property is private and you must use
      type.GetProperty("propertyname", BindingFlags.NonPublic | BindingFlags.Instance |
      BindingFlags.Static) to get it.</para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
   nested types to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public properties
      in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      properties (that is, private and protected members) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      properties up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the properties
      declared on the <see cref="System.Type"/>, not properties that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example creates two public properties and one protected
      property and displays information for the properties that match the specified
      binding constraints.</para>
			<codelink SampleID="Type_GetProperties2" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.PropertyInfo"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Type.GetProperty"/>
	</doc>
	<doc for="Type.GetProperties1">
		<summary>
			<para>Returns all the public properties of the current <see cref="System.Type"/>.</para>
		</summary>
		<returns>
			<para>An array of <see cref="System.Reflection.PropertyInfo"/> objects representing all public
   properties of the current <see cref="System.Type"/>.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Reflection.PropertyInfo"/>, if the current <see cref="System.Type"/> does not have public properties.</para>
		</returns>
		<remarks>
			<para>The following table shows what members of a base class are returned by the
   <see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always
            hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual)
            can be hide-by-name or hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
         
         Hide-by-name-and-signature considers all of the parts
         of the signature, including custom modifiers, return types, parameter types,
         sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
         
         For reflection, properties and events are
         hide-by-name-and-signature. If you have a property with both a get and a set
         accessor in the base class, but the derived class has only a get accessor, the
         derived class property hides the base class property, and you will not be able
         to access the setter on the base class.</term>
				</item>
				<item>
					<term>
         
         Custom attributes are not part of the common type system.</term>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example demonstrates the use of the
   <see langword="GetProperties"/> method.</para>
			<codelink SampleID="Type_GetTypeCode" SnippetID="2"/>
		</example>
		<seealso cref="System.Reflection.PropertyInfo"/>
		<seealso cref="System.Type.GetProperty"/>
	</doc>
	<doc for="Type.GetNestedTypes">
		<overload>
			<para>Gets the types nested within the current <see cref="System.Type"/>.</para>
		</overload>
		<summary>
			<para>Returns all the types nested within the current <see cref="System.Type"/>.</para>
		</summary>
		<returns>
			<para>An array of <see cref="System.Type"/> objects representing all the types nested within
   the current <see cref="System.Type"/>.</para>
			<para>-or-</para>
An empty array of type <see cref="System.Type"/>, if no types are nested within the current <see cref="System.Type"/>.
</returns>
		<remarks>
			<para>The following table shows what members of a base class are returned by the
   <see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always
            hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual)
            can be hide-by-name or hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
         
         Hide-by-name-and-signature considers all of the parts
         of the signature, including custom modifiers, return types, parameter types,
         sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
         
         For reflection, properties and events are
         hide-by-name-and-signature. If you have a property with both a get and a set
         accessor in the base class, but the derived class has only a get accessor, the
         derived class property hides the base class property, and you will not be able
         to access the setter on the base class.</term>
				</item>
				<item>
					<term>
         
         Custom attributes are not part of the common type system.</term>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example defines a nested class and a struct in
   <see langword="MyClass"/> and obtains objects of the nested types using the
      type object of <see langword="MyClass"/>.</para>
			<codelink SampleID="Type_GetNestedTypes" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.GetNestedType"/>
	</doc>
	<doc for="Type.GetNestedType">
		<overload>
			<para>Gets a specific type nested within the current <see cref="System.Type"/>.</para>
		</overload>
		<summary>
			<para>Searches for the nested type with the specified name.</para>
		</summary>
		<param name="name">The string containing the name of the nested type to get, specified as nested.</param>
		<returns>
			<para>A <see cref="System.Type"/> object representing the nested type with the specified
   name, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>. </exception>
		<remarks>
			<para>The search for <paramref name="name"/> is case-sensitive.</para>
			<para>The following table shows what members of a base class are returned by the
<see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always
         hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
         inheritance is the same as that of the methods that implement the
         property. Reflection treats properties as hide-by-name-and-signature. See
         note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual)
         can be hide-by-name or hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
         inheritance is the same as that of the methods that implement the
         property. Reflection treats properties as hide-by-name-and-signature. See
         note 2 below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
      
      Hide-by-name-and-signature considers all of the parts
      of the signature, including custom modifiers, return types, parameter types,
      sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
      
      For reflection, properties and events are
      hide-by-name-and-signature. If you have a property with both a get and a set
      accessor in the base class, but the derived class has only a get accessor, the
      derived class property hides the base class property, and you will not be able
      to access the setter on the base class.</term>
				</item>
				<item>
					<term>
      
      Custom attributes are not part of the common type system.</term>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting methods that are not public. Associated enumerations: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/> , <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Type.GetNestedTypes"/>
	</doc>
	<doc for="Type.GetNestedType1">
		<summary>
			<para>When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</para>
		</summary>
		<param name="name">The string containing the name of the nested type to get, specified as nested.</param>
		<param name="bindingAttr"><para>A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<returns>
			<para>A <see cref="System.Type"/> object representing the nested type that
   matches the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>. </exception>
		<remarks>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
   nested types to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public nested
      types in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      nested types (that is, private and protected members) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      nested types up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.IgnoreCase"/> to ignore the case of
   <paramref name="name"/>.</term>
				</item>
				<item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the nested types
      declared on the <see cref="System.Type"/>, not nested types that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting methods that are not public. Associated enumerations: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/> , <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<seealso cref="System.String"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Type.GetNestedTypes"/>
	</doc>
	<doc for="Type.GetMember1">
		<summary>
			<para>Searches for the specified members, using the specified binding constraints.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the members to get.</param>
		<param name="bindingAttr"><para>A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<returns>
			<para>An array of <see cref="System.Reflection.MemberInfo"/> objects representing the public members with
   the specified name, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>. </exception>
		<remarks>
			<para>This method can be overridden by a derived class.</para>
			<para>Members include properties, methods, fields, events, and so on.</para>
			<para>This method searches the current classes and its base
      classes. If the requested member is non-public and the caller does not have
   <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
      outside the current assembly, this method returns <see langword="null"/> .</para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
   members to include in the search:</para>
			<list type="bullet"><item>
					<term>
						<paramref name="Instance"/> to include 
      instance members in the search.</term>
				</item>
				<item>
					<term>
						<paramref name="Static"/> to include static 
      members in the search.</term>
				</item>
				<item>
					<term>
						<paramref name="Public"/> to include public 
      members in the search.</term>
				</item>
				<item>
					<term>
						<paramref name="NonPublic"/> to include non-public members (that is, private and
      protected members) in the search.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<paramref name="IgnoreCase"/> to ignore the case of <paramref name="name"/>.</term>
				</item>
				<item>
					<term>
						<paramref name="DeclaredOnly"/> to search only the members declared on the <see cref="System.Type"/>, not members
      that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>Class initializers are available through <see cref="System.Type.GetMember"/>, <see cref="System.Type.GetMembers"/>,
<see cref="System.Type.FindMembers"/>, and <see cref="System.Type.GetConstructors"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example displays all the public static members of the
   <see langword="myString"/> class that start with the letter C.</para>
			<codelink SampleID="Type_GetMember" SnippetID="2"/>
		</example>
		<seealso cref="System.Reflection.MemberInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetMembers"/>
		<seealso cref="System.Type.GetDefaultMembers"/>
		<seealso cref="System.Type.FindMembers"/>
	</doc>
	<doc for="Type.GetMember2">
		<summary>
			<para> Searches for the specified members of the specified member type, using the
      specified binding constraints.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the members to get.</param>
		<param name="type">The <see cref="System.Type.MemberType"/> to search for.</param>
		<param name="bindingAttr"><para>A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<returns>
			<para>An array of <see cref="System.Reflection.MemberInfo"/> objects representing the public members with
   the specified name, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>. </exception>
		<exception cref="System.NotSupportedException">A derived class must provide an implementation.</exception>
		<remarks>
			<para>Members include properties, methods, fields, events, and so on.</para>
			<para>This method searches the current classes and its base
      classes. If the requested type is non-public and the caller does not have
   <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
      outside the current assembly, this method returns <see langword="null"/> .</para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
   members to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public members in
      the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      members (that is, private and protected members) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      members up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.IgnoreCase"/> to ignore the case of
   <paramref name="name"/>.</term>
				</item>
				<item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the members
      declared on the <see cref="System.Type"/>, not members that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>Class initializers are available through <see cref="System.Type.GetMember"/>, <see cref="System.Type.GetMembers"/>,
<see cref="System.Type.FindMembers"/>, and <see cref="System.Type.GetConstructors"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example displays all the methods of the
   <see langword="myString"/> class that start with the letter C.</para>
			<codelink SampleID="Type_GetMember" SnippetID="3"/>
		</example>
		<seealso cref="System.Reflection.MemberInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetMembers"/>
		<seealso cref="System.Type.GetDefaultMembers"/>
		<seealso cref="System.Type.FindMembers"/>
	</doc>
	<doc for="Type.GetMembers">
		<overload>
			<para>Gets the members (properties, methods, fields, events, and so on) of the
      current <see cref="System.Type"/>.</para>
		</overload>
		<summary>
			<para>Returns all the public members of the current <see cref="System.Type"/>.</para>
		</summary>
		<returns>
			<para>An array of <see cref="System.Reflection.MemberInfo"/> objects representing all the public
   members of the current <see cref="System.Type"/>.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Reflection.MemberInfo"/>, if the current <see cref="System.Type"/> does not have public members.</para>
		</returns>
		<remarks>
			<para>Members include properties, methods, fields, events, and so on.</para>
			<para>Class initializers are available through <see cref="System.Type.GetMember"/>, <see cref="System.Type.GetMembers"/>,
<see cref="System.Type.FindMembers"/>, and <see cref="System.Type.GetConstructors"/>. </para>
			<para>The following table shows what members of a base class are returned by the
<see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always
         hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
         inheritance is the same as that of the methods that implement the
         property. Reflection treats properties as hide-by-name-and-signature. See
         note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual)
         can be hide-by-name or hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
         inheritance is the same as that of the methods that implement the
         property. Reflection treats properties as hide-by-name-and-signature. See
         note 2 below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
      
      Hide-by-name-and-signature considers all of the parts
      of the signature, including custom modifiers, return types, parameter types,
      sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
      
      For reflection, properties and events are
      hide-by-name-and-signature. If you have a property with both a get and a set
      accessor in the base class, but the derived class has only a get accessor, the
      derived class property hides the base class property, and you will not be able
      to access the setter on the base class.</term>
				</item>
				<item>
					<term>
      
      Custom attributes are not part of the common type system.</term>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<codelink SampleID="Type_GetMembers1" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.MemberInfo"/>
		<seealso cref="System.Type.GetMember"/>
		<seealso cref="System.Type.GetDefaultMembers"/>
		<seealso cref="System.Type.FindMembers"/>
	</doc>
	<doc for="Type.GetMembers1">
		<summary>
			<para>When overridden in a derived class, searches for the members defined for the current <see cref="System.Type"/>,
   using the specified binding constraints.</para>
		</summary>
		<param name="bindingAttr"><para>A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<returns>
			<para>An array of <see cref="System.Reflection.MemberInfo"/> objects representing all members defined for
   the current <see cref="System.Type"/> that match the specified binding constraints.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Reflection.MemberInfo"/>, if no members are defined for the current
<see cref="System.Type"/>, or if none of the defined members match the binding constraints.</para>
		</returns>
		<remarks>
			<para>Members include properties, methods, fields, events, and so on.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
   outside the current assembly, this method returns <see langword="null"/>.</para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
members to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public members in
      the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      members (that is, private and protected members) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      members up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search
      only the members declared on the <see cref="System.Type"/>, not members that were simply inherited.</term>
				</item>
			</list>
			<para>Calling this method with only the <see langword="Public"/>
flag or only the <see langword="NonPublic"/> flag will return
the specified members and does not require any other flags.</para>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>Class initializers are available through <see cref="System.Type.GetMember"/>, <see cref="System.Type.GetMembers"/>, <see cref="System.Type.FindMembers"/>,
and <see cref="System.Type.GetConstructors"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<codelink SampleID="Type_GetMembers2" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.MemberInfo"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetMember"/>
		<seealso cref="System.Type.GetDefaultMembers"/>
		<seealso cref="System.Type.FindMembers"/>
	</doc>
	<doc for="Type.GetDefaultMembers">
		<summary>
			<para>Searches for the members defined for the current <see cref="System.Type"/> whose <see cref="System.Reflection.DefaultMemberAttribute"/> is set.</para>
		</summary>
		<returns>
			<para>An array of <see cref="System.Reflection.MemberInfo"/> objects representing all default members of
   the current <see cref="System.Type"/>.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Reflection.MemberInfo"/>, if the current <see cref="System.Type"/> does not have default members.</para>
		</returns>
		<remarks>
			<para>This method can be overridden by a derived class.</para>
			<para>Members include properties, methods, fields, events, and so on.</para>
			<para>The following table shows what members of a base class are returned by the
   <see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always
            hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual)
            can be hide-by-name or hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
         
         Hide-by-name-and-signature considers all of the parts
         of the signature, including custom modifiers, return types, parameter types,
         sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
         
         For reflection, properties and events are
         hide-by-name-and-signature. If you have a property with both a get and a set
         accessor in the base class, but the derived class has only a get accessor, the
         derived class property hides the base class property, and you will not be able
         to access the setter on the base class.</term>
				</item>
				<item>
					<term>
         
         Custom attributes are not part of the common type system.</term>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example obtains the default member information of
   <see langword="MyClass"/> and displays the default members.</para>
			<codelink SampleID="Type_GetDefaultMembers" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.MemberInfo"/>
		<seealso cref="System.Reflection.DefaultMemberAttribute"/>
		<seealso cref="System.Type.GetMember"/>
		<seealso cref="System.Type.GetMembers"/>
		<seealso cref="System.Type.FindMembers"/>
	</doc>
	<doc for="Type.FindMembers">
		<summary>
			<para>Returns a filtered array of <see cref="System.Reflection.MemberInfo"/> objects of the specified member type.</para>
		</summary>
		<param name="memberType">A <see langword="MemberTypes"/> object indicating the type of member to search for.</param>
		<param name="bindingAttr"><para>A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/> .</para></param>
		<param name="filter">The delegate that does the comparisons, returning <see langword="true"/> if the member currently being inspected matches the <paramref name="filterCriteria"/> and <see langword="false"/> otherwise. You can use the <see langword="FilterAttribute"/>, <see langword="FilterName"/>, and <see langword="FilterNameIgnoreCase"/> delegates supplied by this class. The first uses the fields of <see langword="FieldAttributes"/>, <see langword="MethodAttributes"/>, and <see langword="MethodImplAttributes"/> as search criteria, and the other two delegates use <see langword="String"/> objects as the search criteria.</param>
		<param name="filterCriteria"><para>The search criteria that determines whether a member is returned in the array of <see langword="MemberInfo"/> objects.</para>
			<para>The fields of <see langword="FieldAttributes"/>, <see langword="MethodAttributes"/>, and <see langword="MethodImplAttributes"/> can be used in conjunction with the <see langword="FilterAttribute"/> delegate supplied by this class. </para></param>
		<returns>
			<para>A filtered array of <see cref="System.Reflection.MemberInfo"/> objects of the specified member type.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Reflection.MemberInfo"/>, if the current <see cref="System.Type"/> does not have members of type
<paramref name="memberType"/> that match the filter criteria. </para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="filter"/> is <see langword="null"/>. </exception>
		<remarks>
			<para>This method can be overridden by a derived class.</para>
			<para>Members include properties, methods, fields, events, and
      so on. If the requested type is non-public and the caller does not have
   <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
      outside the current assembly, this method returns <see langword="null"/> .</para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define
   which members to include in the search:</para>
			<list type="bullet"><item>
					<term>
						<paramref name="Instance"/> to include 
      instance members in the search.</term>
				</item>
				<item>
					<term>
						<paramref name="Static"/> to include static 
      members in the search.</term>
				</item>
				<item>
					<term>
						<paramref name="Public"/> to include public 
      members in the search.</term>
				</item>
				<item>
					<term>
						<paramref name="NonPublic"/> to include non-public members (that is, private and
      protected members) in the search.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<paramref name="DeclaredOnly"/> to search only the members declared on the <see cref="System.Type"/>, not members
      that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>Valid values for <see cref="System.Type.MemberType"/> are
defined in <see cref="System.Reflection.MemberInfo"/> . If no such members are
found, an empty array is returned.</para>
			<para>Class initializers are available through <see cref="System.Type.GetMember"/>, <see cref="System.Type.GetMembers"/>,
<see cref="System.Type.FindMembers"/>, and <see cref="System.Type.GetConstructors"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example finds all the members in a class that match the
      specified search criteria, and then displays the matched members.</para>
			<codelink SampleID="Type_FindMembers" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.MemberInfo"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetMember"/>
		<seealso cref="System.Type.GetMembers"/>
		<seealso cref="System.Type.GetDefaultMembers"/>
	</doc>
	<doc for="Type.IsValueTypeImpl">
		<summary>
			<para> Implements the <see cref="System.Type.IsValueType"/> property and determines whether the
<see cref="System.Type"/> is a value type; that is, not a class or an interface.</para>
		</summary>
		<returns>
			<para><see langword="true"/> if the <see cref="System.Type"/> is a value type; otherwise, <see langword="false"/>. </para>
		</returns>
		<remarks>
			<para> Value types describe values that are represented as
      sequences of bits; value types are not classes or interfaces. These are referred to
      as "structs" in some programming languages. Enums are value types.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<codelink SampleID="Type_IsValueTypeImpl" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
		<seealso cref="System.Type.IsClass"/>
		<seealso cref="System.Type.IsInterface"/>
		<seealso cref="System.ValueType"/>
		<seealso cref="System.Type.IsValueType"/>
	</doc>
	<doc for="Type.GetAttributeFlagsImpl">
		<summary>
			<para>When overridden in a derived class, implements the <see cref="System.Type.Attributes"/> property and gets a bitmask indicating the attributes
   associated with the <see cref="System.Type"/>.</para>
		</summary>
		<returns>
			<para>A <see cref="System.Reflection.TypeAttributes"/> object
   representing the attribute set of the <see cref="System.Type"/>.</para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<seealso cref="System.Type.Attributes"/>
		<seealso cref="System.Reflection.TypeAttributes"/>
	</doc>
	<doc for="Type.IsArrayImpl">
		<summary>
			<para>When overridden in a derived class, implements the <see cref="System.Type.IsArray"/> property and determines whether the <see cref="System.Type"/> is an array.</para>
		</summary>
		<returns>
			<para><see langword="true"/> if the <see cref="System.Type"/> is an array; otherwise, <see langword="false"/>. </para>
		</returns>
		<remarks>
			<para>An instance of the <see cref="System.Array"/> class must return <see langword="false"/> because it is an object, not an array.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example overrides the <see langword="IsArrayImpl"/> method in
   the <see langword="MyTypeDelegator "/>class, checks if a variable is an array,
   and displays the result.</para>
			<codelink SampleID="Type_IsArrayImpl" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.IsArray"/>
	</doc>
	<doc for="Type.IsByRefImpl">
		<summary>
			<para>When overridden in a derived class, implements the <see cref="System.Type.IsByRef"/>
property and determines whether the <see cref="System.Type"/> is passed by reference.</para>
		</summary>
		<returns>
			<para><see langword="true"/> if the <see cref="System.Type"/> is passed by reference; otherwise, <see langword="false"/>. </para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<seealso cref="System.Type.IsByRef"/>
	</doc>
	<doc for="Type.IsPointerImpl">
		<summary>
			<para>When overridden in a derived class, implements the <see cref="System.Type.IsPointer"/> property and determines whether the
<see cref="System.Type"/> is a pointer.</para>
		</summary>
		<returns>
			<para><see langword="true"/> if the <see cref="System.Type"/> is a pointer; otherwise, <see langword="false"/>. </para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<seealso cref="System.Type.IsPointer"/>
	</doc>
	<doc for="Type.IsPrimitiveImpl">
		<summary>
			<para>When overridden in a derived class, implements the <see cref="System.Type.IsPrimitive"/> property and determines whether the
<see cref="System.Type"/> is one of the primitive types.</para>
		</summary>
		<returns>
			<para><see langword="true"/> if the <see cref="System.Type"/> is one of the primitive types; otherwise, <see langword="false"/>. </para>
		</returns>
		<remarks>
			<para>The primitive types are <see cref="System.Boolean"/>, <see cref="System.Byte"/>, <see cref="System.SByte"/>, <see cref="System.Int16"/>, <see cref="System.UInt16"/>, <see cref="System.Int32"/>, <see cref="System.UInt32"/>, <see cref="System.Int64"/>, <see cref="System.UInt64"/>, <see cref="System.Char"/>, <see cref="System.Double"/>, and <see cref="System.Single"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example determines whether the given type is a primitive type
      and displays the result.</para>
			<codelink SampleID="Type_IsPrimitiveImpl" SnippetID="1"/>
		</example>
		<seealso cref="System.Boolean"/>
		<seealso cref="System.Byte"/>
		<seealso cref="System.SByte"/>
		<seealso cref="System.Int16"/>
		<seealso cref="System.UInt16"/>
		<seealso cref="System.Int32"/>
		<seealso cref="System.UInt32"/>
		<seealso cref="System.Int64"/>
		<seealso cref="System.UInt64"/>
		<seealso cref="System.Char"/>
		<seealso cref="System.Double"/>
		<seealso cref="System.Single"/>
		<seealso cref="System.Type.IsPrimitive"/>
	</doc>
	<doc for="Type.IsCOMObjectImpl">
		<summary>
			<para>When overridden in a derived class, implements the <see cref="System.Type.IsCOMObject"/> property and determines whether the
<see cref="System.Type"/> is a COM object.</para>
		</summary>
		<returns>
			<para><see langword="true"/> if the <see cref="System.Type"/> is a COM object; otherwise, <see langword="false"/>. </para>
		</returns>
		<remarks>
			<para>This method returns <see langword="false"/> for COM interfaces because they
   are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<seealso cref="System.Type.IsCOMObject"/>
	</doc>
	<doc for="Type.IsContextfulImpl">
		<summary>
			<para> Implements the <see cref="System.Type.IsContextful"/>
property and determines whether the <see cref="System.Type"/> can be hosted in a context.</para>
		</summary>
		<returns>
			<para><see langword="true"/> if the <see cref="System.Type"/> can be hosted in a context; otherwise, <see langword="false"/>.
   </para>
		</returns>
		<remarks>
			<para> This method can be overridden by a derived class.
      </para>
			<para> A context intercepts calls to the class members and enforce policies that are
      applied to the class, such as synchronization.
      </para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example demonstrates a use of the
   <see langword="IsContextfulImpl"/> method.</para>
			<codelink SampleID="Type_IsContextfulImpl" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.IsContextful"/>
	</doc>
	<doc for="Type.IsMarshalByRefImpl">
		<summary>
			<para> Implements the <see cref="System.Type.IsMarshalByRef"/> property and determines whether
   the <see cref="System.Type"/> is marshalled by reference.
   </para>
		</summary>
		<returns>
			<para><see langword="true"/> if the <see cref="System.Type"/> is marshalled by reference; otherwise, <see langword="false"/>.
   </para>
		</returns>
		<remarks>
			<para> This method can be overridden by a derived class.
      </para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example determines whether the given type is marshalled by
      reference and displays the result. </para>
			<codelink SampleID="Type_IsMarshalByRefImpl" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.IsMarshalByRef"/>
	</doc>
	<doc for="Type.GetElementType">
		<summary>
			<para>When overridden in a derived class, returns the <see cref="System.Type"/> of the object encompassed or referred to by the current
   array, pointer or reference type.</para>
		</summary>
		<returns>
			<para>The <see cref="System.Type"/> of the object encompassed or referred to by the current array, pointer or reference type.</para>
			<para>-or-</para>
			<para><see langword="null"/> if the current <see cref="System.Type"/> is not an array or a
pointer, or is not passed by reference.</para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example demonstrates using the <see langword="GetElementType"/>
method.</para>
			<codelink SampleID="TestGetElementType" SnippetID="1"/>
			<para>This code produces the following output:</para>
			<code>
System.Int32[] element type is System.Int32
    TestGetElementType element type is null
</code>
		</example>
		<seealso cref="System.Type.HasElementType"/>
	</doc>
	<doc for="Type.HasElementTypeImpl">
		<summary>
			<para>When overridden in a derived class, implements the <see cref="System.Type.HasElementType"/> property and
   determines whether the current <see cref="System.Type"/> encompasses or
   refers to another type; that is,
   whether the current <see cref="System.Type"/> is an array, a pointer, or is passed by
   reference.</para>
		</summary>
		<returns>
			<para><see langword="true"/> if the <see cref="System.Type"/> is an array, a pointer, or is passed by reference; otherwise, <see langword="false"/>. </para>
		</returns>
		<remarks>
			<para>For example, Type.GetType("Int32[]").HasElementTypeImpl returns
   <see langword="true"/>, but Type.GetType("Int32").HasElementTypeImpl returns
   <see langword="false"/>. HasElementTypeImpl also returns <see langword="true"/>
   for "Int32*" and "Int32&amp;".</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example defines the class <see langword="MyTypeDelegator"/>,
   which overrides the <see langword="HasElementTypeImpl"/> method. The main class
   checks for the <see langword="HasElementType"/> property and displays the element
   type.</para>
			<codelink SampleID="Type_HasElementTypeImpl" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.HasElementType"/>
		<seealso cref="System.Type.IsArray"/>
		<seealso cref="System.Type.IsPointer"/>
		<seealso cref="System.Type.IsByRef"/>
		<seealso cref="System.Type.GetElementType"/>
		<seealso cref="System.Type.GetType"/>
	</doc>
	<doc for="Type.IsInstanceOfType">
		<summary>
			<para> Determines whether the specified object is an instance of the current <see cref="System.Type"/>.
   </para>
		</summary>
		<param name="o">The object to compare with the current <see langword="Type"/>. </param>
		<returns>
			<para><see langword="true"/> if the current
<see langword="Type"/> is in the inheritance hierarchy of the object represented 
   by the <paramref name="o"/> parameter, or if the current Type is an interface that
<paramref name="o"/> supports. <see langword="false"/> 
if neither of these conditions is the case, or if <paramref name="o"/> is
<see langword="null"/> .</para>
		</returns>
		<remarks>
			<para> This method can be overridden by a derived class.
      </para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example demonstrates the use of the
   <see langword="IsInstanceOfType"/> method.</para>
			<codelink SampleID="TestIsInstanceOfType" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Type.IsAssignableFrom">
		<summary>
			<para> Determines whether an instance of the
      current <see cref="System.Type"/> can be assigned from an instance of the specified
   <see langword="Type"/> .
      </para>
		</summary>
		<param name="c">The <see langword="Type"/> to compare with the current <see langword="Type"/> . </param>
		<returns>
			<para><see langword="true"/> if the <paramref name="c"/> parameter and
   the current <see langword="Type"/> represent the same type, or if the current
<see langword="Type"/> is in the inheritance hierarchy of <paramref name="c"/>, or if the 
   current <see langword="Type"/> is an interface that <paramref name="c"/> supports.
<see langword="false"/> if none of these conditions are the case, or if 
<paramref name="c"/> is <see langword="null"/>. </para>
		</returns>
		<remarks>
			<para> This method can be overridden by a derived class.
      </para>
			<para> Determine the element types of a <see langword="Type"/>
using <see cref="System.Type.GetElementType"/> .</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example demonstrates the
   <see langword="IsAssignable"/> method using arrays.</para>
			<codelink SampleID="TestIsAssignableFrom" SnippetID="1"/>
			<para>This code produces the following output:</para>
			<code>
int[2] is assignable from int? False
    int[2] is assignable from int[10]? True
    int[2,2] is assignable from int[2,4]? True
    int[2,4] is assignable from int[2,2]? True
    int[2,2] is assignable from int[10]? False
    int[2,2] is assignable from int[3,3,3]? False
    int[3,3,3] is assignable from int[2,2]? False
</code>
		</example>
	</doc>
	<doc for="Type.ToString">
		<summary>
			<para> Returns a <see langword="String"/> representing the name
   of the current <see langword="Type"/>.
   </para>
		</summary>
		<returns>
			<para>A <see cref="System.String"/> representing the name of the current <see cref="System.Type"/>.</para>
		</returns>
		<remarks>
			<para>This method returns the fully qualified common language
      runtime namespace and name for all primitive types. For example, the C#
      instruction, <c>(long)0.Type().ToString()</c> returns "System.Int64" instead of merely
   "Int64".</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>This following example demonstrates a use of the <see cref="System.Type.Namespace"/>
and <see cref="System.Type.Module"/> properties and the <see langword="ToString"/> method of
<see cref="System.Type"/>.</para>
			<codelink SampleID="Type_ToString" SnippetID="1"/>
		</example>
		<seealso cref="System.String"/>
	</doc>
	<doc for="Type.GetTypeArray">
		<summary>
			<para> Gets the types of the objects in the specified array.
      </para>
		</summary>
		<param name="args">An array of objects whose types to determine. </param>
		<returns>
			<para> An array of <see cref="System.Type"/> objects representing the types of the corresponding
   elements in <paramref name="args"/>.
   </para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="args"/> is <see langword="null"/>. </exception>
		<exception cref="System.Reflection.TargetInvocationException">The class initializers are invoked and at least one throws an exception. </exception>
		<remarks>
			<para>If a requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to non-public objects
   outside the current assembly, this method returns <see langword="null"/> for the corresponding element in the result
   array.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<codelink SampleID="Type_GetTypeCode" SnippetID="3"/>
		</example>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
	</doc>
	<doc for="Type.Equals1">
		<summary>
			<para>Determines if the underlying system type of the current <see cref="System.Type"/> is the same as the
   underlying system type of the specified <see cref="System.Type"/>.</para>
		</summary>
		<param name="o">The <see cref="System.Type"/> whose underlying system type is to be compared with the underlying system type of the current <see cref="System.Type"/>.</param>
		<returns>
			<para><see langword="true"/> if the underlying system type of <paramref name="o"/> is the same
   as the underlying system type of the current <see cref="System.Type"/>; otherwise, <see langword="false"/>.</para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example uses <see langword="Equals"/> to compare two types.</para>
			<codelink SampleID="Classic Type.Equals1 Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.UnderlyingSystemType"/>
	</doc>
	<doc for="Type.GetHashCode">
		<summary>
			<para>Returns the hash code for this instance.</para>
		</summary>
		<returns>
			<para>An <see cref="System.Int32"/> containing the hash code for this instance.</para>
		</returns>
		<remarks>
			<para>This method overrides <see cref="System.Object.GetHashCode" qualify="true"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example displays the hash code of the
   <see langword="System.Windows.Forms.Button"/> class.</para>
			<codelink SampleID="Type_GetHashCode_GetFields" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Type.GetInterfaceMap">
		<summary>
			<para> Returns an interface mapping for the
      specified interface type.</para>
		</summary>
		<param name="interfaceType">The <see cref="System.Type"/> of the interface of which to retrieve a mapping.</param>
		<returns>
			<para>An <see cref="System.Reflection.InterfaceMapping"/> object representing the
   interface mapping for <paramref name="interfaceType"/>.</para>
		</returns>
		<exception cref="System.ArgumentException">The <paramref name="interfaceType"/> parameter does not refer to an interface.</exception>
		<exception cref="System.ArgumentNullException"><paramref name="interfaceType"/> is <see langword="null"/>.</exception>
		<remarks>
			<para>The interface map denotes how an interface is mapped into the actual
      methods on a class that implements that interface.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<seealso cref="System.Reflection.InterfaceMapping"/>
	</doc>
	<doc for="Type.Equals">
		<overload>
			<para>Determines if the underlying system type of the current <see cref="System.Type"/> is the same as the underlying system
   type of the specified <see cref="System.Object"/> or <see cref="System.Type"/>.</para>
		</overload>
		<summary>
			<para>Determines if the underlying system type of the
      current <see cref="System.Type"/> is the same as the underlying system type of the
      specified <see cref="System.Object"/>.</para>
		</summary>
		<param name="o">The <see cref="System.Object"/> whose underlying system type is to be compared with the underlying system type of the current <see cref="System.Type"/>.</param>
		<returns>
			<para><see langword="true"/> if the underlying system type of <paramref name="o"/> is the same as the underlying system type of the current <see cref="System.Type"/>; otherwise, <see langword="false"/>.
   This method also returns <see langword="false"/> if the object specified by the
<paramref name="o"/> parameter is not a <see langword="Type"/>.</para>
		</returns>
		<remarks>
			<para>This method overrides <see cref="System.Object.Equals" qualify="true"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example uses <see langword="Equals"/> to compare two
<see langword="Object"/> instances.</para>
			<codelink SampleID="Classic Type.Equals Example" SnippetID="1"/>
			<para>This code produces the following output: </para>
			<para>False </para>
			<para>True </para>
		</example>
		<seealso cref="System.Type.UnderlyingSystemType"/>
	</doc>
	<doc for="Type.GetEvents">
		<overload>
			<para>Gets the events that are declared or inherited by
      the current <see cref="System.Type"/>.</para>
		</overload>
		<summary>
			<para>Returns all the public events that are declared or
      inherited by the current <see cref="System.Type"/>.</para>
		</summary>
		<returns>
			<para>An array of <see cref="System.Reflection.EventInfo"/> objects representing all the public
   events which are declared or inherited by the current <see cref="System.Type"/>.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Reflection.EventInfo"/>, if
the current <see cref="System.Type"/> does not have public events.</para>
		</returns>
		<remarks>
			<para>This method can be overridden by a derived class.</para>
			<para>The following table shows what members of a base class are returned by the
   <see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always
            hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual)
            can be hide-by-name or hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
         
         Hide-by-name-and-signature considers all of the parts
         of the signature, including custom modifiers, return types, parameter types,
         sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
         
         For reflection, properties and events are
         hide-by-name-and-signature. If you have a property with both a get and a set
         accessor in the base class, but the derived class has only a get accessor, the
         derived class property hides the base class property, and you will not be able
         to access the setter on the base class.</term>
				</item>
				<item>
					<term>
         
         Custom attributes are not part of the common type system.</term>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example obtains an array of <see cref="System.Reflection.EventInfo"/> objects, gets all
   the events for a <see langword="Button"/> class, and
   displays the event names. To compile the Visual Basic
   example, use the following command line:</para>
			<para><see langword="vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll"/>
			</para>
			<codelink SampleID="Type_GetEvents1" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.EventInfo"/>
		<seealso cref="System.Type.GetEvent"/>
	</doc>
	<doc for="Type.IsPrimitive">
		<summary>
			<para>Gets a value indicating whether the <see cref="System.Type"/> is one of the primitive types.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is one of the primitive types; otherwise, <see langword="false"/>. </para>
		</value>
		<remarks>
			<para>The primitive types are <see cref="System.Boolean"/>, <see cref="System.Byte"/>, <see cref="System.SByte"/>, <see cref="System.Int16"/>, <see cref="System.UInt16"/>, <see cref="System.Int32"/>, <see cref="System.UInt32"/>, <see cref="System.Int64"/>, <see cref="System.UInt64"/>, <see cref="System.Char"/>, <see cref="System.Double"/>, and <see cref="System.Single"/>.</para>
		</remarks>
		<example>
			<para>The following example demonstrates the <see langword="IsContextful"/>, <see cref="System.Type.IsMarshalByRef"/>, and
<see cref="System.Type.IsPrimitive"/> 
properties of the <see cref="System.Type"/> class. It checks whether the given type can be
hosted in the context, whether it can be marshalled by reference,
and whether the type is a primitive data type.</para>
			<codelink SampleID="Type_IsContextful" SnippetID="1"/>
		</example>
		<seealso cref="System.Boolean"/>
		<seealso cref="System.Byte"/>
		<seealso cref="System.SByte"/>
		<seealso cref="System.Int16"/>
		<seealso cref="System.UInt16"/>
		<seealso cref="System.Int32"/>
		<seealso cref="System.UInt32"/>
		<seealso cref="System.Int64"/>
		<seealso cref="System.UInt64"/>
		<seealso cref="System.Char"/>
		<seealso cref="System.Double"/>
		<seealso cref="System.Single"/>
		<seealso cref="System.Type.IsPrimitiveImpl"/>
	</doc>
	<doc for="Type.GetMethod5">
		<summary>
			<para>Searches for the public method with the specified name.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the public method to get.</param>
		<returns>
			<para>A <see cref="System.Reflection.MethodInfo"/> object
   representing the public method with the
   specified name, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one method is found with the specified name.</exception>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>. </exception>
		<remarks>
			<para>The search for <paramref name="name"/> is case-sensitive.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
			<note type="note">
   You cannot omit parameters when looking up
   constructors and methods. You can only omit parameters when invoking.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example gets the parameters of <see langword="MyFunction"/>
in <see langword="MyClass"/> and displays their position and data type. </para>
			<codelink SampleID="Type_GetMethod1" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.MethodInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetMethodImpl"/>
		<seealso cref="System.Type.GetMethods"/>
	</doc>
	<doc for="Type.GetNestedTypes1">
		<summary>
			<para>When overridden in a derived class, searches for the types nested within the current <see cref="System.Type"/>,
   using the specified binding constraints.</para>
		</summary>
		<param name="bindingAttr"><para> A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<returns>
			<para>An array of <see cref="System.Type"/> objects representing all the types nested within
   the current <see cref="System.Type"/> that match the specified binding constraints.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Type"/>, if no types are nested within the current <see cref="System.Type"/>, or if none of
the nested types match the binding constraints.</para>
		</returns>
		<remarks>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
   nested types to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public nested
      types in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      nested types (that is, private and protected members) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      nested types up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the nested types
      declared on the <see cref="System.Type"/>, not nested types that were simply inherited.</term>
				</item>
			</list>
			<para>Calling this method with only the <paramref name="Public"/> flag or only the
<paramref name="NonPublic"/> flag will return the specified nested types and does not
require any other flags.</para>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting methods that are not public. Associated enumerations: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/> , <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example creates two nested public classes and two nested
      protected classes and displays information for classes that match the specified
      binding constraints. </para>
			<codelink SampleID="Type_GetNestedClassesAbs" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Type.GetNestedType"/>
	</doc>
	<doc for="Type.GetEvents1">
		<summary>
			<para>When overridden in a derived class, searches for events
      that are declared or inherited by the current <see cref="System.Type"/>, using the specified binding
      constraints.</para>
		</summary>
		<param name="bindingAttr"><para>A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<returns>
			<para>An array of <see cref="System.Reflection.EventInfo"/> objects representing all events
   which are declared or inherited by the current <see cref="System.Type"/> that match the specified binding constraints.</para>
			<para>-or-</para>
An empty array of type <see cref="System.Reflection.EventInfo"/>, if the current
<see cref="System.Type"/> does not have events, or
if none of the events match the binding constraints.
</returns>
		<remarks>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
   events to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public events in
      the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      events (that is, private and protected events) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      members up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the events
      declared on the <see cref="System.Type"/>, not events that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example obtains an array of <see cref="System.Reflection.EventInfo"/> objects that match the
   specified binding flags, gets all the events for a <see langword="Button"/> class, and displays the event names. To
   compile the Visual Basic
   example, use the following command line:</para>
			<para><see langword="vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll"/></para>
			<codelink SampleID="Type_GetEvents2" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.EventInfo"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetEvent"/>
	</doc>
	<doc for="Type.IsNestedFamANDAssem">
		<summary>
			<para> Gets a value indicating whether the <see cref="System.Type"/> is nested and visible only to classes that belong to both its own family and
   its own assembly.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Type"/> is nested
   and visible only to classes that belong to both its own family and its own assembly; otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The <see cref="System.Reflection.TypeAttributes.VisibilityMask"/> selects the visibility attributes.</para>
			<para>A <see cref="System.Type"/> object's family is defined as all objects of the exact
same <see cref="System.Type"/> and of its subtypes.</para>
		</remarks>
		<example>
			<para>The following example demonstrates a use of the 
   <see langword="IsNestedFamANDAssem"/> property.</para>
			<codelink SampleID="type_isnestedfamandassem" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.TypeAttributes"/>
	</doc>
	<doc for="Type.GetInterfaces">
		<summary>
			<para>When overridden in a derived class, gets all the
      interfaces implemented or inherited by the current <see cref="System.Type"/>.</para>
		</summary>
		<returns>
			<para>An array of <see cref="System.Type"/> objects representing all the interfaces implemented or
   inherited by the current <see cref="System.Type"/>.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Type"/>, if no interfaces are implemented or inherited by the
current <see cref="System.Type"/>.</para>
		</returns>
		<exception cref="System.Reflection.TargetInvocationException">A static initializer is invoked and throws an exception.</exception>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example gets the type of the specified
      class and displays all the interfaces that the type implements or
      inherits. To compile the Visual Basic example, use the following compiler
      commands:</para>
			<para><see langword="vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll"/>
			</para>
			<codelink SampleID="Type_GetInterfaces1" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.GetInterface"/>
		<seealso cref="System.Type.FindInterfaces"/>
	</doc>
	<doc for="Type.GetMember">
		<overload>
			<para>Gets the specified members of the current <see cref="System.Type"/>.</para>
		</overload>
		<summary>
			<para>Searches for the members with the specified name.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the public members to get.</param>
		<returns>
			<para>An array of <see cref="System.Reflection.MemberInfo"/> objects representing the public members with
   the specified name, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>. </exception>
		<remarks>
			<para>The search for <paramref name="name"/> is case-sensitive.</para>
			<para>Members include properties, methods, fields, events, and so on.</para>
			<para>This method searches the current classes and its base
   classes. Only public methods can be found using this method. If the
   requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
   outside the current assembly, this method returns <see langword="null"/>
   .</para>
			<para>Class initializers are available through <see cref="System.Type.GetMember"/>, <see cref="System.Type.GetMembers"/>,
<see cref="System.Type.FindMembers"/>, and <see cref="System.Type.GetConstructors"/>.</para>
			<para>The following table shows what members of a base class are returned by the
<see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always
         hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
         inheritance is the same as that of the methods that implement the
         property. Reflection treats properties as hide-by-name-and-signature. See
         note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual)
         can be hide-by-name or hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
         inheritance is the same as that of the methods that implement the
         property. Reflection treats properties as hide-by-name-and-signature. See
         note 2 below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
      
      Hide-by-name-and-signature considers all of the parts
      of the signature, including custom modifiers, return types, parameter types,
      sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
      
      For reflection, properties and events are
      hide-by-name-and-signature. If you have a property with both a get and a set
      accessor in the base class, but the derived class has only a get accessor, the
      derived class property hides the base class property, and you will not be able
      to access the setter on the base class.</term>
				</item>
				<item>
					<term>
      
      Custom attributes are not part of the common type system.</term>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example displays all the members of the <see langword="String"/>
class that start with the letter C.</para>
			<codelink SampleID="Type_GetMember" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.MemberInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetMembers"/>
		<seealso cref="System.Type.GetDefaultMembers"/>
		<seealso cref="System.Type.FindMembers"/>
	</doc>
	<doc for="Type.DefaultBinder">
		<summary>
			<para>Gets a reference to the default binder, which
      implements internal rules for selecting the appropriate members to be
      called by <see cref="System.Type.InvokeMember"/> .</para>
		</summary>
		<value>
			<para>A reference to the default binder used by the system.</para>
		</value>
		<remarks>
			<para>The default binder provided with the common language
      runtime is applicable in all but the most specialized circumstances. If you need
      a binder that follows rules that differ from those of the supplied
      default binder, define a type derived from the <see cref="System.Reflection.Binder"/> class and pass an instance
      of that type using the <paramref name="binder"/> parameter of one of the <see cref="System.Type.InvokeMember"/>
      
      overloads. </para>
			<para>Reflection models the accessibility rules of the common
      type system. For example, if the caller is in the same assembly, the caller does
      not need special permissions for internal members. Otherwise, the caller needs
   <see cref="System.Security.Permissions.ReflectionPermission"/>
   . This is consistent with lookup of members that
   are protected, private, and so on. </para>
			<para> The general principle is that <see cref="System.Reflection.Binder.ChangeType"/> should perform only widening
conversions, which never lose data. An example of a widening conversion is converting
a value that is a 32-bit signed integer to a value that is a 64-bit signed
integer. This is distinguished from a narrowing conversion, which may lose data.
An example of a narrowing conversion is converting a 64-bit signed integer to a
32-bit signed integer. </para>
			<para>The following table lists the conversions supported
   by the default binder.</para>
			<list type="table">
				<listheader>
					<term>Source Type</term>
					<description>Target Type</description>
				</listheader>
				<item>
					<term> Any type</term>
					<description>Its base type.</description>
				</item>
				<item>
					<term> Any type</term>
					<description>The interface it implements.</description>
				</item>
				<item>
					<term> Char</term>
					<description>Unt16, UInt32, Int32, UInt64, Int64, Single, Double</description>
				</item>
				<item>
					<term> Byte</term>
					<description>Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</description>
				</item>
				<item>
					<term> SByte</term>
					<description>Int16, Int32, Int64, Single, Double</description>
				</item>
				<item>
					<term> UInt16</term>
					<description>UInt32, Int32, UInt64, Int64, Single, Double</description>
				</item>
				<item>
					<term> Int16</term>
					<description>Int32, Int64, Single, Double</description>
				</item>
				<item>
					<term> UInt32</term>
					<description>UInt64, Int64, Single, Double</description>
				</item>
				<item>
					<term> Int32</term>
					<description>Int64, Single, Double</description>
				</item>
				<item>
					<term> UInt64</term>
					<description>Single, Double</description>
				</item>
				<item>
					<term> Int64</term>
					<description>Single, Double</description>
				</item>
				<item>
					<term> Single</term>
					<description>Double</description>
				</item>
				<item>
					<term> Non-reference</term>
					<description>By-reference.</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example gets the default binder from the
   <see langword="DefaultBinder"/> property, and invokes a 
      member of MyClass by passing the <see langword="DefaultBinder"/> value as
      a parameter to <see cref="System.Type.InvokeMember"/>.</para>
			<codelink SampleID="Type_DefaultBinder" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.Binder"/>
	</doc>
	<doc for="Type.GetTypeFromProgID">
		<overload>
			<para>Gets the type associated with the specified program identifier (ProgID).</para>
		</overload>
		<summary>
			<para>Gets the type associated with the specified program
      identifier (ProgID), returning null if an error is encountered while
      loading the <see cref="System.Type"/>.</para>
		</summary>
		<param name="progID">The ProgID of the type to get.</param>
		<returns>
			<para>The type associated with the specified
      ProgID, if <paramref name="progID"/> is a valid entry in the registry and a type is
      associated with it; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="progID"/> is <see langword="null"/>.</exception>
		<remarks>
			<para> This method is provided for COM support. ProgIDs are not used in the Microsoft .NET Framework because
      they have been superceded by the concept of namespace.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting members that are not public. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<seealso cref="System.Runtime.InteropServices.RegistrationServices.GetProgIdForType"/>
	</doc>
	<doc for="Type.GetTypeFromProgID1">
		<summary>
			<para>Gets the type associated with the specified program 
      identifier (ProgID), specifying whether to throw an exception if an error occurs
      while loading the type.</para>
		</summary>
		<param name="progID">The ProgID of the type to get.</param>
		<param name="throwOnError"><para><see langword="true"/> to throw any exception that occurs.</para>
			<para>-or-</para>
			<para><see langword="false"/> to ignore any exception that occurs.</para></param>
		<returns>
			<para>The type associated with the specified program identifier (ProgID), if <paramref name="progID"/> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="progID"/> is <see langword="null"/>.</exception>
		<exception cref="System.Runtime.InteropServices.COMException">The spedified ProgId is not registered.</exception>
		<remarks>
			<para>This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because
      they have been superceded by the concept of namespace.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting members that are not public. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example retrieves a type by passing a
      ProgID, specifying whether to throw an exception if the ProgID is
      invalid. The example then displays the ClassID related to the ProgID,
      along with any applicable exception message.</para>
			<codelink SampleID="Type_GetTypeFromProgID2" SnippetID="1"/>
		</example>
		<seealso cref="System.Runtime.InteropServices.RegistrationServices.GetProgIdForType"/>
	</doc>
	<doc for="Type.GetTypeFromProgID2">
		<summary>
			<para>Gets the type associated with the specified program 
      identifier (progID) from the specified server, returning null if an error is
      encountered while loading the type.</para>
		</summary>
		<param name="progID">The progID of the type to get.</param>
		<param name="server">The server from which to load the type. If the server name is <see langword="null"/>, this method automatically reverts to the local machine.</param>
		<returns>
			<para>The type associated with the specified program identifier
      (progID), if <paramref name="progID"/> is a valid entry in the registry and a type is
      associated with it; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="prodID"/> is <see langword="null"/>.</exception>
		<remarks>
			<para>This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because
      they have been superceded by the concept of namespace.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting members that are not public. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example retrieves a type by passing a
      ProgID and server name. The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID
      or the server name is invalid.</para>
			<codelink SampleID="Type_GetTypeFromProgID3" SnippetID="1"/>
		</example>
		<seealso cref="System.Runtime.InteropServices.RegistrationServices.GetProgIdForType"/>
	</doc>
	<doc for="Type.GetTypeFromProgID3">
		<summary>
			<para>Gets the type associated with the specified program 
      identifier (progID) from the specified server, specifying whether to throw an
      exception if an error occurs while loading the type.</para>
		</summary>
		<param name="progID">The progID of the <see cref="System.Type"/> to get.</param>
		<param name="server">The server from which to load the type. If the server name is <see langword="null"/>, this method automatically reverts to the local machine.</param>
		<param name="throwOnError"><para><see langword="true"/> to throw any exception that occurs.</para>
			<para>-or-</para>
			<para><see langword="false"/> to ignore any exception that occurs.</para></param>
		<returns>
			<para>The <see cref="System.Type"/> associated with the specified program identifier (progID), if <paramref name="progID"/> is
   a valid entry in the registry and a type is associated with it; otherwise,
<see langword="null"/>. </para>
		</returns>
		<exception cref="System.ArgumentException"><paramref name="progID"/> is <see langword="null"/>.</exception>
		<exception cref="System.Runtime.InteropServices.COMException">The specified progID is not registered.</exception>
		<remarks>
			<para>This method is provided for COM support. Program IDs are not used in
      Microsoft .NET Framework because they have been superceded by the concept of namespace.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting members that are not public. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example retrieves a type by passing a ProgID and server name.
      The example then displays the ClassID related to the ProgID, specifying
      whether to throw an exception if the ProgID or the server name is
      invalid.</para>
			<codelink SampleID="Type_GetTypeFromProgID4" SnippetID="1"/>
		</example>
		<seealso cref="System.Runtime.InteropServices.RegistrationServices.GetProgIdForType"/>
		<seealso cref="System.TypeLoadException"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
	</doc>
	<doc for="Type.GetTypeFromCLSID">
		<overload>
			<para>Gets the type associated with the specified class identifier
      (CLSID).</para>
		</overload>
		<summary>
			<para>Gets the type associated with the specified class identifier
      (CLSID).</para>
		</summary>
		<param name="clsid">The CLSID of the type to get.</param>
		<returns>
			<para><see langword="System.__ComObject "/>regardless of
   whether the CLSID is valid.</para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example retrieves a GUID by passing the <paramref name="clsid"/> parameter to the constructor of the <see cref="System.Guid"/> structure, and then retrieves
   the type associated with the specified class identifier (CLSID).</para>
			<codelink SampleID="Type_GetTypeCLSID1" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Type.GetTypeFromCLSID1">
		<summary>
			<para>Gets the type associated with the specified class 
      identifier (CLSID), specifying whether to throw an exception if an error occurs
      while loading the type.</para>
		</summary>
		<param name="clsid">The CLSID of the type to get.</param>
		<param name="throwOnError"><para><see langword="true"/> to throw any exception that occurs.</para>
			<para>-or-</para>
			<para><see langword="false"/> to ignore any exception that occurs.</para></param>
		<returns>
			<para><see langword="System.__ComObject "/>regardless of whether the CLSID is valid.</para>
		</returns>
		<remarks>
			<para>Exceptions such as <see cref="System.OutOfMemoryException"/> will be thrown when specifying
<see langword="true"/> for <paramref name="throwOnError"/>, but it will not fail for 
   unregistered CLSIDs.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example retrieves the type associated with the CLSID from the local host, specifying whether to throw an exception if an error occurs while loading the type.</para>
			<codelink SampleID="Type_GetTypeCLSID2" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Type.GetTypeFromCLSID2">
		<summary>
			<para>Gets the type associated with the specified class identifier (CLSID) from the specified server.</para>
		</summary>
		<param name="clsid">The CLSID of the type to get.</param>
		<param name=" server">The server from which to load the type. If the server name is <see langword="null"/>, this method automatically reverts to the local machine.</param>
		<returns>
			<para><see langword="System.__ComObject "/>regardless of whether the CLSID is valid.</para>
		</returns>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example retrieves the type associated
      with the CLSID from the local host.</para>
			<codelink SampleID="Type_GetTypeCLSID2" SnippetID="2"/>
		</example>
	</doc>
	<doc for="Type.GetTypeFromCLSID3">
		<summary>
			<para>Gets the type associated with the specified class 
      identifier (CLSID) from the specified server, specifying whether to throw an
      exception if an error occurs while loading the type.</para>
		</summary>
		<param name="clsid">The CLSID of the type to get.</param>
		<param name="server">The server from which to load the type. If the server name is <see langword="null"/>, this method automatically reverts to the local machine.</param>
		<param name="throwOnError"><see langword="true"/> to throw any exception that occurs. <para>-or-</para><para><see langword="false"/> to ignore any exception that occurs.</para></param>
		<returns>
			<para><see langword="System.__ComObject "/>regardless of whether the CLSID is valid.</para>
		</returns>
		<remarks>
			<para>Exceptions such as <see cref="System.OutOfMemoryException"/> will be thrown when specifying
<see langword="true"/> for <paramref name="throwOnError"/>, but it will not fail for 
   unregistered CLSIDs.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example retrieves the type associated with
      the CLSID from the local host, specifying whether to throw an exception if an error occurs while loading the type.</para>
			<codelink SampleID="Type_GetTypeCLSID2" SnippetID="3"/>
		</example>
	</doc>
	<doc for="Type.GetTypeFromHandle">
		<summary>
			<para>Gets the type referenced by the specified type handle.</para>
		</summary>
		<param name="handle">The <see cref="System.RuntimeTypeHandle"/> object that refers to the type.</param>
		<returns>
			<para>The type referenced by the specified <see cref="System.RuntimeTypeHandle"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="handle"/> is <see langword="null"/>.</exception>
		<exception cref="System.Reflection.TargetInvocationException">A class initializer is invoked and throws an exception.</exception>
		<remarks>
			<para>The handles are valid only in the application domain in which they were obtained. </para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
   outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<codelink SampleID="Type_GetTypeFromHandle" SnippetID="1"/>
		</example>
		<seealso cref="System.RuntimeTypeHandle"/>
		<seealso cref="System.Type.TypeHandle"/>
		<seealso cref="System.Type.GetTypeHandle"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
	</doc>
	<doc for="Type.InvokeMember">
		<overload>
			<para>Invokes a specific member of the current <see cref="System.Type"/>
.</para>
		</overload>
		<summary>
			<para> When overridden in a derived class, invokes the specified member, using the specified binding constraints and
      matching the specified argument list, modifiers and culture.</para>
		</summary>
		<param name="name"><para>The <see cref="System.String"/> containing the name of the constructor, method, property, or field member to invoke.</para>
			<para>-or-</para>
			<para>An empty string ("") to invoke the default member.</para></param>
		<param name="invokeAttr">A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. The access can be one of the <see langword="BindingFlags"/> such as <see langword="Public"/>, <see langword="NonPublic"/>, <see langword="Private"/>, <see langword="InvokeMethod"/>, <see langword="GetField"/>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <see langword="BindingFlags.Public"/> | <see langword="BindingFlags.Instance"/> will apply.</param>
		<param name="binder"><para>A <see cref="System.Reflection.Binder"/> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
			<para>-or-</para>
			<para>
				<see langword="null"/>, to use the <see cref="System.Type.DefaultBinder"/>.</para></param>
		<param name="target">The <see cref="System.Object"/> on which to invoke the specified member.</param>
		<param name="args">An array containing the arguments to pass to the member to invoke.</param>
		<param name="modifiers"><para>An array of <see cref="System.Reflection.ParameterModifier"/> objects representing the attributes associated with the corresponding element in the <paramref name="args"/> array. A parameter's associated attributes are stored in the member's signature. The default binder does not process this parameter.</para></param>
		<param name="culture"><para>The <see cref="System.Globalization.CultureInfo"/> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</para>
			<para>-or-</para>
			<para>
				<see langword="null"/> to use the current thread's <see cref="System.Globalization.CultureInfo"/>.</para></param>
		<param name="namedParameters">An array containing the names of the parameters to which the values in the <paramref name="args"/> array are passed.</param>
		<returns>
			<para>An <see cref="System.Object"/> representing the return value of the invoked
   member.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="invokeAttr"/> contains <paramref name="CreateInstance"/> and <paramref name="typeName"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="args"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="modifiers"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="args"/> and <paramref name="modifiers"/> do not have the same length.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> is not a valid <see cref="System.Reflection.BindingFlags"/> attribute.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> contains <paramref name="CreateInstance"/> combined with <paramref name="InvokeMethod"/>, <paramref name="GetField"/>, <paramref name="SetField"/>, <paramref name="GetProperty"/>, or <paramref name="SetProperty"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> contains both <paramref name="GetField"/> and <paramref name="SetField"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> contains both <paramref name="GetProperty"/> and <paramref name="SetProperty"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> contains <paramref name="InvokeMethod"/> combined with <paramref name="SetField"/> or <paramref name="SetProperty"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> contains <paramref name="SetField"/> and <paramref name="args"/> has more than one element.</para>
			<para>-or-</para>
			<para>The named parameter array is larger than the argument array.</para>
			<para>-or-</para>
			<para>This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod"/>, <see langword="BindingFlags.GetProperty"/>, <see langword="BindingFlags.SetProperty"/>, <see langword="BindingFlags.PutDispProperty"/>, or <see langword="BindingFlags.PutRefDispProperty"/>.</para>
			<para>-or-</para>
			<para>One of the named parameter arrays contains a string that is <see langword="null"/>.</para></exception>
		<exception cref="System.MethodAccessException">The specified member is a class initializer.</exception>
		<exception cref="System.MissingFieldException">The field or property cannot be found.</exception>
		<exception cref="System.MissingMethodException">The method cannot be found.</exception>
		<exception cref="System.Reflection.TargetException">The specified member cannot be invoked on <paramref name="target"/>.</exception>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one method matches the binding criteria.</exception>
		<remarks>
			<para><see langword="InvokeMember "/>
calls a constructor member or a method member, gets or
sets a property member, gets or sets a data field member,
or gets or sets an element of an array member.</para>
			<para>Although the default binder does not process <see cref="System.Reflection.ParameterModifier"/> or <see cref="System.Globalization.CultureInfo"/> (the <paramref name="modifiers"/>
and <paramref name="culture"/> parameters), you can use the abstract <see cref="System.Reflection.Binder" qualify="true"/>
class to write a custom binder that does process <paramref name="modifiers"/> and
<paramref name="culture"/>. <see langword="ParameterModifier"/> is only used 
when calling through COM interop, and only parameters that are passed by
reference are handled.</para>
			<para>The <paramref name="args"/> array and the <paramref name="modifiers"/> array have the same
length. A parameter specified in the <paramref name="args"/> array can have the
following attributes, which are specified in the <paramref name="modifiers"/>
array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which
represent [In], [Out], [lcid], [retval], [optional], and a value specifying
whether the parameter has a default value. A parameter's associated attributes
are stored in the metadata and enhance interoperability.</para>
			<para>Each parameter in the <paramref name="namedParameters"/> array gets the value in the corresponding
element in the <paramref name="args"/> array. If the length of <paramref name="args"/> is
greater than the length of <paramref name="namedParameters"/>, the remaining argument values are passed
in order.</para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
members to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public members in
      the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      members (that is, private and protected members) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      members up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.IgnoreCase"/> to ignore the case of
   <paramref name="name"/>.</term>
				</item>
				<item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the members
      declared on the <see cref="System.Type"/>, not members that were simply inherited.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> invocation flags can be used to denote what
action to take with the member:</para>
			<list type="bullet"><item>
					<term>
						<see langword="CreateInstance"/> to invoke a constructor. <paramref name="name"/> is ignored. Not 
      valid with other invocation flags.</term>
				</item>
				<item>
					<term>
						<see langword="InvokeMethod"/> to invoke a method, but
      not a constructor or a type initializer. Not valid with
   <see langword="SetField"/> or <see langword="SetProperty"/>.</term>
				</item>
				<item>
					<term>
						<see langword="GetField"/> to get the value of a field.
      Not valid with <see langword="SetField"/>.</term>
				</item>
				<item>
					<term>
						<see langword="SetField"/> to set the value of a field.
      Not valid with <see langword="GetField"/>.</term>
				</item>
				<item>
					<term>
						<see langword="GetProperty"/> to get a property. Not
      valid with <see langword="SetProperty"/>.</term>
				</item>
				<item>
					<term>
						<see langword="SetProperty"/> to set a property. Not
      valid with <see langword="GetProperty"/>.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more
information.</para>
			<para>A method will be invoked if the following conditions are true:</para>
			<list type="bullet"><item>
					<term>
      
      The number of parameters in the method declaration equals the number of
      arguments in the <paramref name="args"/> array
      (unless default arguments are defined on the member).</term>
				</item>
				<item>
					<term>
      
      The type of each argument can be converted by the binder to the type of
      the parameter.</term>
				</item>
			</list>
The binder will find all of the matching methods. These methods are found based upon the type of binding
requested (<see cref="System.Reflection.BindingFlags"/> values <see langword="InvokeMethod"/>,
<see langword="GetProperty"/>, and so on). The set of methods is 
filtered by the name, number of arguments, and a set of search modifiers defined
in the binder.
<para> After the method is selected, it is invoked.
   Accessibility is checked at that point. The search may control which set of
   methods are searched based upon the accessibility attribute associated with the
   method. The <see cref="System.Reflection.Binder.BindToMethod" qualify="true"/> method of the <see cref="System.Reflection.Binder"/> class is
   responsible for selecting the method to be invoked. The default binder selects
   the most specific match.</para>
			<para><see langword="InvokeMember"/> can be used to invoke
methods with parameters that have default values. To bind to these methods,
Reflection requires <see cref="System.Reflection.BindingFlags.OptionalParamBinding" qualify="true"/> to be specified. For a parameter that has a
default value, you can either supply a different value, or supply <see cref="System.Reflection.Missing.Value" qualify="true"/>
to use the default value.</para>
			<para>For example, consider a method such as MyMethod(int x, float y = 2.0). To
   invoke this method with only the first argument as MyMethod(4), pass one of the
   above binding flags and pass two arguments, namely, 4 for the first argument and
<see langword="Missing.Value"/> for the second argument. Unless you use
<see langword="Missing.Value"/>, you may not omit optional parameters with the
<see langword="Invoke"/> method. If you must do so, use <see langword="InvokeMember"/> instead.</para>
			<para>Access restrictions are ignored for fully trusted code; that is, private
   constructors, methods, fields, and properties can be accessed and invoked
   through <see cref="System.Reflection"/> whenever the code is fully
   trusted.</para>
			<para>You can use <see langword="Type.InvokeMember"/> to set a
field to a particular value by specifying <see cref="System.Reflection.BindingFlags.SetField" qualify="true"/>. For example, if you want to
set a public instance field named F on class C, and F is a
<see langword="String"/>, you can use
code such as: </para>
			<c> 
   typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{"strings new value"}, null,
   null, null);</c>
			<para>If F is a <see langword="String[]"/>, you can use code such as:</para>
			<c> 
   typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{new String[]{"a","z","c","d"},
   null, null, null);</c>
			<para>which will initialize the field F to this new array. You
   can also use <see langword="Type.InvokeMember"/> to
   set a position in an array by supplying the index of the value and then
   the next value by using code such as the following:</para>
			<c> 
   typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{1, "b"}, null, null, null);</c>
			<para>This will change string "z" in the array that F holds to string "b". </para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting members that are not public. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/></permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to call unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/></permission>
		<seealso cref="System.String"/>
		<seealso cref="System.Reflection.Binder"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Reflection.ParameterModifier"/>
		<seealso cref="System.Reflection.ParameterAttributes"/>
		<seealso cref="System.Globalization.CultureInfo"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
	</doc>
	<doc for="Type.InvokeMember1">
		<summary>
			<para>Invokes the specified member, using the specified binding constraints
      and matching the specified argument list and culture.</para>
		</summary>
		<param name="name"><para>The <see cref="System.String"/> containing the name of the constructor, method, property, or field member to invoke.</para>
			<para>-or-</para>
			<para>An empty string ("") to invoke the default member.</para></param>
		<param name="invokeAttr">A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. The access can be one of the <see langword="BindingFlags"/> such as <see langword="Public"/>, <see langword="NonPublic"/>, <see langword="Private"/>, <see langword="InvokeMethod"/>, <see langword="GetField"/>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <see langword="BindingFlags.Public"/> | <see langword="BindingFlags.Instance"/> will apply.</param>
		<param name="binder"><para>A <see cref="System.Reflection.Binder"/> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
			<para>-or-</para>
			<para>
				<see langword="null"/>, to use the <see cref="System.Type.DefaultBinder"/>.</para></param>
		<param name="target">The <see cref="System.Object"/> on which to invoke the specified member.</param>
		<param name="args">An array containing the arguments to pass to the member to invoke.</param>
		<param name="culture"><para>The <see cref="System.Globalization.CultureInfo"/> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</para>
			<para>-or-</para>
			<para>
				<see langword="null"/> to use the current thread's <see cref="System.Globalization.CultureInfo"/>.</para></param>
		<returns>
			<para>An <see cref="System.Object"/> representing the return value of the invoked member.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="invokeAttr"/> contains <paramref name="CreateInstance"/> and <paramref name="typeName"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="args"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> is not a valid <see cref="System.Reflection.BindingFlags"/> attribute.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> contains <paramref name="CreateInstance"/> combined with <paramref name="InvokeMethod"/>, <paramref name="GetField"/>, <paramref name="SetField"/>, <paramref name="GetProperty"/>, or <paramref name="SetProperty"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> contains both <paramref name="GetField"/> and <paramref name="SetField"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> contains both <paramref name="GetProperty"/> and <paramref name="SetProperty"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> contains <paramref name="InvokeMethod"/> combined with <paramref name="SetField"/> or <paramref name="SetProperty"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> contains <paramref name="SetField"/> and <paramref name="args"/> has more than one element.</para>
			<para>-or-</para>
			<para>This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod"/>, <see langword="BindingFlags.GetProperty"/>, <see langword="BindingFlags.SetProperty"/>, <see langword="BindingFlags.PutDispProperty"/>, or <see langword="BindingFlags.PutRefDispProperty"/>.</para>
			<para>-or-</para>
			<para>One of the named parameter arrays contains a string that is <see langword="null"/>.</para></exception>
		<exception cref="System.MethodAccessException">The specified member is a class initializer.</exception>
		<exception cref="System.MissingFieldException">The field or property cannot be found.</exception>
		<exception cref="System.MissingMethodException">The method cannot be found.</exception>
		<exception cref="System.Reflection.TargetException">The specified member cannot be invoked on <paramref name="target"/>.</exception>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one method matches the binding criteria.</exception>
		<remarks>
			<para>Although the default binder does not process <see cref="System.Globalization.CultureInfo"/> (the <paramref name="culture"/> parameter), you
   can use the abstract <see cref="System.Reflection.Binder" qualify="true"/> class to write a custom binder that does
   process <paramref name="culture"/>
   . </para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter
flags can be used to define which members to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public members in
      the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      members (that is, private and protected members) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      members up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.IgnoreCase"/> to ignore the case of
   <paramref name="name"/>.</term>
				</item>
				<item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the members
      declared on the <see cref="System.Type"/>, not members that were simply inherited.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> invocation flags can be used to denote what
action to take with the member:</para>
			<list type="bullet"><item>
					<term>
						<see langword="CreateInstance"/> to invoke a constructor. <paramref name="name"/> is ignored. Not valid 
      with other invocation flags.</term>
				</item>
				<item>
					<term>
						<see langword="InvokeMethod"/> to invoke a method, but not a constructor or
      a type initializer. Not valid with <see langword="SetField"/> or
   <see langword="SetProperty"/>.</term>
				</item>
				<item>
					<term>
						<see langword="GetField"/> to get the value of a field. Not valid with
   <see langword="SetField"/>.</term>
				</item>
				<item>
					<term>
						<see langword="SetField"/> to set the value of a field. Not valid with
   <see langword="GetField"/>.</term>
				</item>
				<item>
					<term>
						<see langword="GetProperty"/> to get a property. Not valid with
   <see langword="SetProperty"/>.</term>
				</item>
				<item>
					<term>
						<see langword="SetProperty"/> to set a property. Not valid with
   <see langword="GetProperty"/>.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>A method will be invoked if the following conditions are true:</para>
			<list type="bullet"><item>
					<term>
      
      The number of parameters in the method declaration equals the number of
      arguments in the <paramref name="args"/> array
      (unless default arguments are defined on the member).</term>
				</item>
				<item>
					<term>
      
      The type of each arguments can be converted by the binder to the type of
      the parameter.</term>
				</item>
			</list>The binder will find all of the matching methods. These
methods are found based upon the type of binding requested (<see cref="System.Reflection.BindingFlags"/> values
<see langword="InvokeMethod"/>, <see langword="GetProperty"/>, and so on). The set of methods is
filtered by the name, number of arguments, and a set of search modifiers defined
in the binder.
<para> After the method is selected, it is invoked. Accessibility is checked at
   that point. The search may control which set of methods are searched based upon
   the accessibility attribute associated with the method. The <see cref="System.Reflection.Binder.BindToMethod" qualify="true"/> method of the <see cref="System.Reflection.Binder"/> class
   is responsible for selecting the method to be invoked. The default binder
   selects the most specific match.</para>
			<para>Access restrictions are ignored for fully trusted code;
   that is, private constructors, methods, fields, and properties can be accessed
   and invoked through Reflection whenever the code is fully trusted.</para>
			<para>You can use <see langword="Type.InvokeMember"/> to set a
field to a particular value by specifying <see cref="System.Reflection.BindingFlags.SetField" qualify="true"/>
. For example, if you want to set a
public instance field named F on class C, and F is
a <see langword="String"/> you can use
code such as:</para>
			<c> 
   typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{"strings new
   value"}, null);</c>
			<para>If F is a <see langword="String[]"/>, you can use code such as:</para>
			<c> 
   typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new
   Object{new String[]{"a","z","c","d"}, null);</c>
			<para>which will initialize the field F to this new array. You
   can also use <see langword="Type.InvokeMember"/>
   to set a position in an array by supplying the
   index of the value and then the next value by using code such as the
   following:</para>
			<c> 
   typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{1, "b"}, null);</c>
			<para>This will change string "z" in the array that F holds to
   string "b".</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting members that are not public. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/></permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to call unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/></permission>
		<seealso cref="System.String"/>
		<seealso cref="System.Reflection.Binder"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Reflection.ParameterModifier"/>
		<seealso cref="System.Reflection.ParameterAttributes"/>
		<seealso cref="System.Globalization.CultureInfo"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
	</doc>
	<doc for="Type.InvokeMember2">
		<summary>
			<para>Invokes the specified member, using the specified
      binding constraints and matching the specified argument list.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the constructor, method, property, or field member to invoke. <para>-or-</para><para>An empty string ("") to invoke the default member.</para></param>
		<param name="invokeAttr">A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. The access can be one of the <see langword="BindingFlags"/> such as <see langword="Public"/>, <see langword="NonPublic"/>, <see langword="Private"/>, <see langword="InvokeMethod"/>, <see langword="GetField"/>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <see langword="BindingFlags.Public"/> | <see langword="BindingFlags.Instance"/> will apply.</param>
		<param name="binder"><para>A <see cref="System.Reflection.Binder"/> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
			<para>-or-</para>
			<para>
				<see langword="null"/>, to use the <see cref="System.Type.DefaultBinder"/>.</para></param>
		<param name="target">The <see cref="System.Object"/> on which to invoke the specified member.</param>
		<param name="args">An array containing the arguments to pass to the member to invoke.</param>
		<returns>
			<para>An <see cref="System.Object"/> representing the return value of the invoked member.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="invokeAttr"/> contains <paramref name="CreateInstance"/> and <paramref name="typeName"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="args"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> is not a valid <see cref="System.Reflection.BindingFlags"/> attribute.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> contains <paramref name="CreateInstance"/> combined with <paramref name="InvokeMethod"/>, <paramref name="GetField"/>, <paramref name="SetField"/>, <paramref name="GetProperty"/>, or <paramref name="SetProperty"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> contains both <paramref name="GetField"/> and <paramref name="SetField"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> contains both<paramref name="GetProperty"/> and <paramref name="SetProperty"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> contains <paramref name="InvokeMethod"/> combined with <paramref name="SetField"/> or <paramref name="SetProperty"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="invokeAttr"/> contains <paramref name="SetField"/> and <paramref name="args"/> has more than one element.</para>
			<para>-or-</para>
			<para>This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod"/>, <see langword="BindingFlags.GetProperty"/>, <see langword="BindingFlags.SetProperty"/>, <see langword="BindingFlags.PutDispProperty"/>, or <see langword="BindingFlags.PutRefDispProperty"/>.</para>
			<para>-or-</para>
			<para>One of the named parameter arrays contains a string that is <see langword="null"/>.</para></exception>
		<exception cref="System.MethodAccessException">The specified member is a class initializer.</exception>
		<exception cref="System.MissingFieldException">The field or property cannot be found.</exception>
		<exception cref="System.MissingMethodException">The method cannot be found.</exception>
		<exception cref="System.Reflection.TargetException">The specified member cannot be invoked on <paramref name="target"/>.</exception>
		<exception cref="System.Reflection.AmbiguousMatchException">More than one method matches the binding criteria.</exception>
		<remarks>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
   members to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public members in
      the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      members (that is, private and protected members) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      members up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.IgnoreCase"/> to ignore the case of
   <paramref name="name"/>.</term>
				</item>
				<item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the members
      declared on the <see cref="System.Type"/>, not members that were simply inherited.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> invocation flags can be used to denote what
action to take with the member:</para>
			<list type="bullet"><item>
					<term>
						<see langword="CreateInstance"/> to invoke a constructor. <paramref name="name"/> is ignored. Not valid 
      with other invocation flags.</term>
				</item>
				<item>
					<term>
						<see langword="InvokeMethod"/> to invoke a method, but not a constructor or
      a type initializer. Not valid with <see langword="SetField"/> or
   <see langword="SetProperty"/>.</term>
				</item>
				<item>
					<term>
						<see langword="GetField"/> to get the value of a field. Not valid with
   <see langword="SetField"/>.</term>
				</item>
				<item>
					<term>
						<see langword="SetField"/> to set the value of a field. Not valid with
   <see langword="GetField"/>.</term>
				</item>
				<item>
					<term>
						<see langword="GetProperty"/> to get a property. Not valid with
   <see langword="SetProperty"/>.</term>
				</item>
				<item>
					<term>
						<see langword="SetProperty"/> to set a property. Not valid with
   <see langword="GetProperty"/>.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>A method will be invoked if the following conditions are true:</para>
			<list type="bullet"><item>
					<term>
      
      The number of parameters in the method declaration equals the number of
      arguments in the <paramref name="args"/> array
      (unless default arguments are defined on the member), and</term>
				</item>
				<item>
					<term>
      
      The type of each arguments can be converted by the binder to the type of the parameter.</term>
				</item>
			</list>The binder will find all of the
matching methods. These methods are found based upon the type of binding
requested (<see cref="System.Reflection.BindingFlags"/> values <see langword="InvokeMethod"/>,
<see langword="GetProperty"/>, and so on). The set of methods is
filtered by the name, number of arguments, and a set of search modifiers defined
in the binder.
<para> After the method is selected, it is invoked. Accessibility is checked at
   that point. The search may control which set of methods are searched based upon
   the accessibility attribute associated with the method. The <see cref="System.Reflection.Binder.BindToMethod" qualify="true"/> method of the <see cref="System.Reflection.Binder"/> class
   is responsible for selecting the method to be invoked. The default binder
   selects the most specific match.</para>
			<para>Access restrictions are ignored for fully trusted code; that is, private
   constructors, methods, fields, and properties can be accessed and invoked
   through <see cref="System.Reflection"/> whenever the code is fully trusted.</para>
			<para>You can use <see langword="Type.InvokeMember"/> to set a
field to a particular value by specifying <see cref="System.Reflection.BindingFlags.SetField" qualify="true"/> . For example, if you want to
set a public instance field named F on class C, and F is a
<see langword="String"/>, you can use 
code such
as:</para>
			<c>
   typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{"strings
   new value"});</c>
			<para> If F is a <see langword="String[]"/>, you can use code such as:</para>
			<c>
   typeof(C).InvokeMember("F", BindingFlags.SetField, null, C,
   new Object{new String[]{"a","z","c","d"});</c>
			<para>which will initialize the field F to this new array.
   You can also use <see langword="Type.InvokeMember"/> to set
   a position in an array by supplying the
   index of the value and then the next value by using code such as the
   following:</para>
			<c>
   typeof(C).InvokeMember("F", BindingFlags.SetField, null, C, new Object{1, "b"});</c>
			<para> This will change string "z" in the array that F holds to
   string "b".</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting members that are not public. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/></permission>
		<permission cref="System.Security.Permissions.SecurityPermission">to call unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/></permission>
		<example>
			<para>The following example uses <see langword="InvokeMember"/> to access members of 
   a type.</para>
			<codelink SampleID="InvokeMem" SnippetID="1"/>
		</example>
		<seealso cref="System.String"/>
		<seealso cref="System.Reflection.Binder"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Reflection.ParameterModifier"/>
		<seealso cref="System.Reflection.ParameterAttributes"/>
		<seealso cref="System.Globalization.CultureInfo"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
	</doc>
	<doc for="Type.IsSubclassOf">
		<summary>
			<para>Determines whether the current <see cref="System.Type"/> derives from the
   specified <see langword="Type"/> .</para>
		</summary>
		<param name="c">The <see langword="Type"/> to compare with the current <see langword="Type"/>.</param>
		<returns>
			<para><see langword="true"/> if the <see langword="Type"/>
represented by the <paramref name="c"/> parameter and the current <see langword="Type"/>
represent classes, and the class represented by the current
<see langword="Type"/> derives from the class represented by <paramref name="c"/>; 
otherwise, <see langword="false"/>. This method also returns
<see langword="false"/> if <paramref name="c"/> and the current <see langword="Type"/> 
represent the same class.</para>
		</returns>
		<exception cref="System.ArgumentNullException">The <paramref name="c"/> parameter is <see langword="null"/>.</exception>
		<remarks>
			<para>This method can be overridden by a derived class.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example demonstrates the use of the
   <see langword="IsSubclassOf"/> method.</para>
			<codelink SampleID="TestIsSubclassOf" SnippetID="1"/>
		</example>
		<seealso cref="System.Type.BaseType"/>
	</doc>
	<doc for="Type.GetConstructor">
		<overload>
			<para>Gets a specific constructor of the current <see cref="System.Type"/>.</para>
		</overload>
		<summary>
			<para>Searches for a constructor whose parameters match the specified argument
      types and modifiers, using the specified binding constraints and the specified calling convention.</para>
		</summary>
		<param name="bindingAttr"><para> A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<param name="binder"><para>A <see cref="System.Reflection.Binder"/> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
			<para>-or-</para>
			<para>
				<see langword="null"/>, to use the <see cref="System.Type.DefaultBinder"/>.</para></param>
		<param name="callConvention">The <see cref="System.Reflection.CallingConventions"/> object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the constructor to get.</para>
			<para>-or-</para>
			<para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</para></param>
		<param name="modifiers">An array of <see cref="System.Reflection.ParameterModifier"/> objects representing the attributes associated with the corresponding element in the <paramref name="types"/> array. The default binder does not process this parameter.</param>
		<returns>
			<para>A <see cref="System.Reflection.ConstructorInfo"/> object representing the constructor that
   matches the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="types"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>One of the elements in <paramref name="types"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="types"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="modifiers"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> and <paramref name="modifiers"/> do not have the same length.</para></exception>
		<remarks>
			<para>Although the default binder does not
      process <see cref="System.Reflection.ParameterModifier"/> (the <paramref name="modifiers"/> parameter), you can
      use the abstract <see cref="System.Reflection.Binder" qualify="true"/> class to write a custom binder that does
      process <paramref name="modifiers"/>. <see langword="ParameterModifier"/>
      is only used when calling through
      COM interop, and only parameters that are passed by reference are
      handled.</para>
			<para>The <paramref name="types"/> array and the <paramref name="modifiers"/>
array have the same length. A parameter specified in the <paramref name="types"/>
array can have the following attributes, which are specified in the
<paramref name="modifiers"/> 
array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault, which
represent [In], [Out], [lcid], [retval], [optional], and a value specifying
whether the parameter has a default value. A parameter's associated attributes
are stored in the metadata and enhance interoperability.</para>
			<para>If an exact match does not exist, the <paramref name="binder"/> will attempt to coerce
the parameter types specified in the <paramref name="types"/> array in order to select a
match. If the <paramref name="binder"/> is unable to select a match, then
<see langword="null"/> is returned.</para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
constructors to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public
      constructors in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      constructors (that is, private and protected constructors) in the search.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para><see cref="System.Type.GetConstructor"/> cannot be used to obtain a class initializer. Class
initializers are available through <see cref="System.Type.GetMember"/>, <see cref="System.Type.GetMembers"/>, <see cref="System.Type.FindMembers"/>,
<see cref="System.Type.GetConstructors"/>, and <see cref="System.Type.TypeInitializer"/>
. </para>
			<para>If the requested constructor is non-public and the caller
   does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public methods
   outside the current assembly, this method returns <see langword="null"/>
   .</para>
			<para>The following table shows what members of a base class are returned by the
<see langword="Get"/> methods when reflecting on a 
   type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always
         hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
         inheritance is the same as that of the methods that implement the
         property. Reflection treats properties as hide-by-name-and-signature. See
         note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual)
         can be hide-by-name or hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
         inheritance is the same as that of the methods that implement the
         property. Reflection treats properties as hide-by-name-and-signature. See
         note 2 below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
      
      Hide-by-name-and-signature considers all of the parts
      of the signature, including custom modifiers, return types, parameter types,
      sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
      
      For reflection, properties and events are
      hide-by-name-and-signature. If you have a property with both a get and a set
      accessor in the base class, but the derived class has only a get accessor, the
      derived class property hides the base class property, and you will not be able
      to access the setter on the base class.</term>
				</item>
				<item>
					<term>
      
      Custom attributes are not part of the common type system.</term>
				</item>
			</list>
			<note type="note">
   You cannot omit parameters
   when looking up constructors and methods. You can only omit parameters when
   invoking.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public methods. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example obtains the type of <see langword="MyClass1"/>, gets the
<see cref="System.Reflection.ConstructorInfo"/> object that matches the specified binding 
   flags, and displays the constructor
   signature.</para>
			<codelink SampleID="Type_GetConstructor3" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.ConstructorInfo"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Reflection.Binder"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Reflection.CallingConventions"/>
		<seealso cref="System.Reflection.ParameterModifier"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetConstructorImpl"/>
		<seealso cref="System.Type.GetConstructors"/>
	</doc>
	<doc for="Type.GetConstructor1">
		<summary>
			<para>Searches for a constructor whose parameters match the specified argument types and modifiers,
      using the specified binding constraints.</para>
		</summary>
		<param name="bindingAttr"><para> A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<param name="binder"><para>A <see cref="System.Reflection.Binder"/> object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</para>
			<para>-or-</para>
			<para>
				<see langword="null"/>, to use the <see cref="System.Type.DefaultBinder"/>.</para></param>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the constructor to get.</para>
			<para>-or-</para>
			<para>An empty array of the type <see cref="System.Type"/> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</para>
			<para>-or-</para>
			<para>
				<see cref="System.Type.EmptyTypes"/>.</para></param>
		<param name="modifiers">An array of <see cref="System.Reflection.ParameterModifier"/> objects representing the attributes associated with the corresponding element in the parameter type array. The default binder does not process this parameter.</param>
		<returns>
			<para>A <see cref="System.Reflection.ConstructorInfo"/> object representing the constructor that
   matches the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="types"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>One of the elements in <paramref name="types"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="types"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="modifiers"/> is multidimensional.</para>
			<para>-or-</para>
			<para>
				<paramref name="types"/> and <paramref name="modifiers"/> do not have the same length.</para></exception>
		<remarks>
			<para>The <paramref name="types"/> array and the <paramref name="modifiers"/> array
   have the same length. A parameter specified in the <paramref name="types"/> array can have
   the following attributes, which are specified in the <paramref name="modifiers"/>
   array: pdIn, pdOut, pdLcid, pdRetval, pdOptional, and pdHasDefault,
   which represent [In], [Out], [lcid], [retval], [optional], and a value specifying
   whether the parameter has a default value. A parameter's associated
   attributes are stored in the metadata
   and enhance interoperability.</para>
			<para>If an exact match does not exist, the <paramref name="binder"/> will attempt to coerce
the parameter types specified in the <paramref name="types"/> array in order to select a
match. If the <paramref name="binder"/> is unable to select a match, then
<see langword="null"/> is returned.</para>
			<para>If the requested constructor is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public methods
outside the current assembly, this method returns <see langword="null"/>.</para>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
constructors to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public
      constructors in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      constructors (that is, private and protected constructors) in the search.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<see cref="System.Type.GetConstructor"/> cannot be used to obtain a class initializer. Class
initializers are available through <see cref="System.Type.GetMember"/>, <see cref="System.Type.GetMembers"/>, <see cref="System.Type.FindMembers"/>,
<see cref="System.Type.GetConstructors"/>, and <see cref="System.Type.TypeInitializer"/>. 
<note type="note">
   You cannot omit
   parameters when looking up constructors and methods. You can only omit parameters when
   invoking.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public methods. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para> The following program obtains the type of
   <see langword="MyClass1"/> class, gets the <see cref="System.Reflection.ConstructorInfo"/>
   object matching
   the specified binding flags, and displays the signature of the constructor.</para>
			<codelink SampleID="Type_GetConstructor2" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.ConstructorInfo"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Reflection.Binder"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Reflection.ParameterModifier"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetConstructorImpl"/>
		<seealso cref="System.Type.GetConstructors"/>
	</doc>
	<doc for="Type.GetConstructor2">
		<summary>
			<para>Searches for a public instance constructor whose parameters match the types in the specified array.</para>
		</summary>
		<param name="types"><para>An array of <see cref="System.Type"/> objects representing the number, order, and type of the parameters for the constructor to get.</para>
			<para>-or-</para>
			<para>An empty array of the type <see cref="System.Type"/> to get a constructor that takes no parameters.</para>
			<para>-or-</para>
			<para>
				<see cref="System.Type.EmptyTypes"/>.</para></param>
		<returns>
			<para>A <see cref="System.Reflection.ConstructorInfo"/> object representing the public instance constructor whose
   parameters match the types in the parameter type array, if found; otherwise,
<see langword="null"/>. </para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="types"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>One of the elements in <paramref name="types"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException"><para>
				<paramref name="types"/> is multidimensional.</para></exception>
		<remarks>
			<para><see cref="System.Type.GetConstructor"/> looks for
   public instance constructors and cannot be used to obtain a class initializer. Class initializers are available through <see cref="System.Type.GetMember"/>, <see cref="System.Type.GetMembers"/>,
<see cref="System.Type.FindMembers"/> , <see cref="System.Type.GetConstructors"/>, and <see cref="System.Type.TypeInitializer"/>.</para>
			<para> If
   the requested constructor is non-public, this method returns <see langword="null"/>.</para>
			<note type="note">
   You cannot omit parameters when looking
   up constructors and methods. You can only omit parameters when invoking.
</note>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example obtains the type of <see langword="MyClass"/>, gets
   the <see cref="System.Reflection.ConstructorInfo"/> object, and displays the constructor
   signature.</para>
			<codelink SampleID="Type_GetConstructor" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.ConstructorInfo"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetConstructorImpl"/>
		<seealso cref="System.Type.GetConstructors"/>
	</doc>
	<doc for="Type.GetField">
		<overload>
			<para>Gets a specific field of the current <see cref="System.Type"/>.</para>
		</overload>
		<summary>
			<para> Searches for the specified field, using the specified binding constraints.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of the data field to get.</param>
		<param name="bindingAttr"><para>A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<returns>
			<para>A <see cref="System.Reflection.FieldInfo"/> object representing the field that matches
   the specified requirements, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>. </exception>
		<remarks>
			<para>The following table shows what members of a base class are returned by the
   <see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always
            hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual)
            can be hide-by-name or hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
         Hide-by-name-and-signature considers all of the parts
         of the signature, including custom modifiers, return types, parameter types,
         sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
         For reflection, properties and events are
         hide-by-name-and-signature. If you have a property with both a get and a set
         accessor in the base class, but the derived class has only a get accessor, the
         derived class property hides the base class property, and you will not be able
         to access the setter on the base class.</term>
				</item>
				<item>
					<term>
         Custom attributes are not part of the common type system.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
fields to include in the search:</para>
			<list type="bullet"><item>
					<term>
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      Specify <see langword="BindingFlags.Public"/> to include public fields in
      the search.</term>
				</item>
				<item>
					<term>
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      fields (that is, private and protected fields) in the search.</term>
				</item>
				<item>
					<term>
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      members up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.IgnoreCase"/> to ignore the case of
   <paramref name="name"/>.</term>
				</item>
				<item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the fields
      declared on the <see cref="System.Type"/>, not fields that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example gets the <see langword="Type"/> object for the specified
   class, obtains the <see cref="System.Reflection.FieldInfo"/> object for the field that matches the
   specified binding flags, and displays the value of the field.</para>
			<codelink SampleID="Type_GetField" SnippetID="2"/>
		</example>
		<seealso cref="System.Reflection.FieldInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetFields"/>
	</doc>
	<doc for="Type.GetFields">
		<overload>
			<para>Gets the fields of the current <see cref="System.Type"/>.</para>
		</overload>
		<summary>
			<para>Returns all the public fields of the current <see cref="System.Type"/>.</para>
		</summary>
		<returns>
			<para>An array of <see cref="System.Reflection.FieldInfo"/> objects representing all the public fields
   defined for the current <see cref="System.Type"/>.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Reflection.FieldInfo"/>, if no public fields are defined for the
current <see cref="System.Type"/>.</para>
		</returns>
		<remarks>
			<para>The following table shows what members of a base class are returned by the
   <see langword="Get"/> methods when reflecting on a type.</para>
			<list type="table">
				<listheader>
					<term>Member Type</term>
					<description>Static</description>
					<description>Non-Static</description>
				</listheader>
				<item>
					<term> Constructor</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Field</term>
					<description>No</description>
					<description>Yes. A field is always
            hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Event</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
				<item>
					<term> Method</term>
					<description>No</description>
					<description>Yes. A method (both virtual and non-virtual)
            can be hide-by-name or hide-by-name-and-signature.</description>
				</item>
				<item>
					<term> Nested Type</term>
					<description>No</description>
					<description>No</description>
				</item>
				<item>
					<term> Property</term>
					<description>Not applicable</description>
					<description>The common type system rule is that the
            inheritance is the same as that of the methods that implement the
            property. Reflection treats properties as hide-by-name-and-signature. See
            note 2 below.</description>
				</item>
			</list>
			<list type="number"><item>
					<term>
         
         Hide-by-name-and-signature considers all of the parts
         of the signature, including custom modifiers, return types, parameter types,
         sentinels, and unmanaged calling conventions. This is a binary comparison.</term>
				</item>
				<item>
					<term>
         
         For reflection, properties and events are
         hide-by-name-and-signature. If you have a property with both a get and a set
         accessor in the base class, but the derived class has only a get accessor, the
         derived class property hides the base class property, and you will not be able
         to access the setter on the base class.</term>
				</item>
				<item>
					<term>
         
         Custom attributes are not part of the common type system.</term>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<example>
			<para>The following example shows a use of 
      the <see langword="GetFields()"/>method.</para>
			<codelink SampleID="FieldInfo_IsSpecialName" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.FieldInfo"/>
		<seealso cref="System.Type.GetField"/>
	</doc>
	<doc for="Type.GetFields1">
		<summary>
			<para>When overridden in a derived class,
      searches for the fields defined for the current <see cref="System.Type"/>, using the specified binding constraints.</para>
		</summary>
		<param name="bindingAttr"><para>A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<returns>
			<para>An array of <see cref="System.Reflection.FieldInfo"/> objects representing all fields defined for
   the current <see cref="System.Type"/> that match the specified binding constraints.</para>
			<para>-or-</para>
			<para>An empty array of type <see cref="System.Reflection.FieldInfo"/>, if no fields are defined for the current
<see cref="System.Type"/>, or if none of the defined fields match the binding constraints.</para>
		</returns>
		<remarks>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
   fields to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public fields in
      the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      fields (that is, private and protected fields) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      members up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the fields
      declared on the <see cref="System.Type"/>, not fields that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<para>The following example shows a use of 
      the <see langword="GetFields(BindingFlags)"/> method.</para>
			<codelink SampleID="Classic MethodBase.Attributes Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.FieldInfo"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetField"/>
	</doc>
	<doc for="Type.AssemblyQualifiedName">
		<summary>
			<para>Gets the fully qualified name of the <see cref="System.Type"/>,
   including the name of the assembly from which the <see cref="System.Type"/> was loaded.</para>
		</summary>
		<value>
			<para>The fully qualified name of the <see cref="System.Type"/>,
   including the name of the assembly from which the <see cref="System.Type"/> was loaded.</para>
		</value>
		<remarks>
			<para> All compilers that support the common language
      runtime will emit the simple name of a nested class, and reflection
      constructs a mangled name when queried, in accordance with the following conventions.</para>
			<list type="table">
				<listheader>
					<term>Delimiter</term>
					<description>Meaning</description>
				</listheader>
				<item>
					<term> Backslash (\)</term>
					<description>Escape character.</description>
				</item>
				<item>
					<term> Comma (,)</term>
					<description>Precedes the Assembly name.</description>
				</item>
				<item>
					<term> Plus sign (+)</term>
					<description>Precedes a nested class.</description>
				</item>
				<item>
					<term> Period (.)</term>
					<description>Denotes namespace identifiers. </description>
				</item>
			</list>
			<para>For example, the fully qualified name for a class might look like this: </para>
			<para>TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly </para>
			<para>If the namespace were TopNamespace.Sub+Namespace, then the string would
      have to precede the plus sign (+) with an escape character (\) to prevent
      it from being interpreted as a nesting separator. Reflection
      emits this string as follows:</para>
			<para>TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly</para>
			<para>A "++" becomes "\+\+", and a "\" becomes "\\".</para>
			<para>This qualified name can be persisted and later used to load the <see cref="System.Type"/>.
   To search for and load a <see cref="System.Type"/>, use <see cref="System.Type.GetType"/> either with the type name only or with
   the assembly qualified type name. <see cref="System.Type.GetType"/> with the type name only will look for
   the <see cref="System.Type"/>
   in the caller's assembly and then in the System assembly. <see cref="System.Type.GetType"/> with the
   assembly qualified type name will look for the <see cref="System.Type"/> in any assembly.</para>
			<para>Type names may include trailing characters that denote
   additional information about the type, such as whether the type is a reference
   type, a pointer type or an array type. To retrieve the type name without these
   trailing characters, use <c>t.GetElementType().ToString()</c>, where <paramref name="t"/>
is the type.</para>
			<para>Spaces are relevant in all type name components except the assembly
   name. In the assembly name, spaces before the ',' separator are relevant, but
   spaces after the ',' separator are ignored.</para>
		</remarks>
		<example>
			<para>The following example displays the assembly name associated with the class
      and the fully qualified name of the type.</para>
			<codelink SampleID="type_assembly" SnippetID="1"/>
		</example>
		<seealso cref="System.String"/>
		<seealso cref="System.Type.GetType"/>
		<seealso cref="System.Type.FullName"/>
		<seealso cref="System.Type.Namespace"/>
		<seealso topic="cpconSpecifyingFullyQualifiedTypeNames"/>
		<seealso cref="System.Reflection.AssemblyName"/>
	</doc>
	<doc for="Type">
		<summary>
			<para>Represents type declarations: class types, interface types, array
      types, value types, and enumeration types.</para>
		</summary>
		<threadsafe>
			<para>This type is safe for multithreaded operations.</para>
		</threadsafe>
		<remarks>
			<para><see langword="Type"/> is the root
   of the <see cref="System.Reflection"/> functionality and is the primary way to access
   metadata. Use the members of
<see langword="Type"/> to get information about a type declaration, such as the 
   constructors, methods, fields, properties, and events of a class, as well as the
   module and the assembly in which the class is deployed.</para>
			<para> Without <see cref="System.Security.Permissions.ReflectionPermission"/>, code can access
only the public members of loaded assemblies. This includes, but is not limited
to, unrestricted access to <see cref="System.Object.GetType" qualify="true"/>, access to public exported types
through <see cref="System.Type.GetType" qualify="true"/>, and access to <see cref="System.Type.GetTypeFromHandle"/>. Some properties of <see langword="Type"/>, such as
<see cref="System.Type.FullName"/> 
and <see cref="System.Type.Attributes"/>, are accessible without
<see langword="ReflectionPermission"/> 
.</para>
			<para><see langword="Type"/> is an abstract base class that allows multiple implementations.
The system will always provide the derived class RuntimeType. In
reflection, all classes beginning with the word Runtime are created
only once per object in the system and support comparison
operations.</para>
			<note type="inheritinfo">
   When you inherit from
<see langword="Type"/>, you must override the following 
   members: <see cref="System.Type.GUID"/>, <see topic="frlrfSystemTypeClassInvokeMemberTopic3" title="InvokeMember(String, BindingFlags, Binder, Object, Object, ParameterModifier, CultureInfo, String)"/>, <see cref="System.Type.Module"/>, <see cref="System.Type.Assembly"/>, <see cref="System.Type.TypeHandle"/>, <see cref="System.Type.FullName"/>, <see cref="System.Type.Namespace"/>, <see cref="System.Type.AssemblyQualifiedName"/>, <see cref="System.Type.BaseType"/>, <see cref="System.Type.GetConstructorImpl"/>, <see topic="frlrfSystemTypeClassGetConstructorsTopic2" title="GetConstructors(BindingFlags)"/>, <see cref="System.Type.GetMethodImpl"/>,
<see topic="frlrfSystemTypeClassGetMethodsTopic2" title="GetMethods(BindingFlags)"/>, <see topic="frlrfSystemTypeClassGetFieldTopic2" title="GetField(String, BindingFlags)"/>, <see topic="frlrfSystemTypeClassGetFieldsTopic2" title="GetFields(BindingFlags)"/>, <see topic="frlrfSystemTypeClassGetInterfaceTopic2" title="GetInterface(String, Boolean)"/>, <see cref="System.Type.GetInterfaces"/>, 
<see topic="frlrfSystemTypeClassGetEventTopic2" title="GetEvent(String, BindingFlags)"/>, <see topic="frlrfSystemTypeClassGetEventsTopic2" title="GetEvents(BindingFlags)"/>, <see cref="System.Type.GetPropertyImpl"/>, 
<see topic="frlrfSystemTypeClassGetPropertiesTopic2" title="GetProperties(BindingFlags)"/>, <see topic="frlrfSystemTypeClassGetNestedTypeTopic2" title="GetNestedType(String, BindingFlags)"/>, <see topic="frlrfSystemTypeClassGetNestedTypesTopic2" title="GetNestedTypes(BindingFlags)"/>, <see cref="System.Type.GetAttributeFlagsImpl"/>, <see cref="System.Type.IsArrayImpl"/>, <see cref="System.Type.IsByRefImpl"/>, 
<see cref="System.Type.IsPointerImpl"/>, <see cref="System.Type.IsPrimitiveImpl"/>, <see cref="System.Type.IsCOMObjectImpl"/>, 
<see cref="System.Type.GetElementType"/>, <see cref="System.Type.HasElementTypeImpl"/>, <see cref="System.Type.UnderlyingSystemType"/>, <see cref="System.Reflection.MemberInfo.Name" qualify="true"/>, <see cref="System.Reflection.MemberInfo.IsDefined" qualify="true"/>, <see topic="frlrfsystemreflectionmemberinfoclassgetcustomattributestopic1" title="System.Reflection.MemberInfo.GetCustomAttributes(Boolean)"/>, 
   and <see topic="frlrfsystemreflectionmemberinfoclassgetcustomattributestopic2" title="System.Reflection.MemberInfo.GetCustomAttributes(Type, Boolean)"/>.
</note>
			<para>A <see langword="Type"/> object that represents a type is unique; that is,
two <see langword="Type"/>
object references refer to the same object if and only if they represent the
same type. This allows for the synchronization of multiple static method
invocations and for comparison of <see langword="Type"/>
objects using reference equality.</para>
			<para>This class is thread safe; multiple threads can concurrently read from or
   write to an instance of this type. An instance of <see langword="Type "/>can
   represent any of the following types:</para>
			<list type="bullet"><item>
					<term>
      
      Classes</term>
				</item>
				<item>
					<term>
      
      Value types</term>
				</item>
				<item>
					<term>
      
      Arrays</term>
				</item>
				<item>
					<term>
      
      Interfaces</term>
				</item>
				<item>
					<term>
      
      Pointers</term>
				</item>
				<item>
					<term>
      
      Enumerations</term>
				</item>
			</list>
			<para>A reference to the <see langword="Type"/> object
associated with a type can be obtained in the following ways.</para>
			<list type="bullet"><item>
					<term>
      
      The <see cref="System.Object.GetType" qualify="true"/> method returns
      a <see langword="Type"/> object that represents the type of an
      instance.</term>
				</item>
				<item>
					<term>
      
      The static <see langword="GetType "/>methods return a <see langword="Type "/>object
      that represents a type specified by its fully qualified name.</term>
				</item>
				<item>
					<term>
      
      The <see cref="System.Reflection.Module.GetTypes" qualify="true"/>, <see cref="System.Reflection.Module.GetType" qualify="true"/>, and <see cref="System.Reflection.Module.FindTypes" qualify="true"/> methods return <see langword="Type "/>objects that represent the
      types defined in a module. The first can be used to obtain an array of
   <see langword="Type "/> objects for all of the public and private
      types defined in a module. (You can obtain an instance of <see langword="Module "/> through the <see cref="System.Reflection.Assembly.GetModule" qualify="true"/> or <see cref="System.Reflection.Assembly.GetModules" qualify="true"/> methods, or through the <see cref="System.Type.Module" qualify="true"/> property.)</term>
				</item>
				<item>
					<term>
      
      The <see cref="System.Type.FindInterfaces"/> method returns a filtered list of interface types
      supported by a type.</term>
				</item>
				<item>
					<term>
      
      The <see cref="System.Type.GetElementType"/> method returns a
   <see langword="Type "/>object that represents the element.</term>
				</item>
				<item>
					<term>
      
      The <see cref="System.Type.GetInterfaces"/> and
   <see cref="System.Type.GetInterface"/> methods return <see langword="Type "/>objects representing the interface types supported by a type.</term>
				</item>
				<item>
					<term>
      
      The <see cref="System.Type.GetTypeArray"/> method returns an
      array of <see langword="Type "/>objects representing the types specified by an
      arbitrary set of objects. The objects are specified with an array of type
   <see langword="Object"/> .</term>
				</item>
				<item>
					<term>
      
      The <see cref="System.Type.GetTypeFromProgID"/> and <see cref="System.Type.GetTypeFromCLSID"/> methods are
      provided for COM interoperability. They return a <see langword="Type "/>object
      that represents the type specified by a <see langword="ProgID"/> or <see langword="CLSID"/> .</term>
				</item>
				<item>
					<term>
      
      The <see cref="System.Type.GetTypeFromHandle"/> method is
      provided for interoperability. It returns a <see langword="Type "/>object that represents the type specified by a class handle.</term>
				</item>
				<item>
					<term>
      
      The C# or C++ <see langword="typeof"/>
      operator obtains the <see langword="Type "/>object for a type.</term>
				</item>
				<item>
					<term>The Visual Basic .NET <see langword="GetType"/> operator obtains the 
<see langword="Type"/> object for a type.</term>
				</item>
			</list>
			<note type="note">
				<see langword=" "/>A derived class can access protected members of the calling code's base
   classes. Also, access is allowed to assembly members of the calling code's
   assembly. As a rule, if you are allowed access in early bound code, then you are also
   allowed access in late bound code.
   
</note>
			<note type="note">
				<see langword=" "/>
Interfaces that extend other interfaces do not inherit the methods defined in the extended
interfaces.
</note>
		</remarks>
		<seealso cref="System.Object"/>
		<seealso cref="System.Reflection"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
	</doc>
	<doc for="Type.GetEvent1">
		<summary>
			<para>When overridden in a derived class, returns the <see cref="System.Reflection.EventInfo"/>
object representing the specified event, using the specified binding constraints.</para>
		</summary>
		<param name="name">The <see cref="System.String"/> containing the name of an event which is declared or inherited by the current <see cref="System.Type"/>.</param>
		<param name="bindingAttr"><para>A bitmask comprised of one or more <see cref="System.Reflection.BindingFlags"/> that specify how the search is conducted. </para>
			<para>-or-</para>
			<para>Zero, to return <see langword="null"/>.</para></param>
		<returns>
			<para>The <see cref="System.Reflection.EventInfo"/> object
   representing the specified event which is declared or inherited by the current
<see cref="System.Type"/>, if found; otherwise, <see langword="null"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="name"/> is <see langword="null"/>. </exception>
		<remarks>
			<para>The following <see cref="System.Reflection.BindingFlags"/> filter flags can be used to define which
   events to include in the search:</para>
			<list type="bullet"><item>
					<term>
      
      You must specify either <see langword="BindingFlags.Instance"/> or
   <see langword="BindingFlags.Static"/> in order to get a return.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.Public"/> to include public events in
      the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.NonPublic"/> to include non-public
      events (that is, private and protected events) in the search.</term>
				</item>
				<item>
					<term>
      
      Specify <see langword="BindingFlags.FlattenHierarchy"/> to include static
      members up the hierarchy.</term>
				</item>
			</list>
			<para>The following <see cref="System.Reflection.BindingFlags"/> modifier flags can be used to change how the
search works:</para>
			<list type="bullet"><item>
					<term>
						<see langword="BindingFlags.IgnoreCase"/> to ignore the case of <paramref name="name"/>.</term>
				</item>
				<item>
					<term>
						<see langword="BindingFlags.DeclaredOnly"/> to search only the events declared on the <see cref="System.Type"/>, not events
      that were simply inherited.</term>
				</item>
			</list>
			<para>See <see cref="System.Reflection.BindingFlags" qualify="true"/> for more information.</para>
			<para>If the requested type is non-public and the caller does not have <see cref="System.Security.Permissions.ReflectionPermission"/> to reflect non-public objects
outside the current assembly, this method returns <see langword="null"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.ReflectionPermission">to enhance security and performance when invoked late-bound through mechanisms such as <see cref="System.Type.InvokeMember" qualify="true"/>. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" qualify="true"/>.</permission>
		<permission cref="System.Security.Permissions.ReflectionPermission">for reflecting non-public objects. Associated enumeration: <see cref="System.Security.Permissions.ReflectionPermissionFlag.TypeInformation" qualify="true"/></permission>
		<example>
			<codelink SampleID="Type_GetEvent1" SnippetID="1"/>
		</example>
		<seealso cref="System.Reflection.EventInfo"/>
		<seealso cref="System.String"/>
		<seealso cref="System.Reflection.BindingFlags"/>
		<seealso cref="System.Type.DefaultBinder"/>
		<seealso cref="System.Security.Permissions.ReflectionPermission"/>
		<seealso cref="System.Type.GetEvents"/>
	</doc>
</docs>
