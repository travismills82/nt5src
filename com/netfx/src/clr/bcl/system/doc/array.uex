<docs>
    <doc for="Array">
        <summary>
            <para>Provides methods for creating, manipulating, searching, and sorting arrays,
 thereby serving as the base class for all arrays in the common language runtime.</para>
        </summary>
        <threadsafe>
            <para>Public static (<see langword="Shared" /> in Visual Basic) members of this type are safe for multithreaded operations.
   Instance members are not guaranteed to be thread-safe.</para>
            <para>This implementation does not provide a synchronized (thread-safe) wrapper for an <see cref="System.Array" />;
however, .NET Framework classes based on <see cref="System.Array" /> provide their own synchronized version of the collection using the <see cref="System.Array.SyncRoot" /> property.</para>
            <para>Enumerating through a collection is intrinsically not a thread-safe procedure.
   Even when a collection is synchronized, other threads could still modify the collection, which causes the enumerator to throw an exception.
   To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</para>
        </threadsafe>
        <remarks>
            <para>The <see cref="System.Array" /> class is the base class for language implementations that support arrays.
   However, only the system and compilers can derive explicitly from the <see cref="System.Array" /> class.
   Users should use the array constructs provided by the language.</para>
            <para>An element is a value in an <see cref="System.Array" />.
The length of an <see cref="System.Array" /> is the total number of elements it can contain.
The rank of an <see cref="System.Array" /> is the number of dimensions in the <see cref="System.Array" />.
The lower bound of a dimension of an <see cref="System.Array" /> is the starting index of that dimension of the <see cref="System.Array" />;
a multidimensional <see cref="System.Array" /> can have different bounds for each dimension.</para>
            <para><see cref="System.Type" /> objects provide information about array type declarations.
<see cref="System.Array" /> objects with the same array type share the same <see cref="System.Type" /> object.</para>
            <para><see cref="System.Type.IsArray" qualify="true" /> and <see cref="System.Type.GetElementType" qualify="true" /> might not return the expected results with <see cref="System.Array" />
because if an array is cast to the type <see cref="System.Array" />, the result is an object, not an array.
That is, <c>typeof(System.Array).IsArray</c> returns <see langword="false" />, and <c>typeof(System.Array).GetElementType</c> returns <see langword="null" />.</para>
            <para>Unlike most classes, <see cref="System.Array" /> provides the <see cref="System.Array.CreateInstance" /> method, instead of public constructors, to allow for late bound access.</para>
            <para> The <see cref="System.Array.Copy" qualify="true" /> method copies elements not only between arrays of the same type
but also between standard arrays of different types; it handles type casting automatically.</para>
            <para>Some methods, such as <see cref="System.Array.CreateInstance" />, <see cref="System.Array.Copy" />,
 <see cref="System.Array.CopyTo" />, <see cref="System.Array.GetValue" /> and <see cref="System.Array.SetValue" />, 
 provide overloads that accept 64-bit integers as parameters to accommodate large capacity arrays.
 <see cref="System.Array.LongLength" /> and <see cref="System.Array.GetLongLength" /> return 64-bit integers
 indicating the length of the array.</para>
        </remarks>
        <example>
            <para>The following code example shows how <see cref="System.Array.Copy" qualify="true" /> copies elements between an array of type integer and an array of type <see cref="System.Object" />.</para>
            <codelink SampleID="Classic Array Example" SnippetID="1" />
            <para>The following code example creates and initializes an <see cref="System.Array" /> and displays its properties and its elements.</para>
            <codelink SampleID="Classic Array Example" SnippetID="2" />
        </example>
        <seealso cref="System.Array.Copy" />
        <seealso cref="System.Object" />
        <seealso cref="System.Type" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.CreateInstance">
        <overload>
            <para>Initializes a new instance of the <see cref="System.Array" /> class.</para>
        </overload>
        <summary>
            <para>Creates a one-dimensional <see cref="System.Array" />
 of the specified <see cref="System.Type" /> and length,
 with zero-based indexing.</para>
        </summary>
        <param name="elementType">The <see cref="System.Type" /> of the <see cref="System.Array" /> to create.</param>
        <param name="length">The size of the <see cref="System.Array" /> to create.</param>
        <returns>
            <para>A new one-dimensional <see cref="System.Array" /> of the specified <see cref="System.Type" /> with the specified length, using zero-based indexing.</para>
        </returns>
        <exception cref="System.ArgumentNullException"><paramref name="elementType" /> is <see langword="null" />.</exception>
        <exception cref="System.ArgumentException"><paramref name="elementType" /> is not a valid <see cref="System.Type" />.</exception>
        <exception cref="System.NotSupportedException"><paramref name="elementType" /> is not supported.</exception>
        <exception cref="System.ArgumentOutOfRangeException"><paramref name="length" /> is less than zero.</exception>
        <remarks>
            <para>Unlike most classes, <see cref="System.Array" /> provides the <see cref="System.Array.CreateInstance" /> method, instead of public 
   constructors, to allow for late bound access.</para>
            <para>Reference-type elements are initialized to <see langword="null" />. Value-type elements are initialized to zero.</para>
        </remarks>
        <example>
            <para>The following code example shows how to create and
      initialize a one-dimensional <see cref="System.Array" />.</para>
            <codelink SampleID="Classic Array.CreateInstance Example" SnippetID="1" />
        </example>
    </doc><doc for="Array.CreateInstance1">
        <summary>
            <para>Creates a two-dimensional <see cref="System.Array" />
 of the specified <see cref="System.Type" /> and dimension lengths,
 with zero-based indexing.</para>
        </summary>
        <param name="elementType">The <see cref="System.Type" /> of the <see cref="System.Array" /> to create.</param>
        <param name="length1">The size of the first dimension of the <see cref="System.Array" /> to create.</param>
        <param name="length2">The size of the second dimension of the <see cref="System.Array" /> to create.</param>
        <returns>
            <para>A new two-dimensional <see cref="System.Array" /> of the specified <see cref="System.Type" /> with the specified length
   for each dimension, using zero-based indexing.</para>
        </returns>
        <exception cref="System.ArgumentNullException"><paramref name="elementType" /> is <see langword="null" />.</exception>
        <exception cref="System.ArgumentException"><paramref name="elementType" /> is not a valid <see cref="System.Type" />.</exception>
        <exception cref="System.NotSupportedException"><paramref name="elementType" /> is not supported.</exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="length1" /> is less than zero.</para><para> -or-</para>
            <para><paramref name="length2" /> is less than zero.</para></exception>
<remarks>
            <para>Unlike most classes, <see cref="System.Array" /> provides the <see cref="System.Array.CreateInstance" /> method, instead of public 
   constructors, to allow for late bound access.</para>
            <para>Reference-type elements are initialized to <see langword="null" />. Value-type elements are initialized to zero.</para>
        </remarks>
        <example>
            <para>The following code example shows how to create and
      initialize a two-dimensional <see cref="System.Array" />.</para>
            <codelink SampleID="Classic Array.CreateInstance1 Example" SnippetID="1" />
        </example>
    </doc><doc for="Array.CreateInstance2">
        <summary>
            <para>Creates a three-dimensional <see cref="System.Array" />
 of the specified <see cref="System.Type" /> and dimension lengths,
 with zero-based indexing.</para>
        </summary>
        <param name="elementType">The <see cref="System.Type" /> of the <see cref="System.Array" /> to create.</param>
        <param name="length1">The size of the first dimension of the <see cref="System.Array" /> to create.</param>
        <param name="length2">The size of the second dimension of the <see cref="System.Array" /> to create.</param>
        <param name="length3">The size of the third dimension of the <see cref="System.Array" /> to create.</param>
        <returns>
            <para>A new three-dimensional <see cref="System.Array" /> of the specified <see cref="System.Type" /> with the specified length
   for each dimension, using zero-based indexing.</para>
        </returns>
        <exception cref="System.ArgumentNullException"><paramref name="elementType" /> is <see langword="null" />.</exception>
        <exception cref="System.ArgumentException"><paramref name="elementType" /> is not a valid <see cref="System.Type" />.</exception>
        <exception cref="System.NotSupportedException"><paramref name="elementType" /> is not supported.</exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="length1" /> is less than zero.</para><para> -or-</para>
            <para><paramref name="length2" /> is less than zero.</para><para> -or-</para>
            <para><paramref name="length3" /> is less than zero.</para></exception>
<remarks>
            <para>Unlike most classes, <see cref="System.Array" /> provides the <see cref="System.Array.CreateInstance" /> method, instead of public 
   constructors, to allow for late bound access.</para>
            <para>Reference-type elements are initialized to <see langword="null" />. Value-type elements are initialized to zero.</para>
        </remarks>
        <example>
            <para>The following code example shows how to create and
      initialize a three-dimensional <see cref="System.Array" />.</para>
            <codelink SampleID="Classic Array.CreateInstance2 Example" SnippetID="1" />
        </example>
    </doc><doc for="Array.CreateInstance3">
        <summary>
            <para>Creates a multidimensional <see cref="System.Array" />
 of the specified <see cref="System.Type" /> and dimension lengths,
 with zero-based indexing.
 The dimension lengths are specified in an array of 32-bit integers.</para>
        </summary>
        <param name="elementType">The <see cref="System.Type" /> of the <see cref="System.Array" /> to create.</param>
        <param name="lengths">An array of 32-bit integers that represent the size of each dimension of the <see cref="System.Array" /> to create.</param>
        <returns>
            <para>A new multidimensional <see cref="System.Array" /> of the
   specified <see cref="System.Type" /> with the specified length for each dimension, using zero-based indexing.</para>
        </returns>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="elementType" /> is <see langword="null" />.</para><para> -or-</para>
            <para><paramref name="lengths" /> is <see langword="null" />.</para></exception>
        <exception cref="System.ArgumentException">
            <para><paramref name="elementType" /> is not a valid <see cref="System.Type" />.</para><para> -or-</para><para>The <paramref name="lengths" /> array contains less than one element.</para></exception>
        <exception cref="System.NotSupportedException"><paramref name="elementType" /> is not supported.</exception>
<exception cref="System.ArgumentOutOfRangeException">Any value in <paramref name="lengths" /> is less than zero.</exception>
<remarks>
            <para>Unlike most classes, <see cref="System.Array" /> provides the <see cref="System.Array.CreateInstance" /> method, instead of public
   constructors, to allow for late bound access.</para>
            <para>The number of elements in the <paramref name="lengths" /> array must equal the number of dimensions in
the new <see cref="System.Array" />. Each element of the <paramref name="lengths" /> array must specify the
length of the corresponding dimension in the new <see cref="System.Array" />.</para>
            <para>Reference-type elements are initialized to <see langword="null" />. Value-type
elements are initialized to zero.</para>
        </remarks>
        <example>
            <para>The following code example shows how to create and initialize a
      multidimensional <see cref="System.Array" />.</para>
            <codelink SampleID="Classic Array.CreateInstance3 Example" SnippetID="1" />
        </example>
    </doc><doc for="Array.CreateInstance5">
        <summary>
            <para>Creates a multidimensional <see cref="System.Array" />
 of the specified <see cref="System.Type" /> and dimension lengths,
 with zero-based indexing.
 The dimension lengths are specified in an array of 64-bit integers.</para>
        </summary>
        <param name="elementType">The <see cref="System.Type" /> of the <see cref="System.Array" /> to create.</param>
        <param name="lengths">An array of 64-bit integers that represent the size of each dimension of the <see cref="System.Array" /> to create.</param>
        <returns>
            <para>A new multidimensional <see cref="System.Array" /> of the
   specified <see cref="System.Type" /> with the specified length for each dimension, using zero-based indexing.</para>
        </returns>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="elementType" /> is <see langword="null" />.</para><para> -or-</para>
            <para><paramref name="lengths" /> is <see langword="null" />.</para></exception>
        <exception cref="System.ArgumentException">
            <para><paramref name="elementType" /> is not a valid <see cref="System.Type" />.</para><para> -or-</para><para>The <paramref name="lengths" /> array contains less than one element.</para></exception>
        <exception cref="System.NotSupportedException"><paramref name="elementType" /> is not supported.</exception>
<exception cref="System.ArgumentOutOfRangeException">Any value in <paramref name="lengths" /> is less than zero.</exception>
<remarks>
            <para>Unlike most classes, <see cref="System.Array" /> provides the <see cref="System.Array.CreateInstance" /> method, instead of public
   constructors, to allow for late bound access.</para>
            <para>The number of elements in the <paramref name="lengths" /> array must equal the number of dimensions in
the new <see cref="System.Array" />. Each element of the <paramref name="lengths" /> array must specify the
length of the corresponding dimension in the new <see cref="System.Array" />.</para>
            <para>Reference-type elements are initialized to <see langword="null" />. Value-type
elements are initialized to zero.</para>
        </remarks>
    </doc><doc for="Array.CreateInstance4">
        <summary>
            <para>Creates a multidimensional <see cref="System.Array" />
 of the specified <see cref="System.Type" /> and dimension lengths,
 with the specified lower bounds.</para>
        </summary>
        <param name="elementType">The <see cref="System.Type" /> of the <see cref="System.Array" /> to create.</param>
        <param name="lengths">A one-dimensional array that contains the size of each dimension of the <see cref="System.Array" /> to create.</param>
        <param name="lowerBounds">A one-dimensional array that contains the lower bound (starting index) of each dimension of the <see cref="System.Array" /> to create.</param>
        <returns>
            <para>A new multidimensional <see cref="System.Array" /> of the specified <see cref="System.Type" /> with
   the specified length and lower bound for each dimension.</para>
        </returns>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="elementType" /> is <see langword="null" />.</para><para>-or-</para>
            <para><paramref name="lengths" /> is <see langword="null" />.</para><para>-or-</para>
            <para><paramref name="lowerBounds" /> is <see langword="null" />. </para></exception>
        <exception cref="System.ArgumentException">
            <para><paramref name="elementType" /> is not a valid <see cref="System.Type" />.</para><para> -or-</para><para>The <paramref name="lengths" /> array contains less than one element.</para><para> -or-</para><para>The <paramref name="lengths" /> and <paramref name="lowerBounds" /> arrays do not contain the same number of elements.</para></exception>
        <exception cref="System.NotSupportedException"><paramref name="elementType" /> is not supported.</exception>
        <exception cref="System.ArgumentOutOfRangeException"><para>Any value in <paramref name="lengths" /> is less than zero.</para><para>-or-</para><para>Any value in <paramref name="lowerbounds" /> is very large, such that the sum of a dimension's lowerbound and length is greater than <see cref="System.Int32.MaxValue" qualify="true" />. </para></exception>
<remarks>
            <para>Unlike most classes, <see cref="System.Array" /> provides the <see cref="System.Array.CreateInstance" /> method, instead of public
   constructors, to allow for late bound access.</para>
            <para>The <paramref name="lengths" /> and <paramref name="lowerBounds" />
arrays must have the same number of elements. The number of elements in the
<paramref name="lengths" />
array must equal the number of dimensions in the new <see cref="System.Array" />.</para>
            <para>Each element of the <paramref name="lengths" />
array must specify the length of the corresponding dimension in the new <see cref="System.Array" />.</para>
            <para>Each element of the <paramref name="lowerBounds" /> array must specify the lower bound of the
corresponding dimension in the new <see cref="System.Array" />. Generally, the .NET Framework class library and many programming languages
do not handle nonzero lower bounds.</para>
            <para>Reference-type elements are initialized to <see langword="null" />. Value-type
elements are initialized to zero.</para>
        </remarks>
        <example>
            <para>The following code example shows how to create and
      initialize a multidimensional <see cref="System.Array" />
      with specified lower bounds.</para>
            <codelink SampleID="Classic Array.CreateInstance4 Example" SnippetID="1" />
        </example>
    </doc><doc for="Array.Copy">
        <overload>
            <para>Copies a section of one <see cref="System.Array" /> to another
<see cref="System.Array" /> and performs type casting and boxing as required.</para>
        </overload>
        <summary>
            <para> Copies a range of elements from an <see cref="System.Array" /> starting at the first element
 and pastes them into another <see cref="System.Array" /> starting at the first element.
 The length is specified as a 32-bit integer.</para>
        </summary>
        <param name="sourceArray">The <see cref="System.Array" /> that contains the data to copy.</param>
        <param name="destinationArray">The <see cref="System.Array" /> that receives the data.</param>
        <param name="length">A 32-bit integer that represents the number of elements to copy.</param>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="sourceArray" /> is <see langword="null" />.</para><para> -or-</para>
            <para><paramref name="destinationArray" /> is <see langword="null" />.</para></exception>
        <exception cref="System.RankException">
            <para><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</para></exception>
        <exception cref="System.ArrayTypeMismatchException">
            <para><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</para></exception>
        <exception cref="System.InvalidCastException"><para>At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</para></exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="length" /> is less than zero.</para></exception>
        <exception cref="System.ArgumentException">
            <para><paramref name="length" /> is greater than the number of elements in <paramref name="sourceArray" />.</para><para>-or-</para>
            <para><paramref name="length" /> is greater than the number of elements in <paramref name="destinationArray" />.</para></exception>
<remarks>
            <para>The <paramref name="sourceArray" /> and <paramref name="destinationArray" /> parameters must have the same number of dimensions. </para>
            <para>When copying between multidimensional arrays, the
   array behaves like a long one-dimensional array, where the rows (or
   columns) are conceptually laid end to end. For example, if an array has
   three rows (or columns) with four elements each, copying six
   elements from the beginning of the array would copy all four elements of
   the first row (or column) and the first two elements of the second row
   (or column).</para>
            <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> overlap,
this method behaves as if the original values of <paramref name="sourceArray" /> were preserved in a temporary location
before <paramref name="destinationArray" /> is overwritten.</para>
            <para lang="C++">This method is equivalent to the standard C/C++ function <see langword="memmove" />, not <see langword="memcpy" />.</para>
            <para>The arrays can be reference-type arrays or value-type arrays. Type downcasting is performed, as required.</para>
            <list type="bullet">
                <item>
                    <term>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.
 When copying from a value-type array to a reference-type array, each element is boxed and then copied.</term>
                </item>
                <item>
                    <term>When copying from a reference-type or value-type array to an <see cref="System.Object" /> array, an <see cref="System.Object" /> is created to hold each value or reference and then copied.
 When copying from an <see cref="System.Object" /> array to a reference-type or value-type array and the assignment is not possible, an <see cref="System.InvalidCastException" /> is thrown.</term>
                </item>
                <item>
                    <term>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are both reference-type arrays
      or are both arrays of type <see cref="System.Object" />, a shallow copy is performed.
      A shallow copy of an <see cref="System.Array" /> is a new <see cref="System.Array" /> containing references to the same elements as the original <see cref="System.Array" />.
      The elements themselves or anything referenced by the elements are not copied.
      In contrast, a deep copy of an <see cref="System.Array" /> copies the elements and everything directly or indirectly referenced by the elements.</term>
                </item>
            </list>
            <para>An <see cref="System.ArrayTypeMismatchException" /> is thrown if the arrays are of incompatible types.
Type compatibility is defined as follows:</para>
            <list type="bullet">
                <item>
                    <term>A type is compatible with itself.</term>
                </item>
                <item>
                    <term>A value type is compatible with <see cref="System.Object" /> and with an interface type implemented by that value type.
 A value type is considered connected to an interface only if it implements that interface directly. Disconnected types are not compatible.</term>
                </item>
                <item>
                    <term>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.
      A widening conversion never loses information, whereas a narrowing conversion can lose information.
      For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion,
      and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.
      For more information about conversions, see <see cref="System.Convert" />.</term>
                </item>
                <item>
                    <term>A nonintrinsic (user-defined) value type is compatible only with itself.</term>
                </item>
            </list>
            <para>If every element in <paramref name="sourceArray" /> requires a downcast
(for example, from a base class to a derived class or from an interface to an object)
and one or more elements cannot be cast to the corresponding type in <paramref name="destinationArray" />,
an <see cref="System.InvalidCastException" /> is thrown.</para>
            <para>If this method throws an exception while copying, the state of <paramref name="destinationArray" /> is undefined.</para>
        </remarks>
    </doc><doc for="Array.Copy1">
        <summary>
            <para> Copies a range of elements from an <see cref="System.Array" /> starting at the specified source index
   and pastes them to another <see cref="System.Array" /> starting at the specified destination index.
   The length and the indexes are specified as 32-bit integers.</para>
        </summary>
        <param name="sourceArray">The <see cref="System.Array" /> that contains the data to copy.</param>
        <param name="sourceIndex">A 32-bit integer that represents the index in the <paramref name="sourceArray" /> at which copying begins.</param>
        <param name="destinationArray">The <see cref="System.Array" /> that receives the data.</param>
        <param name="destinationIndex">A 32-bit integer that represents the index in the <paramref name="destinationArray" /> at which storing begins.</param>
        <param name="length">A 32-bit integer that represents the number of elements to copy.</param>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="sourceArray" /> is <see langword="null" />.</para><para>-or-</para>
            <para><paramref name="destinationArray" /> is <see langword="null" />.</para></exception>
        <exception cref="System.RankException">
            <para><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</para></exception>
        <exception cref="System.ArrayTypeMismatchException">
            <para><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</para></exception>
        <exception cref="System.InvalidCastException"><para>At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</para></exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="sourceIndex" /> is less than the lower bound of the first dimension of <paramref name="sourceArray" />.</para><para>-or-</para>
            <para><paramref name="destinationIndex" /> is less than the lower bound of the first dimension of <paramref name="destinationArray" />.</para><para>-or-</para>
            <para><paramref name="length" /> is less than zero.</para></exception>
        <exception cref="System.ArgumentException">
            <para><paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.</para><para>-or-</para>
            <para><paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</para></exception>
<remarks>
            <para>The <paramref name="sourceArray" /> and <paramref name="destinationArray" /> parameters must have the same number of dimensions. </para>
            <para>When copying between multidimensional arrays, the array behaves like a
   long one-dimensional array, where the rows (or columns) are conceptually laid
   end to end. For example, if an array has three rows (or columns) with four
   elements each, copying six elements from the beginning of the array would copy
   all four elements of the first row (or column) and the first two elements of the
   second row (or column). To start copying from the second element of the
   third row (or column), <paramref name="srcIndex" /> must be the upper bound of the first row
   (or column) plus the length of the second row (or column) plus
   two.</para>
            <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> overlap,
this method behaves as if the original values of <paramref name="sourceArray" /> were preserved in a temporary location
before <paramref name="destinationArray" /> is overwritten.</para>
            <para lang="C++">This method is equivalent to the standard C/C++ function <see langword="memmove" />, not <see langword="memcpy" />.</para>
            <para>The arrays can be reference-type arrays or value-type arrays. Type downcasting is performed, as required.</para>
            <list type="bullet">
                <item>
                    <term>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.
 When copying from a value-type array to a reference-type array, each element is boxed and then copied.</term>
                </item>
                <item>
                    <term>When copying from a reference-type or value-type array to an <see cref="System.Object" /> array, an <see cref="System.Object" /> is created to hold each value or reference and then copied.
 When copying from an <see cref="System.Object" /> array to a reference-type or value-type array and the assignment is not possible, an <see cref="System.InvalidCastException" /> is thrown.</term>
                </item>
                <item>
                    <term>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are both reference-type arrays
 or are both arrays of type <see cref="System.Object" />, a shallow copy is performed.
 A shallow copy of an <see cref="System.Array" /> is a new <see cref="System.Array" /> containing references to the same elements as the original <see cref="System.Array" />.
 The elements themselves or anything referenced by the elements are not copied.
 In contrast, a deep copy of an <see cref="System.Array" /> copies the elements and everything directly or indirectly referenced by the elements.</term>
                </item>
            </list>
            <para>An <see cref="System.ArrayTypeMismatchException" /> is thrown if the arrays are of incompatible types.
 Type compatibility is defined as follows:</para>
            <list type="bullet">
                <item>
                    <term>A type is compatible with itself.</term>
                </item>
                <item>
                    <term>A value type is compatible with <see cref="System.Object" /> and with an interface type implemented by that value type.
 A value type is considered connected to an interface only if it implements that interface directly. Disconnected types are not compatible.</term>
                </item>
                <item>
                    <term>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.
 A widening conversion never loses information, whereas a narrowing conversion can lose information.
 For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion,
 and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.
 For more information about conversions, see <see cref="System.Convert" />.</term>
                </item>
                <item>
                    <term>A nonintrinsic (user-defined) value type is compatible only with itself.</term>
                </item>
            </list>
            <para>If every element in <paramref name="sourceArray" /> requires a downcast (for example, from a base class to a derived class or from an interface to an object)
and one or more elements cannot be cast to the corresponding type in <paramref name="destinationArray" />, an <see cref="System.InvalidCastException" /> is thrown.</para>
            <para>If this method throws an exception while copying, the state of <paramref name="destinationArray" /> is undefined.</para>
        </remarks>
        <example>
            <para>The following code example shows how to copy from one <see cref="System.Array" /> of type <see cref="System.Object" /> to another <see cref="System.Array" /> of type integer. </para>
            <codelink SampleID="Classic Array.Copy1 Example" SnippetID="1" />
        </example>
    </doc><doc for="Array.Copy2">
        <summary>
            <para> Copies a range of elements from an <see cref="System.Array" /> starting at the first element
 and pastes them into another <see cref="System.Array" /> starting at the first element.
 The length is specified as a 64-bit integer.</para>
        </summary>
        <param name="sourceArray">The <see cref="System.Array" /> that contains the data to copy.</param>
        <param name="destinationArray">The <see cref="System.Array" /> that receives the data.</param>
        <param name="length">A 64-bit integer that represents the number of elements to copy.</param>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="sourceArray" /> is <see langword="null" />.</para><para> -or-</para>
            <para><paramref name="destinationArray" /> is <see langword="null" />.</para></exception>
        <exception cref="System.RankException">
            <para><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</para></exception>
        <exception cref="System.ArrayTypeMismatchException">
            <para><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</para></exception>
        <exception cref="System.InvalidCastException"><para>At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</para></exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="length" /> is less than zero.</para></exception>
        <exception cref="System.ArgumentException">
            <para><paramref name="length" /> is greater than the number of elements in <paramref name="sourceArray" />.</para><para>-or-</para>
            <para><paramref name="length" /> is greater than the number of elements in <paramref name="destinationArray" />.</para></exception>
<remarks>
            <para>The <paramref name="sourceArray" /> and <paramref name="destinationArray" /> parameters must have the same number of dimensions. </para>
            <para>When copying between multidimensional arrays, the
   array behaves like a long one-dimensional array, where the rows (or
   columns) are conceptually laid end to end. For example, if an array has
   three rows (or columns) with four elements each, copying six
   elements from the beginning of the array would copy all four elements of
   the first row (or column) and the first two elements of the second row
   (or column).</para>
            <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> overlap,
this method behaves as if the original values of <paramref name="sourceArray" /> were preserved in a temporary location
before <paramref name="destinationArray" /> is overwritten.</para>
            <para lang="C++">This method is equivalent to the standard C/C++ function <see langword="memmove" />, not <see langword="memcpy" />.</para>
            <para>The arrays can be reference-type arrays or value-type arrays. Type downcasting is performed, as required.</para>
            <list type="bullet">
                <item>
                    <term>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.
 When copying from a value-type array to a reference-type array, each element is boxed and then copied.</term>
                </item>
                <item>
                    <term>When copying from a reference-type or value-type array to an <see cref="System.Object" /> array, an <see cref="System.Object" /> is created to hold each value or reference and then copied.
 When copying from an <see cref="System.Object" /> array to a reference-type or value-type array and the assignment is not possible, an <see cref="System.InvalidCastException" /> is thrown.</term>
                </item>
                <item>
                    <term>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are both reference-type arrays
      or are both arrays of type <see cref="System.Object" />, a shallow copy is performed.
      A shallow copy of an <see cref="System.Array" /> is a new <see cref="System.Array" /> containing references to the same elements as the original <see cref="System.Array" />.
      The elements themselves or anything referenced by the elements are not copied.
      In contrast, a deep copy of an <see cref="System.Array" /> copies the elements and everything directly or indirectly referenced by the elements.</term>
                </item>
            </list>
            <para>An <see cref="System.ArrayTypeMismatchException" /> is thrown if the arrays are of incompatible types.
Type compatibility is defined as follows:</para>
            <list type="bullet">
                <item>
                    <term>A type is compatible with itself.</term>
                </item>
                <item>
                    <term>A value type is compatible with <see cref="System.Object" /> and with an interface type implemented by that value type.
 A value type is considered connected to an interface only if it implements that interface directly. Disconnected types are not compatible.</term>
                </item>
                <item>
                    <term>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.
      A widening conversion never loses information, whereas a narrowing conversion can lose information.
      For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion,
      and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.
      For more information about conversions, see <see cref="System.Convert" />.</term>
                </item>
                <item>
                    <term>A nonintrinsic (user-defined) value type is compatible only with itself.</term>
                </item>
            </list>
            <para>If every element in <paramref name="sourceArray" /> requires a downcast
(for example, from a base class to a derived class or from an interface to an object)
and one or more elements cannot be cast to the corresponding type in <paramref name="destinationArray" />,
an <see cref="System.InvalidCastException" /> is thrown.</para>
            <para>If this method throws an exception while copying, the state of <paramref name="destinationArray" /> is undefined.</para>
        </remarks>
    </doc><doc for="Array.Copy3">
        <summary>
            <para> Copies a range of elements from an <see cref="System.Array" /> starting at the specified source index
   and pastes them to another <see cref="System.Array" /> starting at the specified destination index.
   The length and the indexes are specified as 64-bit integers.</para>
        </summary>
        <param name="sourceArray">The <see cref="System.Array" /> that contains the data to copy.</param>
        <param name="sourceIndex">A 64-bit integer that represents the index in the <paramref name="sourceArray" /> at which copying begins.</param>
        <param name="destinationArray">The <see cref="System.Array" /> that receives the data.</param>
        <param name="destinationIndex">A 64-bit integer that represents the index in the <paramref name="destinationArray" /> at which storing begins.</param>
        <param name="length">A 64-bit integer that represents the number of elements to copy.</param>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="sourceArray" /> is <see langword="null" />.</para><para>-or-</para>
            <para><paramref name="destinationArray" /> is <see langword="null" />.</para></exception>
        <exception cref="System.RankException">
            <para><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</para></exception>
        <exception cref="System.ArrayTypeMismatchException">
            <para><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</para></exception>
        <exception cref="System.InvalidCastException"><para>At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</para></exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="sourceIndex" /> is less than the lower bound of the first dimension of <paramref name="sourceArray" />.</para><para>-or-</para>
            <para><paramref name="destinationIndex" /> is less than the lower bound of the first dimension of <paramref name="destinationArray" />.</para><para>-or-</para>
            <para><paramref name="length" /> is less than zero.</para></exception>
        <exception cref="System.ArgumentException">
            <para><paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.</para><para>-or-</para>
            <para><paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</para></exception>
<remarks>
            <para>The <paramref name="sourceArray" /> and <paramref name="destinationArray" /> parameters must have the same number of dimensions. </para>
            <para>When copying between multidimensional arrays, the array behaves like a
   long one-dimensional array, where the rows (or columns) are conceptually laid
   end to end. For example, if an array has three rows (or columns) with four
   elements each, copying six elements from the beginning of the array would copy
   all four elements of the first row (or column) and the first two elements of the
   second row (or column). To start copying from the second element of the
   third row (or column), <paramref name="srcIndex" /> must be the upper bound of the first row
   (or column) plus the length of the second row (or column) plus
   two.</para>
            <para>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> overlap,
this method behaves as if the original values of <paramref name="sourceArray" /> were preserved in a temporary location
before <paramref name="destinationArray" /> is overwritten.</para>
            <para lang="C++">This method is equivalent to the standard C/C++ function <see langword="memmove" />, not <see langword="memcpy" />.</para>
            <para>The arrays can be reference-type arrays or value-type arrays. Type downcasting is performed, as required.</para>
            <list type="bullet">
                <item>
                    <term>When copying from a reference-type array to a value-type array, each element is unboxed and then copied.
 When copying from a value-type array to a reference-type array, each element is boxed and then copied.</term>
                </item>
                <item>
                    <term>When copying from a reference-type or value-type array to an <see cref="System.Object" /> array, an <see cref="System.Object" /> is created to hold each value or reference and then copied.
 When copying from an <see cref="System.Object" /> array to a reference-type or value-type array and the assignment is not possible, an <see cref="System.InvalidCastException" /> is thrown.</term>
                </item>
                <item>
                    <term>If <paramref name="sourceArray" /> and <paramref name="destinationArray" /> are both reference-type arrays
 or are both arrays of type <see cref="System.Object" />, a shallow copy is performed.
 A shallow copy of an <see cref="System.Array" /> is a new <see cref="System.Array" /> containing references to the same elements as the original <see cref="System.Array" />.
 The elements themselves or anything referenced by the elements are not copied.
 In contrast, a deep copy of an <see cref="System.Array" /> copies the elements and everything directly or indirectly referenced by the elements.</term>
                </item>
            </list>
            <para>An <see cref="System.ArrayTypeMismatchException" /> is thrown if the arrays are of incompatible types.
 Type compatibility is defined as follows:</para>
            <list type="bullet">
                <item>
                    <term>A type is compatible with itself.</term>
                </item>
                <item>
                    <term>A value type is compatible with <see cref="System.Object" /> and with an interface type implemented by that value type.
 A value type is considered connected to an interface only if it implements that interface directly. Disconnected types are not compatible.</term>
                </item>
                <item>
                    <term>Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.
      A widening conversion never loses information, whereas a narrowing conversion can lose information.
      For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion,
      and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.
      For more information about conversions, see <see cref="System.Convert" />.</term>
                </item>
                <item>
                    <term>A nonintrinsic (user-defined) value type is compatible only with itself.</term>
                </item>
            </list>
            <para>If every element in <paramref name="sourceArray" /> requires a downcast (for example, from a base class to a derived class or from an interface to an object)
and one or more elements cannot be cast to the corresponding type in <paramref name="destinationArray" />, an <see cref="System.InvalidCastException" /> is thrown.</para>
            <para>If this method throws an exception while copying, the state of <paramref name="destinationArray" /> is undefined.</para>
        </remarks>
    </doc><doc for="Array.Clear">
        <summary>
            <para>Sets a range of elements in the <see cref="System.Array" />
 to zero, to <see langword="false" />, or to <see langword="null" />,
 depending on the element type.</para>
        </summary>
        <param name="array">The <see cref="System.Array" /> whose elements need to be cleared.</param>
        <param name="index">The starting index of the range of elements to clear.</param>
        <param name="length">The number of elements to clear.</param>
        <exception cref="System.ArgumentNullException"><paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</para><para> -or-</para>
            <para><paramref name="length" /> is less than zero.</para><para> -or-</para><para>The sum of <paramref name="index" /> and <paramref name="length" /> is greater than the size of the <see cref="System.Array" />.</para></exception>
<remarks>
            <para>Reference-type elements are set to <see langword="null" />.
 Boolean-type elements are set to <see langword="false" />.
 Other value-type elements are set to zero.</para>
            <para>This method only clears the values of the elements; it does not delete the elements themselves.
 An <see cref="System.Array" /> has a fixed size; therefore, elements cannot be added or removed.</para>
        </remarks>
        <seealso cref="P:System.Collections.ICollection.Count" qualify="true" />
    </doc><doc for="Array.GetValue">
        <overload>
            <para> Gets the value of the specified element in the current <see cref="System.Array" />.
 The indexes are specified as an array of 32-bit integers.</para>
        </overload>
        <summary>
            <para>Gets the value at the specified position in the multidimensional <see cref="System.Array" />.</para>
        </summary>
        <param name="indices">A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the <see cref="System.Array" /> element to get.</param>
        <returns>
            <para>The value at the specified position in the multidimensional <see cref="System.Array" />.</para>
        </returns>
        <exception cref="System.ArgumentNullException"><paramref name="indices" /> is <see langword="null" />.</exception>
<exception cref="System.ArgumentException">The number of dimensions in the current <see cref="System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</exception>
        <exception cref="System.IndexOutOfRangeException"><para>Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="System.Array" />.</para></exception>
        <remarks>
            <para>The number of elements in <paramref name="indices" /> must equal
   the number of dimensions in the <see cref="System.Array" />. All elements in the <paramref name="indices" />
   array must collectively specify the position of the desired element in the
   multidimensional <see cref="System.Array" />.</para>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" />
methods can determine whether any of the indexes is out of bounds.</para>
        </remarks>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.SetValue" />
    </doc><doc for="Array.GetValue1">
        <summary>
            <para>Gets the value at the specified position in the one-dimensional <see cref="System.Array" />.
 The index is specified as a 32-bit integer.</para>
        </summary>
        <param name="index">A 32-bit integer that represents the position of the <see cref="System.Array" /> element to get.</param>
        <returns>
            <para>The value at the specified position in the one-dimensional <see cref="System.Array" />.</para>
        </returns>
<exception cref="System.ArgumentException">The current <see cref="System.Array" /> does not have exactly one dimension.</exception>
        <exception cref="System.IndexOutOfRangeException">
            <para><paramref name="index" /> is outside the range of valid indexes for the current <see cref="System.Array" />.</para></exception>
<remarks>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" />
methods can determine whether the value of <paramref name="index" />
is out of bounds.</para>
        </remarks>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.SetValue" />
    </doc><doc for="Array.GetValue2">
        <summary>
            <para>Gets the value at the specified position in the two-dimensional <see cref="System.Array" />.
 The indexes are specified as 32-bit integers.</para>
        </summary>
        <param name="index1">A 32-bit integer that represents the first-dimension index of the <see cref="System.Array" /> element to get.</param>
        <param name="index2">A 32-bit integer that represents the second-dimension index of the <see cref="System.Array" /> element to get.</param>
        <returns>
            <para>The value at the specified position in the two-dimensional <see cref="System.Array" />.</para>
        </returns>
<exception cref="System.ArgumentException">The current <see cref="System.Array" /> does not have exactly two dimensions.</exception>
<exception cref="System.IndexOutOfRangeException">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="System.Array" />.</exception>
        <remarks>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" /> methods can determine
   whether any of the indexes is out of bounds.</para>
        </remarks>
        <example>
            <para>The following code example shows how to
      use <see cref="System.Array.GetValue" /> to get a specific value
      in the <see cref="System.Array" />.</para>
            <codelink SampleID="Classic Array.GetValue2 Example" SnippetID="1" />
        </example>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.SetValue" />
    </doc><doc for="Array.GetValue3">
        <summary>
            <para>Gets the value at the specified position in the three-dimensional <see cref="System.Array" />.
 The indexes are specified as 32-bit integers.</para>
        </summary>
        <param name="index1">A 32-bit integer that represents the first-dimension index of the <see cref="System.Array" /> element to get.</param>
        <param name="index2">A 32-bit integer that represents the second-dimension index of the <see cref="System.Array" /> element to get.</param>
        <param name="index3">A 32-bit integer that represents the third-dimension index of the <see cref="System.Array" /> element to get.</param>
        <returns>
            <para>The value at the specified position in the three-dimensional <see cref="System.Array" />.</para>
        </returns>
<exception cref="System.ArgumentException">The current <see cref="System.Array" /> does not have exactly three dimensions.</exception>
        <exception cref="System.IndexOutOfRangeException">
            <para><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="System.Array" />.</para></exception>
<remarks>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" /> methods can determine
   whether any of the indexes is out of bounds.</para>
        </remarks>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.SetValue" />
    </doc><doc for="Array.GetValue4">
        <summary>
            <para>Gets the value at the specified position in the one-dimensional <see cref="System.Array" />.
 The index is specified as a 64-bit integer.</para>
        </summary>
        <param name="index">A 64-bit integer that represents the position of the <see cref="System.Array" /> element to get.</param>
        <returns>
            <para>The value at the specified position in the one-dimensional <see cref="System.Array" />.</para>
        </returns>
<exception cref="System.ArgumentException">The current <see cref="System.Array" /> does not have exactly one dimension.</exception>
        <exception cref="System.IndexOutOfRangeException">
            <para><paramref name="index" /> is outside the range of valid indexes for the current <see cref="System.Array" />.</para></exception>
<remarks>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" />
methods can determine whether the value of <paramref name="index" />
is out of bounds.</para>
        </remarks>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.SetValue" />
    </doc><doc for="Array.GetValue5">
        <summary>
            <para>Gets the value at the specified position in the two-dimensional <see cref="System.Array" />.
 The indexes are specified as 64-bit integers.</para>
        </summary>
        <param name="index1">A 64-bit integer that represents the first-dimension index of the <see cref="System.Array" /> element to get.</param>
        <param name="index2">A 64-bit integer that represents the second-dimension index of the <see cref="System.Array" /> element to get.</param>
        <returns>
            <para>The value at the specified position in the two-dimensional <see cref="System.Array" />.</para>
        </returns>
<exception cref="System.ArgumentException">The current <see cref="System.Array" /> does not have exactly two dimensions.</exception>
<exception cref="System.IndexOutOfRangeException">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="System.Array" />.</exception>
        <remarks>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" /> methods can determine
   whether any of the indexes is out of bounds.</para>
        </remarks>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.SetValue" />
    </doc><doc for="Array.GetValue6">
        <summary>
            <para>Gets the value at the specified position in the three-dimensional <see cref="System.Array" />.
 The indexes are specified as 64-bit integers.</para>
        </summary>
        <param name="index1">A 64-bit integer that represents the first-dimension index of the <see cref="System.Array" /> element to get.</param>
        <param name="index2">A 64-bit integer that represents the second-dimension index of the <see cref="System.Array" /> element to get.</param>
        <param name="index3">A 64-bit integer that represents the third-dimension index of the <see cref="System.Array" /> element to get.</param>
        <returns>
            <para>The value at the specified position in the three-dimensional <see cref="System.Array" />.</para>
        </returns>
<exception cref="System.ArgumentException">The current <see cref="System.Array" /> does not have exactly three dimensions.</exception>
        <exception cref="System.IndexOutOfRangeException">
            <para><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="System.Array" />.</para></exception>
<remarks>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" /> methods can determine
   whether any of the indexes is out of bounds.</para>
        </remarks>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.SetValue" />
    </doc><doc for="Array.GetValue7">
        <summary>
            <para>Gets the value at the specified position in the multidimensional <see cref="System.Array" />.
 The indexes are specified as an array of 64-bit integers.</para>
        </summary>
        <param name="indices">A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the <see cref="System.Array" /> element to get.</param>
        <returns>
            <para>The value at the specified position in the multidimensional <see cref="System.Array" />.</para>
        </returns>
        <exception cref="System.ArgumentNullException"><paramref name="indices" /> is <see langword="null" />.</exception>
<exception cref="System.ArgumentException">The number of dimensions in the current <see cref="System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</exception>
        <exception cref="System.IndexOutOfRangeException"><para>Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="System.Array" />.</para></exception>
        <remarks>
            <para>The number of elements in <paramref name="indices" /> must equal
   the number of dimensions in the <see cref="System.Array" />. All elements in the <paramref name="indices" />
   array must collectively specify the position of the desired element in the
   multidimensional <see cref="System.Array" />.</para>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" />
methods can determine whether any of the indexes is out of bounds.</para>
        </remarks>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.SetValue" />
    </doc><doc for="Array.SetValue">
        <overload>
            <para>Sets the specified element in the current <see cref="System.Array" /> to the specified value.</para>
        </overload>
        <summary>
            <para>Sets a value to the element at the specified position in the one-dimensional <see cref="System.Array" />.
 The index is specified as a 32-bit integer.</para>
        </summary>
        <param name="value">The new value for the specified element.</param>
        <param name="index">A 32-bit integer that represents the position of the <see cref="System.Array" /> element to set.</param>
        <exception cref="System.ArgumentException"><para>The current <see cref="System.Array" /> does not have exactly one dimension.</para><para>-or-</para>
            <para><paramref name="value" /> does not contain a type that can be widened, using the standard widening conversions, to the element type of the current <see cref="System.Array" />.</para></exception>
        <exception cref="System.IndexOutOfRangeException">
            <para><paramref name="index" /> is outside the range of valid indexes for the current <see cref="System.Array" />.</para></exception>
<remarks>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" /> methods can determine
   whether the value of <paramref name="index" /> is out of bounds.</para>
            <para>For more information about conversions, see <see cref="System.Convert" />. </para>
        </remarks>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.GetValue" />
    </doc><doc for="Array.SetValue1">
        <summary>
            <para>Sets a value to the element at the specified position in the two-dimensional <see cref="System.Array" />.
 The indexes are specified as 32-bit integers.</para>
        </summary>
        <param name="value">The new value for the specified element.</param>
        <param name="index1">A 32-bit integer that represents the first-dimension index of the <see cref="System.Array" /> element to set.</param>
        <param name="index2">A 32-bit integer that represents the second-dimension index of the <see cref="System.Array" /> element to set.</param>
        <exception cref="System.ArgumentException"><para>The current <see cref="System.Array" /> does not have exactly two dimensions.</para><para>-or-</para>
            <para><paramref name="value" /> does not contain a type that can be widened, using the standard widening conversions, to the element type of the current <see cref="System.Array" />.</para></exception>
<exception cref="System.IndexOutOfRangeException">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="System.Array" />.</exception>
<remarks>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" /> methods can determine
   whether any of the indexes is out of bounds.</para>
            <para>For more information about conversions, see <see cref="System.Convert" />. </para>
        </remarks>
        <example>
            <para>The following code example shows how to
      use <see cref="System.Array.SetValue" /> to
      initialize an <see cref="System.Array" />.</para>
            <codelink SampleID="Classic Array.GetValue2 Example" SnippetID="1" />
        </example>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.GetValue" />
    </doc><doc for="Array.SetValue2">
        <summary>
            <para>Sets a value to the element at the specified position in the three-dimensional <see cref="System.Array" />.
 The indexes are specified as 32-bit integers.</para>
        </summary>
        <param name="value">The new value for the specified element.</param>
        <param name="index1">A 32-bit integer that represents the first-dimension index of the <see cref="System.Array" /> element to set.</param>
        <param name="index2">A 32-bit integer that represents the second-dimension index of the <see cref="System.Array" /> element to set.</param>
        <param name="index3">A 32-bit integer that represents the third-dimension index of the <see cref="System.Array" /> element to set.</param>
<exception cref="System.ArgumentException">The current <see cref="System.Array" /> does not have exactly three dimensions. <para>-or-</para><para><paramref name="value" /> does not contain a type that can be widened, using the standard widening conversions, to the element type of the current <see cref="System.Array" />.</para></exception>
        <exception cref="System.IndexOutOfRangeException"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="System.Array" />.</exception>
        <remarks>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" /> methods can determine
   whether any of the indexes is out of bounds.</para>
            <para>For more information about conversions, see <see cref="System.Convert" />. </para>
        </remarks>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.GetValue" />
    </doc><doc for="Array.SetValue3">
        <summary>
            <para>Sets a value to the element at the specified position in the multidimensional <see cref="System.Array" />.
 The indexes are specified as an array of 32-bit integers.</para>
        </summary>
        <param name="value">The new value for the specified element.</param>
        <param name="indices">A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the element to set.</param>
        <exception cref="System.ArgumentNullException"><paramref name="indices" /> is <see langword="null" />.</exception>
        <exception cref="System.ArgumentException"><para>The number of dimensions in the current <see cref="System.Array" /> is not equal to the number of elements in <paramref name="indices" />. </para><para>-or-</para>
            <para><paramref name="value" /> does not contain a type that can be widened, using the standard widening conversions, to the element type of the current <see cref="System.Array" />.</para></exception>
        <exception cref="System.IndexOutOfRangeException"><para>Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="System.Array" />.</para></exception>
<remarks>
            <para>The number of elements in <paramref name="indices" /> must equal the number of dimensions
   in the <see cref="System.Array" />.
   All elements in the <paramref name="indices" /> array must collectively specify the position
   of the desired element in the multidimensional <see cref="System.Array" />.</para>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" /> methods can determine whether any of
the values in the <paramref name="indices" /> array is out of bounds.</para>
            <para>For more information about conversions, see <see cref="System.Convert" />. </para>
        </remarks>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.GetValue" />
    </doc><doc for="Array.SetValue4">
        <summary>
            <para>Sets a value to the element at the specified position in the one-dimensional <see cref="System.Array" />.
 The index is specified as a 64-bit integer.</para>
        </summary>
        <param name="value">The new value for the specified element.</param>
        <param name="index">A 64-bit integer that represents the position of the <see cref="System.Array" /> element to set.</param>
        <exception cref="System.ArgumentException"><para>The current <see cref="System.Array" /> does not have exactly one dimension.</para><para>-or-</para>
            <para><paramref name="value" /> does not contain a type that can be widened, using the standard widening conversions, to the element type of the current <see cref="System.Array" />.</para></exception>
        <exception cref="System.IndexOutOfRangeException">
            <para><paramref name="index" /> is outside the range of valid indexes for the current <see cref="System.Array" />.</para></exception>
<remarks>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" /> methods can determine
   whether the value of <paramref name="index" /> is out of bounds.</para>
            <para>For more information about conversions, see <see cref="System.Convert" />. </para>
        </remarks>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.GetValue" />
    </doc><doc for="Array.SetValue5">
        <summary>
            <para>Sets a value to the element at the specified position in the two-dimensional <see cref="System.Array" />.
 The indexes are specified as 64-bit integers.</para>
        </summary>
        <param name="value">The new value for the specified element.</param>
        <param name="index1">A 64-bit integer that represents the first-dimension index of the <see cref="System.Array" /> element to set.</param>
        <param name="index2">A 64-bit integer that represents the second-dimension index of the <see cref="System.Array" /> element to set.</param>
        <exception cref="System.ArgumentException"><para>The current <see cref="System.Array" /> does not have exactly two dimensions.</para><para>-or-</para>
            <para><paramref name="value" /> does not contain a type that can be widened, using the standard widening conversions, to the element type of the current <see cref="System.Array" />.</para></exception>
<exception cref="System.IndexOutOfRangeException">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="System.Array" />.</exception>
<remarks>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" /> methods can determine
   whether any of the indexes is out of bounds.</para>
            <para>For more information about conversions, see <see cref="System.Convert" />. </para>
        </remarks>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.GetValue" />
    </doc><doc for="Array.SetValue6">
        <summary>
            <para>Sets a value to the element at the specified position in the three-dimensional <see cref="System.Array" />.
 The indexes are specified as 64-bit integers.</para>
        </summary>
        <param name="value">The new value for the specified element.</param>
        <param name="index1">A 64-bit integer that represents the first-dimension index of the <see cref="System.Array" /> element to set.</param>
        <param name="index2">A 64-bit integer that represents the second-dimension index of the <see cref="System.Array" /> element to set.</param>
        <param name="index3">A 64-bit integer that represents the third-dimension index of the <see cref="System.Array" /> element to set.</param>
<exception cref="System.ArgumentException">The current <see cref="System.Array" /> does not have exactly three dimensions. <para>-or-</para><para><paramref name="value" /> does not contain a type that can be widened, using the standard widening conversions, to the element type of the current <see cref="System.Array" />.</para></exception>
        <exception cref="System.IndexOutOfRangeException"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="System.Array" />.</exception>
        <remarks>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" /> methods can determine
   whether any of the indexes is out of bounds.</para>
            <para>For more information about conversions, see <see cref="System.Convert" />. </para>
        </remarks>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.GetValue" />
    </doc><doc for="Array.SetValue7">
        <summary>
            <para>Sets a value to the element at the specified position in the multidimensional <see cref="System.Array" />.
 The indexes are specified as an array of 64-bit integers.</para>
        </summary>
        <param name="value">The new value for the specified element.</param>
        <param name="indices">A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the element to set.</param>
        <exception cref="System.ArgumentNullException"><paramref name="indices" /> is <see langword="null" />.</exception>
        <exception cref="System.ArgumentException"><para>The number of dimensions in the current <see cref="System.Array" /> is not equal to the number of elements in <paramref name="indices" />. </para><para>-or-</para>
            <para><paramref name="value" /> does not contain a type that can be widened, using the standard widening conversions, to the element type of the current <see cref="System.Array" />.</para></exception>
        <exception cref="System.IndexOutOfRangeException"><para>Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="System.Array" />.</para></exception>
<remarks>
            <para>The number of elements in <paramref name="indices" /> must equal the number of dimensions
   in the <see cref="System.Array" />.
   All elements in the <paramref name="indices" /> array must collectively specify the position
   of the desired element in the multidimensional <see cref="System.Array" />.</para>
            <para>The <see cref="System.Array.GetLowerBound" /> and <see cref="System.Array.GetUpperBound" /> methods can determine whether any of
the values in the <paramref name="indices" /> array is out of bounds.</para>
            <para>For more information about conversions, see <see cref="System.Convert" />. </para>
        </remarks>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.GetValue" />
    </doc><doc for="Array.Length">
        <summary>
            <para>Gets a 32-bit integer that represents the total number of elements in all the dimensions of the <see cref="System.Array" />.</para>
        </summary>
        <value>
            <para>A 32-bit integer that represents the total number of elements in all the dimensions of the <see cref="System.Array" />.</para>
        </value>
        <seealso cref="P:System.Collections.ICollection.Count" qualify="true" />
        <seealso cref="System.Array.GetLength" />
        <seealso cref="System.Array.Rank" />
    </doc><doc for="Array.LongLength">
        <summary>
            <para>Gets a 64-bit integer that represents the total number of elements in all the dimensions of the <see cref="System.Array" />.</para>
        </summary>
        <value>
            <para>A 64-bit integer that represents the total number of elements in all the dimensions of the <see cref="System.Array" />.</para>
        </value>
        <seealso cref="P:System.Collections.ICollection.Count" qualify="true" />
        <seealso cref="System.Array.GetLength" />
        <seealso cref="System.Array.Rank" />
    </doc><doc for="Array.GetLength">
        <summary>
            <para>Gets a 32-bit integer that represents the number of elements in the specified dimension of the <see cref="System.Array" />.</para>
        </summary>
        <param name="dimension">A zero-based dimension of the <see cref="System.Array" /> whose length needs to be determined. </param>
        <returns>
            <para>A 32-bit integer that represents the number of elements in the specified dimension.
      </para>
        </returns>
        <exception cref="System.IndexOutOfRangeException">
            <para><paramref name="dimension" /> is less than zero.</para><para>-or-</para>
            <para><paramref name="dimension" /> is equal to or greater than <see cref="System.Array.Rank" />. </para></exception>
<remarks>
            <para>An example of <see cref="System.Array.GetLength" /> is <c>GetLength(0)</c>, which returns the number of elements in
 the first dimension of the <see cref="System.Array" />.</para>
        </remarks>
        <seealso cref="System.Array.Length" />
        <seealso cref="P:System.Collections.ICollection.Count" qualify="true" />
        <seealso cref="System.Array.Rank" />
    </doc><doc for="Array.GetLongLength">
        <summary>
            <para>Gets a 64-bit integer that represents the number of elements in the specified dimension of the <see cref="System.Array" />.
      </para>
        </summary>
        <param name="dimension">A zero-based dimension of the <see cref="System.Array" /> whose length needs to be determined. </param>
        <returns>
            <para>A 64-bit integer that represents the number of elements in the specified dimension.
      </para>
        </returns>
        <exception cref="System.IndexOutOfRangeException">
            <para><paramref name="dimension" /> is less than zero.</para><para>-or-</para>
            <para><paramref name="dimension" /> is equal to or greater than <see cref="System.Array.Rank" />. </para></exception>
<remarks>
            <para>An example of <see cref="System.Array.GetLength" /> is <c>GetLength(0)</c>, which returns the number of elements in
the first dimension of the <see cref="System.Array" />.</para>
        </remarks>
        <seealso cref="System.Array.Length" />
        <seealso cref="P:System.Collections.ICollection.Count" qualify="true" />
        <seealso cref="System.Array.Rank" />
    </doc><doc for="Array.Rank">
        <summary>
            <para>Gets the rank (number of dimensions) of the <see cref="System.Array" />.</para>
        </summary>
        <value>
            <para>The rank (number of dimensions) of the <see cref="System.Array" />.</para>
        </value>
        <seealso cref="System.Array.Length" />
        <seealso cref="System.Array.GetLength" />
    </doc><doc for="Array.GetUpperBound">
        <summary>
            <para>Gets the upper bound of the specified dimension in the <see cref="System.Array" />.</para>
        </summary>
        <param name="dimension">A zero-based dimension of the <see cref="System.Array" /> whose upper bound needs to be determined.</param>
        <returns>
            <para>The upper bound of the specified dimension in the
    <see cref="System.Array" />.</para>
        </returns>
        <exception cref="System.IndexOutOfRangeException">
            <para><paramref name="dimension" /> is less than zero.</para><para> -or-</para>
            <para><paramref name="dimension" /> is equal to or greater than <see cref="System.Array.Rank" />.</para></exception>
<remarks>
            <para>An example of <see cref="System.Array.GetUpperBound" /> is <c>GetUpperBound(0)</c>, which returns the upper bound for the
       indexes of the first dimension of the <see cref="System.Array" /> and <c>GetUpperBound(Rank - 1)</c> returns the upper bound of the last dimension of the
    <see cref="System.Array" />.</para>
        </remarks>
        <example>
            <para>The following code example uses <see cref="System.Array.GetLowerBound" /> 
 and <see cref="System.Array.GetUpperBound" /> to initialize two arrays, one-dimensional and multidimensional.</para>
            <codelink SampleID="Classic Array.GetUpperBound Example" SnippetID="1" />
        </example>
        <seealso cref="System.Array.GetLowerBound" />
        <seealso cref="System.Array.Rank" />
    </doc><doc for="Array.GetLowerBound">
        <summary>
            <para>Gets the lower bound of the specified dimension in the <see cref="System.Array" />.</para>
        </summary>
        <param name="dimension">A zero-based dimension of the <see cref="System.Array" /> whose lower bound needs to be determined.</param>
        <returns>
            <para>The lower bound of the specified dimension in the <see cref="System.Array" />.</para>
        </returns>
        <exception cref="System.IndexOutOfRangeException">
            <para><paramref name="dimension" /> is less than zero.</para><para>-or-</para>
            <para><paramref name="dimension" /> is equal to or greater than <see cref="System.Array.Rank" />.</para></exception>
<remarks>
            <para>An example of <see cref="System.Array.GetLowerBound" /> is <c>GetLowerBound(0)</c>, which returns the lower bound for the
       indexes of the first dimension of the <see cref="System.Array" />, and <c>GetLowerBound(Rank - 1)</c> returns the lower bound of the last dimension of
       the <see cref="System.Array" />.</para>
        </remarks>
        <example>
            <para>The following code example uses <see cref="System.Array.GetLowerBound" /> 
 and <see cref="System.Array.GetUpperBound" /> to initialize two arrays, one-dimensional and multidimensional.</para>
            <codelink SampleID="Classic Array.GetUpperBound Example" SnippetID="1" />
        </example>
        <seealso cref="System.Array.GetUpperBound" />
        <seealso cref="System.Array.Rank" />
    </doc><doc for="Array.ICollection.Count">
        <summary>
            <para> Gets the number of elements contained in the <see cref="System.Array" />.</para>
        </summary>
        <value>
            <para> The number of elements contained in the <see cref="System.Array" />.</para>
        </value>
        <remarks>
            <para><see cref="P:System.Collections.ICollection.Count" qualify="true" /> is always equal to <see cref="System.Array.Length" />.</para>
        </remarks>
        <seealso cref="System.Array.Length" />
        <seealso cref="System.Array.GetLength" />
    </doc><doc for="Array.SyncRoot">
        <summary>
            <para>Gets an object that can be used to synchronize access to the <see cref="System.Array" />.</para>
        </summary>
        <value>
            <para>An object that can be used to synchronize access to the
   <see cref="System.Array" />.</para>
        </value>
        <remarks>
            <para>This property implements the <see cref="System.Collections.ICollection" qualify="true" /> interface.</para>
            <para>.NET Framework classes based on <see cref="System.Array" /> provide their own synchronized version of the collection using the <see cref="System.Array.SyncRoot" /> property.</para>
            <para>Classes that use arrays can also implement their own synchronization using the <see cref="System.Array.SyncRoot" /> property. 
 The synchronizing code must perform operations on the <see langword="SyncRoot" /> of the collection, not directly on the collection.
 This ensures proper operation of collections that are derived from other objects.
 Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.
 Note that some implementations of <see cref="System.Array.SyncRoot" /> might return the <see cref="System.Array" /> itself.</para>
            <para>Enumerating through a collection is intrinsically not a thread-safe procedure.
   Even when a collection is synchronized, other threads could still modify the collection, which causes the enumerator to throw an exception.
   To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</para>
            <para lang="VB, C#">The following code example shows how to lock a collection during the entire enumeration by using the <see cref="System.Array.SyncRoot" />:</para>
            <code lang="C#">Array myCollection = new int[];
 lock( myCollection.SyncRoot ) {
 foreach ( Object item in myCollection ) {
 // Insert your code here.
 }
}
</code>
            <code lang="VB">Dim myCollection As New Int[]
Dim item As Object
SyncLock myCollection.SyncRoot
 For Each item In myCollection
 ' Insert your code here.
 Next item
End SyncLock
</code>
        </remarks>
        <seealso cref="System.Array.IsSynchronized" />
    </doc><doc for="Array.IsReadOnly">
        <summary>
            <para>Gets a value indicating whether the <see cref="System.Array" /> is read-only.</para>
        </summary>
        <value>
            <para>This property is always <see langword="false" /> for all arrays.</para>
        </value>
        <remarks>
            <para><see cref="System.Array" /> implements the <see cref="System.Array.IsReadOnly" /> property because it is required by the <see cref="System.Collections.IList" qualify="true" /> interface.</para>
            <para>If you require a read-only collection, use a <see cref="System.Collections" /> class that implements the <see cref="System.Collections.IList" qualify="true" /> interface.</para>
            <para>An array that is read-only does not allow the addition, removal, or modification of elements after the array is created.</para>
        </remarks>
        <seealso cref="System.Collections.IList" qualify="true" />
        <seealso cref="System.Collections" />
    </doc><doc for="Array.IsFixedSize">
        <summary>
            <para>Gets a value indicating whether the <see cref="System.Array" /> has a fixed size.</para>
        </summary>
        <value>
            <para>This property is always <see langword="true" /> for all arrays.</para>
        </value>
        <remarks>
            <para><see cref="System.Array" /> implements the <see cref="System.Array.IsFixedSize" /> property because it is required by the <see cref="System.Collections.IList" qualify="true" /> interface.</para>
            <para>An array with a fixed size does not allow the addition or removal of elements after the array is created,
   but it allows the modification of existing elements.</para>
        </remarks>
        <seealso cref="System.Collections.IList" qualify="true" />
    </doc><doc for="Array.IsSynchronized">
        <summary>
            <para>Gets a value indicating whether access to the <see cref="System.Array" /> is synchronized (thread-safe).</para>
        </summary>
        <value>
            <para>This property is always <see langword="false" /> for all arrays.</para>
        </value>
        <remarks>
            <para><see cref="System.Array" /> implements the <see cref="System.Array.IsSynchronized" /> property because it is required by the <see cref="System.Collections.ICollection" qualify="true" /> interface.</para>
            <para>.NET Framework classes based on <see cref="System.Array" /> provide their own synchronized version of the collection using the <see cref="System.Array.SyncRoot" /> property.</para>
            <para>Classes that use arrays can also implement their own synchronization using the <see cref="System.Array.SyncRoot" /> property.
The synchronizing code must perform operations on the <see langword="SyncRoot" /> of the collection, not directly on the collection.
This ensures proper operation of collections that are derived from other objects.
Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.
Note that some implementations of <see cref="System.Array.SyncRoot" /> might return the <see cref="System.Array" /> itself.</para>
            <para>Enumerating through a collection is intrinsically not a thread-safe procedure.
   Even when a collection is synchronized, other threads could still modify the collection, which causes the enumerator to throw an exception.
   To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</para>
            <para lang="VB, C#">The following code example shows how to lock a collection during the entire enumeration by using the <see cref="System.Array.SyncRoot" />:</para>
            <code lang="C#">Array myCollection = new int[];
 lock( myCollection.SyncRoot ) {
 foreach ( Object item in myCollection ) {
 // Insert your code here.
 }
}
</code>
            <code lang="VB">Dim myCollection As New Int[]
Dim item As Object
SyncLock myCollection.SyncRoot
 For Each item In myCollection
 ' Insert your code here.
 Next item
End SyncLock
</code>
        </remarks>
        <seealso cref="System.Array.SyncRoot" />
        <seealso cref="System.Collections.ICollection" qualify="true" />
    </doc><doc for="Array.IList.this">
        <summary>
            <para>Gets or sets the element at the specified index.</para>
        </summary>
        <param name="index">The zero-based index of the element to get or set.</param>
        <value>
            <para>The element at the specified index.</para>
        </value>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="index" /> is less than zero.</para><para>-or-</para>
            <para><paramref name="index" /> is equal to or greater than <see cref="P:System.Collections.ICollection.Count" qualify="true" />.</para></exception>
<remarks>
            <para>This property provides the ability to access a specific element in the collection by using the following syntax: <c>myCollection[index]</c>.</para>
        </remarks>
        <seealso cref="P:System.Collections.ICollection.Count" qualify="true" />
    </doc><doc for="Array.IList.Add">
        <summary>
            <para>Implements <see cref="System.Collections.IList.Add" qualify="true" />. Always throws <see cref="System.NotSupportedException" />.</para>
        </summary>
        <param name="value">The object to be added to the <see cref="System.Array" />.</param>
        <returns>
            <para>An exception is always thrown.</para>
        </returns>
        <exception cref="System.NotSupportedException"><para> Always thrown.</para></exception>
        <remarks>
            <para><see cref="System.Array" /> has a fixed size; therefore, elements cannot be added or removed.
   Use <see cref="System.Array.SetValue" /> to change the value of an existing element.</para>
        </remarks>
        <seealso cref="System.Array.SetValue" />
    </doc><doc for="Array.IList.Contains">
        <summary>
            <para>Determines whether an element is in the <see cref="System.Array" />.</para>
        </summary>
        <param name="value">
            <para>The object to locate in the <see cref="System.Array" />. The element to locate can be <see langword="null" />.</para>
        </param>
        <returns>
            <para><see langword="true" /> if <paramref name="value" /> is found in the <see cref="System.Array" />; otherwise, <see langword="false" />.</para>
        </returns>
<exception cref="System.RankException">The current <see cref="System.Array" /> is multidimensional.</exception>
        <remarks>
            <para>This method performs a linear search; therefore, the average execution time is proportional to <see cref="P:System.Collections.ICollection.Count" qualify="true" />.
   That is, this method is an O(<paramref name="n" />) operation, where <paramref name="n" /> is <see cref="P:System.Collections.ICollection.Count" qualify="true" />.</para>
            <para> This method determines equality by calling <see cref="System.Object.Equals" qualify="true" />.</para>
        </remarks>
        <seealso cref="System.Array.IndexOf" />
        <seealso cref="System.Array.LastIndexOf" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.IList.Clear">
        <summary>
            <para>Sets all elements in the <see cref="System.Array" /> to zero, to <see langword="false" />, or to <see langword="null" />, depending on the element type.</para>
        </summary>
        <exception cref="System.NotSupportedException"><para>The <see cref="System.Array" /> is read-only.</para><para>-or-</para><para>The <see cref="System.Array" /> has a fixed size.</para></exception>
        <remarks>
            <para>Reference-type elements are set to <see langword="null" />.
 Boolean-type elements are set to <see langword="false" />.
 Other value-type elements are set to zero.</para>
            <para>This method only clears the values of the elements; it does not delete the elements themselves.
 <see cref="System.Array" /> has a fixed size; therefore, elements cannot be added or removed.</para>
        </remarks>
        <seealso cref="P:System.Collections.ICollection.Count" qualify="true" />
    </doc><doc for="Array.IList.IndexOf">
        <summary>
            <para>Searches for the specified object and returns the index of the first occurrence within the current one-dimensional instance.</para>
        </summary>
        <param name="value">The object to locate in the current <see cref="System.Array" />.</param>
        <returns>
            <para>The index of the first occurrence of <paramref name="value" /> within the entire <see cref="System.Array" />, if found; otherwise, the lower bound of the <see cref="System.Array" /> - 1.</para>
        </returns>
<exception cref="System.RankException">The current <see cref="System.Array" /> is multidimensional.</exception>
        <remarks>
            <para>The one-dimensional <see cref="System.Array" /> is searched forward starting at the first element and ending at the last element.</para>
            <para>The elements are compared to the specified value using the <see cref="System.Object.Equals" qualify="true" /> method.
 If the element type is a nonintrinsic (user-defined) type, the <see langword="Equals" /> implementation of that type is used.</para>
            <para>Since most arrays will have a lower bound of zero, this method would generally return -1 when <paramref name="value" /> is not found.
 In the rare case that the lower bound of the array is equal to <see cref="System.Int32.MinValue" qualify="true" /> and <paramref name="value" /> is not found,
 this method returns <see cref="System.Int32.MaxValue" qualify="true" />, which is <c>System.Int32.MinValue - 1</c>.</para>
        </remarks>
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.IList.Insert">
        <summary>
            <para>Implements <see cref="System.Collections.IList.Insert" qualify="true" />. Always throws <see cref="System.NotSupportedException" />.</para>
        </summary>
        <param name="index">The index at which <paramref name="value" /> should be inserted.</param>
        <param name="value">The object to insert.</param>
<exception cref="System.NotSupportedException">Always thrown.</exception>
        <remarks>
            <para><see cref="System.Array" /> has a fixed size; therefore, elements cannot be added or removed.
   Use <see cref="System.Array.SetValue" /> to change the value of an existing element.</para>
        </remarks>
        <seealso cref="System.Array.SetValue" />
    </doc><doc for="Array.IList.Remove">
        <summary>
            <para>Implements <see cref="System.Collections.IList.Remove" qualify="true" />. Always throws <see cref="System.NotSupportedException" />.</para>
        </summary>
        <param name=" value">The object to remove from the <see cref="System.Array" />.</param>
<exception cref="System.NotSupportedException">Always thrown.</exception>
        <remarks>
            <para><see cref="System.Array" /> has a fixed size; therefore, elements cannot be added or removed.
   Use <see cref="System.Array.SetValue" /> to change the value of an existing element.</para>
        </remarks>
        <seealso cref="System.Array.SetValue" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.IList.RemoveAt">
        <summary>
            <para>Implements <see cref="System.Collections.IList.RemoveAt" qualify="true" />. Always throws <see cref="System.NotSupportedException" />.</para>
        </summary>
        <param name=" index">The index of the element to remove.</param>
<exception cref="System.NotSupportedException">Always thrown.</exception>
        <remarks>
            <para><see cref="System.Array" /> has a fixed size; therefore, elements cannot be added or removed.
   Use <see cref="System.Array.SetValue" /> to change the value of an existing element.</para>
        </remarks>
        <seealso cref="System.Array.SetValue" />
    </doc><doc for="Array.Clone">
        <summary>
            <para>Creates a shallow copy of the <see cref="System.Array" />.</para>
        </summary>
        <returns>
            <para>A shallow copy of the <see cref="System.Array" />.</para>
        </returns>
        <remarks>
            <para> A shallow copy of an <see cref="System.Array" /> copies only the elements of the <see cref="System.Array" />, whether they are reference types or value types,
 but it does not copy the objects that the references refer to.
 The references in the new <see cref="System.Array" /> point to the same objects that the references in the original <see cref="System.Array" /> point to.</para>
            <para>In contrast, a deep copy of an <see cref="System.Array" /> copies the elements and everything directly or indirectly referenced by the elements.</para>
            <para>The clone is of the same <see cref="System.Type" /> as the original <see cref="System.Array" />.</para>
        </remarks>
    </doc><doc for="Array.BinarySearch">
        <overload>
            <para>Searches a one-dimensional sorted <see cref="System.Array" />
 for a value, using a binary search algorithm.</para>
        </overload>
        <summary>
            <para>Searches an entire one-dimensional sorted <see cref="System.Array" /> for a specific element,
 using the <see cref="System.IComparable" /> interface implemented
 by each element of the <see cref="System.Array" /> and by the specified object.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to search.</param>
        <param name="value">The object to search for.</param>
        <returns>
            <para>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found.</para>
            <para>-or-</para>
            <para> A negative number, which is the bitwise complement of the index of the first element that is larger than <paramref name="value" />,
 if <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />.</para>
            <para>-or-</para>
            <para>A negative number, which is the bitwise complement of (the index of the last element + 1),
   if <paramref name="value" /> is not found and <paramref name="value" /> is greater than any of the elements in <paramref name="array" />.</para>
        </returns>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="array" /> is <see langword="null" />. </para></exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional.</exception>
        <exception cref="System.ArgumentException"><paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</exception>
<exception cref="System.InvalidOperationException">Neither <paramref name="value" /> nor the elements of <paramref name="array" /> implement the <see cref="System.IComparable" /> interface.</exception>
<remarks>
            <para>Either <paramref name="value" /> or every element of
 <paramref name="array" /> must implement the <see cref="System.IComparable" /> interface, which is used for
   comparisons. If the elements of <paramref name="array" /> are not already sorted in increasing value
   according to the <see cref="System.IComparable" /> implementation,
   the result might be incorrect.</para>
            <para>Duplicate elements are allowed.
 If the <see cref="System.Array" /> contains more than one element equal to <paramref name="value" />,
 the method returns the index of only one of the occurrences,
 and not necessarily the first one.</para>
            <para><see langword="null" /> can always be compared with any other type; therefore,
 comparisons with <see langword="null" /> do not generate an exception. When
 sorting, <see langword="null" /> is considered to be less than any other object.</para>
            <para>If the <see cref="System.Array" /> does not contain the specified value, the
 method returns a negative integer. You can apply the bitwise complement operator (~) to a negative result to
 produce the index of the first element, if any, that is larger than the
 specified search value.</para>
        </remarks>
        <example>
            <para>The following code example shows how to
      use <see cref="System.Array.BinarySearch" /> to locate a
      specific object in an <see cref="System.Array" />.</para>
            <codelink SampleID="Classic Array.BinarySearch Example" SnippetID="1" />
        </example>
        <seealso cref="System.IComparable" />
        <seealso cref="System.Array.Sort" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.BinarySearch1">
        <summary>
            <para>Searches a section of a one-dimensional sorted <see cref="System.Array" /> for a value,
 using the <see cref="System.IComparable" /> interface implemented
 by each element of the <see cref="System.Array" /> and by the specified value.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to search.</param>
        <param name="index">The starting index of the range to search.</param>
        <param name="length">The length of the range to search.</param>
        <param name="value">The object to search for.</param>
        <returns>
            <para>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found.</para>
            <para>-or-</para>
            <para>A negative number, which is the bitwise complement of the index of the first element that is larger than <paramref name="value" />,
 if <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />.</para>
            <para>-or-</para>
            <para>A negative number, which is the bitwise complement of (the index of the last element + 1),
   if <paramref name="value" /> is not found and <paramref name="value" /> is greater than any of the elements in <paramref name="array" />.</para>
        </returns>
        <exception cref="System.ArgumentNullException"><paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional.</exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</para><para>-or-</para>
            <para><paramref name="length" /> is less than zero.</para></exception>
        <exception cref="System.ArgumentException">
            <para><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />. </para><para>-or-</para>
            <para><paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</para></exception>
<exception cref="System.InvalidOperationException">Neither <paramref name="value" /> nor the elements of <paramref name="array" /> implement the <see cref="System.IComparable" /> interface.</exception>
<remarks>
            <para>Either <paramref name="value" /> or every element of
 <paramref name="array" /> must implement the <see cref="System.IComparable" /> interface, which is used for
   comparisons. If the elements of <paramref name="array" /> are not already sorted in increasing value
   according to the<see cref="System.IComparable" /> implementation,
   the result might be incorrect.</para>
            <para>Duplicate elements are allowed.
 If the <see cref="System.Array" /> contains more than one element equal to <paramref name="value" />,
 the method returns the index of only one of the occurrences,
 and not necessarily the first one.</para>
            <para><see langword="null" /> can always be compared with any other type; therefore,
 comparisons with <see langword="null" /> do not generate an exception. When
 sorting, <see langword="null" /> is considered to be less than any
 other object.</para>
            <para>If the <see cref="System.Array" /> does not contain the specified value, the
 method returns a negative integer. You can apply the bitwise complement operator (~) to a negative result to
 produce the index of the first element, if any, that is larger than the
 specified search value.</para>
        </remarks>
        <seealso cref="System.IComparable" />
        <seealso cref="System.Array.Sort" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.BinarySearch2">
        <summary>
            <para>Searches an entire one-dimensional sorted <see cref="System.Array" /> for a value,
 using the specified <see cref="System.Collections.IComparer" /> interface.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to search.</param>
        <param name="value">The object to search for.</param>
        <param name="comparer">
            <para>The <see cref="System.Collections.IComparer" /> implementation to use when comparing elements.</para>
            <para> -or-</para>
            <para><see langword="null" /> to use the <see cref="System.IComparable" /> implementation of each element.</para>
        </param>
        <returns>
            <para>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found.</para>
            <para>-or-</para>
            <para>A negative number, which is the bitwise complement of the index of the first element that is larger than <paramref name="value" />,
 if <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />.</para>
            <para>-or-</para>
            <para>A negative number, which is the bitwise complement of (the index of the last element + 1),
   if <paramref name="value" /> is not found and <paramref name="value" /> is greater than any of the elements in <paramref name="array" />.</para>
        </returns>
        <exception cref="System.ArgumentNullException"><paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional.</exception>
        <exception cref="System.ArgumentException"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</exception>
        <exception cref="System.InvalidOperationException"><paramref name="comparer" /> is <see langword="null" />, and neither <paramref name="value" /> nor the elements of <paramref name="array" /> implement the <see cref="System.IComparable" /> interface.</exception>
        <remarks>
            <para>The comparer customizes how the elements are compared.
      For example, you can use a <see cref="System.Collections.CaseInsensitiveComparer" qualify="true" />
      as the comparer to perform case-insensitive string searches.</para>
            <para>If <paramref name="comparer" /> is not <see langword="null" />, the
      elements of <paramref name="array" /> are compared to the specified value using the
      specified <see cref="System.Collections.IComparer" />
      implementation. If the elements of <paramref name="array" /> are not already sorted in increasing value
      according to <paramref name="comparer" />, the result might be incorrect.</para>
            <para>If <paramref name=" comparer" /> is <see langword="null" />, the comparison is done using the <see cref="System.IComparable" /> implementation provided by
   the element itself or by the specified value. If the elements of <paramref name="array" /> are not already sorted in increasing value according to the
 <see cref="System.IComparable" /> implementation, the result might be incorrect.</para>
            <para>Duplicate elements are allowed.
 If the <see cref="System.Array" /> contains more than one element equal to <paramref name="value" />,
 the method returns the index of only one of the occurrences,
 and not necessarily the first one.</para>
            <para><see langword="null" /> can always be compared with any other type; therefore,
 comparisons with <see langword="null" /> do not generate an exception. When
 sorting, <see langword="null" /> is considered to be less than any
 other object.</para>
            <para>If the <see cref="System.Array" /> does not contain the specified value, the
 method returns a negative integer. You can apply the bitwise complement operator (~) to a negative result to
 produce the index of the first element, if any, that is larger than the
 specified search value.</para>
        </remarks>
        <seealso cref="System.Collections.IComparer" />
        <seealso cref="System.IComparable" />
        <seealso cref="System.Array.Sort" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.BinarySearch3">
        <summary>
            <para>Searches a section of a one-dimensional sorted <see cref="System.Array" /> for a value,
 using the specified <see cref="System.Collections.IComparer" /> interface.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to search.</param>
        <param name="index">The starting index of the range to search.</param>
        <param name="length">The length of the range to search.</param>
        <param name="value">The object to search for.</param>
        <param name="comparer">
            <para>The <see cref="System.Collections.IComparer" /> implementation to use when comparing elements.</para>
            <para>-or-</para>
            <para><see langword="null" /> to use the <see cref="System.IComparable" /> implementation of each element. </para>
        </param>
        <returns>
            <para>The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found.</para>
            <para>-or-</para>
            <para>A negative number, which is the bitwise complement of the index of the first element that is larger than <paramref name="value" />,
 if <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />.</para>
            <para>-or-</para>
            <para>A negative number, which is the bitwise complement of (the index of the last element + 1),
   if <paramref name="value" /> is not found and <paramref name="value" /> is greater than any of the elements in <paramref name="array" />.</para>
        </returns>
        <exception cref="System.ArgumentNullException"><paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional.</exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</para><para>-or-</para>
            <para><paramref name="length" /> is less than zero.</para></exception>
        <exception cref="System.ArgumentException">
            <para><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />. </para><para>-or-</para>
            <para><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</para></exception>
        <exception cref="System.InvalidOperationException"><paramref name="comparer" /> is <see langword="null" />, and neither <paramref name="value" /> nor the elements of <paramref name="array" /> implement the <see cref="System.IComparable" /> interface.</exception>
<remarks>
            <para>The comparer customizes how the elements are compared.
      For example, you can use a <see cref="System.Collections.CaseInsensitiveComparer" qualify="true" /> as the
      comparer to perform case-insensitive string searches.</para>
            <para>If <paramref name="comparer" /> is not <see langword="null" />, the
   elements of <paramref name="array" /> are compared to the specified value using the
   specified <see cref="System.Collections.IComparer" />
   implementation. If the elements of <paramref name="array" /> are not already sorted in increasing value
   according to <paramref name="comparer" />, the result might be incorrect.</para>
            <para>If <paramref name="comparer" /> is <see langword="null" />, the comparison is done using the <see cref="System.IComparable" /> implementation provided by
 the element itself or by the specified value. If the elements of <paramref name="array" /> are not already sorted in increasing value
 according to the <see cref="System.IComparable" /> implementation, the result might be incorrect.</para>
            <para>Duplicate elements are allowed.
 If the <see cref="System.Array" /> contains more than one element equal to <paramref name="value" />,
 the method returns the index of only one of the occurrences,
 and not necessarily the first one.</para>
            <para><see langword="null" /> can always be compared with any other type; therefore,
 comparisons with <see langword="null" /> do not generate an exception when
 using <see cref="System.IComparable" />. When sorting, <see langword="null" /> is considered to be less than any other
 object.</para>
            <para>If the <see cref="System.Array" /> does not contain the specified value, the
 method returns a negative integer. You can apply the bitwise complement operator (~) to a negative result to
 produce the index of the first element, if any, that is larger than the
 specified search value.</para>
        </remarks>
        <seealso cref="System.Collections.IComparer" />
        <seealso cref="System.IComparable" />
        <seealso cref="System.Array.Sort" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.CopyTo">
        <overload>
            <para>Copies all the elements of the current one-dimensional <see cref="System.Array" /> to the specified one-dimensional <see cref="System.Array" />.</para>
        </overload>
        <summary>
            <para> Copies all the elements of the current one-dimensional <see cref="System.Array" /> to the specified one-dimensional <see cref="System.Array" />
starting at the specified destination <see cref="System.Array" /> index.
The index is specified as a 32-bit integer.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> that is the destination of the elements copied from the current <see cref="System.Array" />.</param>
        <param name="index">A 32-bit integer that represents the index in <paramref name="array" /> at which copying begins.</param>
        <exception cref="System.ArgumentNullException"><paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="System.ArgumentOutOfRangeException"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</exception>
        <exception cref="System.ArgumentException">
            <para>The source <see cref="System.Array" /> is multidimensional.</para><para>-or-</para>
            <para><paramref name="array" /> is multidimensional.</para><para>-or-</para>
            <para><paramref name="index" /> is equal to or greater than the length of <paramref name="array" />.</para><para>-or-</para>
            <para>The number of elements in the source <see cref="System.Array" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</para></exception>
        <exception cref="System.ArrayTypeMismatchException">The type of the source <see cref="System.Array" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
<remarks>
            <para>This method supports the <see cref="System.Collections.ICollection" qualify="true" /> interface. If implementing <see cref="System.Collections.ICollection" qualify="true" /> is not explicitly required, use <see cref="System.Array.Copy" />
to avoid an extra indirection.</para>
            <para>If this method throws an exception while copying, the state of <paramref name="array" />
is undefined.</para>
        </remarks>
        <example>
            <para>The following code example shows how to copy an <see cref="System.Array" /> to another
<see cref="System.Array" />.</para>
            <codelink SampleID="Classic Array.CopyTo Example" SnippetID="1" />
            <para>The following code example shows how to copy an <see cref="System.Array" /> to another <see cref="System.Array" /> with a nonzero lower bound.
 Note that the entire source <see cref="System.Array" /> is copied, including empty elements that overwrite existing elements in the target <see cref="System.Array" />.</para>
            <codelink SampleID="Classic Array.CopyTo Example" SnippetID="2" />
        </example>
        <seealso cref="System.Collections.ICollection" />
        <seealso cref="System.Array.Copy" />
    </doc><doc for="Array.CopyTo1">
        <summary>
            <para> Copies all the elements of the current one-dimensional <see cref="System.Array" /> to the specified one-dimensional <see cref="System.Array" />
starting at the specified destination <see cref="System.Array" /> index.
The index is specified as a 64-bit integer.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> that is the destination of the elements copied from the current <see cref="System.Array" />.</param>
        <param name="index">A 64-bit integer that represents the index in <paramref name="array" /> at which copying begins.</param>
        <exception cref="System.ArgumentNullException"><paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="System.ArgumentOutOfRangeException"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</exception>
        <exception cref="System.ArgumentException">
            <para>The source <see cref="System.Array" /> is multidimensional.</para><para>-or-</para>
            <para><paramref name="array" /> is multidimensional.</para><para>-or-</para>
            <para><paramref name="index" /> is equal to or greater than the length of <paramref name="array" />.</para><para>-or-</para>
            <para>The number of elements in the source <see cref="System.Array" /> is greater than the available space from <paramref name="index" /> to the end of the destination <paramref name="array" />.</para></exception>
        <exception cref="System.ArrayTypeMismatchException">The type of the source <see cref="System.Array" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
<remarks>
            <para>This method supports the <see cref="System.Collections.ICollection" qualify="true" /> interface. If implementing <see cref="System.Collections.ICollection" qualify="true" /> is not explicitly required, use <see cref="System.Array.Copy" />
to avoid an extra indirection.</para>
            <para>If this method throws an exception while copying, the state of <paramref name="array" />
is undefined.</para>
        </remarks>
        <seealso cref="System.Collections.ICollection" />
        <seealso cref="System.Array.Copy" />
    </doc><doc for="Array.GetEnumerator">
        <summary>
            <para>Returns an <see cref="System.Collections.IEnumerator" /> for the <see cref="System.Array" />.</para>
        </summary>
        <returns>
            <para>An <see cref="System.Collections.IEnumerator" /> for the <see cref="System.Array" />.</para>
        </returns>
        <remarks>
            <para> Enumerators only allow reading the data in the collection.
 Enumerators cannot be used to modify the underlying collection.</para>
            <para>Initially, the enumerator is positioned before the first element in the collection.
 <see cref="System.Collections.IEnumerator.Reset" /> also brings the enumerator back to this position.
 At this position, calling <see cref="System.Collections.IEnumerator.Current" /> throws an exception.
 Therefore, you must call <see cref="System.Collections.IEnumerator.MoveNext" /> to advance the enumerator to the first element of the collection
 before reading the value of <see cref="System.Collections.IEnumerator.Current" />.</para>
            <para><see cref="System.Collections.IEnumerator.Current" /> returns the same object until either <see cref="System.Collections.IEnumerator.MoveNext" /> or <see cref="System.Collections.IEnumerator.Reset" /> is called.
 <see cref="System.Collections.IEnumerator.MoveNext" /> sets <see cref="System.Collections.IEnumerator.Current" /> to the next element.</para>
            <para>After the end of the collection is passed, the enumerator is positioned after the last element in the collection, and calling <see cref="System.Collections.IEnumerator.MoveNext" /> returns <see langword="false" />.
 If the last call to <see cref="System.Collections.IEnumerator.MoveNext" /> returned <see langword="false" />, calling <see cref="System.Collections.IEnumerator.Current" /> throws an exception.
 To set <see cref="System.Collections.IEnumerator.Current" /> to the first element of the collection again,
 you can call <see cref="System.Collections.IEnumerator.Reset" /> followed by <see cref="System.Collections.IEnumerator.MoveNext" />.</para>
            <para>An enumerator remains valid as long as the collection remains unchanged.
 If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated
 and the next call to <see cref="System.Collections.IEnumerator.MoveNext" /> or <see cref="System.Collections.IEnumerator.Reset" /> throws an <see cref="System.InvalidOperationException" />. 
 If the collection is modified between <see cref="System.Collections.IEnumerator.MoveNext" /> and <see cref="System.Collections.IEnumerator.Current" />,
 <see cref="System.Collections.IEnumerator.Current" /> returns the element that it is set to, even if the enumerator is already invalidated.</para>
            <para>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.
 Even when a collection is synchronized, other threads could still modify the collection, which causes the enumerator to throw an exception.
 To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</para>
        </remarks>
        <example>
            <para>The following code example shows how to use <see cref="System.Array.GetEnumerator" /> to list the elements of an array.</para>
            <codelink SampleID="System.Array_GetEnumerator" SnippetID="1" />
        </example>
    </doc><doc for="Array.IndexOf">
        <overload>
            <para>Returns the index of the first occurrence of a value in
      a one-dimensional <see cref="System.Array" /> or in a portion of the <see cref="System.Array" />.</para>
        </overload>
        <summary>
            <para>Searches for the specified object and returns the index of the first occurrence
   within the entire one-dimensional <see cref="System.Array" />.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to search.</param>
        <param name="value">The object to locate in <paramref name="array" />.</param>
        <returns>
            <para>The index of the first occurrence of <paramref name="value" /> within the entire <paramref name="array" />, if found; otherwise, the lower bound of the array - 1.</para>
        </returns>
        <exception cref="System.ArgumentNullException"><paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional.</exception>
        <remarks>
            <para>The one-dimensional <see cref="System.Array" /> is searched forward starting at the first element and ending at the last element.</para>
            <para>The elements are compared to the specified value using the <see cref="System.Object.Equals" qualify="true" /> method.
 If the element type is a nonintrinsic (user-defined) type, the <see langword="Equals" /> implementation of that type is used.</para>
            <para>Since most arrays will have a lower bound of zero, this method would
   generally return -1 when <paramref name="value" /> is not found.
   In the rare case that the lower bound of the array is equal to <see cref="System.Int32.MinValue" qualify="true" /> and
 <paramref name="value" /> is not found, this method returns <see cref="System.Int32.MaxValue" qualify="true" />, which 
   is <c>System.Int32.MinValue - 1</c>.</para>
        </remarks>
        <example>
            <para>The following code example shows how to determine the index of the first
      occurrence of a specified element.</para>
            <codelink SampleID="Classic Array.IndexOf Example" SnippetID="1" />
        </example>
        <seealso cref="System.Array.LastIndexOf" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.IndexOf1">
        <summary>
            <para>Searches for the specified object and returns the index of the first occurrence
   within the section of the one-dimensional <see cref="System.Array" /> that extends from the specified index to the last element.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to search.</param>
        <param name="value">The object to locate in <paramref name="array" />.</param>
        <param name="startIndex">The starting index of the search.</param>
        <returns>
            <para>The index of the first occurrence of <paramref name="value" /> within the section of <paramref name="array" /> that extends from <paramref name="startIndex" /> to the last element, if found; otherwise, the lower bound of the array - 1.</para>
        </returns>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="array" /> is <see langword="null" />. </para></exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</para></exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional.</exception>
<remarks>
            <para>The one-dimensional <see cref="System.Array" /> is searched forward starting at <paramref name="startIndex" /> and ending at the last element.</para>
            <para>The elements are compared to the specified value using the <see cref="System.Object.Equals" qualify="true" /> method.
 If the element type is a nonintrinsic (user-defined) type, the <see langword="Equals" /> implementation of that type is used.</para>
            <para>Since most arrays will have a lower bound of zero, this method would
   generally return -1 when <paramref name="value" /> is not found.
   In the rare case that the lower bound of the array is equal to <see cref="System.Int32.MinValue" qualify="true" /> and
 <paramref name="value" /> is not found, this method returns <see cref="System.Int32.MaxValue" qualify="true" />, which 
   is <c>System.Int32.MinValue - 1</c>.</para>
        </remarks>
        <example>
            <para>The following code example shows how to determine the index of the first
      occurrence of a specified element.</para>
            <codelink SampleID="Classic Array.IndexOf Example" SnippetID="1" />
        </example>
        <seealso cref="System.Array.LastIndexOf" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.IndexOf2">
        <summary>
            <para>Searches for the specified object and returns the index of the first occurrence
 within the section of the one-dimensional <see cref="System.Array" /> that starts at the specified index and contains the specified number of elements.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to search.</param>
        <param name="value">The object to locate in <paramref name="array" />.</param>
        <param name="startIndex">The starting index of the search.</param>
        <param name="count">The number of elements in the section to search.</param>
        <returns>
            <para>The index of the first occurrence of <paramref name="value" /> within the section of <paramref name="array" /> that starts
   at <paramref name="startIndex" /> and contains the number of elements specified in <paramref name="count" />, if found; otherwise, the lower bound of the array - 1.</para>
        </returns>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="array" /> is <see langword="null" />.</para></exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</para><para>-or-</para>
            <para><paramref name="count" /> is less than zero.</para><para>-or-</para>
            <para><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</para></exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional.</exception>
<remarks>
            <para>The one-dimensional <see cref="System.Array" /> is searched forward starting at <paramref name="startIndex" /> and ending at <paramref name="startIndex" /> + <paramref name="count" /> - 1.</para>
            <para>The elements are compared to the specified value using the <see cref="System.Object.Equals" qualify="true" /> method.
 If the element type is a nonintrinsic (user-defined) type, the <see langword="Equals" /> implementation of that type is used.</para>
            <para>Since most arrays will have a lower bound of zero, this method would generally return -1 when <paramref name="value" /> is not found.
 In the rare case that the lower bound of the array is equal to <see cref="System.Int32.MinValue" qualify="true" /> and
 <paramref name="value" /> is not found, this method returns <see cref="System.Int32.MaxValue" qualify="true" />, which 
 is <c>System.Int32.MinValue - 1</c>.</para>
        </remarks>
        <example>
            <para>The following code example shows how to determine the index of the first
      occurrence of a specified element.</para>
            <codelink SampleID="Classic Array.IndexOf Example" SnippetID="1" />
        </example>
        <seealso cref="System.Array.LastIndexOf" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.LastIndexOf">
        <overload>
            <para>Returns the index of the last occurrence of a value in a
      one-dimensional <see cref="System.Array" />
      or in a portion of the <see cref="System.Array" />.</para>
        </overload>
        <summary>
            <para> Searches for the specified object and returns the index of the last occurrence
 within the entire one-dimensional <see cref="System.Array" />.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to search.</param>
        <param name="value">The object to locate in <paramref name="array" />.</param>
        <returns>
            <para>The index of the last occurrence of <paramref name="value" /> within the entire <paramref name="array" />, if found; otherwise, the lower bound of the array - 1.</para>
        </returns>
        <exception cref="System.ArgumentNullException"><paramref name="array" /> is <see langword="null" />. </exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional.</exception>
        <remarks>
            <para>The one-dimensional <see cref="System.Array" /> is searched backward starting at the last element and ending at the first element.</para>
            <para>The elements are compared to the specified value using the <see cref="System.Object.Equals" qualify="true" /> method.
 If the element type is a nonintrinsic (user-defined) type, the <see langword="Equals" /> implementation of that type is used.</para>
            <para>Since most arrays will have a lower bound of zero, this method would generally return -1 when <paramref name="value" /> is not found.
 In the rare case that the lower bound of the array is equal to <see cref="System.Int32.MinValue" qualify="true" /> and
 <paramref name="value" /> is not found, this method returns <see cref="System.Int32.MaxValue" qualify="true" />, which 
 is <c>System.Int32.MinValue - 1</c>.</para>
        </remarks>
        <example>
            <para>The following code example shows how to determine the index of the last
      occurrence of a specified element in an array.</para>
            <codelink SampleID="Classic Array.LastIndexOf Example" SnippetID="1" />
        </example>
        <seealso cref="System.Array.IndexOf" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.LastIndexOf1">
        <summary>
            <para> Searches for the specified object and returns the index of the last occurrence
 within the section of the one-dimensional <see cref="System.Array" /> that extends from the first element to the specified index.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to search.</param>
        <param name="value">The object to locate in <paramref name="array" />.</param>
        <param name="startIndex">The starting index of the backward search.</param>
        <returns>
            <para>The index of the last occurrence of <paramref name="value" /> within the section of <paramref name="array" /> that extends from the first element to <paramref name="startIndex" />, if found; otherwise, the lower bound of the array - 1.</para>
        </returns>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="array" /> is <see langword="null" />.</para></exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</para></exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional.</exception>
<remarks>
            <para>The one-dimensional <see cref="System.Array" /> is searched backward starting at <paramref name="startIndex" /> and ending at the first element.</para>
            <para>The elements are compared to the specified value using the <see cref="System.Object.Equals" qualify="true" /> method.
 If the element type is a nonintrinsic (user-defined) type, the <see langword="Equals" /> implementation of that type is used.</para>
            <para>Since most arrays will have a lower bound of zero, this method would
   generally return -1 when <paramref name="value" /> is not found.
   In the rare case that the lower bound of the array is equal to <see cref="System.Int32.MinValue" qualify="true" /> and
 <paramref name="value" /> is not found, this method returns <see cref="System.Int32.MaxValue" qualify="true" />, which 
   is <c>System.Int32.MinValue - 1</c>.</para>
        </remarks>
        <example>
            <para>The following code example shows how to determine the index of the last
      occurrence of a specified element in an array.</para>
            <codelink SampleID="Classic Array.LastIndexOf Example" SnippetID="1" />
        </example>
        <seealso cref="System.Array.IndexOf" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.LastIndexOf2">
        <summary>
            <para> Searches for the specified object and returns the index of the last occurrence
 within the section of the one-dimensional <see cref="System.Array" /> that contains the specified number of elements and ends at the specified index.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to search.</param>
        <param name="value">The object to locate in <paramref name="array" />.</param>
        <param name="startIndex">The starting index of the backward search.</param>
        <param name="count">The number of elements in the section to search.</param>
        <returns>
            <para>The index of the last occurrence of <paramref name="value" /> within the section of <paramref name="array" /> that contains the number of elements specified in <paramref name="count" /> and ends at <paramref name="startIndex" />, if found; otherwise, the lower bound of the array - 1.</para>
        </returns>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="array" /> is <see langword="null" />.</para></exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</para><para>-or-</para>
            <para><paramref name="count" /> is less than zero.</para><para>-or-</para>
            <para><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</para></exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional.</exception>
<remarks>
            <para>The one-dimensional <see cref="System.Array" /> is searched backward starting at <paramref name="startIndex" /> and ending at <paramref name="startIndex" /> - <paramref name="count" /> + 1.</para>
            <para>The elements are compared to the specified value using the <see cref="System.Object.Equals" qualify="true" /> method.
 If the element type is a nonintrinsic (user-defined) type, the <see langword="Equals" /> implementation of that type is used.</para>
            <para>Since most arrays will have a lower bound of zero, this method would
   generally return -1 when <paramref name="value" /> is not found.
   In the rare case that the lower bound of the array is equal to <see cref="System.Int32.MinValue" qualify="true" /> and
 <paramref name="value" /> is not found, this method returns <see cref="System.Int32.MaxValue" qualify="true" />, which 
   is <c>System.Int32.MinValue - 1</c>.</para>
        </remarks>
        <example>
            <para> The following code example shows how to determine the index
      of the last occurrence of a specified element in an array. Note that the <see cref="System.Array.LastIndexOf" /> method is a
      backward search; therefore, <paramref name="count" /> must be less than or equal to
   (<paramref name="startIndex" /> - the lower bound of the array + 1).</para>
            <codelink SampleID="Classic Array.LastIndexOf Example" SnippetID="1" />
        </example>
        <seealso cref="System.Array.IndexOf" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.Reverse">
        <overload>
            <para>Reverses the order of the elements in a one-dimensional <see cref="System.Array" />
 or in a portion of the <see cref="System.Array" />.</para>
        </overload>
        <summary>
            <para>Reverses the sequence of the elements in the entire one-dimensional <see cref="System.Array" />.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to reverse.</param>
        <exception cref="System.ArgumentNullException"><paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional.</exception>
        <remarks>
            <para>After a call to this method, the element at
       <c>myArray[i]</c>, where <paramref name="i" /> is any index in the array, moves to
       <c>myArray[j]</c>, where <paramref name="j" /> equals <c>( myArray.Length + myArray.GetLowerBound(0) ) - ( i - myArray.GetLowerBound(0) ) - 1</c>.</para>
        </remarks>
        <example>
            <para>The following code example shows how to reverse the 
       sort of the values in an <see cref="System.Array" />.</para>
            <codelink SampleID="Classic Array.Reverse Example" SnippetID="1" />
        </example>
    </doc><doc for="Array.Reverse1">
        <summary>
            <para>Reverses the sequence of the elements in a section of the one-dimensional <see cref="System.Array" />.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to reverse.</param>
        <param name="index">The starting index of the section to reverse.</param>
        <param name="length">The number of elements in the section to reverse.</param>
        <exception cref="System.ArgumentNullException"><paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional.</exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</para><para>-or-</para>
            <para><paramref name="length" /> is less than zero.</para></exception>
        <exception cref="System.ArgumentException"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</exception>
<remarks>
            <para>After a call to this method, the element at
       <c>myArray[i]</c>, where <paramref name="i" /> is any index in the array, moves to
       <c>myArray[j]</c>, where <paramref name="j" /> equals <c>( myArray.Length + myArray.GetLowerBound(0) ) - ( i - myArray.GetLowerBound(0) ) - 1</c>.</para>
        </remarks>
        <example>
            <para>The following code example shows how to reverse the sort of the values in a 
       section of an <see cref="System.Array" />.</para>
            <codelink SampleID="Classic Array.Reverse1 Example" SnippetID="1" />
        </example>
    </doc><doc for="Array.Sort">
        <overload>
            <para>Sorts the elements in one-dimensional <see cref="System.Array" /> objects.</para>
        </overload>
        <summary>
            <para>Sorts the elements in an entire one-dimensional <see cref="System.Array" />
 using the <see cref="System.IComparable" /> interface implemented
 by each element of the <see cref="System.Array" />.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to sort.</param>
        <exception cref="System.ArgumentNullException"><paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional.</exception>
<exception cref="System.InvalidOperationException">One or more elements in <paramref name="array" /> do not implement the <see cref="System.IComparable" /> interface.</exception>
        <remarks>
            <para>Each element of <paramref name="array" /> must implement
   the <see cref="System.IComparable" /> interface to be capable of comparisons with every other
   element in <paramref name="array" />.</para>
            <para>If the sort is not successfully completed, the results are undefined.</para>
            <para>This method uses the QuickSort algorithm. This is an O(<paramref name="n" />^2) operation,
   where <paramref name="n" /> is the number of elements to sort, with an average of (theta)(<paramref name="n" />log<paramref name="n" />).</para>
            <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.
   In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <example>
            <para>The following code example shows how to sort the values
      in an <see cref="System.Array" />. Note that the result
      might vary depending on the current <see cref="System.Globalization.CultureInfo" />.</para>
            <codelink SampleID="System.Array.Sort" SnippetID="1" />
        </example>
        <seealso cref="System.IComparable" />
        <seealso cref="System.Array.BinarySearch" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.Sort1">
        <summary>
            <para>Sorts a pair of one-dimensional <see cref="System.Array" /> objects
 (one contains the keys and the other contains the corresponding items)
 based on the keys in the first <see cref="System.Array" />
 using the <see cref="System.IComparable" /> interface implemented by each key.</para>
        </summary>
        <param name="keys">The one-dimensional <see cref="System.Array" /> that contains the keys to sort.</param>
        <param name="items">
            <para>The one-dimensional <see cref="System.Array" /> that contains the items that correspond to each of the keys in the <paramref name="keys" /><see cref="System.Array" />.</para>
            <para>-or-</para>
            <para><see langword="null" /> to sort only the <paramref name="keys" /><see cref="System.Array" />.</para>
        </param>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="keys" /> is <see langword="null" />. </para></exception>
        <exception cref="System.RankException"><para>The <paramref name="keys" /><see cref="System.Array" /> is multidimensional.</para><para>-or-</para><para>The <paramref name="items" /><see cref="System.Array" /> is multidimensional.</para></exception>
        <exception cref="System.ArgumentException">
            <para><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</para><para>-or-</para>
            <para><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> does not match the length of <paramref name="items" />.</para></exception>
<exception cref="System.InvalidOperationException">One or more elements in the <paramref name="keys" /><see cref="System.Array" /> do not implement the <see cref="System.IComparable" /> interface.</exception>
<remarks>
            <para>Each key in the <paramref name="keys" /><see cref="System.Array" /> has a
   corresponding item in the <paramref name="items" /><see cref="System.Array" />. When a key is repositioned during the
   sorting, the corresponding item in the <paramref name="items" /><see cref="System.Array" /> is similarly
   repositioned. Therefore, the <paramref name="items" /><see cref="System.Array" /> is sorted according to the
   arrangement of the corresponding keys in the <paramref name="keys" /><see cref="System.Array" />.</para>
            <para>Each key in the <paramref name="keys" /><see cref="System.Array" /> must implement the <see cref="System.IComparable" />
 interface to be capable of comparisons with every other key.</para>
            <para>If the sort is not successfully completed, the results are undefined.</para>
            <para>This method uses the QuickSort algorithm. This is an O(<paramref name="n" />^2) operation,
   where <paramref name="n" /> is the number of elements to sort, with an average of (theta)(<paramref name="n" />log<paramref name="n" />).</para>
            <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.
   In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <example>
            <codelink SampleID="System.Array.Sort2" SnippetID="1" />
        </example>
        <seealso cref="System.IComparable" />
        <seealso cref="System.Array.BinarySearch" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.Sort2">
        <summary>
            <para>Sorts the elements in a section of a one-dimensional <see cref="System.Array" />
 using the <see cref="System.IComparable" /> interface implemented
 by each element of the <see cref="System.Array" />.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to sort.</param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <exception cref="System.ArgumentNullException"><paramref name="array" /> is <see langword="null" />. </exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional. </exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</para><para>-or-</para>
            <para><paramref name="length" /> is less than zero.</para></exception>
        <exception cref="System.ArgumentException"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</exception>
<exception cref="System.InvalidOperationException">One or more elements in <paramref name="array" /> do not implement the <see cref="System.IComparable" /> interface.</exception>
<remarks>
            <para>Each element within the specified section of
   <paramref name="array" /> must implement the <see cref="System.IComparable" /> interface to be capable of comparisons
      with every other element in <paramref name="array" />.</para>
            <para>If the sort is not successfully completed, the results are undefined.</para>
            <para>This method uses the QuickSort algorithm. This is an O(<paramref name="n" />^2) operation,
   where <paramref name="n" /> is the number of elements to sort, with an average of (theta)(<paramref name="n" />log<paramref name="n" />).</para>
            <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.
   In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <example>
            <codelink SampleID="System.Array.Sort" SnippetID="1" />
        </example>
        <seealso cref="System.IComparable" />
        <seealso cref="System.Array.BinarySearch" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.Sort3">
        <summary>
            <para>Sorts a section of a pair of one-dimensional <see cref="System.Array" /> objects
 (one contains the keys and the other contains the corresponding items)
 based on the keys in the first <see cref="System.Array" />
 using the <see cref="System.IComparable" /> interface implemented by each key.</para>
        </summary>
        <param name="keys">The one-dimensional <see cref="System.Array" /> that contains the keys to sort.</param>
        <param name="items">The one-dimensional <see cref="System.Array" /> that contains the items that correspond to each of the keys in the <paramref name="keys" /><see cref="System.Array" />. <para>-or-</para><para><see langword="null" /> to sort only the <paramref name="keys" /><see cref="System.Array" />.</para></param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="keys" /> is <see langword="null" />.</para></exception>
        <exception cref="System.RankException"><para>The <paramref name="keys" /><see cref="System.Array" /> is multidimensional.</para><para>-or-</para>
            <para><paramref name="items" /> is not <see langword="null" /> and is multidimensional.</para></exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</para><para>-or-</para>
            <para><paramref name="length" /> is less than zero.</para></exception>
        <exception cref="System.ArgumentException">
            <para><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</para><para>-or-</para>
            <para><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> does not match the length of <paramref name="items" />.</para><para>-or-</para>
            <para><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="System.Array" />. </para><para>-or- </para>
            <para><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="System.Array" />. </para></exception>
<exception cref="System.InvalidOperationException">One or more elements in the <paramref name="keys" /><see cref="System.Array" /> do not implement the <see cref="System.IComparable" /> interface.</exception>
<remarks>
            <para>Each key in the <paramref name="keys" /><see cref="System.Array" /> has a corresponding item in the <paramref name="items" /><see cref="System.Array" />. When a key is
   repositioned during the sorting, the corresponding item in the <paramref name="items" /><see cref="System.Array" /> is
   similarly repositioned. Therefore, the <paramref name="items" /><see cref="System.Array" /> is sorted according to the arrangement
   of the corresponding keys in the <paramref name="keys" /><see cref="System.Array" />.</para>
            <para>Each key within the specified section of the <paramref name="keys" /><see cref="System.Array" /> must implement
 the <see cref="System.IComparable" />
 interface to be capable of comparisons with every other key.</para>
            <para>If the sort is not successfully completed, the results are undefined.</para>
            <para>This method uses the QuickSort algorithm. This is an O(<paramref name="n" />^2) operation,
   where <paramref name="n" /> is the number of elements to sort, with an average of (theta)(<paramref name="n" />log<paramref name="n" />).</para>
            <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.
   In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <example>
            <codelink SampleID="System.Array.Sort2" SnippetID="1" />
        </example>
        <seealso cref="System.IComparable" />
        <seealso cref="System.Array.BinarySearch" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.Sort4">
        <summary>
            <para>Sorts the elements in a one-dimensional <see cref="System.Array" /> using the specified <see cref="System.Collections.IComparer" /> interface.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to sort.</param>
        <param name="comparer">
            <para>The <see cref="System.Collections.IComparer" /> implementation to use when comparing elements.</para>
            <para> -or-</para>
            <para><see langword="null" /> to use the <see cref="System.IComparable" /> implementation of each element.</para>
        </param>
        <exception cref="System.ArgumentNullException"><paramref name="array" /> is <see langword="null" />. </exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional. </exception>
        <exception cref="System.InvalidOperationException"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="System.IComparable" /> interface.</exception>
        <remarks>
            <para>If <paramref name="comparer" /> is <see langword="null" />, each element of <paramref name="array" />
 must implement the <see cref="System.IComparable" /> interface to be capable of comparisons with every other
 element in <paramref name="array" />.</para>
            <para>If the sort is not successfully completed, the results are undefined.</para>
            <para>This method uses the QuickSort algorithm. This is an O(<paramref name="n" />^2) operation,
   where <paramref name="n" /> is the number of elements to sort, with an average of (theta)(<paramref name="n" />log<paramref name="n" />).</para>
            <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.
   In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <example>
            <codelink SampleID="System.Array.Sort" SnippetID="1" />
        </example>
        <seealso cref="System.Collections.IComparer" />
        <seealso cref="System.IComparable" />
        <seealso cref="System.Array.BinarySearch" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.Sort5">
        <summary>
            <para>Sorts a pair of one-dimensional <see cref="System.Array" /> objects
 (one contains the keys and the other contains the corresponding items)
 based on the keys in the first <see cref="System.Array" />
 using the specified <see cref="System.Collections.IComparer" /> interface.</para>
        </summary>
        <param name="keys">The one-dimensional <see cref="System.Array" /> that contains the keys to sort.</param>
        <param name="items">
            <para>The one-dimensional <see cref="System.Array" /> that contains the items that correspond to each of the keys in the <paramref name="keys" /><see cref="System.Array" />.</para>
            <para>-or-</para>
            <para><see langword="null" /> to sort only the <paramref name="keys" /><see cref="System.Array" />.</para>
        </param>
        <param name="comparer">
            <para>The <see cref="System.Collections.IComparer" /> implementation to use when comparing elements.</para>
            <para>-or-</para>
            <para><see langword="null" /> to use the <see cref="System.IComparable" /> implementation of each element.</para>
        </param>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="keys" /> is <see langword="null" />.</para></exception>
        <exception cref="System.RankException"><para>The <paramref name="keys" /><see cref="System.Array" /> is multidimensional.</para><para>-or-</para><para>The <paramref name="items" /><see cref="System.Array" /> is multidimensional.</para></exception>
        <exception cref="System.ArgumentException">
            <para><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</para><para>-or-</para>
            <para><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> does not match the length of <paramref name="items" />.</para></exception>
        <exception cref="System.InvalidOperationException"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="System.Array" /> do not implement the <see cref="System.IComparable" /> interface.</exception>
<remarks>
            <para>Each key in the <paramref name="keys" /><see cref="System.Array" /> has a corresponding item in the <paramref name="items" /><see cref="System.Array" />. When a key is
   repositioned during the sorting, the corresponding item in the <paramref name="items" /><see cref="System.Array" /> is
   similarly repositioned. Therefore, the <paramref name="items" /><see cref="System.Array" /> is sorted according to the arrangement
   of the corresponding keys in the <paramref name="keys" /><see cref="System.Array" />.</para>
            <para>If <paramref name="comparer" /> is <see langword="null" />, each
 key in the <paramref name="keys" /><see cref="System.Array" /> must implement the <see cref="System.IComparable" /> interface to be capable of comparisons
 with every other key.</para>
            <para>If the sort is not successfully completed, the results are undefined.</para>
            <para>This method uses the QuickSort algorithm. This is an O(<paramref name="n" />^2) operation,
   where <paramref name="n" /> is the number of elements to sort, with an average of (theta)(<paramref name="n" />log<paramref name="n" />).</para>
            <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.
   In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <example>
            <codelink SampleID="System.Array.Sort2" SnippetID="1" />
        </example>
        <seealso cref="System.Collections.IComparer" />
        <seealso cref="System.IComparable" />
        <seealso cref="System.Array.BinarySearch" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.Sort6">
        <summary>
            <para>Sorts the elements in a section of a one-dimensional <see cref="System.Array" />
 using the specified <see cref="System.Collections.IComparer" /> interface.</para>
        </summary>
        <param name="array">The one-dimensional <see cref="System.Array" /> to sort.</param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <param name="comparer">
            <para>The <see cref="System.Collections.IComparer" /> implementation to use when comparing elements.</para>
            <para>-or-</para>
            <para><see langword="null" /> to use the <see cref="System.IComparable" /> implementation of each element. </para>
        </param>
        <exception cref="System.ArgumentNullException"><paramref name="array" /> is <see langword="null" />. </exception>
        <exception cref="System.RankException"><paramref name="array" /> is multidimensional. </exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</para><para>-or-</para>
            <para><paramref name="length" /> is less than zero.</para></exception>
        <exception cref="System.ArgumentException"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />. </exception>
        <exception cref="System.InvalidOperationException"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="System.IComparable" /> interface.</exception>
<remarks>
            <para>If <paramref name="comparer" /> is <see langword="null" />, each element within the
   specified section of <paramref name="array" /> must implement the <see cref="System.IComparable" /> interface
   to be capable of comparisons with every other element in <paramref name="array" />.</para>
            <para>If the sort is not successfully completed, the results are undefined.</para>
            <para>This method uses the QuickSort algorithm. This is an O(<paramref name="n" />^2) operation,
   where <paramref name="n" /> is the number of elements to sort, with an average of (theta)(<paramref name="n" />log<paramref name="n" />).</para>
            <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.
   In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <example>
            <codelink SampleID="System.Array.Sort" SnippetID="1" />
        </example>
        <seealso cref="System.Collections.IComparer" />
        <seealso cref="System.IComparable" />
        <seealso cref="System.Array.BinarySearch" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.Sort7">
        <summary>
            <para>Sorts a section of a pair of one-dimensional <see cref="System.Array" /> objects
 (one contains the keys and the other contains the corresponding items)
 based on the keys in the first <see cref="System.Array" />
 using the specified <see cref="System.Collections.IComparer" /> interface.</para>
        </summary>
        <param name="keys">The one-dimensional <see cref="System.Array" /> that contains the keys to sort.</param>
        <param name="items">
            <para>The one-dimensional <see cref="System.Array" /> that contains the items that correspond to each of the keys in the <paramref name="keys" /><see cref="System.Array" />.</para>
            <para>-or-</para>
            <para><see langword="null" /> to sort only the <paramref name="keys" /><see cref="System.Array" />.</para>
        </param>
        <param name="index">The starting index of the range to sort.</param>
        <param name="length">The number of elements in the range to sort.</param>
        <param name="comparer">
            <para>The <see cref="System.Collections.IComparer" /> implementation to use when comparing elements.</para>
            <para>-or-</para>
            <para><see langword="null" /> to use the <see cref="System.IComparable" /> implementation of each element. </para>
        </param>
        <exception cref="System.ArgumentNullException">
            <para><paramref name="keys" /> is <see langword="null" />.</para></exception>
        <exception cref="System.RankException"><para>The <paramref name="keys" /><see cref="System.Array" /> is multidimensional.</para><para>-or-</para>
            <para><paramref name="items " /> is not <see langword="null" /> and is multidimensional.</para></exception>
        <exception cref="System.ArgumentOutOfRangeException">
            <para><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</para><para>-or-</para>
            <para><paramref name="length" /> is less than zero.</para></exception>
        <exception cref="System.ArgumentException">
            <para><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</para><para>-or-</para>
            <para><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> does not match the length of <paramref name="items" />.</para><para>-or-</para>
            <para><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="System.Array" />. </para><para>-or-</para>
            <para><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="System.Array" />.</para></exception>
        <exception cref="System.InvalidOperationException"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="System.Array" /> do not implement the <see cref="System.IComparable" /> interface.</exception>
<remarks>
            <para>Each key in the <paramref name="keys" /><see cref="System.Array" /> has a corresponding item in the <paramref name="items" /><see cref="System.Array" />. When a key is
   repositioned during the sorting, the corresponding item in the <paramref name="items" /><see cref="System.Array" /> is
   similarly repositioned. Therefore, the <paramref name="items" /><see cref="System.Array" /> is sorted according to the arrangement
   of the corresponding keys in the <paramref name="keys" /><see cref="System.Array" />.</para>
            <para>If <paramref name="comparer" /> is <see langword="null" />, each key within the specified
 section of the <paramref name="keys" /><see cref="System.Array" /> must implement the <see cref="System.IComparable" /> interface to be capable of comparisons
 with every other key.</para>
            <para>If the sort is not successfully completed, the results are undefined.</para>
            <para>This method uses the QuickSort algorithm. This is an O(<paramref name="n" />^2) operation,
   where <paramref name="n" /> is the number of elements to sort, with an average of (theta)(<paramref name="n" />log<paramref name="n" />).</para>
            <para>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.
   In contrast, a stable sort preserves the order of elements that are equal.</para>
        </remarks>
        <example>
            <codelink SampleID="System.Array.Sort2" SnippetID="1" />
        </example>
        <seealso cref="System.Collections.IComparer" />
        <seealso cref="System.IComparable" />
        <seealso cref="System.Array.BinarySearch" />
        <seealso topic="cpconperformingculture-insensitivestringoperationsinarrays" />
    </doc><doc for="Array.Initialize">
        <summary>
            <para>Initializes every element of the value-type <see cref="System.Array" />
 by calling the default constructor of the value type.</para>
        </summary>
        <remarks>
            <para>This method is designed to help compilers support value-type arrays; most users do not need this method.
 It must not be used on reference-type arrays.</para>
            <para>If the <see cref="System.Array" /> is not a value-type <see cref="System.Array" /> or if the value type does not have a
   default constructor, the <see cref="System.Array" /> is not modified.</para>
            <para>The value-type <see cref="System.Array" /> can have any lower bound and any number of dimensions.</para>
            <note type="caution">
   You can use this method only on value types that have constructors; however, value types that are
   native to C# do not have constructors.
            </note>
        </remarks>
    </doc>
</docs>
