// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
//
// Author: ddriver
// Date: April 2000
//

// #define _TRACE_STACKS
// #define _DEBUG_PERF

using System.EnterpriseServices;
using System.Runtime.InteropServices;

namespace System.EnterpriseServices
{
    using System;
    using System.Diagnostics;
    using System.Reflection;
    using System.IO;
    using System.Collections;
    using Microsoft.Win32;
    using System.EnterpriseServices.Admin;
    using System.Runtime.Serialization;
    using System.Security;
    using System.Security.Permissions;
    using System.Globalization;
    
    // Default registration expects the application to already exist.
    /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags"]/*' />
    [Flags, Serializable]
    public enum InstallationFlags
    {
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.Default"]/*' />
        Default                        = 0x000,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.ExpectExistingTypeLib"]/*' />
        ExpectExistingTypeLib          = 0x001,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.CreateTargetApplication"]/*' />
        CreateTargetApplication        = 0x002,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.FindOrCreateTargetApplication"]/*' />
        FindOrCreateTargetApplication  = 0x004,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.ReconfigureExistingApplication"]/*' />
        ReconfigureExistingApplication = 0x008,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.ConfigureComponentsOnly"]/*' />
        ConfigureComponentsOnly        = 0x010,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.ReportWarningsToConsole"]/*' />
        ReportWarningsToConsole        = 0x020,

        // If none of Register, Install, or Configure are specified,
        // then all are performed.  If any one is specified, only the ones
        // specified are performed.
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.Register"]/*' />
        Register                      = 0x100,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.Install"]/*' />
        Install                       = 0x200,
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="InstallationFlags.Configure"]/*' />
        Configure                     = 0x400,
    }

    [Flags, Serializable]
    internal enum ClassTypes
    {
        Event  = 0x1,
        Normal = 0x2,
        All    = Event|Normal,
    }

    [InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    [Guid("04C6BE1E-1DB1-4058-AB7A-700CCCFBF254")]
    [ComImport]
    internal interface ICatalogServices
    {
        [AutoComplete(true)]
        void Autodone();
        [AutoComplete(false)]
        void NotAutodone();
    }

    /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationErrorInfo"]/*' />

    //
    // The registration helper allows the user to grab an assembly, and do
    // all the steps necessary to get it configured based on its metadata.
    // In theory, all these steps should be transactional:
    //
    // Exception Rules:
    //     We throw RegistrationExceptions.  For the most part, these
    //     exceptions are simply specializations of corresponding COM
    //     exceptions.  When the COMException is generated by the catalog,
    //     we gather up the ErrorInfo collection, and package it into
    //     the RegistrationException.

    [Serializable]
    public sealed class RegistrationErrorInfo
    {
        private String _majorRef;
        private String _minorRef;
        private String _name;
        private int    _errorCode;
        private String _errorString;

        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationErrorInfo.MajorRef"]/*' />
        public String MajorRef    { get { return(_majorRef); } }
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationErrorInfo.MinorRef"]/*' />
        public String MinorRef    { get { return(_minorRef); } }
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationErrorInfo.Name"]/*' />
        public String Name        { get { return(_name); } }
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationErrorInfo.ErrorCode"]/*' />
        public int    ErrorCode   { get { return(_errorCode); } }
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationErrorInfo.ErrorString"]/*' />
        public String ErrorString { get { return(_errorString); } }

        internal RegistrationErrorInfo(String majorRef, String minorRef, 
                                     String name, int errorCode)
        {
            _majorRef  = majorRef;
            _minorRef  = minorRef;
            _name      = name;
            _errorCode = errorCode;
              
            if(_majorRef == null) _majorRef = "";
            if(_minorRef == null) _minorRef = "<invalid>";
            // Calculate an error string off of the errorcode:
            _errorString = Util.GetErrorString(_errorCode);
            if(_errorString == null)
            {
                _errorString = Resource.FormatString("Err_UnknownHR", _errorCode);
            }
        }
    }

    /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationException"]/*' />
    [Serializable]
    public sealed class RegistrationException : SystemException
    {
        private RegistrationErrorInfo[] _errorInfo;

        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationException.RegistrationException"]/*' />
        public RegistrationException(String msg)
          : base(msg)
        {
            _errorInfo = null;
        }

        internal RegistrationException(String msg, Exception inner)
          : base(msg, inner)
        {
            _errorInfo = null;
        }

        internal RegistrationException(String msg,
                                       RegistrationErrorInfo[] errorInfo)
          : base(msg)
        {
            _errorInfo = errorInfo;
        }

        internal RegistrationException(String msg,
                                       RegistrationErrorInfo[] errorInfo,
                                       Exception inner)
          : base(msg, inner)
        {
            _errorInfo = errorInfo;
        }

        internal RegistrationException(SerializationInfo info, StreamingContext context) 
          : base(info, context) 
        {
            try {           // work around URT bug #61954
                _errorInfo = (RegistrationErrorInfo[])(info.GetValue("RegistrationException._errorInfo", typeof(RegistrationErrorInfo[])));
            }
            catch (SerializationException)
            {
                _errorInfo = null;
            }
        }

        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext ctx)
        {
            if(info == null) throw new ArgumentException("info");
            
            // Call the parent serializer:
            base.GetObjectData(info, ctx);

            // Shove the error-info array in:
            if (_errorInfo != null)     // work around URT bug #61954
                info.AddValue("RegistrationException._errorInfo", _errorInfo, typeof(RegistrationErrorInfo[]));
        }
        /// <include file='doc\RegistrationHelper.uex' path='docs/doc[@for="RegistrationException.ErrorInfo"]/*' />
        public RegistrationErrorInfo[] ErrorInfo { get { return(_errorInfo); } }
    }

    internal delegate void Report(String msg);    

    internal class RegistrationExporterNotifySink : ITypeLibExporterNotifySink
    {
        private String                     _tlb;
        // Should this really be a RegistrationHelperTx object, in case
        // we go out of context in the TypeLibExporter?  probably.
        // I'm going to ignore that for now, because the TypeLibExport
        // code isn't covered by our transaction right now.
        private Report _report;

        internal RegistrationExporterNotifySink(String tlb, Report report)
        {
            _tlb    = tlb;
            _report = report;
        }

        public void ReportEvent(ExporterEventKind EventKind, int EventCode, String EventMsg)
        {
            // What do we do here?  We should be able to specify a verbosity flag.
            // Or, we try to 
            DBG.Info(DBG.Registration, EventMsg);
            if(EventKind != ExporterEventKind.NOTIF_TYPECONVERTED && _report != null)
            {
                _report(EventMsg);
            }
        }

        public Object ResolveRef(Assembly asm)
        {
            UCOMITypeLib rslt = null;
            String asmPath = Path.GetDirectoryName(asm.Location);
            
            String typeLibName = Path.Combine(asmPath, asm.GetName().Name) + ".tlb";

            DBG.Info(DBG.Registration, "Auto exporting type library for asm: " + asm);
            
            if (_report != null)
                _report(Resource.FormatString("Reg_AutoExportMsg", asm.GetName(), typeLibName));
            
            rslt = (UCOMITypeLib)(RegistrationDriver.GenerateTypeLibrary(asm, typeLibName, _report));

            // TODO:  Add this to a list of changes which should be backed
            // out if this fails.

            return(rslt);
        }
    }

    [ComImport]
    [Guid("00020406-0000-0000-C000-000000000046")]
    [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
    internal interface ICreateTypeLib
    {
        [return : MarshalAs(UnmanagedType.Interface)]
        Object CreateTypeInfo([In, MarshalAs(UnmanagedType.LPStr)] String szName,
                              int tkind);
        
        
        void SetName(String szName);
        
        void SetVersion(short wMajorVerNum, short wMinorVerNum);
        
        void SetGuid([In, MarshalAs(UnmanagedType.LPStruct)] Guid guid);
        
        void SetDocString([In, MarshalAs(UnmanagedType.LPStr)] String szDoc);
        
        void SetHelpFileName([In, MarshalAs(UnmanagedType.LPStr)] String szHelpFileName);
        
        void SetHelpContext(int dwHelpContext);
        
        void SetLcid(int lcid);
        
        void SetLibFlags(int uLibFlags);
        
        void SaveAllChanges();
    }

    internal class ApplicationSpec
    {
        RegistrationConfig _regConfig;        		
        private Assembly   _asm;
        private Type[]     _events;
        private Type[]     _normal;
        private Type[]     _cfgtypes;
        private String     _appid;
        
        internal ApplicationSpec(Assembly asm, RegistrationConfig regConfig)
        {
            _asm = asm;
            _regConfig = regConfig;            

            // Generate an application name from the assembly.
            // Get an ID from the assembly.
            GenerateNames();
            ReadTypes();
        }
        
        internal String Partition 
		{	
			get { return _regConfig.Partition; } 
			set { _regConfig.Partition = value; }
		}
        internal String Name 
        { 
            get { return _regConfig.Application;  } 
            set { _regConfig.Application = value;	  } 
        }
        internal String ID			{ get { return _appid; } }
        internal String TypeLib		{ get { return _regConfig.TypeLibrary; } }
        internal String File		{ get { return _regConfig.AssemblyFile; } }
        internal String AppRootDir  { get { return _regConfig.ApplicationRootDirectory; } }
        internal Assembly Assembly	{ get { return(_asm); } }
        
        internal Type[] EventTypes	{ get { return(_events); } }
        internal Type[] NormalTypes	{ get { return(_normal); } }
        internal Type[] ConfigurableTypes { get { return(_cfgtypes); } }
        
        internal String DefinitiveName 
        {
            get
            {
                if(ID != null) 
					return ID;
                else 
					return Name;
            }
        }
        
        private String FormatApplicationName(Assembly asm)
        {
            String realName = null;
            Object[] attr = asm.GetCustomAttributes(typeof(ApplicationNameAttribute), true);
            if(attr.Length > 0)
            {
                // Get the application name from the Name attribute:
                realName = (String)(((ApplicationNameAttribute)(attr[0])).Value);
                DBG.Info(DBG.Registration, "Attribute name = " + realName);
            }
            else
            {           
                realName = asm.GetName().Name;

                DBG.Info(DBG.Registration, "Generated name \"" + realName + "\" for \"" + asm.FullName + "\"");
            }
            return(realName);
        }
        
        private void GenerateNames()
        {                        
            if(_regConfig.TypeLibrary == null || _regConfig.TypeLibrary.Length == 0)
            {
                String strDir = System.IO.Path.GetDirectoryName(File);
                _regConfig.TypeLibrary = Path.Combine(strDir, _asm.GetName().Name + ".tlb");
            }
            else
            {
                _regConfig.TypeLibrary = Path.GetFullPath(_regConfig.TypeLibrary);
            }

			// Check if name is really an ID.            
            if(Name != null && Name.Length != 0 && '{' == Name[0])
			{
                _appid = "{" + (new Guid(Name)) + "}";
				Name = null;
			}

            if(Name == null || Name.Length == 0)
            {
                // We should strip out the version number, because
                // versions aren't going to work "correctly" anyway.
                // Right?                
                Name		= FormatApplicationName(_asm);
            }
            
            // If there's an ID embedded in the assembly, use that
            // to generate our ID, if not, then we use the NAME
            // as the definitive search item.
            Object[] attr = _asm.GetCustomAttributes(typeof(ApplicationIDAttribute), true);
            if(attr.Length > 0)
            {
                ApplicationIDAttribute a = (ApplicationIDAttribute)(attr[0]);
                _appid = "{" + (new Guid(a.Value.ToString())).ToString() + "}";
            }
            
            // TODO:  Should we use the assembly GUID?  Not a Guid attribute,
            // but a Marshal.GenerateGuidForType type of guid?
        }
        
        public bool Matches(ICatalogObject obj)
        {
            if(ID != null) // Match by ID
            {
                Guid id = new Guid(ID);
                Guid objid = new Guid((String)(obj.GetValue("ID")));
                DBG.Info(DBG.Registration, "Comparing ID with: " + objid);
                if(id == objid)
				{
					/*
					// Make sure the name is in sync with the one from the real app.
					String name = (String)(obj.GetValue("Name"));
					if (0 != String.Compare(this.Name, name, true))
						this.Name = name;
					*/

					return(true);
				}
            }
            else // Match by name
            {
                String name = ((String)(obj.GetValue("Name"))).ToLower(CultureInfo.InvariantCulture);
                DBG.Info(DBG.Registration, "Comparing name with: " + name);
                if(this.Name.ToLower(CultureInfo.InvariantCulture) == name) return(true);
            }
            return(false);
        }
        
        public override String ToString()
        {
            // If we've got an ID, display the ID:
            if(ID != null)
            {
                return("id=" + ID);
            }
            else
            {
                return("name=" + Name);
            }
        }
        
        private void ReadTypes()
        {
            ArrayList eventList = new ArrayList();
            ArrayList normalList = new ArrayList();
            Type[] regTypes = new RegistrationServices().GetRegistrableTypesInAssembly(_asm);
            
            foreach(Type t in regTypes)
            {
                // A type is configurable if it is a ServicedComponent
                if (ServicedComponentInfo.IsTypeServicedComponent(t))
                {
                    Object[] attr = t.GetCustomAttributes(typeof(EventClassAttribute), true);
                    if(attr != null && attr.Length > 0)
                    {
                        eventList.Add(t);
                    }
                    else // Normal type
                    {
                        normalList.Add(t);
                    }
                }
            }
            
            if(eventList.Count > 0)
            {
                _events = new Type[eventList.Count];
                eventList.CopyTo(_events);
            }
            else _events = null;
            
            if(normalList.Count > 0)
            {
                _normal = new Type[normalList.Count];
                normalList.CopyTo(_normal);
            }
            else _normal = null;
            
            int total = (((_normal != null)?_normal.Length:0) 
                         + ((_events != null)?_events.Length:0));
            if(total > 0)
            {
                _cfgtypes = new Type[total];
                if(_events != null) _events.CopyTo(_cfgtypes, 0);
                if(_normal != null) _normal.CopyTo(_cfgtypes, total-_normal.Length);
            }            
        }
    }
    
    internal class RegistrationDriver
    {                                                  
        private ICatalog           _cat;
        private IMtsCatalog        _mts;
        private ICatalogCollection _appColl;
        private Hashtable          _cache;
        private InstallationFlags  _installFlags;
        
        // private RollbackEngine     _rollback;

#if _DEBUG_PERF
        private static int       _saveCount;
        private static int       _popCount;
        private static Hashtable _counts;
#endif        
        internal static void SaveChanges(ICatalogCollection coll)
        {
#if _DEBUG_PERF
            if(_counts == null) _counts = new Hashtable();

            DBG.Info(DBG.Perf, "PERF:  SaveChanges(): " + (++_saveCount)
#if _TRACE_STACKS
                     + new System.Diagnostics.StackTrace().ToString()
#endif
                       );
            if(_counts[coll] == null)
            {
                _counts[coll] = 1;
            }
            else
            {
                int i = ((int)(_counts[coll])) + 1;
                _counts[coll] = i;
                DBG.Assert(i <= 3, "No collection should be saved more than 3 times!");
            }
#endif
            coll.SaveChanges();
        }
        
        internal static void Populate(ICatalogCollection coll)
        {
#if _DEBUG_PERF
            DBG.Info(DBG.Perf, "PERF:  Populate(): " + (++_popCount)
#if _TRACE_STACKS
                     + new System.Diagnostics.StackTrace().ToString()
#endif
                       );
#endif
            try { coll.Populate(); }
            catch(COMException e)
            {
                DBG.Info(DBG.Registration, "Populate caught exception: " + e);
                if(e.ErrorCode != Util.COMADMIN_E_OBJECTERRORS) throw;
            }
            // we just fall through if it was OBJECTERRORS, because the contract
            // says to ignore that problem.
            // TODO:  Feed this back as warnings to regsvcs?
        }
        
        private static RegistrationErrorInfo[] BuildErrorInfoChain(ICatalogCollection coll)
        {
            try {
                Populate(coll);
                int count = coll.Count();
                RegistrationErrorInfo[] errors = null;
                
                if(count > 0) {
                    errors = new RegistrationErrorInfo[count];
                    
                    for(int i = 0; i < count; i++)
                    {
                        String majorRef = null;
                        String minorRef = null;
                        String name;
                        int errorCode = 0;
                        ICatalogObject obj = (ICatalogObject)(coll.Item(i));
                        name      = (String)(obj.GetValue("Name"));
                        errorCode = (int)(obj.GetValue("ErrorCode"));
                        // More info if we're on W2K or above:
                        if(!Platform.IsLessThan(Platform.W2K))
                        {
                            majorRef  = (String)(obj.GetValue("MajorRef"));
                            minorRef  = (String)(obj.GetValue("MinorRef"));
                        }
                        errors[i] = new RegistrationErrorInfo(majorRef, minorRef, name, errorCode);
                    }
                }
                return(errors);
            }
            catch(Exception e)
            {
                throw new RegistrationException(Resource.FormatString("Reg_ErrCollectionErr"), e);
            }
        }

        private static void RegisterTypeLibrary(String tlb)
        {
            // REGKIND_REGISTER = 1
            IntPtr pptlib = (IntPtr)0;
            tlb = Path.GetFullPath(tlb);
            int hr = Util.LoadTypeLibEx(tlb, 1, out pptlib);
            if(hr < 0 || pptlib == (IntPtr)0) {
                Exception e = Util.GetExceptionForHR(hr);
                throw new RegistrationException(Resource.FormatString("Reg_TypeLibRegErr", tlb), e);
            }
            hr = Util.RegisterTypeLib(pptlib, tlb, Path.GetDirectoryName(tlb));
            if(hr < 0 || pptlib == (IntPtr)0) {
                Exception e = Util.GetExceptionForHR(hr);
                throw new RegistrationException(Resource.FormatString("Reg_TypeLibRegErr", tlb), e);
            }
            Marshal.Release(pptlib);
        }
        
        private RegistrationException WrapCOMException(ICatalogCollection coll,
                                                       COMException e, 
                                                       String msg)
        {
            DBG.Assert(_cat != null || _mts != null, "Wrapping COM exception w/ no catalog!");
            RegistrationErrorInfo[] errorInfo = null;
            if(e.ErrorCode == Util.COMADMIN_E_OBJECTERRORS) 
            {
                ICatalogCollection errors = null;
                if(coll == null)
                {
                    errors = (ICatalogCollection)_cat.GetCollection("ErrorInfo");
                }
                else
                {
                    errors = (ICatalogCollection)coll.GetCollection("ErrorInfo", "");
                }
                if(errors != null)
                {
                    errorInfo = BuildErrorInfoChain(errors);
                }
            }
            return new RegistrationException(msg, errorInfo);
        }

        internal void ReportWarning(String msg)
        {
            if((_installFlags & InstallationFlags.ReportWarningsToConsole) != 0)
            {
                Console.WriteLine(msg);
            }
        }

        /*

        public static bool IsV1Assembly(Assembly asm)
        {
            AssemblyName[] anames = asm.GetReferencedAssemblies();
            foreach (AssemblyName an in anames)
            {
                if (an.Name.Equals("mscorlib"))
                {		
                    Version v = an.Version;
                    if ((v.Major == 1) && (v.Minor ==0) && (v.Build==3300))
                        return true;
                    else
                        return false;
                 }
            }
            return false;         // more secure default, assume it is a newer assembly
        }
		
        // We now mandate that every assembly has to make a statement about security one way or another (on or off)
        // see COM+ 30749
        public void CheckAssemblySecurity(Assembly asm)
        {
            if (IsV1Assembly(asm))       // for backcompat, we let V1 assemblies through without any security checks
                return;

            // Only server apps need to have their security checked
			
            // absence of this attribute means it is a library app
            Object[] appattr = asm.GetCustomAttributes(typeof(ApplicationActivationAttribute), true);
            if(appattr.Length == 0)
                return;
            
            ApplicationActivationAttribute aaa = (ApplicationActivationAttribute) appattr[0];
            if (aaa.Value == ActivationOption.Library)   // if explicitly a library app, just return
                return;
            
            // new (post V1) assemblies, must make a statement about security, i.e. the attribute must be in the assembly
            Object[] attr = asm.GetCustomAttributes(typeof(ApplicationAccessControlAttribute), true);
            if(attr.Length > 0)
                return;

            // otherwise, through a security exception			
            throw new RegistrationException(Resource.FormatString("Reg_NoApplicationSecurity"));
        }
        */
        
        // checks if the assembly has a app-security attribute.  If not, report a warning.
        // v1.1 has different defaults (on) than v1.0, so a warning should help users figure out whats going on
        public void CheckForAppSecurityAttribute(Assembly asm)
        {            
            Object[] attr = asm.GetCustomAttributes(typeof(ApplicationAccessControlAttribute), true);
            if(attr.Length > 0)
                return;

            ReportWarning(Resource.FormatString("Reg_NoApplicationSecurity"));								
        }

        // Checks that all ServicedComponent-derived classes in an assembly are valid (i.e. would get Registered).
        // returns false if any classes are invalid
        public void CheckAssemblySCValidity(Assembly asm)
        {
            Type[] asmTypes = asm.GetTypes();
            bool bValid = true;
            ArrayList errorInfoList = null;
            RegistrationServices rs = new RegistrationServices();
            
            
            foreach(Type t in asmTypes)
            {
                if (t.IsClass && t.IsSubclassOf(typeof(ServicedComponent)))
                {
                    if (rs.TypeRequiresRegistration(t)==false && !t.IsAbstract)
                    {
                        bValid = false;
                        
                        if (errorInfoList==null)
                            errorInfoList = new ArrayList();
                        
                        RegistrationErrorInfo ei = new RegistrationErrorInfo(null, null, t.ToString(), unchecked((int)0x80004005));	// E_FAIL
                        errorInfoList.Add(ei);				
                    }

                    MethodInfo[] methods = t.GetMethods();
                    foreach(MethodInfo m in methods)
                    {
                        if(ServicedComponentInfo.IsMethodAutoDone(m)
                           && !ServicedComponentInfo.HasClassInterface(t))
                        {
                            ReportWarning(Resource.FormatString("Reg_NoClassInterface", t.FullName));
                            break;
                        }
                    }
                }
            }
            
            if (!bValid)
            {
                RegistrationErrorInfo[] errorInfo = (RegistrationErrorInfo[]) errorInfoList.ToArray(typeof(RegistrationErrorInfo));
                throw new RegistrationException(Resource.FormatString("Reg_InvalidServicedComponents"), errorInfo);
            }
        }

        // checks to see if the assembly has a strong name
        // by checking for a public key token
        // 
        internal bool AssemblyHasStrongName(Assembly asm)
        {
        AssemblyName an = asm.GetName();

        return (an.GetPublicKeyToken() != null);
        }

    internal Assembly NewLoadAssembly(String assembly)
    {
        Assembly asm;
        
        DBG.Info(DBG.Registration, "NewLoadAssembly: AssemblyName = " + assembly);
        
        try {
            // this will throw a FileNotFoundException if the assembly is not in the GAC
            asm = Assembly.Load(assembly);
            DBG.Info(DBG.Registration, "NewLoadAssembly: Assembly was loaded from the GAC");
            
            // this will throw a RegistrationException if any SC's are invalid
            CheckAssemblySCValidity(asm);                   
            
            // this will throw a RegistrationException if the assembly doesn't have appropriate security attributes
            // CheckAssemblySecurity(asm);
            
            return asm;
        }
        
	// We can tolerate some set of failures from Assembly.Load.
        catch (FileLoadException) {}
	catch (FileNotFoundException) {}
        
        asm = LoadAssembly( assembly );
        DBG.Info(DBG.Registration, "NewLoadAssembly: Assembly was loaded from file");
            
        // this will throw a RegistrationException if any SC's are invalid
        CheckAssemblySCValidity(asm);

        // this will throw a RegistrationException if the assembly doesn't have appropriate security attributes
        // CheckAssemblySecurity(asm);
            
            // bug 23665
            // check that assembly has a strong name
            if (!AssemblyHasStrongName(asm))
            {
                throw new RegistrationException(Resource.FormatString("Reg_NoStrongName",assembly));
            }
					
		return asm;
		}		
	
    
    internal Assembly LoadAssembly(String assembly)
        {
            assembly = Path.GetFullPath(assembly).ToLower(CultureInfo.InvariantCulture);

            // 1. Load the given assembly.
            bool dirChanged = false;
            String initialDir = null;

            String assemblyDir = Path.GetDirectoryName(assembly);
            initialDir = Environment.CurrentDirectory;

            if(initialDir != assemblyDir) {
                Environment.CurrentDirectory = assemblyDir;
                dirChanged = true;
            }
            
            Assembly asm = null;
            try {
                asm = Assembly.LoadFrom(assembly);
            }
            catch(Exception e)
            {
                throw new RegistrationException(Resource.FormatString("Reg_AssemblyLoadErr", assembly), e);
            }

            if(dirChanged) Environment.CurrentDirectory = initialDir;
            if(asm == null) throw new RegistrationException(Resource.FormatString("Reg_AssemblyLoadErr", assembly));

            // special case our own assembly
        if (asm.GetName().Name == "System.EnterpriseServices")
                    throw new RegistrationException(Resource.FormatString("RegSvcs_NoBootstrap"));

            return(asm);
        }

        internal static Object GenerateTypeLibrary(Assembly asm, String tlb, Report report)
        {
           try {
                TypeLibConverter converter = new TypeLibConverter();
                RegistrationExporterNotifySink sink = new RegistrationExporterNotifySink(tlb, report);
                Object o = converter.ConvertAssemblyToTypeLib(asm, 
                                                              tlb, 
                                                              TypeLibExporterFlags.OnlyReferenceRegistered, 
                                                              sink);
                ICreateTypeLib creat = (ICreateTypeLib)o;
                creat.SaveAllChanges();
                RegisterTypeLibrary(tlb);
                return(o);
            }
            catch(Exception e)
            {
                throw new RegistrationException(Resource.FormatString("Reg_TypeLibGenErr", tlb, asm), e);
            }
        }

        private void PostProcessApplication(ICatalogObject app, ApplicationSpec spec)
        {
            try {
	            DBG.Info(DBG.Registration, "PostProcessing app: " + spec);
	            
	            if (AfterSaveChanges(spec.Assembly, app, _appColl, "Application", _cache))
	            {
	                SaveChanges(_appColl);
	            }
             }
            catch (Exception e)
            {
            	throw new RegistrationException(Resource.FormatString("Reg_ConfigUnkErr"), e);
            }
        }
		
        private ICatalogObject CreateApplication(ApplicationSpec spec, bool checkExistence)
        {
            DBG.Info(DBG.Registration, "FindOrCreating app: " + spec);
            if(checkExistence)
            {
                ICatalogObject temp = FindApplication(_appColl, spec);
                if(temp != null) 
                {
                    throw new RegistrationException(Resource.FormatString("Reg_AppExistsErr", spec));
                }
            }

            ICatalogObject app = (ICatalogObject)(_appColl.Add());

            CheckForAppSecurityAttribute(spec.Assembly);	// will just give a warning if no app-security attribute in the assembly

            ApplicationDefaults(app, _appColl);
            app.SetValue("Name", spec.Name);
            if(spec.ID != null)
                app.SetValue("ID", spec.ID);
            if(spec.AppRootDir != null)
            {
                Platform.Assert(Platform.Whistler, "ApplicationRootDirectory");
                app.SetValue("ApplicationDirectory", spec.AppRootDir);
            }
            SaveChanges(_appColl);
            ConfigureObject(spec.Assembly, app, _appColl, "Application", _cache);
            // Make sure we have an up-to-date name:
            spec.Name = (String)(app.GetValue("Name"));
            SaveChanges(_appColl);
            return(app);
        }

        private ICatalogObject FindOrCreateApplication(ApplicationSpec spec, bool configure)
        {
            DBG.Info(DBG.Registration, "FindOrCreating app: " + spec + ": configure = " + configure);
            ICatalogObject app = FindApplication(_appColl, spec);
            
            if(app == null)
            {
                app = CreateApplication(spec, false);
            }
            else if(configure) // Configure the application:
            {
                CheckForAppSecurityAttribute(spec.Assembly);	// will give a warning if no app-security attribute in the assembly
            	
                ApplicationDefaults(app, _appColl);
                app.SetValue("Name", spec.Name);
                if(!Platform.IsLessThan(Platform.Whistler))
                {
                    app.SetValue("ApplicationDirectory", (spec.AppRootDir == null) ? "" : spec.AppRootDir);
                }
                ConfigureObject(spec.Assembly, app, _appColl, "Application", _cache);
                // Make sure we have an up-to-date name:
                spec.Name = (String)(app.GetValue("Name"));
                SaveChanges(_appColl);                
            }
            return(app);
        }

        private void InstallTypeLibrary(ApplicationSpec spec)
        {
            if(Platform.IsLessThan(Platform.W2K))
            {
                InstallTypeLibrary_MTS(spec);
            }
            else
            {
                InstallTypeLibrary_W2K(spec);
            }
        }

        private void InstallTypeLibrary_W2K(ApplicationSpec spec)
        {
            try 
            {
                Object[] saFileNames = new Object[1];
                saFileNames[0] = spec.TypeLib;
                
                // Normal classes:
                Type[] regTypes = spec.NormalTypes;
                if(regTypes != null)
                {
                    DBG.Info(DBG.Registration, "Trying to get ID's for " + regTypes.Length + " components.");
                    if(regTypes == null || regTypes.Length == 0)
                    {
                        throw new RegistrationException(Resource.FormatString("Reg_NoConfigTypesErr"));
                    }
                    
                    // Run through these types, and get GUID's for them.
                    Object[] saCLSID = new Object[regTypes.Length];
                    for(int i = 0; i < regTypes.Length; i++)
                    {
                        DBG.Info(DBG.Registration, "ID: " + Marshal.GenerateGuidForType(regTypes[i]));
                        saCLSID[i] = "{" + Marshal.GenerateGuidForType(regTypes[i]).ToString() + "}";
                    }
                    
                    // Now, we've got components to install.
                    DBG.Info(DBG.Registration, "Installing multiple components.");
                    _cat.InstallMultipleComponents(spec.DefinitiveName, ref saFileNames, ref saCLSID);
                }

                // Event classes:
                regTypes = spec.EventTypes;
                if(regTypes != null)
                {
                    DBG.Info(DBG.Registration, "Trying to get ID's for " + regTypes.Length + " components.");
                    if(regTypes == null || regTypes.Length == 0)
                    {
                        throw new RegistrationException(Resource.FormatString("Reg_NoConfigTypesErr"));
                    }
                    
                    // Run through these types, and get GUID's for them.
                    Object[] saCLSID = new Object[regTypes.Length];
                    for(int i = 0; i < regTypes.Length; i++)
                    {
                        DBG.Info(DBG.Registration, "ID: " + Marshal.GenerateGuidForType(regTypes[i]));
                        saCLSID[i] = "{" + Marshal.GenerateGuidForType(regTypes[i]).ToString() + "}";
                    }
                    
                    // Now, we've got components to install.
                    DBG.Info(DBG.Registration, "Installing multiple components.");

                    _cat.InstallMultipleEventClasses(spec.DefinitiveName, ref saFileNames, ref saCLSID);
                }
            }
            catch(COMException e)
            {
                // It's safe to pass in NULL as the collection here, because
                // we're on W2K or above.
                throw WrapCOMException(null, e, 
                                       Resource.FormatString("Reg_TypeLibInstallErr", spec.TypeLib, spec.Name));
            }
        }

        private void InstallTypeLibrary_MTS(ApplicationSpec spec)
        {
            ICatalogCollection comps = null;
            try 
            {
                // TODO:  Figure out how to hack interfaces in here:
                DBG.Assert(_mts != null, "MTS object is null on MTS machine?");
                ICatalogObject app = FindApplication(_appColl, spec);
                comps = (ICatalogCollection)_appColl.GetCollection(CollectionName.Components, app.Key());
                Populate(comps);
                IComponentUtil util = (IComponentUtil)(comps.GetUtilInterface());
                foreach(Type t in spec.NormalTypes)
                {
                    Guid id = Marshal.GenerateGuidForType(t);
                    // We have to make sure this guy doesn't already
                    // exist in this application:
                    bool found = false;
                    for(int i = 0; i < comps.Count(); i++)
                    {
                        ICatalogObject o = (ICatalogObject)(comps.Item(i));
                        Guid possible = new Guid((String)(o.Key()));
                        if(possible == id) 
                        {
                            found = true;
                            break;
                        }
                    }

                    if(!found) util.ImportComponent("{" + id + "}");
                }
            }
            catch(COMException e)
            {
                throw WrapCOMException(comps, e, 
                                       Resource.FormatString("Reg_TypeLibInstallErr", spec.TypeLib, spec.Name));
            }
            catch(Exception e)
            {
                throw new RegistrationException(Resource.FormatString("Reg_TypeLibInstallErr", spec.TypeLib, spec.Name),
                                                e);
            }
        }

        private ICatalogObject FindApplication(ICatalogCollection apps, ApplicationSpec spec)
        {
            DBG.Info(DBG.Registration, "Finding app: " + spec);
            for(int i = 0; i < apps.Count(); i++)
            {
                ICatalogObject obj = (ICatalogObject)(apps.Item(i));
                if(spec.Matches(obj)) return(obj);
            }
            return(null);
        }

        private void ApplicationDefaults(ICatalogObject obj, ICatalogCollection coll)
        {
            DBG.Info(DBG.Registration, "Setting application defaults");
            if(Platform.IsLessThan(Platform.W2K))
            {
                obj.SetValue("Activation", "Inproc");
                obj.SetValue("SecurityEnabled", "N");
                obj.SetValue("Authentication", AuthenticationOption.Packet);
            }
            else
            {
                obj.SetValue("Activation", ActivationOption.Library);
                obj.SetValue("AccessChecksLevel", AccessChecksLevelOption.Application);
                obj.SetValue("ApplicationAccessChecksEnabled", true);
                obj.SetValue("Authentication", AuthenticationOption.Packet);
                obj.SetValue("CRMEnabled", false);
                obj.SetValue("EventsEnabled", true);
                obj.SetValue("ImpersonationLevel", ImpersonationLevelOption.Impersonate);
                obj.SetValue("QueuingEnabled", false);
                obj.SetValue("QueueListenerEnabled", false);
            }
            if(!Platform.IsLessThan(Platform.Whistler))
            {
                obj.SetValue("SoapActivated", false);
                obj.SetValue("QCListenerMaxThreads", 0);    // 0 means use default number of player threads
            }

        }

        internal bool ConfigureObject(ICustomAttributeProvider t, 
                                      ICatalogObject obj,
                                      ICatalogCollection coll,
                                      String prefix, 
                                      Hashtable cache)
        {
            bool dirty = false;

            DBG.Info(DBG.Registration, "Configuring object: " + prefix + " " + t);
            Object[] attributes = t.GetCustomAttributes(true);
            cache[prefix]              = obj;
            cache[prefix+"Type"]       = t;
            cache[prefix+"Collection"] = coll;
            cache["CurrentTarget"]     = prefix;
            
            foreach(Object attr in attributes)
            {
                if(attr is IConfigurationAttribute)
                {
                	try {
                        IConfigurationAttribute config = (IConfigurationAttribute)attr;
                        if(config.IsValidTarget(prefix)) 
                        {
                            DBG.Info(DBG.Registration, "Applying: " + attr.GetType().FullName);
                            if(config.Apply(cache)) dirty = true;
                        }
                    }
                    catch (Exception e)
                    {
                    	 throw new RegistrationException(Resource.FormatString("Reg_ComponentAttrErr", obj.Name(), attr), e);
                    }
                }
            }
            return(dirty);
        }

        internal bool AfterSaveChanges(ICustomAttributeProvider t, 
                                        ICatalogObject obj, 
                                        ICatalogCollection coll,
                                        String prefix, 
                                        Hashtable cache)
        {
            bool dirty = false;

            DBG.Info(DBG.Registration, "After save changes on: " + prefix + " " + t);
            Object[] attributes = t.GetCustomAttributes(true);
            cache[prefix]              = obj;
            cache[prefix+"Type"]       = t;
            cache[prefix+"Collection"] = coll;
            cache["CurrentTarget"]     = prefix;
            
            foreach(Object attr in attributes)
            {
                if(attr is IConfigurationAttribute)
                {
                    IConfigurationAttribute config = (IConfigurationAttribute)attr;
                    if(config.IsValidTarget(prefix))
                    {
                        if(config.AfterSaveChanges(cache)) dirty = true;
                    }
                }
            }
            return(dirty);
        }
        
        internal void ConfigureCollection(ICatalogCollection coll, IConfigCallback cb)
        {
            bool postChanged = false;

            // Create a permission object for unmanaged code
            SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);

            // demand that the caller have this permission
            sp.Demand();

            // now that the caller is clean, assert it from now on.
            sp.Assert();

            // Make sure that we're all set to defaults.
            foreach(Object o in cb)
            {
                // Set defaults:  Find the item in the collection, configure
                // appropriately
                Object catObj = cb.FindObject(coll, o);
                cb.ConfigureDefaults(catObj, o);
            }
            SaveChanges(coll);

            postChanged = false;
            foreach(Object o in cb)
            {
                Object catObj = cb.FindObject(coll, o);
                if(cb.Configure(catObj, o)) postChanged = true;
            }
            SaveChanges(coll);

            postChanged = false;
            foreach(Object o in cb)
            {
                Object catObj = cb.FindObject(coll, o);
                if(cb.AfterSaveChanges(catObj, o)) postChanged = true;
            }
            if(postChanged) SaveChanges(coll);

            cb.ConfigureSubCollections(coll);
        }

        private void ConfigureComponents(ApplicationSpec spec)
        {
            ICatalogCollection catComps = null;

            try 
            {
                ICatalogObject app = FindApplication(_appColl, spec);
                if(app == null) throw new RegistrationException(Resource.FormatString("Reg_AppNotFoundErr", spec));
                
                // Make sure we've got the Application stored up in the cache:
                _cache["Application"] = app;
                _cache["ApplicationType"] = spec.Assembly;
                _cache["ApplicationCollection"] = _appColl;

                catComps = (ICatalogCollection)(_appColl.GetCollection(CollectionName.Components, app.Key()));
                ConfigureCollection(catComps, new ComponentConfigCallback(catComps, spec, _cache, this, _installFlags));
            }
            catch(RegistrationException)
            {
                throw;
            }
            catch(COMException e)
            {
                throw WrapCOMException(catComps, e, Resource.FormatString("Reg_ConfigErr"));
            }
            catch(Exception e)
            {
                throw new RegistrationException(Resource.FormatString("Reg_ConfigUnkErr"), e);
            }
        }

		internal bool IsAssemblyRegistered(ApplicationSpec spec)
		{
			bool fPresent = false;

            // Bail out if there are no configurable types in the assembly..			
			if (null == spec || null == spec.ConfigurableTypes) 
				return false;

            RegistryKey BaseClsIdKey = Registry.ClassesRoot.OpenSubKey("CLSID");
            if (null == BaseClsIdKey)
				throw new RegistrationException(Resource.FormatString("Reg_RegistryErr"));

			// Check if any of the types in the assembly are registered.
            foreach(Type t in spec.ConfigurableTypes)
            {
                String strClsId = "{" + Marshal.GenerateGuidForType(t).ToString() + "}";

				RegistryKey ClsIdKey		= null;
				RegistryKey InProcServerKey = null;

				try
				{	// Open the InProcServer32 key.
					ClsIdKey = BaseClsIdKey.OpenSubKey(strClsId);
					if (ClsIdKey != null)
					{
						InProcServerKey = ClsIdKey.OpenSubKey("InprocServer32");
						if (InProcServerKey != null)
						{
							// Try reading the Assembly and Class values.
							if (null != InProcServerKey.GetValue("Assembly") &&
							    null != InProcServerKey.GetValue("Class"))
							{
								fPresent = true;
								break;
							}
						}
					}
				}
				catch
				{} // Continue if any error.
				finally
				{
					if (null != InProcServerKey)
						InProcServerKey.Close();

					if (null != ClsIdKey)
						ClsIdKey.Close();
				}

			}

			BaseClsIdKey.Close();
			return fPresent;
		}

		internal void UnregisterAssembly(Assembly asm, ApplicationSpec spec)
		{
			bool unregAssembly = true;

            // Bail out if no assembly.
			if (null == asm)
				return;

            // Bail out if there are no configurable types in the assembly..			
			if (null == spec || null == spec.ConfigurableTypes) 
				return;

			// Check always on Whistler and above.
			if (!Platform.IsLessThan(Platform.Whistler) && null != _cat) 
            {	
				// Check if any of the types in the assembly are still in use in other partitions.
                foreach(Type t in spec.ConfigurableTypes)
                {
                    String id = "{" + Marshal.GenerateGuidForType(t).ToString() + "}";
					
					try
					{
						int		nVersions	= 0;
						/* 
						// Early binding.
						Object		o1, o2, o3, o4;
						ICatalog2	cat2	= (ICatalog2)_cat;
						nVersions = cat2.GetComponentVersions(id, out o1, out o2, out o3, out o4)
						*/
						
						// Late binding.
						Type ot	  = _cat.GetType();
						try
						{
							nVersions = (int)InvokeMemberHelper(ot,
                                                            "GetComponentVersions",
															BindingFlags.InvokeMethod,
															null,
															_cat,
															new object[] {id, null, null, null, null});
						}
						catch(COMException e)
						{
							if (Util.DISP_E_UNKNOWNNAME == e.ErrorCode)
							{
								// Try the new method name.
								nVersions = (int)InvokeMemberHelper(ot, 
                                                                "GetComponentVersionCount",
																BindingFlags.InvokeMethod,
																null,
																_cat,
                                                                new object[] {id} );
							}
							else
							{
								throw;	// re-throw.
							}
						}

						if (nVersions > 0)
						{
							unregAssembly = false;
							break;
						}
					}
					catch(COMException e)
					{
						if (Util.REGDB_E_CLASSNOTREG != e.ErrorCode)
							throw;
					}	// else continue if class not registered.
                }
			}

			if (unregAssembly)
            {
				ClassicUnregistration(asm);
                try { UnregisterTypeLib(asm); }
                catch(Exception) {}
            }
		}

        internal void ClassicRegistration(Assembly asm)
        {
            // UNDONE - this is too restrictive
            //
            RegistryPermission rp = new RegistryPermission(PermissionState.Unrestricted);
            rp.Demand();
            rp.Assert();

            try {
                RegistrationServices rs = new RegistrationServices();
                
                rs.RegisterAssembly(asm, AssemblyRegistrationFlags.SetCodeBase);
                // _rollback.Add(new ClassicRegistrationRollback(this, asm));
            }
            catch(Exception e)
            {
                throw new RegistrationException(Resource.FormatString("Reg_AssemblyRegErr", asm), e);
            }
        }

        internal void ClassicUnregistration(Assembly asm)
        {
            try {
                new RegistrationServices().UnregisterAssembly(asm);
            }
            catch(Exception e)
            {
                throw new RegistrationException(Resource.FormatString("Reg_AssemblyUnregErr", asm), e);
            }
        }

        internal void UnregisterTypeLib(Assembly asm)
        {
            IntPtr pAttr = IntPtr.Zero;
            Object tlbobj = null;
            UCOMITypeLib tlb = null;

            try
            {
                Guid id = Marshal.GetTypeLibGuidForAssembly(asm);
                Version ver = asm.GetName().Version;
                if(ver.Major == 0 && ver.Minor == 0)
                {
                    ver = new Version(1, 0);
                }
                
                if (0 != Util.LoadRegTypeLib(id, (short)ver.Major, (short)ver.Minor, 0, out tlbobj))
                	return;
                	
                tlb = (UCOMITypeLib)tlbobj;
                // Retrieve the version information from the typelib.
                tlb.GetLibAttr(out pAttr);
                
                // Copy the int we got back from GetLibAttr to a TypeLibAttr struct.
                TYPELIBATTR attr = (TYPELIBATTR)Marshal.PtrToStructure((IntPtr)pAttr, typeof(TYPELIBATTR));

                // Unregister the typelib.
                Util.UnRegisterTypeLib(attr.guid, attr.wMajorVerNum, attr.wMinorVerNum, attr.lcid, attr.syskind);
            }
            finally
            {
                if(tlb != null && pAttr != IntPtr.Zero) 
                    tlb.ReleaseTLibAttr(pAttr);
                if(tlb != null)
                    Marshal.ReleaseComObject(tlb);
            }
        }

        private Object InvokeMemberHelper(Type type, String name, BindingFlags invokeAttr, Binder binder, Object target, Object[] args)
        {
            try
            {
                return type.InvokeMember(name, invokeAttr, binder, target, args);
            }
            catch(TargetInvocationException e)
            {
                throw e.InnerException;
            }
        }

        private void PrepDriver(ref ApplicationSpec spec)
        {
            if(Platform.IsLessThan(Platform.W2K)) // NT and below.
            {	
                try 
                {
                    _cat = null;
                    _mts = (IMtsCatalog)(new xMtsCatalog());
                    _appColl = (ICatalogCollection)(_mts.GetCollection(CollectionName.Applications));
                    Populate(_appColl);
                }
                catch(Exception e)
                {
                    throw new RegistrationException(Resource.FormatString("Reg_CatalogErr"), e);
                }
            }
            else if (Platform.IsLessThan(Platform.Whistler)) // W2k.
            {	
                try 
                {
                    _mts = null;
                    _cat = (ICatalog)(new xCatalog());
                    _appColl = (ICatalogCollection)(_cat.GetCollection(CollectionName.Applications));
                    Populate(_appColl);
                }
                catch(Exception e)
                {
                    throw new RegistrationException(Resource.FormatString("Reg_CatalogErr"), e);
                }
            }
			else // Whistler and above.
			{	
				/*
				// Early Binding.
				ICatalog2 cat2 = null;
				*/

				// Get the new com+ admin interface.
                try 
                {	
					/*
					// Early Binding.
					//cat2 = (ICatalog2)(new xCatalog());
					*/

					// Late Binding.
					_cat = (ICatalog)(new xCatalog());
				}
                catch(Exception e)
                {
                    throw new RegistrationException(Resource.FormatString("Reg_CatalogErr"), e);
                }

				// Try to find a partition for this app.
				if ((null == spec.Partition || 0 == spec.Partition.Length) && null != spec.ID)
				{
					try
					{
						/*
						// Early Binding.
						spec.Partition = cat2.GetAppPartitionId(spec.ID);
						*/

						// Late Binding.
						Type ot			= _cat.GetType();
						try
						{
							spec.Partition	= (String)InvokeMemberHelper(ot, 
                                                                        "GetAppPartitionId",
																		BindingFlags.InvokeMethod,
																		null,
																		_cat,
																		new object[] {spec.ID});
						}
						catch(COMException e)
						{
							if (Util.DISP_E_UNKNOWNNAME == e.ErrorCode)
							{
								// Try the new method name.
								spec.Partition	= (String)InvokeMemberHelper(ot,
                                                                            "GetPartitionID",
																			BindingFlags.InvokeMethod,
																			null,
																			_cat,
																			new object[] {spec.ID});
							}
						}
					}
					catch	// default to app not present if any error.
					{}
				}
				
				// If specified, set target partition.
				if (null != spec.Partition && 0 != spec.Partition.Length)
				{
					try
					{
						/*
						// Early Binding.
						cat2.SetApplicationPartition(spec.Partition);
						*/

						// Late Binding.
						Type ot = _cat.GetType();
						try
						{
							InvokeMemberHelper(ot, 
                                            "SetApplicationPartition",
											BindingFlags.InvokeMethod,
											null,
											_cat,
											new object[] {spec.Partition} );
						}
						catch(COMException e)
						{
							if (Util.DISP_E_UNKNOWNNAME == e.ErrorCode)
							{
								// Try setting the new partition property.
								InvokeMemberHelper(ot,
                                                "CurrentPartition",
												BindingFlags.SetProperty,
												null,
												_cat,
												new object[] {spec.Partition} );
							}
							else
							{
								throw;	// re-throw original exception.
							}
						}

					}
					catch(Exception e)
					{
						throw new RegistrationException(Resource.FormatString("Reg_PartitionErr", spec.Partition), e);
					}
				}

				// Init "this" obj data members.
				try
				{
                    _mts = null;

					/* 
					// Early Binding.
                    _cat = (ICatalog)cat2;
					*/

                    _appColl = (ICatalogCollection)(_cat.GetCollection(CollectionName.Applications));
                    Populate(_appColl);
                }
                catch(Exception e)
                {
                    throw new RegistrationException(Resource.FormatString("Reg_CatalogErr"), e);
                }
			}
            _cache    = new Hashtable();
            // _rollback = new RollbackEngine();
        }

        private void CleanupDriver()
        {
            _cat     = null;
            _cache   = null;
            _appColl = null;
        }

        private void PrepArguments(RegistrationConfig regConfig)
        {
            // We must have an assembly name                        
            if(regConfig.AssemblyFile == null || regConfig.AssemblyFile.Length == 0)
            {
                throw new RegistrationException(Resource.FormatString("Reg_ArgumentAssembly"));
            }

            // If we're expecting an existing typelib, TLB must be non-null:           
            if((regConfig.InstallationFlags & InstallationFlags.ExpectExistingTypeLib) != 0)
            {
                if(regConfig.TypeLibrary == null || regConfig.TypeLibrary.Length == 0) 
                {
                    throw new RegistrationException(Resource.FormatString("Reg_ExpectExisting"));
                }
            }

            // ForceCreate and FindOrCreate are mutually exclusive:
            if(((regConfig.InstallationFlags & InstallationFlags.CreateTargetApplication) != 0) 
               && ((regConfig.InstallationFlags & InstallationFlags.FindOrCreateTargetApplication) != 0))
            {
                throw new RegistrationException(Resource.FormatString("Reg_CreateFlagErr"));
            }

            if(!(((regConfig.InstallationFlags & InstallationFlags.Register) != 0)
                 || ((regConfig.InstallationFlags & InstallationFlags.Install) != 0)
                 || ((regConfig.InstallationFlags & InstallationFlags.Configure) != 0)))
            {
                regConfig.InstallationFlags |= (InstallationFlags.Register | InstallationFlags.Install | InstallationFlags.Configure);
            }

            _installFlags = regConfig.InstallationFlags;
            if(Platform.IsLessThan(Platform.W2K)) _installFlags |= InstallationFlags.ConfigureComponentsOnly;

			// Validate partition info.			
			if(null != regConfig.Partition && 0 != regConfig.Partition.Length)
			{
				// Check for default partitions.
				String strDefPartitionName	= "Base Application Partition";
				String strDefPartitionId	= "{41E90F3E-56C1-4633-81C3-6E8BAC8BDD70}";
				
				if (0 == String.Compare(regConfig.Partition, strDefPartitionId, true, CultureInfo.InvariantCulture)   ||
					0 == String.Compare(regConfig.Partition, strDefPartitionName, true, CultureInfo.InvariantCulture))
				{                    					
					regConfig.Partition = null;
				}

				// Partitions are only supported in Whistler or above.
				if (null != regConfig.Partition && Platform.IsLessThan(Platform.Whistler))
				{
					throw new RegistrationException(Resource.FormatString("Reg_PartitionsNotSupported"));
				}
			}
            
			if (regConfig.ApplicationRootDirectory != null)
			{
			    // approotdir should be have a valid path form.
			    if (!Directory.Exists(regConfig.ApplicationRootDirectory))
			    {
			        throw new RegistrationException(Resource.FormatString("Reg_BadAppRootDir"));
			    }
			}
        }		                  

        public void InstallAssembly(RegistrationConfig regConfig,                                    
                                    Object obSync)
        {
            Assembly        asm      = null;
            ApplicationSpec spec     = null;
            CatalogSync     sync     = null;
            bool            fUnreg   = false;
            bool            fUnregTlb = false;
            
            // Create a permission object for unmanaged code
            SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);

            // demand that the caller have this permission
            sp.Demand();

            // now that the caller is clean, assert it from now on.
            sp.Assert();
		
            Perf.Tick("RegistrationHelper - Begin");

            try {
            
            	ICatalogObject icoApp = null;
            
                PrepArguments(regConfig);
                
                // 1. Load the given assembly.
                
                asm = NewLoadAssembly(regConfig.AssemblyFile);
                
                // Generate any names we're going to need to generate.
                
                spec = new ApplicationSpec(asm, regConfig);

                // bail out if there are no configurable types in the assembly..
                // the call to NewLoadAssembly won't have added the assembly to the GAC in this condition
                if (spec.ConfigurableTypes == null) 
                {
                    regConfig.Application = null;
                    regConfig.TypeLibrary = null;
                    return; 
                }

                if(obSync != null)
                {
                    if(!(obSync is CatalogSync)) throw new ArgumentException("obSync");
                    sync = (CatalogSync)obSync;
                }
                
                // 0. Prep the driver object:
                PrepDriver(ref spec);
                
                Perf.Tick("RegistrationDriver - Load done");
                
                if((regConfig.InstallationFlags & InstallationFlags.Register) != 0)
                {
                    // 3. Register its members.
                    fUnreg = !IsAssemblyRegistered(spec);
                    ClassicRegistration(spec.Assembly);
                    
                    // 4. Generate a type-library. (or register if we've just got
                    // an existing one.
                    if((regConfig.InstallationFlags & InstallationFlags.ExpectExistingTypeLib) != 0)
                    {
                        RegisterTypeLibrary(spec.TypeLib);
                    }
                    else { // Generate target type library.
                        fUnregTlb = true;
                        GenerateTypeLibrary(spec.Assembly,                                           
                                            spec.TypeLib,
                                            new Report(this.ReportWarning));
                    }
                    Perf.Tick("RegistrationDriver - Classic registration done");
                }
                
                if(((regConfig.InstallationFlags & InstallationFlags.Install) != 0) 
                   && (spec.ConfigurableTypes != null))
                {
                    // 5. Create the application if it does not exist.
                    if((regConfig.InstallationFlags & InstallationFlags.CreateTargetApplication) != 0) 
                    {
                        icoApp = CreateApplication(spec, true);
                    }
                    else if ((regConfig.InstallationFlags & InstallationFlags.FindOrCreateTargetApplication) != 0) 
                    {
                        icoApp = FindOrCreateApplication(spec, ((regConfig.InstallationFlags & InstallationFlags.ReconfigureExistingApplication) != 0));
                    }
                    // else, we expect an existing application.
                    
                    // 6. Install the type-library under the given application.
                    InstallTypeLibrary(spec);
                    
                    if(sync != null) sync.Set();
                    
                    Perf.Tick("RegistrationDriver - Installation done");
                }
                
                if(((regConfig.InstallationFlags & InstallationFlags.Configure) != 0) 
                   && (spec.ConfigurableTypes != null))
                {
                    // 7. Configure the registrable components from the assembly.
                    ConfigureComponents(spec);
                    
                    if(sync != null) sync.Set();
                    Perf.Tick("RegistrationDriver - Configuration done");
                }
                
                if (icoApp!=null)
                {
                    PostProcessApplication(icoApp, spec); // AfterSaveChanges for Applications happens here, after we've configured the components.
                }
                 
                // 8.  Done, cleanup driver
                CleanupDriver();                               
                
                Perf.Tick("RegistrationDriver - Transaction complete");
            }
            catch(Exception)
            {
                // TODO:  On failure, clean up things which succeeded,
                // such as registration, typelib creation.
                // We swallow any exceptions that this throws, because
                // we prefer to have the previously thrown error.
				if (fUnreg && null != asm)
                {
                    try { ClassicUnregistration(asm); }
                    catch(Exception) {}
                }
                if(fUnregTlb && null != asm)
                {
                    try { UnregisterTypeLib(asm); }
                    catch(Exception) {}
                }

                throw;
            }
        }

        // Helper function for UninstallAssembly.
        private int FindIndexOf(String[] arr, String key)
        {
            for(int i = 0; i < arr.Length; i++)
            {
                if(arr[i] == key) return(i);
            }
            return(-1);
        }   

        public void UninstallAssembly(RegistrationConfig regConfig, Object obSync)
        {
            CatalogSync     sync = null;            
            
            // Create a permission object for unmanaged code
            SecurityPermission sp = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);

            // demand that the caller have this permission
            sp.Demand();

            // now that the caller is clean, assert it from now on.
            sp.Assert();
		
            if(obSync != null)
            {
                if(!(obSync is CatalogSync)) throw new ArgumentException("obSync");
                sync = (CatalogSync)obSync;
            }

            DBG.Info(DBG.Registration, "Uninstalling assembly: " + regConfig.AssemblyFile);
            
            // 0. Load the given assembly.
            Assembly asm = NewLoadAssembly(regConfig.AssemblyFile);
            
            // Generate any names we're going to need to generate.
            ApplicationSpec spec = new ApplicationSpec(asm, regConfig);
            DBG.Info(DBG.Registration, "Application name = " + spec.Name);
            
            // bail out if there are no configurable types in the assembly..			
			if (spec.ConfigurableTypes == null) 
				return; 
			
            // 1. Prep the helper object:
            PrepDriver(ref spec);

            // If we didn't configure any components, no app exists.
            if(spec.ConfigurableTypes != null) 
            {
                // To do the uninstall, we need to do open up the components
                // list in the target application, and remove all components
                // in it that are listed in the ConfigureableComponents list.
                ICatalogObject app = FindApplication(_appColl, spec);
                
                if(app == null) throw new RegistrationException(Resource.FormatString("Reg_AppNotFoundErr", spec));
                
                // Get the components in this puppy:
                ICatalogCollection compColl = (ICatalogCollection)(_appColl.GetCollection(CollectionName.Components, app.Key()));
                
                String[] keys  = new String[spec.ConfigurableTypes.Length];
                
                int k = 0;
                foreach(Type t in spec.ConfigurableTypes)
                {
                    keys[k] = Marshal.GenerateGuidForType(t).ToString();
                    k++;
                }
                
                Populate(compColl);
                bool empty = true;
                for(int i = 0; i < compColl.Count();)
                {
                    ICatalogObject obj = (ICatalogObject)(compColl.Item(i));
                    String key = (String)(obj.Key());
                    
                    // Make sure we've got the same formatting as we have above:
                    key = (new Guid(key)).ToString();
                    
                    if(FindIndexOf(keys, key) != -1)
                    {
                        // Found it, let's delete it:
                        DBG.Info(DBG.Registration, "Removing item: " + (String)(obj.Name()));
                        
                        compColl.Remove(i);
                        if(sync != null) sync.Set();
                    }
                    else 
                    {
                        // Only kick up the index if we didn't do a deletion.
                        i++;
                        empty = false;
                    }
                }
                SaveChanges(compColl);
                
                if(empty)
                {
                    DBG.Info(DBG.Registration, "Deleting the enclosing application.");
                    // Delete the parent application as well.
                    for(int i = 0; i < _appColl.Count(); i++)
                    {
                        ICatalogObject obj = (ICatalogObject)(_appColl.Item(i));
                        if(obj.Key().Equals(app.Key()))
                        {
                            _appColl.Remove(i);
                            if(sync != null) sync.Set();
                            break;
                        }
                    }
                    SaveChanges(_appColl);
                }
            }
            
            // Unregister the assembly:  Should we also delete the type lib?
			UnregisterAssembly(asm, spec);
            
            // TODO:  Unregister the type library.   
            CleanupDriver();
        }
        
    }

}
