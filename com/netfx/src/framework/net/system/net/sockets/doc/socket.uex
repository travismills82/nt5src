<docs>
	<doc for="Socket.Socket1">
		<summary>
			<para>
       Called by the class to create a socket to accept an
       incoming request.
    </para>
		</summary>
		<param name="fd">
    Handle to a socket.
 </param>
		<remarks>
			<para>
       This constructor is used by the class to create a copy of
       the socket to m_Handle an incoming connection request when <see cref="Sockets.Socket.Accept"/> is called. The socket returned is a copy of
       the socket referenced by <paramref name="fd"/>.
    </para>
		</remarks>
	</doc>
	<doc for="Socket.Audit">
		<summary>
			<para>Enables monitoring incoming and outgoing socket activity.</para>
		</summary>
		<param name="outgoing">Stream to receive sent data.</param>
		<param name=" incoming">Stream to receive received data.</param>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.Audit"/> method provides a test interface to
   synchronous sends and receives over a socket. All data written to the socket is
   sent to the stream specified in <paramref name="outgoing"/>, and all data recieved on the
   socket is set to the stream specified in <paramref name="incoming"/>.</para>
		</remarks>
	</doc><doc for="Socket.GetHashCode">
		<nodoc/>
	</doc><doc for="Socket.IDisposable.Dispose">
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc><doc for="Socket.AddressFamily">
		<summary>
			<para> Gets the address family of the <see cref="System.Net.Sockets.Socket"/>.
      </para>
		</summary>
		<value>
			<para>One of the <see cref="System.Net.Sockets.AddressFamily"/> values.</para>
		</value>
		<remarks>
			<para><see cref="System.Net.Sockets.AddressFamily"/> specifies the addressing scheme that an instance
   of the <see cref="System.Net.Sockets.Socket"/> class can use. This property is read-only and is
   set when the <see cref="System.Net.Sockets.Socket"/> is created.</para>
		</remarks>
		<example>
			<para>The following example displays the <see cref="System.Net.Sockets.AddressFamily"/>, <see cref="System.Net.Sockets.SocketType"/>, and <see cref="System.Net.Sockets.ProtocolType"/>
to the console.</para>
			<codelink SampleID="Socket_Socket_Options" SnippetID="3"/>
		</example>
		<seealso cref="System.Net.Sockets.AddressFamily"/>
	</doc><doc for="Socket.SocketType">
		<summary>
			<para> Gets the type of the <see cref="System.Net.Sockets.Socket"/>.
   </para>
		</summary>
		<value>
			<para>One of the <see cref="System.Net.Sockets.SocketType"/> values.</para>
		</value>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket.SocketType"/> is read-only and is set when the 
<see cref="System.Net.Sockets.Socket"/> is created. </para>
		</remarks>
		<example>
			<para>The following example displays the <see cref="System.Net.Sockets.AddressFamily"/>, <see cref="System.Net.Sockets.SocketType"/>, and <see cref="System.Net.Sockets.ProtocolType"/>
to the console.</para>
			<codelink SampleID="Socket_Socket_Options" SnippetID="3"/>
		</example>
		<seealso cref="System.Net.Sockets.SocketType"/>
	</doc>
	<doc for="Socket.Finalize">
		<summary>
			<para>Frees resources used by the <see cref="System.Net.Sockets.Socket"/> class.</para>
		</summary>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket"/> class finalizer calls the <see cref="System.Net.Sockets.Socket.Close"/>
method to close the <see cref="System.Net.Sockets.Socket"/> and free resources associated with the <see cref="System.Net.Sockets.Socket"/>.</para>
		</remarks>
	</doc>
	<doc for="Socket.Connected">
		<summary>
			<para>Gets a value indicating whether a <see cref="System.Net.Sockets.Socket"/> is connected to a remote host.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Net.Sockets.Socket"/> is connected to a
   remote resource; otherwise,
<see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The <see langword="Connected"/> property gets the connection state of the <see cref="System.Net.Sockets.Socket"/>. This property will return the latest known
   state of the <see cref="System.Net.Sockets.Socket"/>. When it returns <see langword="false"/>, the
<see cref="System.Net.Sockets.Socket"/> was either never connected, or is no longer connected.</para>
			<para> 
   There is no guarantee that the <see cref="System.Net.Sockets.Socket"/> is still <see cref="System.Net.Sockets.Socket.Connected"/> even if <see cref="System.Net.Sockets.Socket.Connected"/> returns <see langword="true"/>. A value of <see langword=" true"/> simply means that the <see cref="System.Net.Sockets.Socket"/> was connected at the time of the last I/O
   operation.</para>
		</remarks>
		<example>
			<para> The following example connects to a remote endpoint and then verifies the
      connection. </para>
			<codelink SampleID="Classic Socket.Connect Example" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Socket.ProtocolType">
		<summary>
			<para> Gets the protocol type of the <see cref="System.Net.Sockets.Socket"/>.
   </para>
		</summary>
		<value>
			<para>One of the <see cref="System.Net.Sockets.ProtocolType"/> values. </para>
		</value>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.ProtocolType"/> property is set when the <see cref="System.Net.Sockets.Socket"/> is
   created, and specifies the protocol used by that <see cref="System.Net.Sockets.Socket"/> . </para>
		</remarks>
		<example>
			<para>The following example displays the <see cref="System.Net.Sockets.AddressFamily"/>, <see cref="System.Net.Sockets.SocketType"/>, and <see cref="System.Net.Sockets.ProtocolType"/>
to the console.</para>
			<codelink SampleID="Socket_Socket_Options" SnippetID="3"/>
		</example>
	</doc>
	<doc for="Socket.GetSocketOption1">
		<summary>
			<para>Returns the specified <see cref="System.Net.Sockets.Socket"/> option setting, represented as a byte array.</para>
		</summary>
		<param name="optionLevel">One of the <see cref="System.Net.Sockets.SocketOptionLevel"/> values. </param>
		<param name="optionName">One of the <see cref="System.Net.Sockets.SocketOptionName"/> values.</param>
		<param name=" optionValue">An array of type <see cref="System.Byte"/> that is to receive the option setting.</param>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket"/> options determine the behavior of the
   current <see cref="System.Net.Sockets.Socket"/>. Upon successful completion of this method,
   the array specified by the <paramref name="optionValue "/>parameter contains the value of
   the specified <see cref="System.Net.Sockets.Socket"/> option. </para>
When the length of the <paramref name="optionValue "/>array is smaller than the number of
bytes required to store the value of the specified <see cref="System.Net.Sockets.Socket"/> option, <see cref="System.Net.Sockets.Socket.GetSocketOption"/> will throw a <see cref="System.Net.Sockets.SocketException"/>. If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
the specific error code. Once you have obtained this code, you can refer to the
Windows Socket Version 2 API error code documentation in MSDN for a detailed
description of the error. Use this overload for any sockets that
are represented by Boolean values or integers.
</remarks>
		<example>
			<para>The following example retrieves the <see cref="System.Net.Sockets.LingerOption"/>
and <see cref="System.Net.Sockets.Socket.Send"/> time-out values and displays them to
the console.</para>
			<codelink SampleID="Socket_Socket_Options" SnippetID="2"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.SetSocketOption"/>
		<seealso cref="System.Net.Sockets.SocketOptionName"/>
		<seealso cref="System.Net.Sockets.SocketOptionLevel"/>
	</doc>
	<doc for="Socket.GetSocketOption2">
		<summary>
			<para> Returns the value of the specified <see cref="System.Net.Sockets.Socket"/> option
   in an array.</para>
		</summary>
		<param name="optionLevel">One of the <see cref="System.Net.Sockets.SocketOptionLevel"/> values. </param>
		<param name="optionName">One of the <see cref="System.Net.Sockets.SocketOptionName"/> values.</param>
		<param name=" optionLength">The length, in bytes, of the expected return value.</param>
		<returns>
			<para>An array of type <see cref="System.Byte"/> that contains the value of the socket option.</para>
		</returns>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para>The <paramref name="optionLength"/> parameter sets the maximum size of the returned byte
   array. If the option value requires fewer bytes, the array will contain only
   that many bytes. If the option value requires more bytes, <see cref="System.Net.Sockets.Socket.GetSocketOption"/> will throw a <see cref="System.Net.Sockets.SocketException"/>. Use this overload for any sockets that are
   represented by Boolean values or integers.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example retrieves the <see cref="System.Net.Sockets.LingerOption"/> and <see cref="System.Net.Sockets.Socket.Send"/>
time-out values and displays them to the console.</para>
			<codelink SampleID="Socket_Socket_Options" SnippetID="2"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.SetSocketOption"/>
		<seealso cref="System.Net.Sockets.SocketOptionName"/>
		<seealso cref="System.Net.Sockets.SocketOptionLevel"/>
	</doc>
	<doc for="Socket.LocalEndPoint">
		<summary>
			<para> Gets the local endpoint.
      </para>
		</summary>
		<value>
			<para> The <see cref="System.Net.EndPoint"/> that the <see cref="System.Net.Sockets.Socket"/> is
   using for communications.</para>
		</value>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.LocalEndPoint"/> property gets an <see cref="System.Net.EndPoint"/> containing
   the local IP address and port number to which your <see cref="System.Net.Sockets.Socket"/> is bound. You must
   cast this <see cref="System.Net.EndPoint"/> to an <see cref="System.Net.IPEndPoint"/> before retrieving any information.
   You can then call the <see cref="System.Net.IPEndPoint.Address" qualify="true"/> method to
   retrieve the local <see cref="System.Net.IPAddress"/> ,
   and the <see cref="System.Net.IPEndPoint.Port" qualify="true"/> method to retrieve the local port number. </para>
			<para>The <see cref="System.Net.Sockets.Socket.LocalEndPoint"/> property is usually set after you
make a call to the <see cref="System.Net.Sockets.Socket.Bind"/> method. If you allow the system to
assign your socket's local IP address and port number, the <see cref="System.Net.Sockets.Socket.LocalEndPoint"/> property will be set after the first
I/O operation. For connection-oriented protocols, the first I/O operation would
be a call to the <see cref="System.Net.Sockets.Socket.Connect"/> or <see cref="System.Net.Sockets.Socket.Accept"/> method. For connectionless protocols,
the first I/O operation would be any of the send or receive calls. </para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para> The following example retrieves and displays the local and remote
      endpoints.</para>
			<codelink SampleID="Socket_Socket_Options" SnippetID="4"/>
		</example>
		<seealso cref="System.Net.EndPoint"/>
		<seealso cref="System.Net.IPEndPoint"/>
		<seealso cref="System.Net.Sockets.Socket.Bind"/>
	</doc>
	<doc for="Socket.RemoteEndPoint">
		<summary>
			<para> Gets the remote endpoint.
      </para>
		</summary>
		<value>
			<para> The <see cref="System.Net.EndPoint"/> with which the <see cref="System.Net.Sockets.Socket"/> is communicating.</para>
		</value>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para>If you are using a connection-oriented protocol, the <see cref="System.Net.Sockets.Socket.RemoteEndPoint"/> property gets the <see cref="System.Net.EndPoint"/> containing
   the remote IP address and port number to which the <see cref="System.Net.Sockets.Socket"/> is connected. If you are
   using a connectionless protocol, <see cref="System.Net.Sockets.Socket.RemoteEndPoint"/> contains the default
   remote IP address and port number with which the <see cref="System.Net.Sockets.Socket"/> will communicate. You
   must cast this <see cref="System.Net.EndPoint"/> to an <see cref="System.Net.IPEndPoint"/> before retrieving any information.
   You can then call the <see cref="System.Net.IPEndPoint.Address" qualify="true"/> method to
   retrieve the remote <see cref="System.Net.IPAddress"/> ,
   and the <see cref="System.Net.IPEndPoint.Port" qualify="true"/> method to retrieve the remote port
   number. </para>
			<para>The <see cref="System.Net.Sockets.Socket.RemoteEndPoint"/> is set after a call to either <see cref="System.Net.Sockets.Socket.Accept"/> or <see cref="System.Net.Sockets.Socket.Connect"/>. If you try to
access this property earlier, <see cref="System.Net.Sockets.Socket.RemoteEndPoint"/> will throw a <see cref="System.Net.Sockets.SocketException"/>. If you
receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
the specific error code. Once you have obtained this code, you can refer to the
Windows Socket Version 2 API error code documentation in MSDN for a detailed
description of the error. </para>
		</remarks>
		<example>
			<para> The following example retrieves and displays the local and remote
      endpoints.</para>
			<codelink SampleID="Socket_Socket_Options" SnippetID="4"/>
		</example>
		<seealso cref="System.Net.EndPoint"/>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.Accept"/>
	</doc>
	<doc for="Socket.Handle">
		<summary>
			<para> Gets the operating system handle for the <see cref="System.Net.Sockets.Socket"/>.
   </para>
		</summary>
		<value>
			<para>An <see cref="System.IntPtr"/> representing the operating system handle for the <see cref="System.Net.Sockets.Socket"/>.</para>
		</value>
	</doc>
	<doc for="Socket.Blocking">
		<summary>
			<para> Gets or sets a value that indicates whether the <see cref="System.Net.Sockets.Socket"/> is in blocking mode.
   </para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Net.Sockets.Socket"/> will block; otherwise,
<see langword="false"/>. The default is <see langword="true"/>.</para>
		</value>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.Blocking"/> property indicates whether a <see cref="System.Net.Sockets.Socket"/> is in
   blocking mode.</para>
			<para>If you are in blocking mode, and you make a method call which does not complete
   immediately, your application will block execution until the requested operation
   completes. If you want execution to continue even though the requested operation
   is not complete, change the <see cref="System.Net.Sockets.Socket.Blocking"/> property to <see langword="false"/>.
   The <see cref="System.Net.Sockets.Socket.Blocking"/> property has no effect on
   asynchronous methods. If you are sending and receiving data asynchronously and
   want to block execution, use the <see cref="System.Threading.ManualResetEvent"/> class. </para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
	</doc>
	<doc for="Socket.Accept">
		<summary>
			<para>Creates a new <see cref="System.Net.Sockets.Socket"/> for a newly created
   connection.</para>
		</summary>
		<returns>
			<para> A <see cref="System.Net.Sockets.Socket"/> for a newly created
   connection.</para>
		</returns>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.InvalidOperationException">The <see cref="System.Net.Sockets.Socket"/> is not bound. You must call <see cref="System.Net.Sockets.Socket.Bind"/> before calling <see cref="System.Net.Sockets.Socket.Accept"/>.</exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket.Accept"/> 
synchronously extracts the
first pending connection request from the connection request queue of
the listening socket, and then creates and returns a new
<see cref="System.Net.Sockets.Socket"/> 
. You cannot use this returned <see cref="System.Net.Sockets.Socket"/> to accept any additional connections from
the connection queue. However, you can call the <see cref="System.Net.Sockets.Socket.RemoteEndPoint"/> method of the returned <see cref="System.Net.Sockets.Socket"/> to identify the remote host's network address
and port number. </para>
			<para> In blocking mode, <see cref="System.Net.Sockets.Socket.Accept"/>
will block until an incoming connection attempt is queued. After accepting a
connection, the original <see cref="System.Net.Sockets.Socket"/> will continue queuing incoming connection
requests until you close it. </para>
			<para> If you call this method using a non-blocking
<see cref="System.Net.Sockets.Socket"/>, and no connection requests are queued, 
<see cref="System.Net.Sockets.Socket.Accept"/>will throw a <see cref="System.Net.Sockets.SocketException"/>. If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> 
to obtain the specific error code. Once you have obtained this code, you can
refer to the Windows Socket Version 2 API error code documentation in MSDN for a
detailed description of the error.</para>
			<note type="note">
   Before calling the <see cref="System.Net.Sockets.Socket.Accept"/> method, you must first call the
<see cref="System.Net.Sockets.Socket.Listen"/> method to listen for and queue 
   incoming connection requests.
</note>
		</remarks>
		<example>
			<para>The following example accepts a simple <see cref="System.Net.Sockets.Socket"/> connection.</para>
			<codelink SampleID="Classic Socket.Accept Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Listen"/>
		<seealso cref="System.Net.Sockets.Socket.RemoteEndPoint"/>
		<seealso cref="System.Net.Sockets.Socket.BeginAccept" qualify="true"/>
	</doc>
	<doc for="Socket.SetSocketOption">
		<overload>
			<para>Sets a <see cref="System.Net.Sockets.Socket"/> option.</para>
		</overload>
		<summary>
			<para> Sets the specified <see cref="System.Net.Sockets.Socket"/> option to the specified integer value.</para>
		</summary>
		<param name="optionLevel">One of the <see cref="System.Net.Sockets.SocketOptionLevel"/> values. </param>
		<param name="optionName">One of the <see cref="System.Net.Sockets.SocketOptionName"/> values.</param>
		<param name="optionValue">A value of the option.</param>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information. </exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket"/>
options determine the behavior of the
current <see cref="System.Net.Sockets.Socket"/>. For an option with a <see cref="System.Boolean"/> data type, specify a nonzero value to enable the option,
and a zero value to disable the option. For an option with an integer data type,
specify the appropriate value.
<see cref="System.Net.Sockets.Socket"/> options are grouped by level of protocol support.</para>
			<para>Listed below are the various <see cref="System.Net.Sockets.Socket"/> options that can be set using this overload.
These options are grouped by the appropriate <see cref="System.Net.Sockets.SocketOptionLevel"/>. If you intend
to set any of these options, be sure to use the appropriate <see cref="System.Net.Sockets.SocketOptionLevel"/> for the <paramref name=" optionLevel"/> parameter. The option you choose to set
must be specified in the<paramref name="optionName"/> parameter. If
you want to get the current value of any of the options listed, use the<see cref="System.Net.Sockets.Socket.GetSocketOption"/>
method.</para>
			<para><see cref="System.Net.Sockets.SocketOptionLevel.Socket" qualify="true"/> options that can be set
using this overload.</para>
			<list type="bullet"><item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.Broadcast"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.DontLinger"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.Debug"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.Error"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.KeepAlive"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.OutOfBandInline"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.ReceiveBuffer"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.ReceiveTimeout"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.ReuseAddress"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.SendBuffer"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.SendTimeout"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.Type"/></term>
				</item>
			</list>
			<para><see cref="System.Net.Sockets.SocketOptionLevel.IP" qualify="true"/> options that can be set
using this overload.</para>
			<list type="bullet"><item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.HeaderIncluded"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.IPOptions"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.IpTimeToLive"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.MulticastInterface"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.MulticastLoopback"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.MulticastTimeToLive"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.TypeOfService"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.UseLoopback"/></term>
				</item>
			</list>
			<para><see cref="System.Net.Sockets.SocketOptionLevel.Tcp" qualify="true"/> options that can be set
using this overload.</para>
			<list type="bullet"><item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.BsdUrgent"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.Expedited"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.NoDelay"/></term>
				</item>
			</list>
			<para><see cref="System.Net.Sockets.SocketOptionLevel.Udp" qualify="true"/> options that can be set
using this overload.</para>
			<list type="bullet"><item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.ChecksumCoverage"/></term>
				</item>
				<item>
					<term>
						<see cref="System.Net.Sockets.SocketOptionName.NoChecksum"/></term>
				</item>
			</list>
For more information on these options, refer to the
<see cref="System.Net.Sockets.SocketOptionName"/> enumeration.
<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<platnote platform="Win98, NT4">You must call the <see cref="System.Net.Sockets.Socket.Bind"/> method before using <see cref="System.Net.Sockets.SocketOptionName.AddMembership"/> as the <paramref name="optionName "/>parameter.
</platnote>
		<example>
			<para>The following example sets the <see cref="System.Net.Sockets.LingerOption"/>
and <see cref="System.Net.Sockets.Socket.Send"/> time-out values.</para>
			<codelink SampleID="Socket_Socket_Options" SnippetID="1"/>
		</example>
		<seealso cref="System.Net.Sockets.SocketOptionName"/>
		<seealso cref="System.Net.Sockets.SocketOptionLevel"/>
		<seealso cref="System.Net.Sockets.Socket.GetSocketOption"/>
	</doc>
	<doc for="Socket.SetSocketOption1">
		<summary>
			<para>Sets the specified <see cref="System.Net.Sockets.Socket"/> option to the specified value, represented as a byte array.</para>
		</summary>
		<param name="optionLevel">One of the <see cref="System.Net.Sockets.SocketOptionLevel"/> values. </param>
		<param name="optionName">One of the <see cref="System.Net.Sockets.SocketOptionName"/> values.</param>
		<param name="optionValue">An array of type <see cref="System.Byte"/> that represents the value of the option.</param>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information. </exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket"/> options determine the behavior of the current
<see cref="System.Net.Sockets.Socket"/>. Use this overload to set those <see cref="System.Net.Sockets.Socket"/>
options that
require a byte array as an option value.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<platnote platform="Win98, NT4">You must call the <see cref="System.Net.Sockets.Socket.Bind"/> method before using <see cref="System.Net.Sockets.SocketOptionName.AddMembership"/> as the <paramref name="optionName "/>parameter.
</platnote>
		<example>
			<para>The following example sets the <see cref="System.Net.Sockets.LingerOption"/> and <see cref="System.Net.Sockets.Socket.Send"/>
time-out values.</para>
			<codelink SampleID="Socket_Socket_Options" SnippetID="1"/>
		</example>
		<seealso cref="System.Net.Sockets.SocketOptionName"/>
		<seealso cref="System.Net.Sockets.SocketOptionLevel"/>
		<seealso cref="System.Net.Sockets.Socket.GetSocketOption"/>
	</doc>
	<doc for="Socket.SetSocketOption2">
		<summary>
			<para>Sets the specified <see cref="System.Net.Sockets.Socket"/> option to the specified value, represented as an object.</para>
		</summary>
		<param name="optionLevel">One of the <see cref="System.Net.Sockets.SocketOptionLevel"/> values. </param>
		<param name="optionName">One of the <see cref="System.Net.Sockets.SocketOptionName"/> values.</param>
		<param name="optionValue">A <see cref="Sockets.LingerOption"/> or <see cref="Sockets.MulticastOption"/> containing the value of the option.</param>
		<exception cref="System.ArgumentNullException"><paramref name="optionValue"/> is <see langword="null"/>.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information. </exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket"/> options determine the behavior of the current
<see cref="System.Net.Sockets.Socket"/>. Use this overload to set the <see cref="System.Net.Sockets.SocketOptionName.Linger"/>, <see cref="System.Net.Sockets.SocketOptionName.AddMembership"/>, and <see cref="System.Net.Sockets.SocketOptionName.DropMembership"/>
				<see cref="System.Net.Sockets.Socket"/>
options. For the <see cref="System.Net.Sockets.SocketOptionName.Linger"/> option, use <see cref="System.Net.Sockets.Socket"/> for the <paramref name="optionLevel"/>
parameter. For <see cref="System.Net.Sockets.SocketOptionName.AddMembership"/> and <see cref="System.Net.Sockets.SocketOptionName.DropMembership"/>, use <see cref="System.Net.Sockets.SocketOptionLevel.IP"/>. If you want to get the
current value of any of the options listed above, use the <see cref="System.Net.Sockets.Socket.GetSocketOption"/> method.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<platnote platform="Win98, NT4">You must call the <see cref="System.Net.Sockets.Socket.Bind"/> method before using <see cref="System.Net.Sockets.SocketOptionName.AddMembership"/> as the <paramref name="optionName "/>parameter.
</platnote>
		<example>
			<para>The following example sets the <see cref="System.Net.Sockets.LingerOption"/> and <see cref="System.Net.Sockets.Socket.Send"/> time
   out values.</para>
			<codelink SampleID="Socket_Socket_Options" SnippetID="1"/>
		</example>
		<seealso cref="System.Net.Sockets.SocketOptionName"/>
		<seealso cref="System.Net.Sockets.SocketOptionLevel"/>
		<seealso cref="System.Net.Sockets.Socket.GetSocketOption"/>
	</doc>
	<doc for="Socket.GetSocketOption">
		<overload>
			<para>Returns the value of a <see cref="System.Net.Sockets.Socket"/> option.</para>
		</overload>
		<summary>
			<para>Returns the value of a specified <see cref="System.Net.Sockets.Socket"/> option, represented as an object.</para>
		</summary>
		<param name="optionLevel">One of the <see cref="System.Net.Sockets.SocketOptionLevel"/> values. </param>
		<param name="optionName">One of the <see cref="System.Net.Sockets.SocketOptionName"/> values.</param>
		<returns>
			<para>An object representing the value of the option. When the <paramref name="optionName
      "/>parameter is set to <see cref="SocketOptionName.Linger"/> the return value is an instance of the <see cref="Sockets.LingerOption"/> class. When
   <paramref name="optionName "/>is set to <see cref="SocketOptionName.AddMembership"/> or <see cref="SocketOptionName.DropMembership"/>, the return value is an instance of the
   <see cref="Sockets.MulticastOption"/> class. When <paramref name="optionName"/> is any other value, the return
      value is an integer.</para>
		</returns>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket"/> options determine the behavior of the current
<see cref="System.Net.Sockets.Socket"/>. Use this overload to get the <see cref="System.Net.Sockets.SocketOptionName.Linger"/>, <see cref="System.Net.Sockets.SocketOptionName.AddMembership"/>, and <see cref="System.Net.Sockets.SocketOptionName.DropMembership"/>
				<see cref="System.Net.Sockets.Socket"/>
options. For the <see cref="System.Net.Sockets.SocketOptionName.Linger"/> option, use <see cref="System.Net.Sockets.Socket"/> for the <paramref name="optionLevel"/>
parameter. For <see cref="System.Net.Sockets.SocketOptionName.AddMembership"/> and <see cref="System.Net.Sockets.SocketOptionName.DropMembership"/>, use <see cref="System.Net.Sockets.SocketOptionLevel.IP"/>. If you want to set the
value of any of the options listed above, use the <see cref="System.Net.Sockets.Socket.SetSocketOption"/> method.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example retrieves the <see cref="System.Net.Sockets.LingerOption"/>
and <see cref="System.Net.Sockets.Socket.Send"/> time-out values and displays them to
the console.</para>
			<codelink SampleID="Socket_Socket_Options" SnippetID="2"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.SetSocketOption"/>
		<seealso cref="System.Net.Sockets.SocketOptionName"/>
		<seealso cref="System.Net.Sockets.SocketOptionLevel"/>
	</doc>
	<doc for="Socket.EndConnect">
		<summary>
			<para>Ends a pending asynchronous connection request.</para>
		</summary>
		<param name="asyncResult">An <see cref="System.IAsyncResult"/> that stores state information and any user defined data for this asynchronous operation. </param>
		<exception cref="System.ArgumentNullException"><paramref name="asyncResult "/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException"><paramref name="asyncResult "/> was not returned by a call to the <see cref="System.Net.Sockets.Socket.BeginConnect"/> method.</exception>
		<exception cref="System.InvalidOperationException"><see cref="System.Net.Sockets.Socket.EndConnect"/> was previously called for the asynchronous connection.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed. </exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket.EndConnect"/> is a blocking method that completes
   the asynchronous remote host connection request started in the <see cref="System.Net.Sockets.Socket.BeginConnect"/> method.</para>
			<para>Before calling <see cref="System.Net.Sockets.Socket.BeginConnect"/>, you need to create a callback
method that implements the <see cref="System.AsyncCallback"/> delegate. This callback method executes in a separate
thread and is called by the system after <see cref="System.Net.Sockets.Socket.BeginConnect"/> returns. The
callback method must accept the <see cref="System.IAsyncResult"/> returned by the <see cref="System.Net.Sockets.Socket.BeginConnect"/> method as a parameter. </para>
			<para>Within the callback method, call the <see cref="System.IAsyncResult.AsyncState"/> method of the <see cref="System.IAsyncResult"/> parameter
to obtain the <see cref="System.Net.Sockets.Socket"/> on which the connection attempt is being
made. After obtaining the <see cref="System.Net.Sockets.Socket"/>, you can call the <see cref="System.Net.Sockets.Socket.EndConnect"/> method to successfully complete the
connection attempt.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example ends the asynchronous connection attempt.</para>
			<codelink SampleID="Socket_Async_Send_Receive" SnippetID="5"/>
		</example>
		<seealso topic="cpconasynchronousprogramming"/>
		<seealso cref="System.Net.Sockets.Socket.BeginConnect"/>
		<seealso cref="System.AsyncCallback"/>
		<seealso cref="System.IAsyncResult.AsyncState"/>
	</doc>
	<doc for="Socket.EndSend">
		<summary>
			<para>Ends a pending asynchronous send.</para>
		</summary>
		<param name="asyncResult">An <see cref="System.IAsyncResult"/> that stores state information for this asynchronous operation.</param>
		<returns>
			<para> If successful, the number of bytes sent to the <see cref="System.Net.Sockets.Socket"/>; otherwise, an invalid <see cref="System.Net.Sockets.Socket"/> error.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="asyncResult "/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException"><paramref name="asyncResult "/> was not returned by a call to the <see cref="System.Net.Sockets.Socket.BeginSend"/> method.</exception>
		<exception cref="System.InvalidOperationException"><see cref="System.Net.Sockets.Socket.EndSend"/> was previously called for the asynchronous read.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket.EndSend"/> completes the asynchronous send
   operation started in <see cref="System.Net.Sockets.Socket.BeginSend"/>.</para>
			<para>Before calling <see cref="System.Net.Sockets.Socket.BeginSend"/>, you need to create a callback method 
that implements the <see cref="System.AsyncCallback"/> delegate. This callback method executes in a separate
thread and is called by the system after <see cref="System.Net.Sockets.Socket.BeginSend"/> returns. The
callback method must accept the <see cref="System.IAsyncResult"/> returned by the <see cref="System.Net.Sockets.Socket.BeginSend"/> method as a parameter. </para>
			<para>Within the callback method, call the <see cref="System.IAsyncResult.AsyncState"/> method of the <see cref="System.IAsyncResult"/> parameter
to obtain the sending <see cref="System.Net.Sockets.Socket"/>. After obtaining the <see cref="System.Net.Sockets.Socket"/>, you
can call the <see cref="System.Net.Sockets.Socket.EndSend"/> method to successfully complete the
send operation and return the number of bytes sent.</para>
If you are using a connectionless protocol, <see cref="System.Net.Sockets.Socket.EndSend"/> will block until the
datagram is sent. If you are using a connection-oriented protocol, <see cref="System.Net.Sockets.Socket.EndSend"/> will block until the requested number
of bytes are sent. There is no guarantee that the data you send will appear on
the network immediately. To increase network efficiency, the underlying system
may delay transmission until a significant amount of outgoing data is collected.
A successful completion of the <see cref="System.Net.Sockets.Socket.BeginSend"/> method means that the underlying
system has had room to buffer your data for a network send. If it is important
to your application to send every byte to the remote host immediately, you can
use <see cref="System.Net.Sockets.Socket.SetSocketOption"/> to enable <see cref="System.Net.Sockets.SocketOptionName.NoDelay" qualify="true"/>. For more information about buffering for network efficiency, refer to the
Nagle algorithm in MSDN.
<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example ends a pending asynchronous
      send.</para>
			<codelink SampleID="Socket_Async_Send_Receive" SnippetID="6"/>
		</example>
		<seealso topic="cpconasynchronousprogramming"/>
		<seealso cref="System.Net.Sockets.Socket.BeginSend"/>
		<seealso cref="System.AsyncCallback"/>
		<seealso cref="System.IAsyncResult.AsyncState"/>
		<seealso cref="System.Net.Sockets.Socket.SetSocketOption"/>
		<seealso cref="System.Net.Sockets.SocketOptionName.NoDelay"/>
	</doc>
	<doc for="Socket.EndSendTo">
		<summary>
			<para>Ends a pending asynchronous send to a specific location.</para>
		</summary>
		<param name="asyncResult">An <see cref="System.IAsyncResult"/> that stores state information and any user defined data for this asynchronous operation.</param>
		<returns>
			<para> If successful, the number of bytes sent; otherwise, an invalid <see cref="System.Net.Sockets.Socket"/> error.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="asyncResult "/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException"><paramref name="asyncResult "/> was not returned by a call to the <see cref="System.Net.Sockets.Socket.BeginSendTo"/> method.</exception>
		<exception cref="System.InvalidOperationException"><see cref="System.Net.Sockets.Socket.EndSendTo"/> was previously called for the asynchronous read.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket.EndSendTo"/> completes the asynchronous send
   operation started in <see cref="System.Net.Sockets.Socket.BeginSendTo"/>.</para>
			<para>Before calling <see cref="System.Net.Sockets.Socket.BeginSendTo"/>, you need to create a callback
method that implements the <see cref="System.AsyncCallback"/> delegate. This callback method executes in a separate
thread and is called by the system after <see cref="System.Net.Sockets.Socket.BeginReceive"/> returns. The
callback method must accept the <see cref="System.IAsyncResult"/> returned by the <see cref="System.Net.Sockets.Socket.BeginSendTo"/> method as a parameter. </para>
			<para>Within the callback method, call the <see cref="System.IAsyncResult.AsyncState"/> method of the <see cref="System.IAsyncResult"/> parameter
to obtain the sending <see cref="System.Net.Sockets.Socket"/>. After obtaining the <see cref="System.Net.Sockets.Socket"/>, you
can call the <see cref="System.Net.Sockets.Socket.EndSendTo"/> method to successfully complete the
send operation and return the number of bytes sent.</para>
			<para>If you are using a connectionless protocol, <see cref="System.Net.Sockets.Socket.EndSendTo"/> will block until the
datagram is sent. If you are using a connection-oriented protocol, <see cref="System.Net.Sockets.Socket.EndSendTo"/> will block until the requested number
of bytes are sent. There is no guarantee that the data you send will appear on
the network immediately. To increase network efficiency, the underlying system
may delay transmission until a significant amount of outgoing data is collected.
A successful completion of the <see cref="System.Net.Sockets.Socket.BeginSendTo"/> method means that
the underlying system has had room to buffer your data for a network send. If it
is important to your application to send every byte to the remote host
immediately, you can use <see cref="System.Net.Sockets.Socket.SetSocketOption"/> to enable <see cref="System.Net.Sockets.SocketOptionName.NoDelay" qualify="true"/>. For more information
about buffering for network efficiency, refer to the Nagle algorithm in MSDN. </para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example ends an asynchronous send to a specific location.</para>
			<codelink SampleID="Socket_Async_Send_Receive" SnippetID="9"/>
		</example>
		<seealso topic="cpconasynchronousprogramming"/>
	</doc>
	<doc for="Socket.EndReceive">
		<summary>
			<para>Ends a pending asynchronous read.</para>
		</summary>
		<param name="asyncResult">An <see cref="System.IAsyncResult"/> that stores state information and any user defined data for this asynchronous operation.</param>
		<returns>
			<para> The number of bytes received.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="asyncResult "/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException"><paramref name="asyncResult "/> was not returned by a call to the <see cref="System.Net.Sockets.Socket.BeginReceive"/> method.</exception>
		<exception cref="System.InvalidOperationException"><see cref="System.Net.Sockets.Socket.EndReceive"/> was previously called for the asynchronous read.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.EndReceive"/> method completes the asynchronous
   read operation started in the <see cref="System.Net.Sockets.Socket.BeginReceive"/> method.</para>
			<para>Before calling <see cref="System.Net.Sockets.Socket.BeginReceive"/>, you need to create a callback
method that implements the <see cref="System.AsyncCallback"/> delegate. This callback method executes in a separate
thread and is called by the system after <see cref="System.Net.Sockets.Socket.BeginReceive"/> returns. The
callback method must accept the <see cref="System.IAsyncResult"/> returned by the <see cref="System.Net.Sockets.Socket.BeginReceive"/> method as a parameter. </para>
			<para>Within the callback method, call the <see cref="System.IAsyncResult.AsyncState"/> method of the <see cref="System.IAsyncResult"/> to
obtain the state object passed to the <see cref="System.Net.Sockets.Socket.BeginReceive"/> method. Extract the
receiving <see cref="System.Net.Sockets.Socket"/> from this state object. After obtaining the
<see cref="System.Net.Sockets.Socket"/>, you can call the <see cref="System.Net.Sockets.Socket.EndReceive"/> method to successfully complete the 
read operation and return the number of bytes read.</para>
			<para>The <see cref="System.Net.Sockets.Socket.EndReceive"/> method will block until data is
available. If you are using a connectionless protocol, <see cref="System.Net.Sockets.Socket.EndReceive"/> will read the first enqueued
datagram available in the incoming network buffer. If you are using a
connection-oriented protocol, the <see cref="System.Net.Sockets.Socket.EndReceive"/> method will read
as much data as is available up to the number of bytes you specified in the
<paramref name="size"/> parameter of the <see cref="System.Net.Sockets.Socket.BeginReceive"/> method. If the 
remote host shuts down the <see cref="System.Net.Sockets.Socket"/> connection with the <see cref="System.Net.Sockets.Socket.Shutdown"/> method, and all available data has
been received, the <see cref="System.Net.Sockets.Socket.EndReceive"/> method will complete immediately and
return zero bytes. </para>
To obtain the received data, call the <see cref="System.IAsyncResult.AsyncState"/> method of the <see cref="System.IAsyncResult"/>, and extract the buffer contained in the resulting
state object.
<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example ends a pending asynchronous read.</para>
			<codelink SampleID="Socket_Async_Send_Receive" SnippetID="8"/>
		</example>
		<seealso topic="cpconasynchronousprogramming"/>
		<seealso cref="System.Net.Sockets.Socket.BeginReceive"/>
		<seealso cref="System.AsyncCallback"/>
		<seealso cref="System.IAsyncResult"/>
		<seealso cref="System.IAsyncResult.AsyncState"/>
		<seealso cref="System.Net.Sockets.Socket.Shutdown"/>
	</doc>
	<doc for="Socket.EndReceiveFrom">
		<summary>
			<para> Ends a pending asynchronous read from a specific endpoint.</para>
		</summary>
		<param name="asyncResult">An <see cref="System.IAsyncResult"/> that stores state information and any user defined data for this asynchronous operation. </param>
		<param name=" endPoint">The source <see cref="System.Net.EndPoint"/>. </param>
		<returns>
			<para> If successful, the number of bytes received. If unsuccessful, returns 0.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="asyncResult "/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException"><paramref name="asyncResult "/> was not returned by a call to the <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method.</exception>
		<exception cref="System.InvalidOperationException"><see cref="System.Net.Sockets.Socket.EndReceiveFrom"/> was previously called for the asynchronous read.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.EndReceiveFrom"/> method completes the asynchronous
   read operation started in the <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method. </para>
			<para>Before calling <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> , you need to create a callback
method that implements the <see cref="System.AsyncCallback"/> delegate. This callback method executes in a separate
thread and is called by the system after <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> returns. The
callback method must accept the <see cref="System.IAsyncResult"/> returned by the <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method as a parameter. </para>
			<para>Within the callback method, call the <see cref="System.IAsyncResult.AsyncState"/> method of the <see cref="System.IAsyncResult"/> to
obtain the state object passed to the <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method. Extract the
receiving <see cref="System.Net.Sockets.Socket"/> from this state object. After obtaining the
<see cref="System.Net.Sockets.Socket"/>, you can call the <see cref="System.Net.Sockets.Socket.EndReceiveFrom"/> method to successfully complete the 
read operation and return the number of bytes read.</para>
			<para>The <see cref="System.Net.Sockets.Socket.EndReceiveFrom"/> method will block until data is
available. If you are using a connectionless protocol, <see cref="System.Net.Sockets.Socket.EndReceiveFrom"/> will read the first enqueued
datagram available in the incoming network buffer. If you are using a
connection-oriented protocol, the <see cref="System.Net.Sockets.Socket.EndReceiveFrom"/> method will read as
much data as is available up to the number of bytes you specified in the
<paramref name="size"/> parameter of the <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method. If the 
remote host shuts down the <see cref="System.Net.Sockets.Socket"/> connection with the <see cref="System.Net.Sockets.Socket.Shutdown"/> method, and all available data has
been received, the <see cref="System.Net.Sockets.Socket.EndReceiveFrom"/> method will complete immediately and
return zero bytes. To obtain the received data, call the <see cref="System.IAsyncResult.AsyncState"/>
method of the <see cref="System.IAsyncResult"/> object, and extract the buffer contained in the
resulting state object. To identify the originating host, extract the <see cref="System.Net.EndPoint"/> and cast it
to an <see cref="System.Net.IPEndPoint"/>. Use the <see cref="System.Net.IPEndPoint.Address" qualify="true"/> method to obtain the IP
address and the <see cref="System.Net.IPEndPoint.Port" qualify="true"/> method to obtain the port number.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example ends a pending asynchronous read from a specific
   <see cref="System.Net.EndPoint"/>.</para>
			<codelink SampleID="Socket_Async_Send_Receive" SnippetID="10"/>
		</example>
		<seealso topic="cpconasynchronousprogramming"/>
	</doc>
	<doc for="Socket.BeginAccept">
		<summary>
			<para>Begins an asynchronous operation to accept an incoming connection
      attempt.</para>
		</summary>
		<param name="callback">The <see cref="System.AsyncCallback"/>delegate. </param>
		<param name=" state">An object containing state information for this request.</param>
		<returns>
			<para>An <see cref="System.IAsyncResult"/> that references the asynchronous <see cref="System.Net.Sockets.Socket"/> creation.</para>
		</returns>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para>Connection-oriented protocols can use the <see cref="System.Net.Sockets.Socket.BeginAccept"/> method to
   asynchronously process incoming connection attempts. Accepting connections
   asynchronously gives you the ability to send and receive data within a separate
   execution thread. Before calling the <see cref="System.Net.Sockets.Socket.BeginAccept"/> method, you
   must call the <see cref="System.Net.Sockets.Socket.Listen"/> method to listen for and queue
   incoming connection requests. </para>
			<para>You must create a callback method that implements the <see cref="System.AsyncCallback"/> delegate
and pass its name to the <see cref="System.Net.Sockets.Socket.BeginAccept"/> method. To
do this, at the very minimum, you must
pass the listening <see cref="System.Net.Sockets.Socket"/> to <see cref="System.Net.Sockets.Socket.BeginAccept"/> through the
<paramref name="state"/> parameter. If your callback needs more information, you can create 
a small class to hold the <see cref="System.Net.Sockets.Socket"/> and the other required information. Pass an
instance of this class to the <see cref="System.Net.Sockets.Socket.BeginAccept"/> method through the
<paramref name="state"/> parameter. </para>
			<para>Your callback method should implement the <see cref="System.Net.Sockets.Socket.EndAccept"/> method. When your
application calls <see cref="System.Net.Sockets.Socket.BeginAccept"/>, the system will use a separate
thread to execute the specified callback method, and will block on <see cref="System.Net.Sockets.Socket.EndAccept"/> until a pending connection is
retrieved. <see cref="System.Net.Sockets.Socket.EndAccept"/> will return a new <see cref="System.Net.Sockets.Socket"/> that
you can use to send and receive data with the remote host. You cannot use this
returned <see cref="System.Net.Sockets.Socket"/> to accept any additional connections from
the connection queue. If you want the original thread to block after you call
the <see cref="System.Net.Sockets.Socket.BeginAccept"/> method,
use <see cref="System.Threading.WaitHandle.WaitOne" qualify="true"/>. Call <see cref="System.Threading.ManualResetEvent.Set" qualify="true"/> in
the callback method when you want the original thread to continue executing. For
additional information on writing callback methods see
<see topic="cpconcallbacksample"/>. </para>
			<note type="note">
   You can call the <see cref="System.Net.Sockets.Socket.RemoteEndPoint"/> method of the returned <see cref="System.Net.Sockets.Socket"/> to
   identify the remote host's network address and port number.
</note>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example attempts to receive an incoming connection
      asynchronously.</para>
			<codelink SampleID="Socket_Async_Send_Receive" SnippetID="2"/>
		</example>
		<seealso topic="cpconasynchronousprogramming"/>
		<seealso cref="System.Net.Sockets.Socket.Listen"/>
		<seealso cref="System.AsyncCallback"/>
		<seealso cref="System.Net.Sockets.Socket.EndAccept"/>
		<seealso cref="System.Net.Sockets.Socket"/>
		<seealso cref="System.Net.Sockets.Socket.RemoteEndPoint"/>
	</doc>
	<doc for="Socket.Available">
		<summary>
			<para> Gets the amount of data that has been received from the network and is
      available to be read.
      </para>
		</summary>
		<value>
			<para> The number of bytes of data received from the network and
      available to be read.</para>
		</value>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para>If you are using a non-blocking <see cref="System.Net.Sockets.Socket"/>, <see cref="System.Net.Sockets.Socket.Available"/> is a good way to determine whether data is
   queued for reading, before calling <see cref="System.Net.Sockets.Socket.Receive"/>. With <see cref="System.IO.Stream"/>
				<see cref="System.Net.Sockets.Socket"/>
types, the available data is the total amount of data queued in the network
buffer for reading. If you are using a message-oriented <see cref="System.Net.Sockets.Socket"/> type
such as <see cref="System.Net.Sockets.SocketType.Dgram"/>, the available data is the first
message in that buffer. If no data is queued in the network buffer, <see cref="System.Net.Sockets.Socket.Available"/>
returns 0. </para>
			<para> If the remote host
   shuts down or closes the connection, <see cref="System.Net.Sockets.Socket.Available"/> throws a <see cref="System.Net.Sockets.SocketException"/>. If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain the specific error
   code. Once you have obtained this code, you can refer to the Windows Socket
   Version 2 API error code documentation in MSDN for a detailed description of the
   error. </para>
		</remarks>
		<example>
			<para>The following example uses <see cref="System.Net.Sockets.Socket.Available"/> to determine how many bytes to read into a
   local buffer.</para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="3"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Receive"/>
		<seealso cref="System.IO.Stream"/>
		<seealso cref="System.Net.Sockets.SocketType.Dgram"/>
	</doc>
	<doc for="Socket.Socket">
		<summary>
			<para> Initializes a new instance of the <see cref="System.Net.Sockets.Socket"/> class.
   </para>
		</summary>
		<param name="addressFamily">One of the <see cref="System.Net.Sockets.AddressFamily"/> values. </param>
		<param name="socketType">One of the <see cref="System.Net.Sockets.SocketType"/> values. </param>
		<param name="protocolType">One of the <see cref="System.Net.Sockets.ProtocolType"/> values. </param>
		<exception cref="System.Net.Sockets.SocketException">The combination of <paramref name="addressFamily"/>, <paramref name="socketType"/>, and <paramref name="protocolType"/> results in an invalid socket. </exception>
		<remarks>
			<para>The <paramref name="addressFamily "/>parameter specifies the addressing scheme that the
<see cref="System.Net.Sockets.Socket"/> uses, the <paramref name="socketType "/> parameter 
   specifies the type of the <see cref="System.Net.Sockets.Socket"/>, and the <paramref name="protocolType"/> parameter
   specifies the protocol used by the <see cref="System.Net.Sockets.Socket"/>. The three parameters are
   not independent. Some address families restrict which protocols can be used with
   them, and often the <see cref="System.Net.Sockets.Socket"/> type is implicit in the protocol. If the
   combination of address family, <see cref="System.Net.Sockets.Socket"/> type, and protocol type results in an
   invalid <see cref="System.Net.Sockets.Socket"/>, this constructor will throw a <see cref="System.Net.Sockets.SocketException"/>.</para>
			<note type="note">
   If this constructor throws a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example demonstrates how to create an instance
      of the <see cref="System.Net.Sockets.Socket"/> class. </para>
			<codelink SampleID="Socket_Send_Recieve" SnippetID="1"/>
		</example>
		<seealso cref="System.Net.Sockets.SocketException"/>
		<seealso cref="System.Net.Sockets.AddressFamily"/>
		<seealso cref="System.Net.Sockets.ProtocolType"/>
		<seealso cref="System.Net.Sockets.SocketType"/>
	</doc>
	<doc for="Socket.Bind">
		<summary>
			<para>Associates a <see cref="System.Net.Sockets.Socket"/> with a local endpoint.</para>
		</summary>
		<param name="localEP">The local <see cref="System.Net.EndPoint"/> to associate with the <see cref="System.Net.Sockets.Socket"/>.</param>
		<exception cref="System.ArgumentNullException"><paramref name="localEP "/> is <see langword="null"/>.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.Security.SecurityException">A caller higher in the call stack does not have permission for the requested operation. </exception>
		<remarks>
			<para> Use the <see cref="System.Net.Sockets.Socket.Bind"/> method if you need to use a specific local
   endpoint. You must call <see cref="System.Net.Sockets.Socket.Bind"/> before you can call the <see cref="System.Net.Sockets.Socket.Listen"/> method. You do not need to call
<see cref="System.Net.Sockets.Socket.Bind"/> before using the <see cref="System.Net.Sockets.Socket.Connect"/> method
   unless you need to use a specific local endpoint. You can use the <see cref="System.Net.Sockets.Socket.Bind"/>
   method on both connectionless and connection-oriented protocols.</para>
			<para>Before calling <see cref="System.Net.Sockets.Socket.Bind"/>, you must first create the local
<see cref="System.Net.IPEndPoint"/> 
from which you intend to communicate data. If you do not care which local
address is assigned, you can create an <see cref="System.Net.IPEndPoint"/> using <see cref="System.Net.IPAddress.Any" qualify="true"/> as the address parameter,
and the underlying service provider will assign the most appropriate network
address. This might help simplify your application if you have multiple network
interfaces. If you do not care which local port is used, you can create an
<see cref="System.Net.IPEndPoint"/> 
using 0 for the port number. In this case, the service provider will assign an
available port number between 1024 and 5000. </para>
			<para>If you use the above approach, you can discover what local network address and port
   number has been assigned by calling the <see cref="System.Net.Sockets.Socket.LocalEndPoint"/>. If you are using a
   connection-oriented protocol, <see cref="System.Net.Sockets.Socket.LocalEndPoint"/> will not return the
   locally assigned network address until after you have made a call to the <see cref="System.Net.Sockets.Socket.Connect"/> or <see cref="System.Net.Sockets.Socket.EndConnect"/> method. If you are
   using a connectionless protocol, you will not have access to this information
   until you have completed a send or receive.</para>
			<note type="note">
   If you intend to receive multicasted
   datagrams, you must call the <see cref="System.Net.Sockets.Socket.Bind"/>
   method
   with a multicast port
   
   number.
</note>
			<note type="note">
   You must call the <see cref="System.Net.Sockets.Socket.Bind"/>
   method if you intend to receive connectionless datagrams using the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method.
</note>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/> when calling the <see cref="System.Net.Sockets.Socket.Bind"/> method, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain the specific error
   code. Once you have obtained this code, you can refer to the Windows Socket
   Version 2 API error code documentation in MSDN for a detailed description of the
   error.
</note>
		</remarks>
		<permission cref="System.Net.SocketPermission">for accepting connections from the host defined by <paramref name="localEP"/>. Associated enumeration: <see cref="System.Net.NetworkAccess.Accept" qualify="true"/></permission>
		<example>
			<para>The following example binds a <see cref="System.Net.Sockets.Socket"/>
using the specified local endpoint.</para>
			<codelink SampleID="Classic Socket.Bind Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Net.IPEndPoint"/>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.Listen"/>
		<seealso cref="System.Net.IPAddress"/>
		<seealso cref="System.Net.Sockets.Socket.LocalEndPoint"/>
	</doc>
	<doc for="Socket.Close">
		<summary>
			<para>Closes the <see cref="System.Net.Sockets.Socket"/> connection and releases all associated
   resources. </para>
		</summary>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.Close"/> method closes the the remote host
   connection and releases all managed and unmanaged resources associated with the
<see cref="System.Net.Sockets.Socket"/>. Upon closing, the <see cref="System.Net.Sockets.Socket.Connected"/> property is set to 
<see langword="false"/>.</para>
			<para>For connection-oriented protocols, it is recommended that you call <see cref="System.Net.Sockets.Socket.Shutdown"/> before calling the <see cref="System.Net.Sockets.Socket.Close"/> 
method. This ensures that all data is sent and received on the connected
socket before it is
closed. </para>
			<para>If you need to call <see cref="System.Net.Sockets.Socket.Close"/> without first calling <see cref="System.Net.Sockets.Socket.Shutdown"/>, you can ensure that data queued for outgoing transmission will be sent by setting the <see cref="System.Net.Sockets.SocketOptionName.DontLinger"/>
				<see cref="System.Net.Sockets.Socket"/> option to <see langword="false"/> and specifying a non-zero time-out interval.
<see cref="System.Net.Sockets.Socket.Close"/> will then block until this data is 
sent or until the specified time-out expires. If you set <see cref="System.Net.Sockets.SocketOptionName.DontLinger"/> to <see langword="false"/>
and specify a zero time-out interval, <see cref="System.Net.Sockets.Socket.Close"/> releases
the connection and automatically discards outgoing queued data.</para>
			<note type="note">
   To set the <see cref="System.Net.Sockets.SocketOptionName.DontLinger"/> socket option to <see langword="false"/>, create a <see cref="System.Net.Sockets.LingerOption"/>, set the enabled property to
<see langword="false"/>, and set the <see cref="System.Net.Sockets.LingerOption.LingerTime"/> property to the desired time 
   out period. Use this <see cref="System.Net.Sockets.LingerOption"/> along with the <see cref="System.Net.Sockets.SocketOptionName.DontLinger"/>socket option to call the <see cref="System.Net.Sockets.Socket.SetSocketOption"/> method.
</note>
		</remarks>
		<example>
			<para>The following example closes a <see cref="System.Net.Sockets.Socket"/>.</para>
			<codelink SampleID="Classic Socket.Close Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Shutdown"/>
		<seealso cref="System.Net.Sockets.SocketOptionName.DontLinger"/>
	</doc>
	<doc for="Socket.Shutdown">
		<summary>
			<para>Disables sends and receives on a <see cref="System.Net.Sockets.Socket"/>.</para>
		</summary>
		<param name="how">One of the <see cref="System.Net.Sockets.SocketShutdown"/> values that specifies the operation that will no longer be allowed.</param>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para>When using a connection-oriented <see cref="System.Net.Sockets.Socket"/>, always call the <see cref="System.Net.Sockets.Socket.Shutdown"/> method before closing the <see cref="System.Net.Sockets.Socket"/> . This ensures that all data is sent and
   received on the connected socket before it is closed.</para>
			<para> Call the <see cref="System.Net.Sockets.Socket.Close"/> method to free all managed and
unmanaged resources associated with the <see cref="System.Net.Sockets.Socket"/>. Do not attempt to reuse the <see cref="System.Net.Sockets.Socket"/> after closing.</para>
			<para>The following table shows the <see cref="System.Net.Sockets.SocketShutdown"/> enumeration values that are valid for the <paramref name="how "/>parameter.</para>
			<list type="table">
				<listheader>
					<term>Value</term>
					<description>Description</description>
				</listheader>
				<item>
					<term> Send</term>
					<description>Disable sending on this <see cref="System.Net.Sockets.Socket"/>.</description>
				</item>
				<item>
					<term> Receive</term>
					<description>Disable receiving on this <see cref="System.Net.Sockets.Socket"/>.</description>
				</item>
				<item>
					<term> Both</term>
					<description>Disable both sending and receiving on this <see cref="System.Net.Sockets.Socket"/>.</description>
				</item>
			</list>
			<para>Setting <paramref name="how"/> to <see cref="System.Net.Sockets.SocketShutdown.Send"/> specifies that subsequent
calls to <see cref="System.Net.Sockets.Socket.Send"/>
are not allowed. If you are using a
connectionless <see cref="System.Net.Sockets.Socket"/>, specifying
<see cref="System.Net.Sockets.SocketShutdown.Send"/> 
will have no effect. </para>
			<para>Setting <paramref name="how"/> to <see cref="System.Net.Sockets.SocketShutdown.Receive"/> specifies that subsequent
calls to <see cref="System.Net.Sockets.Socket.Receive"/> are not
allowed. This has no effect on lower protocol layers. If you are using a
connection-oriented protocol, the connection is terminated if either of the following
conditions exist after a call to <see cref="System.Net.Sockets.Socket.Shutdown"/>:</para>
			<list type="bullet"><item>
					<term>
      
      Data is in the incoming network buffer waiting to be
      received.</term>
				</item>
				<item>
					<term>
      
      More data has arrived.</term>
				</item>
			</list>
			<para> If you are using a connectionless
   protocol, datagrams are accepted and queued. However, if no buffer space is available
   for additional incoming datagrams, they will be discarded and no error will be
   returned to the sender. Using <see cref="System.Net.Sockets.Socket.Shutdown"/> on a connectionless <see cref="System.Net.Sockets.Socket"/> is not recommended. </para>
			<para>Setting <paramref name="how"/> to <see cref="System.Net.Sockets.SocketShutdown.Both"/> disables both sends and
receives as described above.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/> when calling the <see cref="System.Net.Sockets.Socket.Shutdown"/> method, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain the specific error
   code. Once you have obtained this code, you can refer to the Windows Socket
   Version 2 API error code documentation in MSDN for a detailed description of the
   error.
</note>
		</remarks>
		<example>
			<para>The following example uses <see cref="System.Net.Sockets.Socket.Shutdown"/> to disable the <see cref="System.Net.Sockets.Socket"/>.</para>
			<codelink SampleID="Classic Socket.Close Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Close"/>
		<seealso cref="System.Net.Sockets.SocketShutdown"/>
	</doc>
	<doc for="Socket.Receive">
		<overload>
			<para>Receives data from a bound <see cref="System.Net.Sockets.Socket"/>.</para>
		</overload>
		<summary>
			<para>Receives the specified number of bytes of data from a bound <see cref="System.Net.Sockets.Socket"/> into a
   receive buffer, using the specified <see cref="System.Net.Sockets.SocketFlags"/>.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that is the storage location for the received data.</param>
		<param name="size">The number of bytes to receive.</param>
		<param name="socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<returns>
			<para>The number of bytes received.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="buffer"/> is<paramref name=" "/>
			<see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="size"/> exceeds the size of <paramref name="buffer"/>.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.Receive"/> This method reads data into the <paramref name="buffer"/> parameter and returns the number of
   bytes successfully read. You can call <see cref="System.Net.Sockets.Socket.Receive"/> from both
   connection-oriented and connectionless sockets. </para>
			<para>This overload only requires you to provide a receive buffer, the number of
   bytes you want to receive, and the necessary <see cref="System.Net.Sockets.SocketFlags"/>. The buffer
   offset defaults to 0. If you specify the <see cref="System.Net.Sockets.SocketFlags.Peek"/> flag as the <paramref name="socketFlags
   "/> parameter, the
   available data is copied into the receive buffer but not removed from
   the system buffer.
   If you specify the <see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the <paramref name="socketFlags
   "/>parameter and the <see cref="System.Net.Sockets.Socket"/> is configured for in-line reception of
   out-of-band (OOB) data (using <see cref="System.Net.Sockets.SocketOptionName.OutOfBandInline"/>) and OOB data is
   available, <see cref="System.Net.Sockets.Socket.Receive"/> will
   return only OOB data. The OOB data is a logically independent transmission
   channel associated with each pair of connected stream sockets. This
   data is delivered with higher priority and independently of the
   normal data.</para>
			<para>If you are using a connection-oriented protocol, You must either call <see cref="System.Net.Sockets.Socket.Connect"/> to establish a remote host connection,
or <see cref="System.Net.Sockets.Socket.Accept"/> to accept an incoming connection
prior to calling <see cref="System.Net.Sockets.Socket.Receive"/>. The <see cref="System.Net.Sockets.Socket.Receive"/> method will
only read data that arrives from the remote host established in the <see cref="System.Net.Sockets.Socket.Connect"/> or <see cref="System.Net.Sockets.Socket.Accept"/> method. If you are
using a connectionless protocol, you can also use the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method. <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will allow you to receive data
arriving from any host. </para>
			<para>If no data is available for reading, the <see cref="System.Net.Sockets.Socket.Receive"/>
method will block until data is
available. If you are in non-blocking mode, and there is no data available in the
in the protocol stack buffer, The <see cref="System.Net.Sockets.Socket.Receive"/> method will complete
immediately and throw a <see cref="System.Net.Sockets.SocketException"/>. You can use the <see cref="System.Net.Sockets.Socket.Available"/> property to determine if data is
available for reading. When <see cref="System.Net.Sockets.Socket.Available"/> is non-zero, retry your receive
operation. </para>
			<para>If you are using a connection-oriented <see cref="System.Net.Sockets.Socket"/>, the <see cref="System.Net.Sockets.Socket.Receive"/> method will read as much data as
is available, up to the number of bytes specified by the <paramref name="size"/> parameter. If
the remote host shuts down the <see cref="System.Net.Sockets.Socket"/> connection with the <see cref="System.Net.Sockets.Socket.Shutdown"/> method, and all available data has
been received, the <see cref="System.Net.Sockets.Socket.Receive"/> method will complete immediately and
return zero bytes.</para>
			<para>If you are using a connectionless <see cref="System.Net.Sockets.Socket"/>, <see cref="System.Net.Sockets.Socket.Receive"/> will read the first enqueued datagram
from the destination address you specify in the <see cref="System.Net.Sockets.Socket.Connect"/> method. If the
datagram you receive is larger than the size of the <paramref name="buffer "/> parameter,
<paramref name="buffer"/> gets filled with the first part of the message, the excess data is lost and a <see cref="System.Net.Sockets.SocketException"/> is thrown.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<permission cref="System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="System.Net.NetworkAccess.Accept"/>.</permission>
		<example>
			<para>The following receives the data found into <paramref name="buffer"/>, and
   specifies <see cref="System.Net.Sockets.SocketFlags.None"/> for <see cref="System.Net.Sockets.SocketFlags"/>.</para>
			<codelink SampleID="Socket_Send_Recieve" SnippetID="4"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.ReceiveFrom"/>
		<seealso cref="System.Net.Sockets.Socket.Available"/>
		<seealso cref="System.Net.Sockets.Socket.Shutdown"/>
		<seealso cref="System.Net.Sockets.Socket.Close"/>
	</doc>
	<doc for="Socket.Receive1">
		<summary>
			<para>Receives data from a bound <see cref="System.Net.Sockets.Socket"/> into a receive buffer, using the specified
<see cref="System.Net.Sockets.SocketFlags"/>.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that is the storage location for the received data.</param>
		<param name="socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<returns>
			<para>The number of bytes received.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="buffer "/> is <see langword="null"/>.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.Receive"/> method reads data into the buffer parameter and returns the number of
   bytes successfully read. You can call <see cref="System.Net.Sockets.Socket.Receive"/> from both
   connection-oriented and connectionless sockets. </para>
			<para>This overload only requires you to provide a receive buffer and the necessary
<see cref="System.Net.Sockets.SocketFlags"/>. The 
   buffer offset defaults to 0, and the size defaults to the length of the byte
   parameter. If you specify the <see cref="System.Net.Sockets.SocketFlags.Peek"/> flag as the <paramref name="socketFlags
   "/>parameter, the available data is copied into the receive buffer but not
   removed from the system buffer. If you specify the <see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the <paramref name="socketFlags
   "/>parameter and the <see cref="System.Net.Sockets.Socket"/> is configured for in-line reception of
   out-of-band (OOB) data (using <see cref="System.Net.Sockets.SocketOptionName.OutOfBandInline"/>) and OOB
   data is available, <see cref="System.Net.Sockets.Socket.Receive"/> will return only OOB data. The OOB
   data is a logically independent transmission channel associated with each pair
   of connected stream sockets. This data is
   delivered with higher priority and independently of the normal data.</para>
			<para>If you are using a connection-oriented protocol, You must either call <see cref="System.Net.Sockets.Socket.Connect"/>to establish a remote host connection,
or <see cref="System.Net.Sockets.Socket.Accept"/> to accept an incoming connection
prior to calling <see cref="System.Net.Sockets.Socket.Receive"/>. The <see cref="System.Net.Sockets.Socket.Receive"/> method will
only read data that arrives from the remote host established in the <see cref="System.Net.Sockets.Socket.Connect"/> or <see cref="System.Net.Sockets.Socket.Accept"/> method. If you are
using a connectionless protocol, you can also use the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method. <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will
allow you to receive data arriving from any host. </para>
			<para>If no data is available for reading, the <see cref="System.Net.Sockets.Socket.Receive"/> method
will block until
data is available. If you are in non-blocking mode, and there is no data available
in the protocol stack buffer, the <see cref="System.Net.Sockets.Socket.Receive"/> method will complete
immediately and throw a <see cref="System.Net.Sockets.SocketException"/>. You can use the <see cref="System.Net.Sockets.Socket.Available"/> property to determine if data is
available for reading. When <see cref="System.Net.Sockets.Socket.Available"/> is non-zero, retry your receive
operation. </para>
			<para>If you are using a connection-oriented <see cref="System.Net.Sockets.Socket"/>, the <see cref="System.Net.Sockets.Socket.Receive"/> method will read as much data as is
available up to the size of the buffer. If the remote host shuts down the
<see cref="System.Net.Sockets.Socket"/> connection with the <see cref="System.Net.Sockets.Socket.Shutdown"/> method, and all available data has 
been received, the <see cref="System.Net.Sockets.Socket.Receive"/> method will complete immediately and
return zero bytes.</para>
			<para>If you are using a connectionless <see cref="System.Net.Sockets.Socket"/>, <see cref="System.Net.Sockets.Socket.Receive"/> will read the first enqueued datagram
from the destination address you specify in the <see cref="System.Net.Sockets.Socket.Connect"/> method. If the
datagram you receive is larger than the size of the <paramref name="buffer "/>parameter,
<paramref name="buffer"/> gets filled with the first part of the message, the excess data is lost and a <see cref="System.Net.Sockets.SocketException"/> is thrown.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain the specific error
   code. Once you have obtained this code, you can refer to the Windows Socket
   Version 2 API error code documentation in MSDN for a detailed description of the
   error.
</note>
		</remarks>
		<permission cref="System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="System.Net.NetworkAccess.Accept"/>.</permission>
		<example>
			<para> The following example specifies a data buffer, and <see cref="System.Net.Sockets.SocketFlags"/>
for receiving data on a connected <see cref="System.Net.Sockets.Socket"/>.</para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="2"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.ReceiveFrom"/>
		<seealso cref="System.Net.Sockets.Socket.Available"/>
		<seealso cref="System.Net.Sockets.Socket.Shutdown"/>
		<seealso cref="System.Net.Sockets.Socket.Close"/>
	</doc>
	<doc for="Socket.Receive2">
		<summary>
			<para>Receives data from a bound <see cref="System.Net.Sockets.Socket"/> into a receive
   buffer.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that is the storage location for the received data.</param>
		<returns>
			<para>The number of bytes received.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="buffer "/> is <see langword="null"/>.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.Receive"/> method reads data into the buffer parameter and returns the number of
   bytes successfully read. You can call <see cref="System.Net.Sockets.Socket.Receive"/> from both connection-oriented and
   connectionless sockets. </para>
			<para>This overload only requires you to provide a receive 
   buffer. The buffer offset defaults to 0, the size defaults to the length of the
   buffer parameter, and the <see cref="System.Net.Sockets.SocketFlags"/>
   value defaults to <see cref="System.Net.Sockets.SocketFlags.None"/>. </para>
			<para>If you are using a connection-oriented protocol, You must either call <see cref="System.Net.Sockets.Socket.Connect"/>to establish a remote host connection,
or <see cref="System.Net.Sockets.Socket.Accept"/> to accept an incoming connection
prior to calling <see cref="System.Net.Sockets.Socket.Receive"/>. The <see cref="System.Net.Sockets.Socket.Receive"/> method will
only read data that arrives from the remote host established in the <see cref="System.Net.Sockets.Socket.Connect"/> or <see cref="System.Net.Sockets.Socket.Accept"/> method. If you are
using a connectionless protocol, you can also use the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method. <see cref="System.Net.Sockets.Socket.ReceiveFrom"/>will allow you to receive data
arriving from any host. </para>
			<para>If no data is available for reading, the <see cref="System.Net.Sockets.Socket.Receive"/>
method will block until data is
available. If you are in non-blocking mode, and there is no data available in the
in the protocol stack buffer, the <see cref="System.Net.Sockets.Socket.Receive"/> method will complete
immediately and throw a <see cref="System.Net.Sockets.SocketException"/>. You can use the <see cref="System.Net.Sockets.Socket.Available"/> property to determine if data is
available for reading. When <see cref="System.Net.Sockets.Socket.Available"/> is non-zero, retry the receive
operation. </para>
			<para>If you are using a connection-oriented <see cref="System.Net.Sockets.Socket"/>, the <see cref="System.Net.Sockets.Socket.Receive"/> method will read as much data as is
available, up to the size of the buffer. If the remote host shuts down the
<see cref="System.Net.Sockets.Socket"/> connection with the <see cref="System.Net.Sockets.Socket.Shutdown"/> method, and all available data has 
been received, the <see cref="System.Net.Sockets.Socket.Receive"/> method will complete immediately and
return zero bytes.</para>
			<para>If you are using a connectionless <see cref="System.Net.Sockets.Socket"/>, <see cref="System.Net.Sockets.Socket.Receive"/> will read the first enqueued datagram
from the destination address you specify in the <see cref="System.Net.Sockets.Socket.Connect"/> method. If the
datagram you receive is larger than the size of the <paramref name="buffer "/>parameter,
<paramref name="buffer"/> gets filled with the first part of the message, the excess data is lost and a <see cref="System.Net.Sockets.SocketException"/> is thrown.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain the specific error
   code. Once you have obtained this code, you can refer to the Windows Socket
   Version 2 API error code documentation in MSDN for a detailed description of the
   error.
</note>
		</remarks>
		<permission cref="System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="System.Net.NetworkAccess.Accept"/>.</permission>
		<example>
			<para>The following example receives data on a connected <see cref="System.Net.Sockets.Socket"/>.</para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="1"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.ReceiveFrom"/>
		<seealso cref="System.Net.Sockets.Socket.Available"/>
		<seealso cref="System.Net.Sockets.Socket.Shutdown"/>
		<seealso cref="System.Net.Sockets.Socket.Close"/>
	</doc>
	<doc for="Socket.Receive3">
		<summary>
			<para>Receives the specified number of bytes from a bound <see cref="System.Net.Sockets.Socket"/> into the
   specified offset position of the receive buffer, using the specified
<see cref="System.Net.Sockets.SocketFlags"/>.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that is the storage location for received data.</param>
		<param name="offset">The location in <paramref name="buffer "/>to store the received data.</param>
		<param name="size">The number of bytes to receive.</param>
		<param name="socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<returns>
			<para>The number of bytes received.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="buffer "/>is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="offset"/> is less than 0.</para>
			<para>-or-</para>
			<para><paramref name="offset"/> is greater than the length of <paramref name="buffer"/>. </para>
			<para>-or-</para>
			<para><paramref name="size"/> is less than 0.</para>
			<para>-or-</para>
			<para><paramref name="size"/> is greater than the length of <paramref name="buffer "/>minus the value of the <paramref name="offset"/> parameter.</para></exception>
		<exception cref="System.Net.Sockets.SocketException"><para><paramref name="socketFlags "/> is not a valid combination of values.</para>
			<para> -or-</para>
			<para>The <see cref="System.Net.Sockets.Socket.LocalEndPoint"/> property was not set.</para>
			<para> -or-</para>
			<para>An operating system error occurs while accessing the <see cref="System.Net.Sockets.Socket"/>.</para></exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.Security.SecurityException">A caller in the call stack does not have the required permissions. </exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.Receive"/> method reads data into the buffer parameter and returns the number
   of bytes successfully read. You can call <see cref="System.Net.Sockets.Socket.Receive"/> from both
   connection-oriented and connectionless sockets. </para>
			<para>If you specify the <see cref="System.Net.Sockets.SocketFlags.Peek"/> flag as the <paramref name="socketFlags 
"/>parameter, the available data is copied into the receive buffer but not
removed from the system buffer. If you specify the <see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the <paramref name="socketFlags
"/>parameter and the <see cref="System.Net.Sockets.Socket"/> is configured for in-line reception of
out-of-band (OOB) data (using <see cref="System.Net.Sockets.SocketOptionName.OutOfBandInline"/>) and OOB
data is available, <see cref="System.Net.Sockets.Socket.Receive"/> will return only OOB data. The OOB
data is a logically independent transmission channel associated with each pair
of connected stream sockets. This data is delivered with higher priority and
independently of the normal data.</para>
			<para>If you are using a connection-oriented protocol, You must either call <see cref="System.Net.Sockets.Socket.Connect"/>to establish a remote host connection,
or <see cref="System.Net.Sockets.Socket.Accept"/> to accept an incoming connection
prior to calling <see cref="System.Net.Sockets.Socket.Receive"/>. The <see cref="System.Net.Sockets.Socket.Receive"/> method will
only read data that arrives from the remote host established in the <see cref="System.Net.Sockets.Socket.Connect"/> or <see cref="System.Net.Sockets.Socket.Accept"/> method. If you are
using a connectionless protocol, you can also use the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method. <see cref="System.Net.Sockets.Socket.ReceiveFrom"/>will allow you to receive data
arriving from any host. </para>
			<para>If no data is available for reading, the <see cref="System.Net.Sockets.Socket.Receive"/> method
will block until data is
available. If you are in non-blocking mode, and there is no data available in the
in the protocol stack buffer, the <see cref="System.Net.Sockets.Socket.Receive"/> method will complete
immediately and throw a <see cref="System.Net.Sockets.SocketException"/>. An error occurred when attempting to
access the socket. See Remarks below. You can use the <see cref="System.Net.Sockets.Socket.Available"/> property to determine if data is
available for reading. When <see cref="System.Net.Sockets.Socket.Available"/> is non-zero, retry the receive
operation. </para>
			<para>If you are using a connection-oriented <see cref="System.Net.Sockets.Socket"/>, the <see cref="System.Net.Sockets.Socket.Receive"/> method will read as much data
as is available, up to the number of bytes specified by the size parameter. If the
remote host shuts down the <see cref="System.Net.Sockets.Socket"/> connection with the <see cref="System.Net.Sockets.Socket.Shutdown"/> method, and all available data has
been received, the <see cref="System.Net.Sockets.Socket.Receive"/> method will complete immediately and
return zero bytes.</para>
			<para>If you are using a connectionless <see cref="System.Net.Sockets.Socket"/>, <see cref="System.Net.Sockets.Socket.Receive"/> will read the first enqueued datagram
from the destination address you specify in the <see cref="System.Net.Sockets.Socket.Connect"/> method. If the
datagram you receive is larger than the size of the <paramref name="buffer "/>parameter,
<paramref name="buffer"/> gets filled with the first part of the message, the excess data is lost and a <see cref="System.Net.Sockets.SocketException"/> is thrown.</para>
			<note type="note">
      If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
      the specific error code. Once you have obtained this code, you can refer to the
      Windows Socket Version 2 API error code documentation in MSDN for a detailed
      description of the error.
   </note>
		</remarks>
		<permission cref="System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="System.Net.NetworkAccess.Accept"/>.</permission>
		<example>
			<para>The following example specifies a data buffer, an offset, a size, and a
      socket flag before receiving data on a connected <see cref="System.Net.Sockets.Socket"/>.</para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="4"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.ReceiveFrom"/>
		<seealso cref="System.Net.Sockets.Socket.Available"/>
		<seealso cref="System.Net.Sockets.Socket.Shutdown"/>
		<seealso cref="System.Net.Sockets.Socket.Close"/>
	</doc>
	<doc for="Socket.EndAccept">
		<summary>
			<para>Asynchronously accepts an incoming connection attempt and creates a new
   <see cref="System.Net.Sockets.Socket"/> to handle remote host communication.</para>
		</summary>
		<param name="asyncResult">An <see cref="System.IAsyncResult"/> that stores state information for this asynchronous operation as well as any user defined data.</param>
		<returns>
			<para>A <see cref="System.Net.Sockets.Socket"/> to handle communication with the remote
   host.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="asyncResult "/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException"><paramref name="asyncResult "/> was not created by a call to <see cref="System.Net.Sockets.Socket.BeginAccept"/>.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket.EndAccept"/> completes a call to <see cref="System.Net.Sockets.Socket.BeginAccept"/>. Before calling <see cref="System.Net.Sockets.Socket.BeginAccept"/>, you need to create a callback
   method that implements the <see cref="System.AsyncCallback"/> delegate. This callback method executes in a separate
   thread, and is called by the system after the <see cref="System.Net.Sockets.Socket.BeginAccept"/> method returns. It
   must accept the <paramref name="asyncResult"/> parameter returned from the <see cref="System.Net.Sockets.Socket.BeginAccept"/> method. </para>
			<para>Within the callback method, call the <see cref="System.IAsyncResult.AsyncState"/> method of the
<paramref name="asyncResult"/> parameter to obtain the <see cref="System.Net.Sockets.Socket"/> on which the connection 
attempt is being made. After obtaining the <see cref="System.Net.Sockets.Socket"/>, you can call the <see cref="System.Net.Sockets.Socket.EndAccept"/> method to successfully complete the
connection attempt.</para>
The <see cref="System.Net.Sockets.Socket.EndAccept"/> method blocks until a connection is
pending in the incoming connection queue. The <see cref="System.Net.Sockets.Socket.EndAccept"/> method accepts the
incoming connection and returns a new <see cref="System.Net.Sockets.Socket"/> that can be used to send data to and receive
data from the remote host.
<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example ends an asynchronous request and creates a new <see cref="System.Net.Sockets.Socket"/>
to accept an incoming connection request.</para>
			<codelink SampleID="Socket_Async_Send_Receive" SnippetID="7"/>
		</example>
		<seealso topic="cpconasynchronousprogramming"/>
		<seealso cref="System.Net.Sockets.Socket.BeginAccept"/>
		<seealso cref="System.AsyncCallback"/>
		<seealso cref="System.IAsyncResult.AsyncState"/>
	</doc>
	<doc for="Socket.Connect">
		<summary>
			<para> Establishes a connection to a remote host.</para>
		</summary>
		<param name="remoteEP">An <see cref="System.Net.EndPoint"/> that represents the remote device.</param>
		<exception cref="System.ArgumentNullException"><paramref name="remoteEP "/> is <see langword="null"/>.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.Security.SecurityException">A caller higher in the call stack does not have permission for the requested operation. </exception>
		<remarks>
			<para>If you are using a connection-oriented protocol such as TCP, the <see cref="System.Net.Sockets.Socket.Connect"/> method synchronously establishes a
   network connection between <see cref="System.Net.Sockets.Socket.LocalEndPoint"/> and the specified remote endpoint. If you are
   using a connectionless protocol, <see cref="System.Net.Sockets.Socket.Connect"/> establishes a default remote host.
   After you call <see cref="System.Net.Sockets.Socket.Connect"/>, you can send data to the remote
   device with the <see cref="System.Net.Sockets.Socket.Send"/> method, or receive data from the
   remote device with the <see cref="System.Net.Sockets.Socket.Receive"/> method.</para>
			<para>If you are using a connectionless protocol such as UDP,
   you do not have to call <see cref="System.Net.Sockets.Socket.Connect"/> before sending and receiving data. You can
   use <see cref="System.Net.Sockets.Socket.SendTo"/> and <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> to synchronously
   communicate with a remote host. If you do call <see cref="System.Net.Sockets.Socket.Connect"/>, any datagrams that arrive
   from an address other than the specified default will be discarded. If you
   want to set your default remote host to a broadcast address, you must first call
   the <see cref="System.Net.Sockets.Socket.SetSocketOption"/> method and set the socket option to
<see cref="System.Net.Sockets.SocketOptionName.Broadcast" qualify="true"/>, or <see cref="System.Net.Sockets.Socket.Connect"/> will throw a <see cref="System.Net.Sockets.SocketException"/>. If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/>to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.</para>
			<para>The <see cref="System.Net.Sockets.Socket.Connect"/> method will block, unless you
specifically set the <see cref="System.Net.Sockets.Socket.Blocking"/> property to <see langword="false"/>
prior to calling <see cref="System.Net.Sockets.Socket.Connect"/>. If you are using a
connection-oriented protocol like TCP and you do disable blocking, <see cref="System.Net.Sockets.Socket.Connect"/> will throw a <see cref="System.Net.Sockets.SocketException"/> because it needs time to make the
connection. Connectionless protocols will not throw an exception because they
simply establish a default remote host. You can use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/>to obtain the specific error
code. Once you have obtained this code, you can refer to the Windows Socket
Version 2 API error code documentation in MSDN for a detailed description of the
error. If the error returned WSAEWOULDBLOCK, the remote host connection has been
initiated by a connection-oriented <see cref="System.Net.Sockets.Socket"/>, but has not yet completed
successfully. Use the <see cref="System.Net.Sockets.Socket.Poll"/> method to determine when the <see cref="System.Net.Sockets.Socket"/> is
finished connecting. </para>
			<note type="note">
   If you are using a
   connection-oriented protocol and did not call <see cref="System.Net.Sockets.Socket.Bind"/> before calling
<see cref="System.Net.Sockets.Socket.Connect"/>, the underlying service 
   provider will assign the local network address and port number. If you are
   using a connectionless protocol, the service provider will not assign a local
   network address and port number until you complete a send or receive operation.
   If you want to change the default remote host, call <see cref="System.Net.Sockets.Socket.Connect"/> again with the desired endpoint.
</note>
		</remarks>
		<permission cref="System.Net.SocketPermission">for connecting to the remote host. Associated enumeration: <see cref="System.Net.NetworkAccess.Connect" qualify="true"/></permission>
		<example>
			<para> The following example connects to a remote endpoint and then verifies the
      connection. </para>
			<codelink SampleID="Classic Socket.Connect Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Send"/>
		<seealso cref="System.Net.Sockets.Socket.SendTo"/>
		<seealso cref="System.Net.Sockets.Socket.Receive"/>
		<seealso cref="System.Net.Sockets.Socket.ReceiveFrom"/>
		<seealso cref="System.Net.Sockets.Socket.LocalEndPoint"/>
		<seealso cref="System.Net.Sockets.Socket.SetSocketOption"/>
		<seealso cref="System.Net.Sockets.Socket.Blocking"/>
		<seealso cref="System.Net.Sockets.Socket.Poll"/>
	</doc>
	<doc for="Socket.BeginReceive">
		<summary>
			<para>Begins to asynchronously receive data from a connected <see cref="System.Net.Sockets.Socket"/>.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that is the storage location for the received data.</param>
		<param name=" offset">The zero-based position in the <paramref name="buffer "/>parameter at which to store the received data.</param>
		<param name=" size">The number of bytes to receive.</param>
		<param name=" socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<param name=" callback">The <see cref="System.AsyncCallback"/> delegate.</param>
		<param name=" state">An object containing state information for this request.</param>
		<returns>
			<para>An <see cref="System.IAsyncResult"/> that references the asynchronous read.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="buffer "/> is <see langword="null"/>.</para></exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException"><see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="offset"/> is less than 0.</para>
			<para>-or-</para>
			<para><paramref name="offset"/> is greater than the length of <paramref name="buffer"/>. </para>
			<para>-or-</para>
			<para><paramref name="size"/> is less than 0.</para>
			<para>-or-</para>
			<para><paramref name="size"/> is greater than the length of <paramref name="buffer"/> minus the value of the <paramref name="offset"/> parameter.</para></exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.BeginReceive"/> method starts asynchronously reading
   data from the <see cref="System.Net.Sockets.Socket"/> returned by <see cref="System.Net.Sockets.Socket.EndAccept"/>. Calling the <see cref="System.Net.Sockets.Socket.BeginReceive"/> method gives you the ability to
   receive data within a separate execution thread. </para>
			<para>You can create a<paramref name=" "/>callback method that implements the <see cref="System.AsyncCallback"/> delegate
and pass its name to the <see cref="System.Net.Sockets.Socket.BeginReceive"/>
method. To do this, at the very minimum, your
<paramref name="state"/> parameter must contain the connected or default <see cref="System.Net.Sockets.Socket"/> being used for 
communication. Since you will want to obtain the received data within your
callback method, you should create a small class or structure to
hold a<see langword=" "/>read buffer, and any other useful
information. Pass the structure or class instance to the <see cref="System.Net.Sockets.Socket.BeginReceive"/> method through the <paramref name="state"/>
parameter. </para>
			<para>Your callback method should implement the <see cref="System.Net.Sockets.Socket.EndReceive"/> method. When your
application calls <see cref="System.Net.Sockets.Socket.BeginReceive"/>, the system will use a separate
thread to execute the specified callback method, and will block on <see cref="System.Net.Sockets.Socket.EndReceive"/> until the <see cref="System.Net.Sockets.Socket"/> reads
data or throws an exception. If you want the original thread to block after you
call the <see cref="System.Net.Sockets.Socket.BeginReceive"/> method,
use <see cref="System.Threading.WaitHandle.WaitOne" qualify="true"/>. Call <see cref="System.Threading.ManualResetEvent.Set" qualify="true"/> in
the callback method when you want the original thread to continue executing. For
additional information on writing callback methods, see
<see topic="cpconcallbacksample"/>. </para>
			<para>You can call <see cref="System.Net.Sockets.Socket.BeginReceive"/> from both connection-oriented
and connectionless sockets. You must call the <see cref="System.Net.Sockets.Socket.Connect"/>, <see cref="System.Net.Sockets.Socket.BeginConnect"/>, <see cref="System.Net.Sockets.Socket.Accept"/>, or <see cref="System.Net.Sockets.Socket.BeginAccept"/> method before calling the <see cref="System.Net.Sockets.Socket.BeginReceive"/> method,
because the <see cref="System.Net.Sockets.Socket.BeginReceive"/>
method will only read data which arrives from the remote host you
specify in one of these methods. If you are using a
connectionless protocol, you can also use the <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method. <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/>will allow you to receive data
arriving from any host. </para>
			<para>If you are using a connection-oriented <see cref="System.Net.Sockets.Socket"/>, the <see cref="System.Net.Sockets.Socket.BeginReceive"/> method will read as much data as
is available, up to the number of bytes specified by the <paramref name="size"/> parameter.</para>
			<para>If you are using a connectionless <see cref="System.Net.Sockets.Socket"/>, <see cref="System.Net.Sockets.Socket.BeginReceive"/> will read the first enqueued datagram
from the destination address you specify in the <see cref="System.Net.Sockets.Socket.Connect"/> or <see cref="System.Net.Sockets.Socket.BeginConnect"/> method. If the datagram you receive
is larger than the size of the <paramref name="buffer "/>parameter, <paramref name="buffer"/> gets
filled with the first part of the message, and a <see cref="System.Net.Sockets.SocketException"/> is thrown. With
unreliable protocols the excess data is lost; with reliable protocols, the data
is retained by the service provider and you can retrieve the rest by calling the
<see cref="System.Net.Sockets.Socket.BeginReceive"/> method with a large enough buffer.</para>
			<para> If you specify the <see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the <paramref name="socketFlags"/> parameter and the <see cref="System.Net.Sockets.Socket"/> is configured for in-line reception of
out-of-band (OOB) data (using <see cref="System.Net.Sockets.SocketOptionName.OutOfBandInline"/>) and OOB data is
available, <see cref="System.Net.Sockets.Socket.BeginReceive"/> will
return only OOB data. The OOB data is a logically independent transmission
channel associated with each pair of connected stream sockets. This data is
delivered with higher priority and independently of the normal data. If you specify the <see cref="System.Net.Sockets.SocketFlags.Peek"/>
flag, the available data is
copied into the receive buffer but not removed from the system buffer.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example begins to asynchronously receive data from
      a connected <see cref="System.Net.Sockets.Socket"/>.</para>
			<codelink SampleID="Socket_Async_Send_Receive" SnippetID="7"/>
		</example>
		<seealso topic="cpconasynchronousprogramming"/>
		<seealso cref="System.Net.Sockets.Socket.EndAccept"/>
		<seealso cref="System.AsyncCallback"/>
		<seealso topic="cpconcallbacksample"/>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.BeginReceiveFrom"/>
	</doc>
	<doc for="Socket.Dispose">
		<summary>
			<para> Releases the unmanaged
      resources used by the <see cref="System.Net.Sockets.Socket"/>, and optionally
      disposes of the managed resources.</para>
		</summary>
		<param name="disposing"><see langword="true"/> to release both managed and unmanaged resources; <see langword="false"/> to releases only unmanaged resources.</param>
		<remarks>
			<para>This method is called by the public <see langword="Dispose()"/> method and the
<see cref="System.Object.Finalize"/> 
method. <see langword="Dispose()"/> invokes the protected
<see langword="Dispose(Boolean)"/> method with the <paramref name="disposing"/> parameter 
set to <see langword="true"/>. <see cref="System.Object.Finalize"/> invokes <see langword="Dispose"/> with
<paramref name="disposing"/> set to <see langword="false"/>.</para>
			<para>When the <paramref name="disposing"/> parameter is <see langword="true"/>, this method
releases all resources held by any managed objects that this <see cref="System.Net.Sockets.Socket"/>
references. This method invokes the <see langword="Dispose()"/> method of each
referenced object.</para>
			<note type="inheritinfo">
				<see langword="Dispose"/> can be called multiple times by other objects. When
   overriding <see langword="Dispose(Boolean)"/>, be careful not to reference
   objects that have been previously disposed of in an earlier call to
<see langword="Dispose"/>. For more information about how to implement 
<see langword="Dispose(Boolean)"/>, see <see topic="cpconImplementingDisposeMethod"/>.
</note>
			<para>For more information about <see langword="Dispose"/> and <see cref="System.Object.Finalize"/>, see
<see topic="cpconCleaningUpUnmanagedResources "/> and <see topic="cpconOverridingFinalizeMethod "/>.</para>
		</remarks>
	</doc>
	<doc for="Socket.Poll">
		<summary>
			<para>Determines the status of the <see cref="System.Net.Sockets.Socket"/>.</para>
		</summary>
		<param name="microSeconds">The time to wait for a response, in microseconds.</param>
		<param name=" mode">One of the <see cref="System.Net.Sockets.SelectMode"/> values.</param>
		<returns>
			<list type="table">
				<listheader>
					<term>Mode</term>
					<description>Return Value</description>
				</listheader>
				<item>
					<term><see cref="System.Net.Sockets.SelectMode.SelectRead"/></term>
					<description>
						<para><see langword="true "/>if <see cref="Sockets.Socket.Listen"/> has been
         called and a connection is pending;</para>
						<para>-or-</para>
						<para><see langword="true "/>if data is available for
      reading;</para>
						<para>-or-</para>
						<para><see langword="true"/> if the connection has been closed,
   reset, or terminated;</para>
						<para>otherwise, returns
<see langword="false"/>.</para></description>
				</item>
				<item>
					<term><see cref="System.Net.Sockets.SelectMode.SelectWrite"/></term>
					<description>
						<para><see langword="true"/> , if processing a <see cref="Sockets.Socket.Connect"/>, and the connection has succeeded;</para>
						<para>-or-</para>
						<para><see langword="true"/> if data can be sent;</para>
						<para>otherwise, returns <see langword="false"/>.</para></description>
				</item>
				<item>
					<term><see cref="System.Net.Sockets.SelectMode.SelectError"/></term>
					<description>
						<para><see langword="true"/> if processing a <see cref="Sockets.Socket.Connect"/> that does not
   block, and the connection has failed;</para>
						<para>-or-</para>
						<para><see langword="true"/> if <see cref="SocketOptionName.OutOfBandInline"/> is not set and out-of-band data is
available;</para>
						<para>otherwise, returns <see langword="false"/>.</para></description>
				</item>
			</list>
		</returns>
		<exception cref="System.NotSupportedException">The <paramref name="mode "/>parameter is not one of the <see cref="System.Net.Sockets.SelectMode"/> values.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See remarks below.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed. </exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.Poll"/> method will check the state of the
<see cref="System.Net.Sockets.Socket"/>. Specify <see cref="System.Net.Sockets.SelectMode.SelectRead" qualify="true"/> for the 
<paramref name="selectMode"/> parameter to determine if the <see cref="System.Net.Sockets.Socket"/> is readable. Specify <see cref="System.Net.Sockets.SelectMode.SelectWrite" qualify="true"/> to determine if the <see cref="System.Net.Sockets.Socket"/> is writable. Use <see cref="System.Net.Sockets.SelectMode.SelectError" qualify="true"/> to detect an error condition.
<see cref="System.Net.Sockets.Socket.Poll"/> will block execution until the 
   specified time period, measured in <paramref name="microseconds,"/> elapses. Set the <paramref name="microSeconds"/>
   parameter to a negative integer if you would like to wait indefinitely
   for a response. If you want to check the status of multiple sockets,
   you might prefer to use the <see cref="System.Net.Sockets.Socket.Select"/> method.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<codelink SampleID="SelectModeExample" SnippetID="1"/>
		</example>
		<seealso cref="System.Net.Sockets.SelectMode"/>
		<seealso cref="System.Net.Sockets.Socket.Poll"/>
	</doc>
	<doc for="Socket.BeginSend">
		<summary>
			<para>Sends data asynchronously to a connected <see cref="System.Net.Sockets.Socket"/>.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that contains the data to send.</param>
		<param name=" offset">The zero-based position in the <paramref name="buffer"/> parameter at which to begin sending data.</param>
		<param name=" size">The number of bytes to send.</param>
		<param name=" socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<param name=" callback">The <see cref="System.AsyncCallback"/> delegate.</param>
		<param name=" state">An object containing state information for this request.</param>
		<returns>
			<para>An <see cref="System.IAsyncResult"/> that references the asynchronous send.</para>
		</returns>
		<exception cref="ArgumentNullException"><para>
				<paramref name="buffer "/> is <see langword="null"/>.</para></exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See remarks section below.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="offset"/> is less than 0.</para>
			<para>-or- </para>
			<para><paramref name="offset"/> is less than the length of <paramref name="buffer"/>. </para>
			<para>-or-</para>
			<para><paramref name="size"/> is less than 0.</para>
			<para>-or-</para>
			<para><paramref name="size"/> is greater than the length of <paramref name="buffer "/>minus the value of the <paramref name="offset"/> parameter.</para></exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.BeginSend"/> method starts an asynchronous send
   operation to the remote host established in the <see cref="System.Net.Sockets.Socket.Connect"/>, <see cref="System.Net.Sockets.Socket.BeginConnect"/>, <see cref="System.Net.Sockets.Socket.Accept"/>, <see cref="System.Net.Sockets.Socket.BeginAccept"/> method. <see cref="System.Net.Sockets.Socket.BeginSend"/> will throw an
   exception if you do not first call <see cref="System.Net.Sockets.Socket.Accept"/>, <see cref="System.Net.Sockets.Socket.BeginAccept"/>, <see cref="System.Net.Sockets.Socket.Connect"/>, or <see cref="System.Net.Sockets.Socket.BeginConnect"/>.
   Calling the <see cref="System.Net.Sockets.Socket.BeginSend"/> method gives you the ability to send
   data within a separate execution thread. </para>
			<para>You can create a<paramref name=" "/>callback method that implements the <see cref="System.AsyncCallback"/> delegate
and pass its name to the <see cref="System.Net.Sockets.Socket.BeginSend"/> method.
To do this, at the very minimum, your
<paramref name="state"/> parameter must contain the connected or default <see cref="System.Net.Sockets.Socket"/> being used for 
communication. If your callback needs more information, you can create a small
class or structure to hold the <see cref="System.Net.Sockets.Socket"/> and the other required information. Pass an
instance of this class to the <see cref="System.Net.Sockets.Socket.BeginSend"/> method through the <paramref name="state"/>
parameter. </para>
			<para>Your callback method should implement the <see cref="System.Net.Sockets.Socket.EndSend"/> method. When your
application calls <see cref="System.Net.Sockets.Socket.BeginSend"/>, the system will use a separate
thread to execute the specified callback method, and will block on <see cref="System.Net.Sockets.Socket.EndSend"/> until the <see cref="System.Net.Sockets.Socket"/> sends
the number of bytes requested or throws an exception. If you want the original
thread to block after you call the <see cref="System.Net.Sockets.Socket.BeginSend"/>
method, use the <see cref="System.Threading.WaitHandle.WaitOne" qualify="true"/> method. Call <see cref="System.Threading.ManualResetEvent.Set"/>
in the callback method when you want the original thread to continue
executing. For additional information on writing callback methods see
<see topic="cpconcallbacksample"/>. </para>
			<para>Although intended for connection-oriented protocols, <see cref="System.Net.Sockets.Socket.BeginSend"/> also works for connectionless
protocols, provided that you first call the <see cref="System.Net.Sockets.Socket.Connect"/>or<see cref="System.Net.Sockets.Socket.BeginConnect"/> method to establish a default remote
host. If you are using a connectionless protocol and plan to send data to
several different hosts, you should use <see cref="System.Net.Sockets.Socket.BeginSendTo"/>. It is okay to use
<see cref="System.Net.Sockets.Socket.BeginSendTo"/> even after you have established a 
default remote host with <see cref="System.Net.Sockets.Socket.Connect"/>. You can also change the default
remote host prior to calling <see cref="System.Net.Sockets.Socket.BeginSend"/> by making another call to <see cref="System.Net.Sockets.Socket.Connect"/> or <see cref="System.Net.Sockets.Socket.BeginConnect"/>. With
connectionless protocols, you must also be sure that the size of your buffer
does not exceed the maximum packet size of the underlying service provider. If
it does, the datagram will not be sent and <see cref="System.Net.Sockets.Socket.BeginSend"/> will throw a <see cref="System.Net.Sockets.SocketException"/>
. </para>
			<para>If you specify the <see cref="System.Net.Sockets.SocketFlags.DontRoute"/> flag as the <paramref name="socketflags
"/>parameter, the data you are sending will not be routed. If you specify the
<see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the <paramref name="socketflags 
"/>parameter, only out-of-band (OOB) data is sent.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/>
   to obtain the specific error code. Once you have obtained this code, you can
   refer to the Windows Socket Version 2 API error code documentation in MSDN for a
   detailed description of the error.
</note>
		</remarks>
		<example>
			<para>The following example begins asynchronously sending data to a remote
      host.</para>
			<codelink SampleID="Socket_Async_Send_Receive" SnippetID="5"/>
		</example>
		<seealso topic="cpconasynchronousprogramming"/>
		<seealso topic="cpconcallbacksample"/>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.AsyncCallback"/>
		<seealso cref="System.Net.Sockets.Socket.EndSend"/>
	</doc>
	<doc for="Socket.Listen">
		<summary>
			<para>Places a <see cref="System.Net.Sockets.Socket"/> in a listening state.</para>
		</summary>
		<param name="backlog">The maximum length of the pending connections queue.</param>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed. </exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket.Listen"/> causes a connection-oriented <see cref="System.Net.Sockets.Socket"/> to
   listen for incoming connection attempts. The <paramref name="backlog"/>
   parameter specifies the number of incoming connections that can be
   queued for acceptance. To determine the maximum number of connections you can specify,
   retrieve the <see cref="System.Net.Sockets.SocketOptionName.MaxConnections"/> value.
<see cref="System.Net.Sockets.Socket.Listen"/> 
does not block.</para>
			<para> If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode"/> to obtain
the specific error code. Once you have obtained this code, you can refer to the
Windows Socket Version 2 API error code documentation in MSDN for a detailed
description of the error. Use
<see cref="System.Net.Sockets.Socket.Accept"/> or <see cref="System.Net.Sockets.Socket.BeginAccept"/> to accept a connection from the 
queue.</para>
			<note type="note">
   
   You must call the <see cref="System.Net.Sockets.Socket.Bind"/> method before
   calling <see cref="System.Net.Sockets.Socket.Listen"/>, or <see cref="System.Net.Sockets.Socket.Listen"/>will throw a <see cref="System.Net.Sockets.SocketException"/> .
</note>
		</remarks>
		<example>
			<para>The following example uses <see cref="System.Net.Sockets.Socket"/> to listen for incoming
   connections.</para>
			<codelink SampleID="Classic Socket.Listen Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Net.Sockets.SocketOptionName.MaxConnections"/>
		<seealso cref="System.Net.Sockets.Socket.Accept"/>
		<seealso cref="System.Net.Sockets.Socket.Bind"/>
	</doc>
	<doc for="Socket.BeginReceiveFrom">
		<summary>
			<para>Begins to asynchronously receive data from a specified network
      device.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that is the storage location for the received data.</param>
		<param name=" offset">The zero-based position in the <paramref name="buffer "/>parameter at which to store the data.</param>
		<param name=" size">The number of bytes to receive.</param>
		<param name=" socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<param name=" remoteEP">An <see cref="System.Net.EndPoint"/> that represents the source of the data.</param>
		<param name=" callback">The <see cref="System.AsyncCallback"/> delegate.</param>
		<param name=" state">An object containing state information for this request.</param>
		<returns>
			<para>An <see cref="System.IAsyncResult"/> that references the asynchronous read.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="buffer "/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="remoteEP "/> is <see langword="null"/>.</para></exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="offset"/> is less than 0.</para>
			<para>-or-</para>
			<para><paramref name="offset"/> is greater than the length of <paramref name="buffer"/>.</para>
			<para>-or-</para>
			<para><paramref name="size"/> is less than 0.</para>
			<para>-or-</para>
			<para><paramref name="size"/> is greater than the length of <paramref name="buffer"/> minus the value of the <paramref name="offset"/> parameter.</para></exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.Security.SecurityException">A caller higher in the call stack does not have permission for the requested operation. </exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method starts asynchronously reading
   connectionless datagrams from a remote host. Calling the <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method gives you the ability to
   receive data within a separate execution thread. </para>
			<para>You can create a<paramref name=" callback "/>method that implements the <see cref="System.AsyncCallback"/> delegate
and pass its name to the <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method. To do this, at the very
minimum, your <paramref name="state"/> parameter must contain the connected or default
<see cref="System.Net.Sockets.Socket"/> being used for communication. If your 
callback needs more information, you can create a small class to hold the
<see cref="System.Net.Sockets.Socket"/> and the other required information. Pass an 
instance of this class to the <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method through the
<paramref name="state"/> parameter. </para>
			<para>Your callback method should implement the <see cref="System.Net.Sockets.Socket.EndReceiveFrom"/> method. When your application calls
<see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/>, the system will use a separate thread 
to execute the specified callback method, and it will block on <see cref="System.Net.Sockets.Socket.EndReceiveFrom"/> until the <see cref="System.Net.Sockets.Socket"/> reads
data or throws an exception. If you want the original thread to block after you
call the <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method, use
<see cref="System.Threading.WaitHandle.WaitOne" qualify="true"/>. Call <see cref="System.Threading.ManualResetEvent.Set" qualify="true"/> in the callback
method when you want the original thread to continue executing. For additional
information on writing <paramref name="callback "/> methods, see
<see topic="cpconcallbacksample"/>. </para>
			<note type="note">
   Before calling <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/>, you must explicitly bind the <see cref="System.Net.Sockets.Socket"/> to a
   local endpoint using the <see cref="System.Net.Sockets.Socket.Bind"/> method, or <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> will throw a <see cref="System.Net.Sockets.SocketException"/>.
</note>
			<para>This method reads data into the <paramref name="buffer"/> parameter, and captures the remote
host endpoint from which the data is sent. For information on how to retrieve
this endpoint, refer to <see cref="System.Net.Sockets.Socket.EndReceiveFrom"/>. This method is most useful if you
intend to asynchronously receive connectionless datagrams from an unknown host
or multiple hosts. In these cases, <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> will read the
first enqueued datagram received into the local network buffer. If the datagram
you receive is larger than the size of <paramref name="buffer "/>, the <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method will fill <paramref name="buffer"/>
with as much of the message as is possible, and throw a <see cref="System.Net.Sockets.SocketException"/>. If you are using an unreliable protocol,
the excess data will be lost. If you are using a reliable protocol, the excess
data will be retained by the service provider and you can retrieve it by calling
the <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method with a large enough buffer. </para>
			<para>Although <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> is intended for connectionless
protocols, you can use a connection-oriented protocol as well. If you choose to
do so, you must first either establish a remote host connection by calling the
<see cref="System.Net.Sockets.Socket.Connect"/>/<see cref="System.Net.Sockets.Socket.BeginConnect"/> method or accept an 
incoming connection request by calling the <see cref="System.Net.Sockets.Socket.Accept"/> or <see cref="System.Net.Sockets.Socket.BeginAccept"/> method. If you call the <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method before establishing or
accepting a connection, you will get a <see cref="System.Net.Sockets.SocketException"/>. You can also establish a
default remote host for a connectionless protocol prior to calling the <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method. In either of these cases, the
<see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> method will ignore the 
<paramref name="remoteEP"/> parameter and only receive data from the connected or default 
remote host. </para>
			<para>With connection-oriented sockets, <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> will read as much data as is
available up to the number of bytes specified by the <paramref name="size"/>
parameter. </para>
If you specify the <see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the <paramref name="socketFlags
"/> parameter and the <see cref="System.Net.Sockets.Socket"/> is configured for in-line reception of
out-of-band (OOB) data (using <see cref="System.Net.Sockets.SocketOptionName.OutOfBandInline"/>) and OOB data is
available, <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> returns
only OOB data. The OOB data is a logically independent transmission channel
associated with each pair of connected stream sockets. This data is delivered
with higher priority and independently of the normal data. If you specify the
<see cref="System.Net.Sockets.SocketFlags.Peek"/> flag as the <paramref name="socketFlags
"/>
parameter, the available data is
copied into the receive buffer but not removed from the system buffer.
<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example asynchronously receives connectionless datagrams from a
      remote host.</para>
			<codelink SampleID="Socket_Async_Send_Receive" SnippetID="4"/>
		</example>
		<seealso topic="cpconasynchronousprogramming"/>
		<seealso cref="System.Net.Sockets.Socket.EndReceiveFrom"/>
		<seealso cref="System.AsyncCallback"/>
		<seealso topic="cpconcallbacksample"/>
		<seealso cref="System.Net.Sockets.Socket.Bind"/>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.Accept"/>
	</doc>
	<doc for="Socket.BeginConnect">
		<summary>
			<para>Begins an asynchronous request for a remote host connection.</para>
		</summary>
		<param name=" remoteEP"><para>An <see cref="System.Net.EndPoint"/> that represents the remote host.</para></param>
		<param name=" callback">The <see cref="System.AsyncCallback"/> delegate.</param>
		<param name=" state">An object that contains state information for this request.</param>
		<returns>
			<para>An <see cref="System.IAsyncResult"/> that references the asynchronous connection.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="remoteEP "/> is <see langword="null"/>.</para></exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.Security.SecurityException">A caller higher in the call stack does not have permission for the requested operation. </exception>
		<remarks>
			<para>If you are using a connection-oriented protocol, the <see cref="System.Net.Sockets.Socket.BeginConnect"/> method
   starts an asynchronous request for
   a connection to the <paramref name="remoteEP"/> parameter. If you are using a connectionless
   protocol, <see cref="System.Net.Sockets.Socket.BeginConnect"/> establishes a default remote host.
   Connecting or setting the default remote host asynchronously gives you the
   ability to send and receive data within a separate execution thread. </para>
			<para>You can create a<paramref name=" "/>callback method that implements the <see cref="System.AsyncCallback"/> delegate
and pass its name to the <see cref="System.Net.Sockets.Socket.BeginConnect"/> method. At the very minimum, you must
pass the <see cref="System.Net.Sockets.Socket"/> to <see cref="System.Net.Sockets.Socket.BeginConnect"/> through the
<paramref name="state"/> parameter. If your callback needs more information, you can create 
a small class to hold the <see cref="System.Net.Sockets.Socket"/>, and the other required information. Pass an
instance of this class to the <see cref="System.Net.Sockets.Socket.BeginConnect"/> method through the
<paramref name="state"/> parameter. </para>
			<para>Your callback method should implement the <see cref="System.Net.Sockets.Socket.EndConnect"/> method. When your
application calls <see cref="System.Net.Sockets.Socket.BeginConnect"/>, the system will use a separate
thread to execute the specified callback method, and will block on <see cref="System.Net.Sockets.Socket.EndConnect"/> until the <see cref="System.Net.Sockets.Socket"/>
connects successfully or throws an exception. If you want the original thread to
block after you call the <see cref="System.Net.Sockets.Socket.BeginConnect"/>
method, use <see cref="System.Threading.WaitHandle.WaitOne"/>. Call <see cref="System.Threading.ManualResetEvent.Set"/>
in the callback method when you want the original thread to continue executing.
For additional information on writing callback methods see
<see topic="cpconcallbacksample"/>. </para>
			<para>If you are using a connectionless protocol such as UDP, you do not have to
   call <see cref="System.Net.Sockets.Socket.BeginConnect"/> before sending and receiving data.
   You can use <see cref="System.Net.Sockets.Socket.BeginSendTo"/> and <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> to communicate with a remote host. If
   you do call <see cref="System.Net.Sockets.Socket.BeginConnect"/>, any datagrams that arrive from an
   address other than the specified default will be discarded. If you wish to set
   your default remote host to a broadcast address, you must first call <see cref="System.Net.Sockets.Socket.SetSocketOption"/>
   and set Broadcast to <see langword="true"/>. <see langword=" "/>If you
   cannot, <see cref="System.Net.Sockets.Socket.BeginConnect"/> will throw a <see cref="System.Net.Sockets.SocketException"/>.</para>
			<para>If you are using a connection-oriented protocol and do not call <see cref="System.Net.Sockets.Socket.Bind"/>
before calling <see cref="System.Net.Sockets.Socket.BeginConnect"/>, the underlying service provider will
assign the most appropriate local network address and port number. If you are
using a connectionless protocol, the service provider will not assign a local
network address and port number until you call the <see cref="System.Net.Sockets.Socket.BeginSend"/> or <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method. If you want
to change the default remote host, call the <see cref="System.Net.Sockets.Socket.BeginConnect"/> method again with
the desired endpoint.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example initiates an asynchronous connection attempt.</para>
			<codelink SampleID="Socket_Async_Send_Receive" SnippetID="1"/>
		</example>
		<seealso topic="cpconasynchronousprogramming"/>
		<seealso topic="cpconcallbacksample"/>
		<seealso cref="System.AsyncCallback"/>
		<seealso cref="System.Net.Sockets.Socket.EndConnect"/>
		<seealso cref="System.Net.Sockets.Socket.BeginSendTo"/>
		<seealso cref="System.Net.Sockets.Socket.BeginReceiveFrom"/>
	</doc>
	<doc for="Socket.BeginSendTo">
		<summary>
			<para> Sends data asynchronously to a specific remote host.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that contains the data to send.</param>
		<param name="offset">The zero-based position in <paramref name="buffer "/> at which to begin sending data.</param>
		<param name="size">The number of bytes to send.</param>
		<param name="socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<param name=" remoteEP">An <see cref="System.Net.EndPoint"/> that represents the remote device.</param>
		<param name="callback">The <see cref="System.AsyncCallback"/> delegate.</param>
		<param name="state">An object containing state information for this request.</param>
		<returns>
			<para>An <see cref="System.IAsyncResult"/> that references the asynchronous send.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="buffer "/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="remoteEP "/> is <see langword="null"/>.</para></exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="offset"/> is less than 0.</para>
			<para>-or- </para>
			<para><paramref name="offset"/> is greater than the length of <paramref name="buffer"/>. </para>
			<para>-or-</para>
			<para><paramref name="size"/> is less than 0.</para>
			<para>-or-</para>
			<para><paramref name="size"/> is greater than the length of <paramref name="buffer"/> minus the value of the <paramref name="offset"/> parameter.</para></exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.Security.SecurityException">A caller higher in the call stack does not have permission for the requested operation. </exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.BeginSendTo"/> method starts an asynchronous send
   operation to the remote host specified in the <paramref name="remoteEP"/> parameter. Calling the <see cref="System.Net.Sockets.Socket.BeginSendTo"/> method gives you the ability to send
   data within a separate execution thread. Although intended for connectionless
   protocols, <see cref="System.Net.Sockets.Socket.BeginSendTo"/> works
   with both connectionless and connection-oriented protocols. </para>
			<para>You can create a callback method that implements the <see cref="System.AsyncCallback"/> delegate
and pass its name to the <see cref="System.Net.Sockets.Socket.BeginSendTo"/>
method. To do this, at the very minimum, your
<paramref name="state"/> parameter must contain the connected or default <see cref="System.Net.Sockets.Socket"/> being 
used for communication. If your callback needs more information, you can create
a small class to hold the <see cref="System.Net.Sockets.Socket"/>, and the other required information. Pass an
instance of this class to the <see cref="System.Net.Sockets.Socket.BeginSendTo"/>method through the
<paramref name="state"/> parameter. </para>
			<para>Your callback method should implement the <see cref="System.Net.Sockets.Socket.EndSendTo"/> method. When your
application calls <see cref="System.Net.Sockets.Socket.BeginSendTo"/>, the system will use a separate
thread to execute the specified callback method, and will block on <see cref="System.Net.Sockets.Socket.EndSendTo"/> until the <see cref="System.Net.Sockets.Socket"/> sends
the number of bytes requested or throws an exception. If you want the original
thread to block after you call the <see cref="System.Net.Sockets.Socket.BeginSendTo"/>
method, use the <see cref="System.Threading.WaitHandle.WaitOne" qualify="true"/> method. Call <see cref="System.Threading.ManualResetEvent.Set" qualify="true"/>
in the callback method when you want the original thread to continue executing.
For additional information on writing callback methods see
<see topic="cpconcallbacksample"/>. </para>
			<para> If you are using a connection-oriented protocol, you must first call
   the <see cref="System.Net.Sockets.Socket.Connect"/>, <see cref="System.Net.Sockets.Socket.BeginConnect"/>, <see cref="System.Net.Sockets.Socket.Accept"/>, or <see cref="System.Net.Sockets.Socket.BeginAccept"/> method, or <see cref="System.Net.Sockets.Socket.BeginSendTo"/> will throw a <see cref="System.Net.Sockets.SocketException"/>. <see cref="System.Net.Sockets.Socket.BeginSendTo"/> will ignore the
<paramref name="remoteEP"/> parameter and send data to the <see cref="System.Net.EndPoint"/> established in the 
<see cref="System.Net.Sockets.Socket.Connect"/>, <see cref="System.Net.Sockets.Socket.BeginConnect"/>, <see cref="System.Net.Sockets.Socket.Accept"/>, or <see cref="System.Net.Sockets.Socket.BeginAccept"/>method. </para>
			<para>If you are using a connectionless protocol, you do not need to establish a
   default remote host with the <see cref="System.Net.Sockets.Socket.Connect"/> or <see cref="System.Net.Sockets.Socket.BeginConnect"/> method prior to
   calling <see cref="System.Net.Sockets.Socket.SendTo"/>. You only need to do this if you
   intend to call the <see cref="System.Net.Sockets.Socket.BeginSend"/> method. If you do call the <see cref="System.Net.Sockets.Socket.Connect"/> or <see cref="System.Net.Sockets.Socket.BeginConnect"/> method prior to
   calling <see cref="System.Net.Sockets.Socket.SendTo"/>, the <paramref name="remoteEP"/> parameter will
   override the specified default remote host for that send operation only. You are
   also not required to call the <see cref="System.Net.Sockets.Socket.Bind"/> method. In this case, the underlying
   service provider will assign the most appropriate local network address and port
   number. If you need to identify the assigned local network address and port
   number, you can use the <see cref="System.Net.Sockets.Socket.LocalEndPoint"/> property after the <see cref="System.Net.Sockets.Socket.EndSendTo"/> method successfully completes. </para>
			<para>If you want to send data to a broadcast address, you
   must first call the <see cref="System.Net.Sockets.Socket.SetSocketOption"/> method and set the socket option to
<see cref="System.Net.Sockets.SocketOptionName.Broadcast" qualify="true"/>. -You must also be sure that the size of your buffer does 
   not exceed the maximum packet size of the underlying service provider. If it
   does, the datagram will not be sent and <see cref="System.Net.Sockets.Socket.EndSendTo"/> will throw a <see cref="System.Net.Sockets.SocketException"/>. </para>
			<para>If you specify the <see cref="System.Net.Sockets.SocketFlags.DontRoute"/> flag as the <paramref name="socketflags
"/>parameter, the data you are sending will not be routed. If you specify the
<see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the <paramref name="socketflags 
"/>parameter, only out-of-band (OOB) data is
sent. The OOB data is a logically independent transmission channel associated
with each pair of connected stream sockets. This data is delivered with higher
priority and independently of the normal data.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2
   API error code documentation
   in MSDN for a detailed description of the error.
</note>
		</remarks>
		<example>
			<para>The following example asynchronously sends data to the specified remote
      host.</para>
			<codelink SampleID="Socket_Async_Send_Receive" SnippetID="3"/>
		</example>
		<seealso topic="cpconasynchronousprogramming"/>
		<seealso topic="cpconcallbacksample"/>
		<seealso cref="System.Net.Sockets.Socket.EndSendTo"/>
		<seealso cref="System.AsyncCallback"/>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.LocalEndPoint"/>
		<seealso cref="System.Net.Sockets.SocketOptionName.Broadcast"/>
		<seealso cref="System.Net.Sockets.Socket.SetSocketOption"/>
	</doc>
	<doc for="Socket.Select">
		<summary>
			<para>Determines the status of one or more sockets.</para>
		</summary>
		<param name=" checkRead">An <see cref="System.Collections.IList"/> of <see cref="System.Net.Sockets.Socket"/> instances to check for readability.</param>
		<param name=" checkWrite">An <see cref="System.Collections.IList"/> of <see cref="System.Net.Sockets.Socket"/> instances to check for writeability. </param>
		<param name=" checkError">An <see cref="System.Collections.IList"/> of <see cref="System.Net.Sockets.Socket"/> instances to check for errors.</param>
		<param name=" microSeconds">The time to wait for a response, in microseconds.</param>
		<exception cref="System.ArgumentNullException"><para> The <paramref name="checkRead "/>parameter is <see langword="null"/> or empty.</para>
			<para>-and-</para>
			<para> The <paramref name="checkWrite"/> parameter is <see langword="null"/> or empty</para>
			<para> -and-</para>
			<para>The <paramref name="checkError "/>parameter is <see langword="null"/> or empty.</para></exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remakrs section for more information.</exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket.Select"/> is a static method that determines
   the status of one or more <see cref="System.Net.Sockets.Socket"/> instances. You must place one or more
   sockets into an <see cref="System.Collections.IList"/> before you can use the <see cref="System.Net.Sockets.Socket.Select"/> method. Check for readability by
   calling <see cref="System.Net.Sockets.Socket.Select"/> with the <see cref="System.Collections.IList"/> as the <paramref name="checkread"/>
   parameter. To check your sockets for writeability, use the <paramref name="checkwrite"/>
   parameter. For detecting error conditions, use <paramref name="Checkerror"/>. After calling
<see cref="System.Net.Sockets.Socket.Select"/>, the <see cref="System.Collections.IList"/> will be filled with 
   only those sockets that satisfy the conditions.</para>
			<para>If you are in a listening state, readability means that a call to <see cref="System.Net.Sockets.Socket.Accept"/> will
succeed without blocking.
If you have already accepted the connection, readability means that data
is available for reading. In these cases, all receive operations will
succeed without blocking. Readability can also indicate whether the remote <see cref="System.Net.Sockets.Socket"/> has shut down the connection; in that case a call to <see cref="System.Net.Sockets.Socket.Receive"/> will return
immediately, with zero bytes returned.</para>
			<para>If you make a nonblocking call to <see cref="System.Net.Sockets.Socket.Connect"/>, writability means
that you have connected successfully. If you already have a connection
established, writeability means that all send operations will succeed without
blocking.</para>
			<para>If you have made a non-blocking call to <see cref="System.Net.Sockets.Socket.Connect"/>, the
checkerror
parameter identifies sockets that have not connected successfully. </para>
			<note type="note">
   
   Use the <see cref="System.Net.Sockets.Socket.Poll"/> method if you only
   want to determine the status of a single <see cref="System.Net.Sockets.Socket"/>.
</note>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example uses <see cref="System.Net.Sockets.Socket.Select"/> to determine which listening
   sockets have a connection request.</para>
			<codelink SampleID="Socket_Select" SnippetID="1"/>
		</example>
		<seealso cref="System.Collections.IList"/>
		<seealso cref="System.Net.Sockets.Socket.Accept"/>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.Poll"/>
	</doc>
	<doc for="Socket.Send">
		<overload>
			<para>Sends data to a connected <see cref="System.Net.Sockets.Socket"/>.</para>
		</overload>
		<summary>
			<para>Sends the specified number of bytes of data to a connected <see cref="System.Net.Sockets.Socket"/>, using the specified
<see cref="System.Net.Sockets.SocketFlags"/>.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that contains the data to be sent.</param>
		<param name="size">The number of bytes to send.</param>
		<param name="socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<returns>
			<para> The number of bytes sent to the <see cref="System.Net.Sockets.Socket"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="buffer"/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><paramref name="size"/> is less than 0 or exceeds the size of the buffer.</exception>
		<exception cref="System.Net.Sockets.SocketException"><para><paramref name="socketFlags"/> is not a valid combination of values.</para>
			<para>-or-</para>
			<para> An operating system error occurs while accessing the socket. See the Remarks section for more information.</para></exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket.Send"/> synchronously sends data to the
   remote host established in the <see cref="System.Net.Sockets.Socket.Connect"/> or <see cref="System.Net.Sockets.Socket.Accept"/> method and returns
   the number of bytes successfully sent. <see cref="System.Net.Sockets.Socket.Send"/>
   can be used for both connection-oriented and connectionless protocols. </para>
			<para>This overload requires a buffer containing the data you want to send, the number of bytes you
   want to send, and a bitwise combination of any <see cref="System.Net.Sockets.SocketFlags"/>. If you specify the <see cref="System.Net.Sockets.SocketFlags.DontRoute"/> flag as the <paramref name="socketflags"/> parameter, the data you are
   sending will not be routed. If you specify the
<see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the <paramref name="socketflags"/> parameter, <see cref="System.Net.Sockets.Socket.Send"/> will only send out-of-band (OOB)
   data. The OOB data is a logically independent transmission channel associated
   with each pair of connected stream sockets. This data is delivered with higher priority and independently
   of the normal data. </para>
			<para>If you are using a connectionless protocol, you must call <see cref="System.Net.Sockets.Socket.Connect"/> before calling this method, or <see cref="System.Net.Sockets.Socket.Send"/>
will throw a <see cref="System.Net.Sockets.SocketException"/>. If
you are using a connection-oriented protocol, you must either use <see cref="System.Net.Sockets.Socket.Connect"/> to establish a remote host connection,
or use <see cref="System.Net.Sockets.Socket.Accept"/>
to accept an incoming connection. </para>
			<para>If you are using a connectionless protocol and plan to send data to several
   different hosts, you should use the <see cref="System.Net.Sockets.Socket.SendTo"/> method. If you do not
   use the <see cref="System.Net.Sockets.Socket.SendTo"/> method, you will have to call the
<see cref="System.Net.Sockets.Socket.Connect"/> method before each call to the 
<see cref="System.Net.Sockets.Socket.Send"/> 
method. You can use <see cref="System.Net.Sockets.Socket.SendTo"/> even after you have established a
default remote host with <see cref="System.Net.Sockets.Socket.Connect"/>. You can also change the default
remote host prior to calling <see cref="System.Net.Sockets.Socket.Send"/> by making another call to <see cref="System.Net.Sockets.Socket.Connect"/>. </para>
			<para> With a connection-oriented protocol, <see cref="System.Net.Sockets.Socket.Send"/> will block until the
requested number of bytes are sent. In nonblocking mode, <see cref="System.Net.Sockets.Socket.Send"/>
may complete successfully even if it sends less than the number of bytes you
request. It is your application's responsibility to keep track of the number of
bytes sent and to retry the operation until the application sends the requested
number of bytes. There is also no guarantee that the data you send will appear
on the network immediately. To increase network efficiency, the underlying
system may delay transmission until a significant amount of outgoing data is
collected. A successful completion of the <see cref="System.Net.Sockets.Socket.Send"/> method means that
the underlying system has had room to buffer your data for a network send. If it
is important to your application to send every byte to the remote host
immediately, you can use <see cref="System.Net.Sockets.Socket.SetSocketOption"/> to enable <see cref="System.Net.Sockets.SocketOptionName.NoDelay" qualify="true"/>. For more information about
buffering for network efficiency, refer to the Nagle algorithm in MSDN. </para>
			<note type="note">
   You must ensure that the size does not exceed the
   maximum packet size of the underlying service provider. If it does, the datagram
   will not be sent and <see cref="System.Net.Sockets.Socket.Send"/> will throw a <see cref="System.Net.Sockets.SocketException"/>. If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following sends the data found in buffer, and specifies <see cref="System.Net.Sockets.SocketFlags.None"/> for <see cref="System.Net.Sockets.SocketFlags"/>.</para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="3"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.SendTo"/>
		<seealso cref="System.Net.Sockets.SocketFlags"/>
		<seealso cref="System.Net.Sockets.Socket.SetSocketOption"/>
	</doc>
	<doc for="Socket.Send1">
		<summary>
			<para>Sends data to
      a connected <see cref="System.Net.Sockets.Socket"/> using the specified <see cref="System.Net.Sockets.SocketFlags"/>.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that contains the data to be sent.</param>
		<param name="socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<returns>
			<para> The number of bytes sent to the <see cref="System.Net.Sockets.Socket"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="buffer"/> is <see langword="null"/>.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket.Send"/>
synchronously sends data to the remote host established in the <see cref="System.Net.Sockets.Socket.Connect"/> or <see cref="System.Net.Sockets.Socket.Accept"/> method and returns
the number of bytes successfully sent. The <see cref="System.Net.Sockets.Socket.Send"/> method can be used
for both connection-oriented and connectionless protocols. </para>
			<para>This overload requires a buffer containing the data you want to send and a bitwise combination of
<see cref="System.Net.Sockets.SocketFlags"/>. The buffer offset defaults to 0, and the number of bytes to 
   send defaults to the size of the buffer. If you specify the <see cref="System.Net.Sockets.SocketFlags.DontRoute"/> flag as the <paramref name="socketflags"/> parameter value, the data you are
   sending will not be routed. If you specify the <see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the <paramref name="socketflags"/> parameter, <see cref="System.Net.Sockets.Socket.Send"/> will only send out-of-band (OOB)
   data. The OOB data is a logically independent transmission channel associated
   with each pair of connected stream sockets. This data is delivered with higher priority and
   independently of the normal data. </para>
			<para>If you are using a connectionless protocol, you must call <see cref="System.Net.Sockets.Socket.Connect"/> before calling this method, or <see cref="System.Net.Sockets.Socket.Send"/>
will throw a <see cref="System.Net.Sockets.SocketException"/>. If you are using a connection-oriented
protocol, you must either use <see cref="System.Net.Sockets.Socket.Connect"/> to establish a remote host
connection, or use <see cref="System.Net.Sockets.Socket.Accept"/> to accept
an incoming connection.</para>
			<para>If you are using a connectionless protocol and plan to send data to several
   different hosts, you should use the <see cref="System.Net.Sockets.Socket.SendTo"/> method. If you do not use
   the <see cref="System.Net.Sockets.Socket.SendTo"/> method, you will have to call the <see cref="System.Net.Sockets.Socket.Connect"/> method before each call to <see cref="System.Net.Sockets.Socket.Send"/>. You can use <see cref="System.Net.Sockets.Socket.SendTo"/> even after you have established a
   default remote host with <see cref="System.Net.Sockets.Socket.Connect"/>. You can also change the default
   remote host prior to calling <see cref="System.Net.Sockets.Socket.Send"/> by making another call to <see cref="System.Net.Sockets.Socket.Connect"/>. </para>
			<para>If you are using a connection-oriented protocol, <see cref="System.Net.Sockets.Socket.Send"/> will block until all
of the bytes in the buffer are sent. In nonblocking mode, <see cref="System.Net.Sockets.Socket.Send"/>
may complete successfully even if it sends less than the number of bytes in the
buffer. It is your application's responsibility to keep track of the number of
bytes sent and to retry the operation until the application sends the requested
number of bytes. There is also no guarantee that the data you send will appear
on the network immediately. To increase network efficiency, the underlying
system may delay transmission until a significant amount of outgoing data is
collected. A successful completion of the <see cref="System.Net.Sockets.Socket.Send"/> method means that
the underlying system has had room to buffer your data for a network send. If it
is important to your application to send every byte to the remote host
immediately, you can use <see cref="System.Net.Sockets.Socket.SetSocketOption"/> to enable <see cref="System.Net.Sockets.SocketOptionName.NoDelay" qualify="true"/>. For more information
about buffering for network efficiency, refer to the Nagle algorithm in
MSDN.</para>
			<note type="note">
   You must ensure that the size of your
   buffer does not exceed the maximum packet size of the underlying service
   provider. If it does, the datagram will not be sent and <see cref="System.Net.Sockets.Socket.Send"/>
   will throw a <see cref="System.Net.Sockets.SocketException"/>.
   If you
   receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain the specific error
   code. Once you have obtained this code, you can refer to the Windows Socket
   Version 2 API error code documentation in MSDN for a detailed description of the
   error.
</note>
		</remarks>
		<example>
			<para> The following example specifies the data buffer and <see cref="System.Net.Sockets.SocketFlags"/>
for sending data to a connected <see cref="System.Net.Sockets.Socket"/>.</para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="2"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.SendTo"/>
		<seealso cref="System.Net.Sockets.SocketFlags"/>
		<seealso cref="System.Net.Sockets.Socket.SetSocketOption"/>
	</doc>
	<doc for="Socket.Send2">
		<summary>
			<para>Sends data to
      a connected <see cref="System.Net.Sockets.Socket"/>.</para>
		</summary>
		<param name="buffer">An array of of type <see cref="System.Byte"/> that contains the data to be sent.</param>
		<returns>
			<para> The number of bytes sent to the <see cref="System.Net.Sockets.Socket"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="buffer"/> is <see langword="null"/>.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket.Send"/> synchronously sends data to the remote host
   specified in the <see cref="System.Net.Sockets.Socket.Connect"/> or <see cref="System.Net.Sockets.Socket.Accept"/> method and returns
   the number of bytes successfully sent. <see cref="System.Net.Sockets.Socket.Send"/> can be used for both
   connection-oriented and connectionless protocols. </para>
			<para>This overload requires a buffer containing the data you
   want to send. The <see cref="System.Net.Sockets.SocketFlags"/>
   value defaults to 0, the buffer offset defaults to 0, and
   the number of bytes to send defaults to the size of the buffer.</para>
			<para>If you are using a connectionless protocol, you must call <see cref="System.Net.Sockets.Socket.Connect"/> before calling this method, or <see cref="System.Net.Sockets.Socket.Send"/>
will throw a <see cref="System.Net.Sockets.SocketException"/>. If you are using a connection-oriented
protocol, you must either use <see cref="System.Net.Sockets.Socket.Connect"/> to establish a remote host
connection, or use <see cref="System.Net.Sockets.Socket.Accept"/> to accept an incoming connection.</para>
			<para>If you are using a connectionless protocol and plan to send data to several


   different hosts, you should use the <see cref="System.Net.Sockets.Socket.SendTo"/> method. If you do not use the <see cref="System.Net.Sockets.Socket.SendTo"/> method, you will have to call <see cref="System.Net.Sockets.Socket.Connect"/> before each call to <see cref="System.Net.Sockets.Socket.Send"/>. You can use <see cref="System.Net.Sockets.Socket.SendTo"/> even after you have established a
   default remote host with <see cref="System.Net.Sockets.Socket.Connect"/>. You can also change the default
   remote host prior to calling <see cref="System.Net.Sockets.Socket.Send"/> by making another call to <see cref="System.Net.Sockets.Socket.Connect"/>. </para>
			<para>If you are using a connection-oriented protocol, <see cref="System.Net.Sockets.Socket.Send"/> will block until all
of the bytes in the buffer are sent. In nonblocking mode, <see cref="System.Net.Sockets.Socket.Send"/>
may complete successfully even if it sends less than the number of bytes in the
buffer. It is your application's responsibility to keep track of the number of
bytes sent and to retry the operation until the application sends the bytes in
the buffer. There is also no guarantee that the data you send will appear on the
network immediately. To increase network efficiency, the underlying system may
delay transmission until a significant amount of outgoing data is collected. A
successful completion of the <see cref="System.Net.Sockets.Socket.Send"/> method means that the underlying
system has had room to buffer your data for a network send. If it is important
to your application to send every byte to the remote host immediately, you can
use <see cref="System.Net.Sockets.Socket.SetSocketOption"/> to enable <see cref="System.Net.Sockets.SocketOptionName.NoDelay" qualify="true"/> . For more information
about buffering for network efficiency, refer to the Nagle algorithm in
MSDN.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example demonstrates sending data on a connected <see cref="System.Net.Sockets.Socket"/>.</para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="1"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.SendTo"/>
		<seealso cref="System.Net.Sockets.SocketFlags"/>
		<seealso cref="System.Net.Sockets.Socket.SetSocketOption"/>
	</doc>
	<doc for="Socket.Send3">
		<summary>
			<para>Sends the specified number of bytes of data to
      a connected <see cref="System.Net.Sockets.Socket"/>, starting at the
      specified offset, and using the specified <see cref="System.Net.Sockets.SocketFlags"/>.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that contains the data to be sent.</param>
		<param name="offset">The position in the data buffer at which to begin sending data.</param>
		<param name="size">The number of bytes to send.</param>
		<param name="socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<returns>
			<para> The number of bytes sent to the <see cref="System.Net.Sockets.Socket"/>.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><paramref name="buffer"/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="offset"/> is less than 0.</para>
			<para>-or- </para>
			<para><paramref name="offset"/> is greaterthan the length of <paramref name="buffer"/>. </para>
			<para>-or-</para>
			<para><paramref name="size"/> is less than 0.</para>
			<para>-or-</para>
			<para><paramref name="size"/> is greaterthan the length of <paramref name="buffer "/>minus the value of the <paramref name="offset"/> parameter.</para></exception>
		<exception cref="System.Net.Sockets.SocketException"><para><paramref name="socketFlags"/> is not a valid combination of values.</para>
			<para>-or-</para>
			<para>An operating system error occurs while accessing the <see cref="System.Net.Sockets.Socket"/>. See the Remarks section for more information.</para></exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para><see cref="System.Net.Sockets.Socket.Send"/>
synchronously sends data to the remote host
specified in the <see cref="System.Net.Sockets.Socket.Connect"/> or <see cref="System.Net.Sockets.Socket.Accept"/> method and returns
the number of bytes successfully sent. <see cref="System.Net.Sockets.Socket.Send"/> can be used for both
connection-oriented and connectionless protocols. </para>
			<para>In this overload, if you specify the <see cref="System.Net.Sockets.SocketFlags.DontRoute"/> flag as the
<paramref name="socketflags"/> parameter, the data you are sending will 
not be routed. If you specify the <see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the <paramref name="socketflags"/> parameter, <see cref="System.Net.Sockets.Socket.Send"/> will only send out-of-band (OOB)
data. The OOB data is a logically independent transmission channel associated
with each pair of connected stream sockets. This data is delivered with higher priority and independently of the normal
data.</para>
			<para>If you are using a connectionless protocol, you must call <see cref="System.Net.Sockets.Socket.Connect"/> before calling this method or <see cref="System.Net.Sockets.Socket.Send"/>
will throw a <see cref="System.Net.Sockets.SocketException"/>. If you are using a connection-oriented
protocol, you must either use <see cref="System.Net.Sockets.Socket.Connect"/> to establish a remote host
connection, or use <see cref="System.Net.Sockets.Socket.Accept"/> to accept
an incoming connection.</para>
			<para>If you are using a connectionless protocol and plan to send data to several
   different hosts, you should use <see cref="System.Net.Sockets.Socket.SendTo"/>. If you do not use <see cref="System.Net.Sockets.Socket.SendTo"/>, you will have to call <see cref="System.Net.Sockets.Socket.Connect"/> before each call to <see cref="System.Net.Sockets.Socket.Send"/>.
   It is okay to use <see cref="System.Net.Sockets.Socket.SendTo"/> even after you have established a
   default remote host with <see cref="System.Net.Sockets.Socket.Connect"/>. You can also change the default
   remote host prior to calling <see cref="System.Net.Sockets.Socket.Send"/> by making another call to <see cref="System.Net.Sockets.Socket.Connect"/>. </para>
			<para> You must also be
   sure that the size does not exceed the maximum packet size of the underlying service
   provider. If it does, the datagram will not be sent and <see cref="System.Net.Sockets.Socket.Send"/>
   will throw a <see cref="System.Net.Sockets.SocketException"/>. </para>
			<para>If you are using a connection-oriented protocol, <see cref="System.Net.Sockets.Socket.Send"/> will block until the
requested number of bytes are sent. In nonblocking mode, <see cref="System.Net.Sockets.Socket.Send"/>
may complete successfully even if it sends less than the number of bytes you
request. It is your application's responsibility to keep track of the number of
bytes sent and to retry the operation until the application sends the requested
number of bytes. There is also no guarantee that the data you send will appear
on the network immediately. To increase network efficiency, the underlying
system may delay transmission until a significant amount of outgoing data is
collected. A successful completion of the <see cref="System.Net.Sockets.Socket.Send"/> method
means that the underlying system has had room to buffer your data for a network
send. If it is important to your application to send every byte to the remote
host immediately, you can use <see cref="System.Net.Sockets.Socket.SetSocketOption"/> to enable <see cref="System.Net.Sockets.SocketOptionName.NoDelay" qualify="true"/>. For more information
about buffering for network efficiency, refer to the Nagle algorithm in
MSDN.</para>
			<note type="note">
   If
   you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain the specific error
   code. Once you have obtained this code, you can refer to the Windows Socket
   Version 2 API error code documentation in MSDN for a detailed description of the
   error.
</note>
		</remarks>
		<example>
			<para> The following example specifies the data buffer, an offset, a size,
      and <see cref="System.Net.Sockets.SocketFlags"/> for sending data to a connected <see cref="System.Net.Sockets.Socket"/>.</para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="4"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.SendTo"/>
		<seealso cref="System.Net.Sockets.SocketFlags"/>
		<seealso cref="System.Net.Sockets.Socket.SetSocketOption"/>
	</doc>
	<doc for="Socket.SendTo3">
		<summary>
			<para> Sends data to the specified endpoint.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that contains the data to be sent.</param>
		<param name="remoteEP">The <see cref="System.Net.EndPoint"/> representing the destination for the data.</param>
		<returns>
			<para> The number of bytes
      sent.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="buffer"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="remoteEP"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para>In this overload, the buffer offset defaults to 0,
      the number of bytes to send defaults to the size of the <paramref name="buffer"/> parameter, and the <see cref="System.Net.Sockets.SocketFlags"/>
      value defaults to 0. </para>
			<para>If you are using a connectionless protocol, you do not need to establish a
      default remote host with the <see cref="System.Net.Sockets.Socket.Connect"/> method prior to calling <see cref="System.Net.Sockets.Socket.SendTo"/>. You only need to do this if you
      intend to call the <see cref="System.Net.Sockets.Socket.Send"/> method. If you do call the <see cref="System.Net.Sockets.Socket.Connect"/> method prior to calling <see cref="System.Net.Sockets.Socket.SendTo"/>, the <paramref name="remoteEP"/> parameter will
      override the specified default remote host for that send operation only. You are
      also not required to call the <see cref="System.Net.Sockets.Socket.Bind"/> method, because the underlying
      service provider will assign the most appropriate local network address and port
      number. If you need to identify the assigned local network address and port
      number, you can use the <see cref="System.Net.Sockets.Socket.LocalEndPoint"/> property after the <see cref="System.Net.Sockets.Socket.SendTo"/> method successfully completes. </para>
			<para>Although intended for connectionless protocols, <see cref="System.Net.Sockets.Socket.SendTo"/> also works with
   connection-oriented protocols. If you are using a connection-oriented protocol,
   you must first establish a remote host connection by calling the <see cref="System.Net.Sockets.Socket.Connect"/> method or accept an incoming
   connection request using the <see cref="System.Net.Sockets.Socket.Accept"/> method. If you do not establish or
   accept a remote host connection, <see cref="System.Net.Sockets.Socket.SendTo"/> will throw a <see cref="System.Net.Sockets.SocketException"/>. You can also establish a default remote
   host for a connectionless protocol prior to calling the <see cref="System.Net.Sockets.Socket.SendTo"/> method. In either of these cases,
<see cref="System.Net.Sockets.Socket.SendTo"/> will ignore the <paramref name="remoteEP"/> 
parameter and only send data to the connected or default remote host. </para>
			<para>Blocking sockets will block until the all of the bytes in the buffer are
   sent. Since a nonblocking <see cref="System.Net.Sockets.Socket"/> completes immediately, it might not send all
   of the bytes in the <paramref name="buffer"/>. It is your application's responsibility to
   keep track of the number of bytes sent and to retry the operation until the
   application sends all of the bytes in the <paramref name="buffer"/>. There is also no
   guarantee that the data you send will appear on the network immediately. To
   increase network efficiency, the underlying system may delay transmission until
   a significant amount of outgoing data is collected. A successful completion of
   the <see cref="System.Net.Sockets.Socket.SendTo"/> method means that the underlying
   system has had room to buffer your data for a network send. If it is important
   to your application to send every byte to the remote host immediately, you can
   use <see cref="System.Net.Sockets.Socket.SetSocketOption"/> to enable <see cref="System.Net.Sockets.SocketOptionName.NoDelay" qualify="true"/>. For more information
   about buffering for network efficiency, refer to the Nagle algorithm on MSDN. </para>
If you are using a connectionless protocol in blocking mode, <see cref="System.Net.Sockets.Socket.SendTo"/> will block until the datagram is
sent. If you want to send data to a broadcast address, you must first call the
<see cref="System.Net.Sockets.Socket.SetSocketOption"/> method and set the socket option to 
<see cref="System.Net.Sockets.SocketOptionName.Broadcast" qualify="true"/>. You must also be sure that the number of bytes sent does 
not exceed the maximum packet size of the underlying service provider. If it
does, the datagram will not be sent and <see cref="System.Net.Sockets.Socket.SendTo"/> will throw a <see cref="System.Net.Sockets.SocketException"/>.
<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example sends a connectionless datagram to the specified remote
      host.</para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="5"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.Bind"/>
		<seealso cref="System.Net.Sockets.Socket.Send"/>
		<seealso cref="System.Net.Sockets.Socket.SendTo"/>
		<seealso cref="System.Net.Sockets.Socket.SetSocketOption"/>
		<seealso cref="System.Net.Sockets.Socket.LocalEndPoint"/>
	</doc>
	<doc for="Socket.SendTo2">
		<summary>
			<para> Sends data to a specific endpoint using the specified
      <see cref="System.Net.Sockets.SocketFlags"/>.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that contains the data to be sent.</param>
		<param name="socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<param name="remoteEP">The <see cref="System.Net.EndPoint"/> that represents the destination location for the data.</param>
		<returns>
			<para> The number of bytes
      sent.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="buffer"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="remoteEP"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para>In this overload, the buffer offset defaults to 0,
      and the number of bytes to send
      defaults to the size of the <paramref name="buffer"/>.
      If you specify the <see cref="System.Net.Sockets.SocketFlags.DontRoute"/> flag as the <paramref name="socketflags"/> parameter, the data you are sending will
      not be routed. If you specify the <see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the <paramref name="socketflags"/> parameter, <see cref="System.Net.Sockets.Socket.Send"/> will only send out-of-band (OOB)
      data. The OOB data is a logically independent transmission channel associated
      with each pair of connected stream sockets. This data is delivered with higher priority and independently of the
      normal data. </para>
			<para>If you are using a connectionless protocol, you do not need to establish a
      default remote host with the <see cref="System.Net.Sockets.Socket.Connect"/> method prior to calling <see cref="System.Net.Sockets.Socket.SendTo"/>. You only need to do this if you
      intend to call the <see cref="System.Net.Sockets.Socket.Send"/> method. If you do call the <see cref="System.Net.Sockets.Socket.Connect"/> method prior to calling <see cref="System.Net.Sockets.Socket.SendTo"/>, the <paramref name="remoteEP"/> parameter will
      override the specified default remote host for that send operation only. You are
      also not required to call the <see cref="System.Net.Sockets.Socket.Bind"/> method, because the underlying
      service provider will assign the most appropriate local network address and port
      number. If you need to identify the assigned local network address and port
      number, you can use the <see cref="System.Net.Sockets.Socket.LocalEndPoint"/> property after the <see cref="System.Net.Sockets.Socket.SendTo"/> method successfully completes. </para>
			<para>Although intended for connectionless protocols, <see cref="System.Net.Sockets.Socket.SendTo"/> also works with
   connection-oriented protocols. If you are using a connection-oriented protocol,
   you must first establish a remote host connection by calling the <see cref="System.Net.Sockets.Socket.Connect"/> method or accept an incoming
   connection request using the <see cref="System.Net.Sockets.Socket.Accept"/> method. If you do not establish or
   accept a remote host connection, <see cref="System.Net.Sockets.Socket.SendTo"/> will throw a <see cref="System.Net.Sockets.SocketException"/>. You can also establish a default remote
   host for a connectionless protocol prior to calling the <see cref="System.Net.Sockets.Socket.SendTo"/> method. In either of these cases,
<see cref="System.Net.Sockets.Socket.SendTo"/> will ignore the <paramref name="remoteEP"/> 
parameter and only send data to the connected or default remote host. </para>
			<para>Blocking sockets will block until the requested all of the bytes in the
<paramref name="buffer"/> are sent. Since a nonblocking <see cref="System.Net.Sockets.Socket"/> completes immediately, it 
   might not send all of the bytes in the <paramref name="buffer"/>. It is your application's
   responsibility to keep track of the number of bytes sent and to retry the
   operation until the application sends all of the bytes in the <paramref name="buffer"/>.
   There is also no guarantee that the data you send will appear on the network
   immediately. To increase network efficiency, the underlying system may delay
   transmission until a significant amount of out-going data is collected. A
   successful completion of the <see cref="System.Net.Sockets.Socket.SendTo"/> method means that the underlying
   system has had room to buffer your data for a network send. If it is important
   to your application to send every byte to the remote host immediately, you can
   use <see cref="System.Net.Sockets.Socket.SetSocketOption"/> to enable <see cref="System.Net.Sockets.SocketOptionName.NoDelay" qualify="true"/>. For more information
   about buffering for network efficiency, refer to the Nagle algorithm on MSDN. </para>
			<para>If you are using a connectionless protocol in blocking mode, <see cref="System.Net.Sockets.Socket.SendTo"/> will
block until the datagram is sent. If you want to send data to a broadcast
address, you must first call the <see cref="System.Net.Sockets.Socket.SetSocketOption"/> method and set the
socket option to <see cref="System.Net.Sockets.SocketOptionName.Broadcast" qualify="true"/>. You must also be sure that the number of bytes sent does
not exceed the maximum packet size of the underlying service provider. If it
does, the datagram will not be sent and <see cref="System.Net.Sockets.Socket.SendTo"/> will throw a <see cref="System.Net.Sockets.SocketException"/>. </para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain the specific error
   code. Once you have obtained this code, you can refer to the Windows Socket
   Version 2 API error code documentation in MSDN for a detailed description of the
   error.
</note>
		</remarks>
		<example>
			<para>The following example sends a connectionless datagram to
      the specified remote host. <see cref="System.Net.Sockets.SocketFlags"/> are passed to the <see cref="System.Net.Sockets.Socket.SendTo"/> method. </para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="6"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.Bind"/>
		<seealso cref="System.Net.Sockets.Socket.Send"/>
		<seealso cref="System.Net.Sockets.Socket.SendTo"/>
		<seealso cref="System.Net.Sockets.Socket.SetSocketOption"/>
		<seealso cref="System.Net.Sockets.Socket.LocalEndPoint"/>
	</doc>
	<doc for="Socket.SendTo">
		<overload>
			<para> Sends
      data to a specific
      endpoint.</para>
		</overload>
		<summary>
			<para> Sends the specified number of bytes of data
      to the specified endpoint, starting at the
      specified location in the buffer, and using the specified <see cref="System.Net.Sockets.SocketFlags"/>.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that contains the data to be sent.</param>
		<param name="offset">The position in the data buffer at which to begin sending data.</param>
		<param name="size">The number of bytes to send.</param>
		<param name="socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<param name="remoteEP">The <see cref="System.Net.EndPoint"/> representing the destination location for the data.</param>
		<returns>
			<para> The number of bytes
      sent.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="buffer"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="remoteEP"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="offset"/> is less than 0.</para>
			<para>-or- </para>
			<para><paramref name="offset"/> is greater than the length of <paramref name="buffer"/>. </para>
			<para>-or-</para>
			<para><paramref name="size"/> is less than 0.</para>
			<para>-or-</para>
			<para><paramref name="size"/> is greater than the length of <paramref name="buffer"/> minus the value of the <paramref name="offset"/> parameter.</para></exception>
		<exception cref="System.Net.Sockets.SocketException"><para><paramref name="socketFlags"/> is not a valid combination of values.</para>
			<para> -or-</para>
			<para>An operating system error occurs while accessing the <see cref="System.Net.Sockets.Socket"/>. See the Remarks section for more information.</para></exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.Security.SecurityException">A caller in the call stack does not have the required permissions. </exception>
		<remarks>
			<para>In this overload, if you specify the <see cref="System.Net.Sockets.SocketFlags.DontRoute"/> flag as the <paramref name="socketflags"/> parameter, the data you are sending will
   not be routed. If you specify the <see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the <paramref name="socketflags"/> parameter, <see cref="System.Net.Sockets.Socket.Send"/> will only send out-of-band (OOB)
   data. The OOB data is a logically independent transmission channel associated
   with each pair of connected stream sockets. This data is delivered with higher priority and independently of the normal data. </para>
			<para>If you are using a connectionless protocol, you do not need to establish a
   default remote host with the <see cref="System.Net.Sockets.Socket.Connect"/> method prior to calling <see cref="System.Net.Sockets.Socket.SendTo"/>. You only need to do this if you
   intend to call the <see cref="System.Net.Sockets.Socket.Send"/> method. If you do call the <see cref="System.Net.Sockets.Socket.Connect"/> method prior to calling <see cref="System.Net.Sockets.Socket.SendTo"/>, the <paramref name="remoteEP"/> parameter will
   override the specified default remote host for that send operation only. You are
   also not required to call the <see cref="System.Net.Sockets.Socket.Bind"/> method, because the underlying
   service provider will assign the most appropriate local network address and port
   number. If you need to identify the assigned local network address and port
   number, you can use the <see cref="System.Net.Sockets.Socket.LocalEndPoint"/> property after the <see cref="System.Net.Sockets.Socket.SendTo"/> method successfully completes. </para>
			<para>Although intended for connectionless protocols, <see cref="System.Net.Sockets.Socket.SendTo"/> also works with
connection-oriented protocols. If you are using a connection-oriented protocol,
you must first establish a remote host connection by calling the <see cref="System.Net.Sockets.Socket.Connect"/> method or accept an incoming
connection request using the <see cref="System.Net.Sockets.Socket.Accept"/> method. If you do not establish or
accept a remote host connection, <see cref="System.Net.Sockets.Socket.SendTo"/> will throw a <see cref="System.Net.Sockets.SocketException"/>. You can also establish a default remote
host for a connectionless protocol prior to calling the <see cref="System.Net.Sockets.Socket.SendTo"/> method. In either of these cases,
<see cref="System.Net.Sockets.Socket.SendTo"/> will ignore the <paramref name="remoteEP"/> 
parameter and only send data to the connected or default remote host. </para>
			<para>Blocking sockets will block until the requested number of bytes are sent.
   Since a nonbocking <see cref="System.Net.Sockets.Socket"/> completes immediately, it might not send all
   of the bytes requested in a single operation. It is your applications
   responsibility to keep track of the number of bytes sent and to retry the
   operation until the application sends the requested number of bytes. There is
   also no guarantee that the data you send will appear on the network immediately.
   To increase network efficiency, the underlying system may delay transmission
   until a significant amount of out-going data is collected. A successful
   completion of the <see cref="System.Net.Sockets.Socket.SendTo"/> method means that the underlying
   system has had room to buffer your data for a network send. If it is important
   to your application to send every byte to the remote host immediately, you can
   use <see cref="System.Net.Sockets.Socket.SetSocketOption"/> to enable <see cref="System.Net.Sockets.SocketOptionName.NoDelay" qualify="true"/>. For more information
   about buffering for network efficiency, refer to the Nagle algorithm in MSDN. </para>
			<para>If you are using a connectionless protocol in blocking mode, <see cref="System.Net.Sockets.Socket.SendTo"/> will block
until the datagram is sent. If you want to send data to a broadcast address, you
must first call the <see cref="System.Net.Sockets.Socket.SetSocketOption"/>
method and set the socket option to <see cref="System.Net.Sockets.SocketOptionName.Broadcast" qualify="true"/>. You must also be sure that the size does
not exceed the maximum packet size of the underlying service provider. If it
does, the datagram will not be sent and <see cref="System.Net.Sockets.Socket.SendTo"/> will throw a <see cref="System.Net.Sockets.SocketException"/>. </para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following example sends a connectionless datagram to the specified remote
      host. The offset, size, and <see cref="System.Net.Sockets.SocketFlags"/> are passed to the <see cref="System.Net.Sockets.Socket.SendTo"/> method.</para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="8"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.Bind"/>
		<seealso cref="System.Net.Sockets.Socket.Send"/>
		<seealso cref="System.Net.Sockets.Socket.SendTo"/>
		<seealso cref="System.Net.Sockets.Socket.SetSocketOption"/>
		<seealso cref="System.Net.Sockets.Socket.LocalEndPoint"/>
	</doc>
	<doc for="Socket.SendTo1">
		<summary>
			<para> Sends the specified number of bytes of data to the specified
      endpoint using the specified <see cref="System.Net.Sockets.SocketFlags"/>. </para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that contains the data to be sent.</param>
		<param name="size">The number of bytes to send.</param>
		<param name="socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<param name="remoteEP">The <see cref="System.Net.EndPoint"/> representing the destination location for the data.</param>
		<returns>
			<para> The number of bytes
      sent.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="buffer"/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="remoteEP"/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentOutOfRangeException">The specified <paramref name="size"/> exceeds the size of <paramref name="buffer"/>.</exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<remarks>
			<para>In this overload, the buffer offset defaults to 0. If you specify the <see cref="System.Net.Sockets.SocketFlags.DontRoute"/> flag as the <paramref name="socketflags"/> parameter, the data you are
   sending will not be routed. If you specify the <see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the <paramref name="socketflags"/> parameter, <see cref="System.Net.Sockets.Socket.Send"/> will only send out-of-band (OOB)
   data. The OOB data is a logically independent transmission channel associated
   with each pair of connected stream sockets. This data is delivered with higher priority and independently of the normal data.</para>
			<para>If you are using a connectionless protocol, you do not need to establish a
   default remote host with the <see cref="System.Net.Sockets.Socket.Connect"/> method prior to calling <see cref="System.Net.Sockets.Socket.SendTo"/>. You only need to do this if you
   intend to call the <see cref="System.Net.Sockets.Socket.Send"/> method. If you do call the <see cref="System.Net.Sockets.Socket.Connect"/> method prior to calling <see cref="System.Net.Sockets.Socket.SendTo"/>, the <paramref name="remoteEP"/> parameter will
   override the specified default remote host for that send operation only. You are
   also not required to call the <see cref="System.Net.Sockets.Socket.Bind"/> method, because the underlying
   service provider will assign the most appropriate local network address and port
   number. If you need to identify the assigned local network address and port
   number, you can use the <see cref="System.Net.Sockets.Socket.LocalEndPoint"/> property after the <see cref="System.Net.Sockets.Socket.SendTo"/> method successfully completes. </para>
			<para>Although intended for connectionless protocols, <see cref="System.Net.Sockets.Socket.SendTo"/> also works with
connection-oriented protocols. If you are using a connection-oriented protocol,
you must first establish a remote host connection by calling the <see cref="System.Net.Sockets.Socket.Connect"/> method or accept an incoming
connection request using the <see cref="System.Net.Sockets.Socket.Accept"/> method. If you do not establish or
accept a remote host connection, <see cref="System.Net.Sockets.Socket.SendTo"/> will throw a <see cref="System.Net.Sockets.SocketException"/>. You can also establish a default remote
host for a connectionless protocol prior to calling the <see cref="System.Net.Sockets.Socket.SendTo"/> method. In either of these cases,
<see cref="System.Net.Sockets.Socket.SendTo"/> will ignore the <paramref name="remoteEP"/> 
parameter and only send data to the connected or default remote host. </para>
			<para>Blocking sockets will block until the requested number of bytes are sent.
   Since a nonblocking <see cref="System.Net.Sockets.Socket"/> completes immediately, it might not send all
   of the bytes requested in a single operation. It is your application's
   responsibility to keep track of the number of bytes sent and to retry the
   operation until the application sends the requested number of bytes. There is
   also no guarantee that the data you send will appear on the network immediately.
   To increase network efficiency, the underlying system may delay transmission
   until a significant amount of out-going data is collected. A successful
   completion of the <see cref="System.Net.Sockets.Socket.SendTo"/> method means that the underlying
   system has had room to buffer your data for a network send. If it is important
   to your application to send every byte to the remote host immediately, you can
   use <see cref="System.Net.Sockets.Socket.SetSocketOption"/> to enable <see cref="System.Net.Sockets.SocketOptionName.NoDelay" qualify="true"/>. For more
   information about buffering for network efficiency, refer to the Nagle algorithm on MSDN. </para>
			<para>If you are using a connectionless protocol in blocking mode, <see cref="System.Net.Sockets.Socket.SendTo"/> will
block until the datagram is sent. If you want to send data to a broadcast
address, you must first call the <see cref="System.Net.Sockets.Socket.SetSocketOption"/> method and set the
socket option to <see cref="System.Net.Sockets.SocketOptionName.Broadcast" qualify="true"/>. You must also be sure that the number of bytes sent does
not exceed the maximum packet size of the underlying service provider. If it
does, the datagram will not be sent and <see cref="System.Net.Sockets.Socket.SendTo"/> will throw a <see cref="System.Net.Sockets.SocketException"/>.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain the specific error
   code. Once you have obtained this code, you can refer to the Windows Socket
   Version 2 API error code documentation in MSDN for a detailed description of the
   error.
</note>
		</remarks>
		<example>
			<para>The following example sends a connectionless datagram to the specified remote
      host. The size and <see cref="System.Net.Sockets.SocketFlags"/> are passed to the <see cref="System.Net.Sockets.Socket.SendTo"/> method.</para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="7"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.Bind"/>
		<seealso cref="System.Net.Sockets.Socket.Send"/>
		<seealso cref="System.Net.Sockets.Socket.SendTo"/>
		<seealso cref="System.Net.Sockets.Socket.SetSocketOption"/>
		<seealso cref="System.Net.Sockets.Socket.LocalEndPoint"/>
	</doc>
	<doc for="Socket.ReceiveFrom">
		<overload>
			<para> Receives a datagram and stores the source endpoint.</para>
		</overload>
		<summary>
			<para> Receives the specified number of bytes of
      data into the specified location of the data buffer, using
      the specified <see cref="System.Net.Sockets.SocketFlags"/>, and
      stores the endpoint.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that is the storage location for received data.</param>
		<param name="offset">The position in the <paramref name="buffer "/>parameter to store the received data.</param>
		<param name="size">The number of bytes to receive.</param>
		<param name="socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<param name="remoteEP">An <see cref="System.Net.EndPoint"/>, passed by reference, that represents the remote server.</param>
		<returns>
			<para> The number
      of bytes received.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="buffer "/> is <see langword="null"/>.</para>
			<para>
				<paramref name="-"/>or-</para>
			<para>
				<paramref name="remoteEP "/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="offset"/> is less than 0.</para>
			<para>-or-</para>
			<para><paramref name="offset"/> is greater than the length of <paramref name="buffer"/>.</para>
			<para>-or-</para>
			<para><paramref name="size"/> is less than 0.</para>
			<para>-or-</para>
			<para><paramref name="size"/> is greater than the length of the <paramref name="buffer"/> minus the value of the offset parameter.</para></exception>
		<exception cref="System.Net.Sockets.SocketException"><para><paramref name="socketFlags"/> is not a valid combination of values.</para>
			<para>-or-</para>
			<para>The <see cref="System.Net.Sockets.Socket.LocalEndPoint"/> property was not set.</para>
			<para>-or-</para>
			<para>An error occurred when attempting to access the socket. See the Remarks section for more information.</para></exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.Security.SecurityException">A caller in the call stack does not have the required permissions. </exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method reads data into the <paramref name="buffer"/> parameter, returns the number of bytes
   successfully read, and captures the remote host endpoint from which the data was
   sent. This method is useful if you intend to receive connectionless datagrams
   from an unknown host or multiple hosts. </para>
			<para> If you specify the <see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the <paramref name="socketFlags"/> parameter and the <see cref="System.Net.Sockets.Socket"/> is configured for in-line reception of
out-of-band (OOB) data (using <see cref="System.Net.Sockets.SocketOptionName.OutOfBandInline"/>) and OOB data is
available, <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will
return only OOB data. The OOB data is a logically independent transmission
channel associated with each pair of connected stream sockets. This data is
delivered with higher priority and independently of the normal data. If you specify
the <see cref="System.Net.Sockets.SocketFlags.Peek"/> flag
as the <paramref name="socketFlags "/>
parameter, the available data is copied into the receive buffer
but not removed from the system buffer. </para>
			<para>With connectionless protocols, <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will read the
first enqueued datagram received into the local network buffer. If
the datagram you receive is larger than the size of <paramref name="buffer"/>, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will fill
<paramref name="buffer"/> with as much of the message as is possible, and throw a <see cref="System.Net.Sockets.SocketException"/>. If you are 
using an unreliable protocol, the excess data will be lost. If you are using a reliable
protocol, the excess data will be retained by the service provider and you can retreive it by calling the
<see cref="System.Net.Sockets.Socket.ReceiveFrom"/> 
method with a large enough buffer.</para>
			<para>If no data is available for reading, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method
will block until
data is available. If you are in non-blocking mode, and there is
no data available in the in the protocol stack buffer, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will complete immediately and
throw a <see cref="System.Net.Sockets.SocketException"/>. You can use the <see cref="System.Net.Sockets.Socket.Available"/> property to determine if data is
available for reading. When <see cref="System.Net.Sockets.Socket.Available"/> is non-zero, retry the receive operation. </para>
			<para>Although <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> is intended for connectionless
protocols, you can use a
connection-oriented protocol as well. If you choose to do
so, you must first either establish a remote host connection by calling the <see cref="System.Net.Sockets.Socket.Connect"/> method or
accept an incoming remote host connection by calling the <see cref="System.Net.Sockets.Socket.Accept"/> method. If you do not establish or
accept a connection before calling the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method, you will get a <see cref="System.Net.Sockets.SocketException"/>. You can also
establish a default remote host for a connectionless protocol prior to calling
the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method. In
either of these cases, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will ignore the<paramref name="remoteEP"/> parameter and only receive data from the
connected or default remote host. </para>
			<para>With connection-oriented sockets, <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will read as much data as is
available up to the amount of bytes specified by the size parameter. If the
remote host shuts down the <see cref="System.Net.Sockets.Socket"/> connection with the <see cref="System.Net.Sockets.Socket.Shutdown"/> method, and all available data has
been Received, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will complete immediately and
return zero bytes. </para>
			<note type="note">
   Before calling <see cref="System.Net.Sockets.Socket.ReceiveFrom"/>, you must explicitly bind the <see cref="System.Net.Sockets.Socket"/> to a
   local endpoint using the <see cref="System.Net.Sockets.Socket.Bind"/> method. If you do not, <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will
   throw a <see cref="System.Net.Sockets.SocketException"/>. If you receive a
<see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain the specific error 
   code. Once you have obtained this code, you can refer to the Windows Socket
   Version 2 API error code documentation in MSDN for a detailed description of the
   error.
</note>
			<note type="note">
   The AddressFamily of the EndPoint
   used in ReceiveFrom needs to match the AddressFamily of the EndPoint used in
   SendTo.
</note>
		</remarks>
		<permission cref="System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="System.Net.NetworkAccess.Accept"/>.</permission>
		<example>
			<para>The following example receives a connectionless datagram from a remote host.
      The offset, buffer size, and <see cref="System.Net.Sockets.SocketFlags"/> are passed to the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method.</para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="8"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.Receive"/>
		<seealso cref="System.Net.Sockets.Socket.Available"/>
		<seealso cref="System.Net.Sockets.Socket.Shutdown"/>
		<seealso cref="System.Net.Sockets.Socket.Close"/>
		<seealso cref="System.Net.Sockets.SocketFlags"/>
	</doc>
	<doc for="Socket.ReceiveFrom1">
		<summary>
			<para> Receives the specified number of bytes into the
      data buffer, using the specified <see cref="System.Net.Sockets.SocketFlags"/>, and
      stores the endpoint.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that is the storage location for received data.</param>
		<param name="size">The number of bytes to receive.</param>
		<param name="socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<param name="remoteEP">An <see cref="System.Net.EndPoint"/>, passed by reference, that represents the remote server.</param>
		<returns>
			<para> The number
      of bytes received.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="buffer "/> is <see langword="null"/>.</para>
			<para>
				<paramref name="-"/>or-</para>
			<para>
				<paramref name="remoteEP "/> is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentOutOfRangeException"><para><paramref name="size"/> is less than 0.</para>
			<para>-or-</para>
			<para><paramref name="size"/> is greater than the length of <paramref name="buffer "/> .</para></exception>
		<exception cref="System.Net.Sockets.SocketException"><para><paramref name="socketFlags"/> is not a valid combination of values.</para>
			<para> -or-</para>
			<para>The <see cref="System.Net.Sockets.Socket.LocalEndPoint"/> property was not set.</para>
			<para> -or-</para>
			<para>An operating system error occurs while accessing the <see cref="System.Net.Sockets.Socket"/>.</para></exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.Security.SecurityException">A caller in the call stack does not have the required permissions. </exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method reads data into the <paramref name="buffer"/>
parameter, returns the number of bytes successfully read, and captures the
remote host endpoint from which the data was sent. This method is useful if you intend to receive
connectionless datagrams from an unknown host or multiple hosts. </para>
			<para>This overload only requires you to provide a receive buffer, the number of
   bytes you want to receive, the necessary <see cref="System.Net.Sockets.SocketFlags"/>, and an <see cref="System.Net.EndPoint"/> representing the remote host. The buffer offset
   defaults to 0. If you specify the <see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the
<paramref name="socketFlags"/> parameter and the <see cref="System.Net.Sockets.Socket"/> is configured for in-line 
   reception of out-of-band (OOB) data (using <see cref="System.Net.Sockets.SocketOptionName.OutOfBandInline"/>) and OOB data is available,
<see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will return only OOB data. The OOB 
   data is a logically independent transmission channel associated with each pair
   of connected stream sockets. This data is delivered with higher priority and
   independently of the normal data. If you specify the <see cref="System.Net.Sockets.SocketFlags.Peek"/> flag as the
<paramref name="socketFlags "/> parameter, the available data is
   copied into the
   receive buffer but not removed from the system buffer. </para>
			<para>With connectionless protocols, <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will read the
first enqueued datagram received into the local network buffer. If the datagram
you receive is larger than the size of <paramref name="buffer "/>, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will fill <paramref name="buffer"/>
with as much of the message as is possible, and throw a <see cref="System.Net.Sockets.SocketException"/>
. If you are using an unreliable protocol,
the excess data will be lost. If you are using a reliable protocol, the excess
data will be retained by the service provider and you can retreive it by calling
the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method with a large enough
buffer.</para>
			<para>If no data is available for reading, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method
will block until data is
available. If you are in non-blocking mode, and there is no data available in the
in the protocol stack buffer, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will complete
immediately and throw a <see cref="System.Net.Sockets.SocketException"/>. You can use the <see cref="System.Net.Sockets.Socket.Available"/> property to determine if data is
available for reading. When <see cref="System.Net.Sockets.Socket.Available"/> is non-zero, retry the receive
operation. </para>
			<para>Although <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> is intended for connectionless
protocols, you can use a connection-oriented protocol as well. If you choose to
do so, you must first either establish a remote host connection by calling the
<see cref="System.Net.Sockets.Socket.Connect"/> method or accept an incoming remote 
host connection by calling the <see cref="System.Net.Sockets.Socket.Accept"/> method. If you do not establish or
accept a connection before calling the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method, you will get
a <see cref="System.Net.Sockets.SocketException"/>. You can also establish a default remote
host for a connectionless protocol prior to calling the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method. In either of these cases,
the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will ignore the <paramref name="remoteEP"/>
parameter and only receive data from the connected or default remote host. </para>
			<para>With connection-oriented sockets, <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will read as much data as is
available up to the number of bytes specified by the <paramref name="size"/>
parameter.
If the remote host shuts down the <see cref="System.Net.Sockets.Socket"/> connection with the <see cref="System.Net.Sockets.Socket.Shutdown"/> method, and all available data has
been received, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will complete immediately and
return zero bytes. </para>
			<note type="note">
   Before calling <see cref="System.Net.Sockets.Socket.ReceiveFrom"/>, you must explicitly bind the <see cref="System.Net.Sockets.Socket"/> to a
   local endpoint using the <see cref="System.Net.Sockets.Socket.Bind"/> method. If you do not, <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will throw a <see cref="System.Net.Sockets.SocketException"/>. If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
   
</note>
			<note type="note">
   The AddressFamily of the EndPoint
   used in ReceiveFrom needs to match the AddressFamily of the EndPoint used in
   SendTo.
</note>
		</remarks>
		<permission cref="System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="System.Net.NetworkAccess.Accept"/>.</permission>
		<example>
			<para>The following example receives a connectionless datagram from a remote
      host. The buffer size, and <see cref="System.Net.Sockets.SocketFlags"/> are passed to the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method.</para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="7"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.Receive"/>
		<seealso cref="System.Net.Sockets.Socket.Available"/>
		<seealso cref="System.Net.Sockets.Socket.Shutdown"/>
		<seealso cref="System.Net.Sockets.Socket.Close"/>
		<seealso cref="System.Net.Sockets.SocketFlags"/>
	</doc>
	<doc for="Socket.ReceiveFrom2">
		<summary>
			<para> Receives a datagram into the data buffer, using
      the specified <see cref="System.Net.Sockets.SocketFlags"/>, and
      stores the endpoint.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that is the storage location for the received data.</param>
		<param name="socketFlags">A bitwise combination of the <see cref="System.Net.Sockets.SocketFlags"/> values.</param>
		<param name="remoteEP">An <see cref="System.Net.EndPoint"/>, passed by reference, that represents the remote server.</param>
		<returns>
			<para> The number
      of bytes received.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name="buffer "/> is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="remoteEP "/> is <see langword="null"/>.</para></exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.Security.SecurityException">A caller in the call stack does not have the required permissions.</exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method reads data into the <paramref name="buffer"/> parameter, returns the number of bytes
   successfully read, and captures the remote host endpoint from which the data was
   sent. This method is useful if you intend to receive connectionless datagrams
   from an unknown host or multiple hosts. </para>
			<para>This overload only requires you to provide a receive buffer, the necessary
<see cref="System.Net.Sockets.SocketFlags"/>, and an <see cref="System.Net.EndPoint"/> representing the remote 
   host. The offset defaults to 0 and the size defaults to the length of the
   buffer parameter.
   If you specify the <see cref="System.Net.Sockets.SocketFlags.OutOfBand"/> flag as the <paramref name="socketFlags
   "/> parameter and the <see cref="System.Net.Sockets.Socket"/> is configured for in-line reception of
   out-of-band (OOB) data (using <see cref="System.Net.Sockets.SocketOptionName.OutOfBandInline"/>) and OOB data is available,
<see cref="System.Net.Sockets.Socket.ReceiveFrom"/>
will return only OOB data. If you specify the <see cref="System.Net.Sockets.SocketFlags.Peek"/> flag, the available
data is copied into the receive buffer but not removed from the system buffer. </para>
			<note type="note">
   Before calling <see cref="System.Net.Sockets.Socket.ReceiveFrom"/>, you must explicitly
   bind the <see cref="System.Net.Sockets.Socket"/> to a local endpoint using the <see cref="System.Net.Sockets.Socket.Bind"/> method. If you do not, <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will throw a <see cref="System.Net.Sockets.SocketException"/>.
</note>
			<para>With connectionless protocols, <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will read the
first enqueued datagram received into the local network buffer. If the datagram
you receive is larger than the size of <paramref name="buffer"/>, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will fill <paramref name="buffer"/>
with as much of the message as is possible, and throw a <see cref="System.Net.Sockets.SocketException"/>. If you are using an unreliable protocol,
the excess data will be lost. If you are using a reliable protocol, the excess
data will be retained by the service provider and you can retreive it by calling
the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method with a large enough
buffer.</para>
			<para>If no data is available for reading, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method
will block until data is
available. If you are in non-blocking mode, and there is no data available in the
in the protocol stack buffer, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will complete
immediately and throw a <see cref="System.Net.Sockets.SocketException"/>. You can use the <see cref="System.Net.Sockets.Socket.Available"/> property to determine if data is
available for reading. When <see cref="System.Net.Sockets.Socket.Available"/> is non-zero, retry the receive
operation. </para>
			<para>Although <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> is intended for connectionless
protocols, you can use a connection-oriented protocol as well. If you choose to
do so, you must first either establish a remote host connection by calling the
<see cref="System.Net.Sockets.Socket.Connect"/> method or accept an incoming remote 
host connection by calling the <see cref="System.Net.Sockets.Socket.Accept"/> method. If you do not establish or
accept a connection before calling the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method, you will get
a <see cref="System.Net.Sockets.SocketException"/>. You can also establish a default remote
host for a connectionless protocol prior to calling the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method. In either of these cases,
the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will ignore the <paramref name="remoteEP"/>
parameter and only receive data from the connected or default remote host. </para>
			<para>With connection-oriented sockets, <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will read as
much data as is available up to the size of <paramref name="buffer"/>. If the remote host
shuts down the <see cref="System.Net.Sockets.Socket"/> connection with the <see cref="System.Net.Sockets.Socket.Shutdown"/> method, and all available data has
been Received, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will complete immediately and
return zero bytes. </para>
			<note type="note">
   If you
   receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain the specific error
   code. Once you have obtained this code, you can refer to the Windows Socket
   Version 2 API error code documentation in MSDN for a detailed description of the
   error.
</note>
			<note type="note">
   The AddressFamily of the EndPoint
   used in ReceiveFrom needs to match the AddressFamily of the EndPoint used in
   SendTo.
</note>
		</remarks>
		<permission cref="System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="System.Net.NetworkAccess.Accept"/>.</permission>
		<example>
			<para>The following example receives a connectionless datagram from a remote
      host. <see cref="System.Net.Sockets.SocketFlags"/> are passed to the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method.</para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="6"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.Receive"/>
		<seealso cref="System.Net.Sockets.Socket.Available"/>
		<seealso cref="System.Net.Sockets.Socket.Shutdown"/>
		<seealso cref="System.Net.Sockets.Socket.Close"/>
		<seealso cref="System.Net.Sockets.SocketFlags"/>
	</doc>
	<doc for="Socket.ReceiveFrom3">
		<summary>
			<para> Receives a datagram into the data buffer and stores the
      endpoint.</para>
		</summary>
		<param name="buffer">An array of type <see cref="System.Byte"/> that is the storage location for received data.</param>
		<param name="remoteEP">An <see cref="System.Net.EndPoint"/>, passed by reference, that represents the remote server.</param>
		<returns>
			<para> The number
      of bytes received.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>
				<paramref name=" buffer "/>is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>
				<paramref name="remoteEP "/> is <see langword="null"/>.</para></exception>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.Security.SecurityException">A caller in the call stack does not have the required permissions. </exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method reads data into the <paramref name="buffer"/> parameter, returns the number of bytes
   successfully read, and captures the remote host endpoint from which the data was
   sent. This method is useful if you intend to receive connectionless datagrams
   from an unknown host or multiple hosts. </para>
			<para>This overload only requires you to provide a receive <paramref name="buffer"/>, and
an <see cref="System.Net.EndPoint"/> representing the remote host. The buffer offset
defaults to 0. The size defaults to the length of the <paramref name="buffer"/> parameter<paramref name=" "/>and the <paramref name="socketFlags "/>value defaults to <see cref="System.Net.Sockets.SocketFlags.None"/>.</para>
			<note type="note">
   Before calling <see cref="System.Net.Sockets.Socket.ReceiveFrom"/>, you must explicitly
   bind the <see cref="System.Net.Sockets.Socket"/> to a local endpoint using the <see cref="System.Net.Sockets.Socket.Bind"/>method. If
   you do not, <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will throw a <see cref="System.Net.Sockets.SocketException"/>.
</note>
			<para>With connectionless protocols, <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will read the
first enqueued datagram received into the local network buffer. If the datagram
you receive is larger than the size of <paramref name="buffer "/>, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will fill <paramref name="buffer"/>
with as much of the message as is possible, and throw a <see cref="System.Net.Sockets.SocketException"/>. If you are using an unreliable protocol,
the excess data will be lost. If you are using a reliable protocol, the excess
data will be retained by the service provider and you can retreive it by calling
the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method with a large enough
buffer.</para>
			<para>If no data is available for reading, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method
will block until data is
available. If you are in non-blocking mode, and there is no data available in the
in the protocol stack buffer, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will complete
immediately and throw a <see cref="System.Net.Sockets.SocketException"/>. You can use the <see cref="System.Net.Sockets.Socket.Available"/> property to determine if data is
available for reading. When <see cref="System.Net.Sockets.Socket.Available"/> is non-zero, retry the receive
operation. </para>
			<para>Although <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> is intended for connectionless
protocols, you can use a connection-oriented protocol as well. If you choose to
do so, you must first either establish a remote host connection by calling the
<see cref="System.Net.Sockets.Socket.Connect"/> method or accept an incoming remote 
host connection by calling the <see cref="System.Net.Sockets.Socket.Accept"/> method. If you do not establish or
accept a connection before calling the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method, you will get
a <see cref="System.Net.Sockets.SocketException"/>. You can also establish a default remote
host for a connectionless protocol prior to calling the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method. In either of these cases,
the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will ignore the <paramref name="remoteEP"/>
parameter and only receive data from the connected or default remote host. </para>
			<para>With connection-oriented sockets, <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> will read as
much data as is available up to the size of <paramref name="buffer"/>. If the remote host
shuts down the <see cref="System.Net.Sockets.Socket"/> connection with the <see cref="System.Net.Sockets.Socket.Shutdown"/> method, and all available data has
been received, the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method will complete immediately and
return zero bytes. </para>
			<note type="note">
   If you
   receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain the specific error
   code. Once you have obtained this code, you can refer to the Windows Socket
   Version 2 API error code documentation in MSDN for a detailed description of the
   error.
</note>
			<note type="note">
   The AddressFamily of the EndPoint
   used in ReceiveFrom needs to match the AddressFamily of the EndPoint used in
   SendTo.
</note>
		</remarks>
		<permission cref="System.Net.SocketPermission">for accepting connections from the network. Associated enumeration: <see cref="System.Net.NetworkAccess.Accept"/>.</permission>
		<example>
			<para>The following example receives a connectionless
      datagram from a remote host. </para>
			<codelink SampleID="Socket_Sync_Send_Receive" SnippetID="5"/>
		</example>
		<seealso cref="System.Net.Sockets.Socket.Connect"/>
		<seealso cref="System.Net.Sockets.Socket.Receive"/>
		<seealso cref="System.Net.Sockets.Socket.Available"/>
		<seealso cref="System.Net.Sockets.Socket.Shutdown"/>
		<seealso cref="System.Net.Sockets.Socket.Close"/>
	</doc>
	<doc for="Socket.SupportsIPv4">
		<summary>
			<para> Gets a value indicating whether IPv4 support is
      available and enabled on the current host.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the current host supports the IPv4 protocol;
   otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The value of this property is a function of the Operating System's support for the
      IPv4 protocol.</para>
		</remarks>
	</doc>
	<doc for="Socket.SupportsIPv6">
		<summary>
			<para>Gets a value indicating whether IPv6 support is available and enabled on the
      current host.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the current host supports the IPv6 protocol;
   otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The value of this property is a function of the Operating System's support for the
      IPv6 protocol and of the <SpecialLocalizableItem kind="UIElement">config.ipv6Enabled</SpecialLocalizableItem> field defined by the configuration
   file.</para>
			<note type="note">
   A host can support both IPv4 and
   IPv6 protocols.
</note>
		</remarks>
	</doc>
	<doc for="Socket">
		<summary>
			<para> Implements the Berkeley sockets
      interface.</para>
		</summary>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket"/> class provides a rich set of
   methods and properties for network communications. The <see cref="System.Net.Sockets.Socket"/> class
   allows you to perform both synchronous and asynchronous data transfer using any
   of the communication protocols listed in the <see cref="System.Net.Sockets.ProtocolType"/> enumeration. The <see cref="System.Net.Sockets.Socket"/> class
   follows the .NET Framework naming pattern for asynchronous methods; for example,
   the synchronous <see cref="System.Net.Sockets.Socket.Receive"/> method corresponds to the asynchronous
<see cref="System.Net.Sockets.Socket.BeginReceive"/> and <see cref="System.Net.Sockets.Socket.EndReceive"/> methods.
   </para>
			<para>If your application only requires one thread during
   execution, use the following methods, which are designed for synchronous
   operation mode.
   </para>
			<list type="bullet"><item>
					<term>
      
      If you are
      using a connection-oriented protocol such as TCP, your server can listen for
      connections using the <see cref="System.Net.Sockets.Socket.Listen"/> method. The <see cref="System.Net.Sockets.Socket.Accept"/> method processes any incoming connection
      requests and returns a <see cref="System.Net.Sockets.Socket"/> that you can use to communicate data with
      the remote host. Use this returned <see cref="System.Net.Sockets.Socket"/> to call the <see cref="System.Net.Sockets.Socket.Send"/>
      or <see cref="System.Net.Sockets.Socket.Receive"/> method. Call the <see cref="System.Net.Sockets.Socket.Bind"/>
      method prior to calling the <see cref="System.Net.Sockets.Socket.Listen"/> method if you would like to
      specify the local IP address and port number. If you do not call <see cref="System.Net.Sockets.Socket.Bind"/>,
      the underlying service provider will assign these values for you. You can later
      use the <see cref="System.Net.Sockets.Socket.LocalEndPoint"/> property to identify the IP address and port
      number assigned to your <see cref="System.Net.Sockets.Socket"/>. If you would like to connect to a listening
      host, call the <see cref="System.Net.Sockets.Socket.Connect"/> method. To communicate data, call the
   <see cref="System.Net.Sockets.Socket.Send"/> or <see cref="System.Net.Sockets.Socket.Receive"/> method.</term>
				</item>
				<item>
					<term>
      
      If you are using a connectionless protocol such as UDP, you do not need to
      listen for connections at all. Call the <see cref="System.Net.Sockets.Socket.ReceiveFrom"/> method to accept
      any incoming datagrams. Use the <see cref="System.Net.Sockets.Socket.SendTo"/> method to send datagrams to a
      remote host.</term>
				</item>
			</list>
			<para> To process communications using separate threads during
   execution, use the following methods, which are designed for asynchronous
   operation mode. </para>
			<list type="bullet"><item>
					<term>
      
      If you are
      
      using a connection-oriented protocol such as TCP, use the <see cref="System.Net.Sockets.Socket"/>,
   <see cref="System.Net.Sockets.Socket.BeginConnect"/>, and <see cref="System.Net.Sockets.Socket.EndConnect"/> methods to connect with a listening
      host. Use the <see cref="System.Net.Sockets.Socket.BeginSend"/> and <see cref="System.Net.Sockets.Socket.EndSend"/> or <see cref="System.Net.Sockets.Socket.BeginReceive"/> and <see cref="System.Net.Sockets.Socket.EndReceive"/> methods to communicate data
      asynchronously. Incoming connection requests can be processed using <see cref="System.Net.Sockets.Socket.BeginAccept"/> and <see cref="System.Net.Sockets.Socket.EndAccept"/>.</term>
				</item>
				<item>
					<term>
      
      If you are using a connectionless protocol such as UDP, you can use
   <see cref="System.Net.Sockets.Socket.BeginSendTo"/> and <see cref="System.Net.Sockets.Socket.EndSendTo"/> to send datagrams and
   <see cref="System.Net.Sockets.Socket.BeginReceiveFrom"/> and <see cref="System.Net.Sockets.Socket.EndReceiveFrom"/> to receive datagrams.</term>
				</item>
			</list>
			<para> When you are finished sending and
   receiving data, use the <see cref="System.Net.Sockets.Socket.Shutdown"/> method to disable the <see cref="System.Net.Sockets.Socket"/>.
   After calling <see cref="System.Net.Sockets.Socket.Shutdown"/>, call the <see cref="System.Net.Sockets.Socket.Close"/> method to release all
   resources associated with the <see cref="System.Net.Sockets.Socket"/>. </para>
			<para>The <see cref="System.Net.Sockets.Socket"/> class allows you to configure your <see cref="System.Net.Sockets.Socket"/> using
the <see cref="System.Net.Sockets.Socket.SetSocketOption"/> methods. Retrieve these settings
using the <see cref="System.Net.Sockets.Socket.GetSocketOption"/> methods. </para>
			<note type="note">
   If you are writing a relatively simple
   application and only require synchronous data transfer, consider using <see cref="System.Net.Sockets.TcpClient"/>,
<see cref="System.Net.Sockets.TcpListener"/>, and <see cref="System.Net.Sockets.UdpClient"/>. These classes provide a 
   simpler and more user-friendly interface to <see cref="System.Net.Sockets.Socket"/>
   
   communications.
   
</note>
		</remarks>
		<permission cref="System.Net.SocketPermission">to establish an outgoing connection or accept an incoming request.</permission>
		<example>
			<para> The following example shows how the <see cref="System.Net.Sockets.Socket"/>
class can be used to send data to an HTTP server and receive the
response. </para>
			<codelink SampleID="System.Net.Sockets.Socket" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Socket.IOControl">
		<summary>
			<para>Sets low-level operating modes for the <see cref="System.Net.Sockets.Socket"/>.</para>
		</summary>
		<param name="ioControlCode">The control code of the operation to perform.</param>
		<param name=" optionInValue">An array of type <see cref="System.Byte"/> that contains the input data required by the operation.</param>
		<param name=" optionOutValue">An array of type <see cref="System.Byte"/> that contains the output data returned by the operation.</param>
		<returns>
			<para> The number of bytes in the
   <paramref name="optionOutValue"/> parameter.</para>
		</returns>
		<exception cref="System.Net.Sockets.SocketException">An error occurred when attempting to access the socket. See the Remarks section for more information.</exception>
		<exception cref="System.ObjectDisposedException">The <see cref="System.Net.Sockets.Socket"/> has been closed.</exception>
		<exception cref="System.InvalidOperationException"><para>An attempt was made to change the blocking mode without using the <see cref="System.Net.Sockets.Socket.Blocking"/> property.</para></exception>
		<exception cref="System.Security.SecurityException">A caller in the call stack does not have the required permissions. </exception>
		<remarks>
			<para>The <see cref="System.Net.Sockets.Socket.IOControl"/> method provides low-level access to
   the operating system <see cref="System.Net.Sockets.Socket"/> underlying the current instance of the
<see cref="System.Net.Sockets.Socket"/> class. For more information about <see cref="System.Net.Sockets.Socket.IOControl"/> , see the 
   WSAIoct documentation in MSDN.</para>
			<note type="note">
   If you receive a <see cref="System.Net.Sockets.SocketException"/>, use <see cref="System.Net.Sockets.SocketException.ErrorCode" qualify="true"/> to obtain
   the specific error code. Once you have obtained this code, you can refer to the
   Windows Socket Version 2 API error code documentation in MSDN for a detailed
   description of the error.
</note>
		</remarks>
		<example>
			<para>The following code example creates a
   <see cref="System.Net.Sockets.Socket"/> connection to the server specified by the 
      user, using port 80. Once the connection has been established, it asks the
      server for the content of its home page. It then uses the <see cref="System.Net.Sockets.Socket.IOControl"/>method to find the number
      of bytes received. Finally, it displays the page content. If no server name is
      passed as an argument, it uses the current host as the default server.</para>
			<codelink SampleID="System.Net.Sockets.Socket.IOControl" SnippetID="1"/>
		</example>
	</doc>
</docs>
