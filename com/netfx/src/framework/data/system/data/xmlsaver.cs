//------------------------------------------------------------------------------
// <copyright file="xmlsaver.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data {
    using System;
    using System.Xml;
    using System.Globalization;
    using System.Collections;
    using System.ComponentModel;    
    using System.Diagnostics;    
    using System.IO;    

    internal enum SchemaFormat {
        Public = 1,
        Remoting = 2,
        WebService = 3
    }
    
    /// <include file='doc\xmlsaver.uex' path='docs/doc[@for="XmlTreeGen"]/*' />
    /// <devdoc>
    ///
    /// </devdoc>
    internal sealed class XmlTreeGen {
        ArrayList ConstraintNames;
        Hashtable namespaces;
        Hashtable autogenerated;
        Hashtable prefixes;

        DataSet _ds;
        XmlDocument _dc;
        XmlElement _sRoot;
        int prefixCount = 0;
        private SchemaFormat schFormat = SchemaFormat.Public;
        private string filePath = null;
        private string fileName = null;
        private string fileExt = null;
        XmlElement dsElement = null;
        XmlElement constraintSeparator = null;

        internal XmlTreeGen(SchemaFormat format) {
            this.schFormat = format;
        }

        internal static void AddXdoProperties(Object instance, XmlElement root, XmlDocument xd) {
            if (instance == null) {
                return;
            }

            PropertyDescriptorCollection pds = TypeDescriptor.GetProperties(instance) ;
            
            bool known = (instance is DataSet) || (instance is DataTable) || (instance is DataColumn) || (instance is DataRelation);

            if (!known) {
                return;
            }

            for (int i = 0 ; i < pds.Count ; i++) {
                AddXdoProperty(pds[i], instance, root, xd);
            }
            return;
        }

        internal static void AddExtendedProperties(PropertyCollection props, XmlElement node) {
            AddExtendedProperties(props, node, null);
        }

        internal static void AddExtendedProperties(PropertyCollection props, XmlElement node, Type type) {
            if(props != null) {
                foreach (Object o in props.Keys) {
                    String s = (String) Convert.ToString(o);
                    String v = (String) Convert.ToString(props[s]);
                    if (type == typeof(DataRelation))
                        s = Keywords.MSD_REL_PREFIX + s;
                    if (type == typeof(ForeignKeyConstraint))
                        s = Keywords.MSD_FK_PREFIX + s;
                    node.SetAttribute(XmlConvert.EncodeName(s), Keywords.MSPROPNS, v);
                }
            }
        }


        internal static void AddXdoProperty(PropertyDescriptor pd, Object instance, XmlElement root, XmlDocument xd) {
            Type type = pd.PropertyType;

            if (type != typeof(string) &&
                type != typeof(bool) &&
                type != typeof(Type) &&
                type != typeof(object) &&
                type != typeof(CultureInfo) &&
                type != typeof(Int64) &&
                type != typeof(Int32)) {
                return;
            }

            if (!pd.ShouldSerializeValue(instance) || !pd.Attributes.Contains(DesignerSerializationVisibilityAttribute.Visible)) {
                return;
            }

            Object propInst = pd.GetValue(instance) ;

            if (propInst is InternalDataCollectionBase)
                return;

            if (propInst is PropertyCollection) {
                return;
            }
            // SDUB: perf: Why not have this as a table?
            // there are several xdo properties that equal to some xml attributes, we should not explicitly ouput them.
            if (
                0 == String.Compare(pd.Name, "Namespace"    , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "PrimaryKey"   , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "ColumnName"   , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "DefaultValue" , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "TableName"    , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "DataSetName"  , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "AllowDBNull"  , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "Unique"       , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "NestedInDataSet" , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "Locale"       , false, CultureInfo.InvariantCulture) ||
                0 == String.Compare(pd.Name, "CaseSensitive", false, CultureInfo.InvariantCulture)
            ) {
                return;
            }

            if (instance is DataColumn) {
                if (0 == String.Compare(pd.Name, "DataType", false, CultureInfo.InvariantCulture)) {
                    DataColumn col = (DataColumn)instance;
                    string dt = XmlDataTypeName(col.DataType);
                    if (dt.Length == 0) {
                        root.SetAttribute(Keywords.MSD_DATATYPE, Keywords.MSDNS, col.DataType.AssemblyQualifiedName);
#if DEBUG
                        if (CompModSwitches.XmlWriter.TraceVerbose) {
                            Debug.WriteLine("Adding AttrNode " + Keywords.MSD_DATATYPE + " = " + col.DataType.FullName );
                        }
#endif
                    }
                    return;
                }
                if (0 == String.Compare(pd.Name, "Attribute", false, CultureInfo.InvariantCulture)) {
                    return;
                }
            }

            string textValue = pd.Converter.ConvertToString(propInst) ;
            root.SetAttribute(pd.Name, Keywords.MSDNS, textValue);
#if DEBUG
            if (CompModSwitches.XmlWriter.TraceVerbose) {
                Debug.WriteLine("Adding AttrNode " + pd.Name + " = " + textValue );
            }
#endif
            return;
        }

        internal static string XmlDataTypeName(Type type) {
            if (type == typeof(Char))
                return "_";         // has to have SimpleType in this column.
            if (type == typeof(Byte[]))
                return "base64Binary";       // has to have SimpleType in this column.
            if (type == typeof(DateTime))
                return "dateTime";
            if (type == typeof(TimeSpan))
                return "duration";
            if (type == typeof(Decimal))
                return "decimal";
            if (type == typeof(int))
                return "int";
            if (type == typeof(Boolean))
                return "boolean";
            if (type == typeof(Single))
                return "float";
            if (type == typeof(double))
                return "double";
            if (type == typeof(SByte))
                return "byte";
            if (type == typeof(Byte))
                return "unsignedByte";
            if (type == typeof(Int16))
                return "short";
            if (type == typeof(Int32))
                return "int";
            if (type == typeof(Int64))
                return "long";
            if (type == typeof(UInt16))
                return "unsignedShort";
            if (type == typeof(UInt32))
                return "unsignedInt";
            if (type == typeof(UInt64))
                return "unsignedLong";
            if (type == typeof(Uri))
                return "anyURI";

            return String.Empty;
        }

        private void GenerateConstraintNames(DataTable table) {
          
            foreach(Constraint constr in table.Constraints) {
                string name = constr.ConstraintName;
                int nameInt = 0;

                while (ConstraintNames.Contains(name)) 
                {
                    name= table.TableName + '_' +constr.ConstraintName;
                    if (nameInt > 0) 
                        name = name + '_'  + nameInt.ToString();
                    nameInt++;
                }
            
                ConstraintNames.Add(name);
                constr.SchemaName = name;
            }
        }

        private void GenerateConstraintNames(DataSet ds) {
        
            DataTable[] tables = new DataTable[ds.Tables.Count];
            ds.Tables.CopyTo(tables, 0);
            
            for (int i = 0; i < tables.Length; i++) {
                GenerateConstraintNames(tables[i]);
            }            
        }

        //Does the DS or ANY object in it have ExtendedProperties?
        private static bool _PropsNotEmpty(PropertyCollection props) {
            return props != null && props.Count != 0;
        }

        private bool HaveExtendedProperties(DataSet ds) {
            if(_PropsNotEmpty(ds.extendedProperties)) {
                return true;
            }
            for(int t = 0; t < ds.Tables.Count; t ++) {
                DataTable table = ds.Tables[t];
                if(_PropsNotEmpty(table.extendedProperties)) {
                    return true;
                }
                for(int c = 0; c < table.Columns.Count; c ++) {
                    if(_PropsNotEmpty(table.Columns[c].extendedProperties)) {
                        return true;
                    }
                }
            }
            // What is the best way to enumerate relations? from DataSet of from DataTable?
            for(int r = 0; r < ds.Relations.Count; r ++) {
                if(_PropsNotEmpty(ds.Relations[r].extendedProperties)) {
                    return true;
                }
            }
            // What about constraints?
            return false;                            
        }// HaveExtendedProperties
        
        internal void WriteSchemaRoot(XmlDocument xd, XmlElement rootSchema, string targetNamespace) {
            rootSchema.SetAttribute(Keywords.XSDID, XmlConvert.EncodeLocalName(_ds.DataSetName));
            if (targetNamespace != string.Empty) {
                rootSchema.SetAttribute(Keywords.TARGETNAMESPACE, targetNamespace );
                rootSchema.SetAttribute(Keywords.XMLNS_MSTNS, targetNamespace );
            }
            // Add the namespaces
            // rootSchema.SetAttribute(Keywords.XMLNS, Keywords.XSD_ATOM.String));
            rootSchema.SetAttribute(Keywords.XMLNS, targetNamespace);
            rootSchema.SetAttribute(Keywords.XMLNS_XSD, Keywords.XSDNS);
            rootSchema.SetAttribute(Keywords.XMLNS_MSDATA, Keywords.MSDNS);
            if(HaveExtendedProperties(_ds)) {
                rootSchema.SetAttribute(Keywords.XMLNS_MSPROP, Keywords.MSPROPNS);
            }

            if (targetNamespace != "") {
                rootSchema.SetAttribute(Keywords.XSD_ATTRIBUTEFORMDEFAULT, Keywords.QUALIFIED);
                rootSchema.SetAttribute(Keywords.XSD_ELEMENTFORMDEFAULT, Keywords.QUALIFIED);
            }
        }

        internal void SetupAutoGenerated(DataSet ds){
            foreach (DataTable dt in ds.Tables) {
                foreach (DataColumn col in dt.Columns) {
                    if (AutoGenerated(col))
                        autogenerated[col] = col;
                }
                foreach (Constraint cs in dt.Constraints) {
                    if (cs is ForeignKeyConstraint) {
                        ForeignKeyConstraint fk = (ForeignKeyConstraint) cs;
                        if (AutoGenerated(fk))
                            autogenerated[fk] = fk;
                        else {
                            if (autogenerated[fk.Columns[0]] != null)
                                autogenerated[fk.Columns[0]] = null;

                            if (autogenerated[fk.RelatedColumns[0]] != null)
                                autogenerated[fk.RelatedColumns[0]] = null;
                                // special case of the ghosted constraints:
                                UniqueConstraint _constraint = (UniqueConstraint) fk.RelatedTable.Constraints.FindConstraint( new UniqueConstraint( "TEMP", fk.RelatedColumns));

                                if (_constraint == null)
                                    continue;

                                if(autogenerated[_constraint] != null)
                                    autogenerated[_constraint] = null;
                                if(autogenerated[_constraint.Key.Columns[0]] != null)
                                    autogenerated[_constraint.Key.Columns[0]] = null;
                        }
                    }
                    else {
                        UniqueConstraint unique = (UniqueConstraint) cs;
                        if (AutoGenerated(unique))
                            autogenerated[unique] = unique;
                        else {
                            if (autogenerated[unique.Key.Columns[0]] != null)
                                autogenerated[unique.Key.Columns[0]] = null; 
                        }
                    }
                }
            }
        }

        internal XmlElement SchemaTree(XmlDocument xd, DataSet ds) {
            ConstraintNames = new ArrayList();
            autogenerated = new Hashtable();
            bool genSecondary = filePath != null;
            dsElement = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ELEMENT, Keywords.XSDNS);

            DataTable   []  top;
            bool            fFlat = false;
            _ds = ds;
            _dc = xd;
            if (schFormat != SchemaFormat.Remoting) {
                namespaces = new Hashtable();
                prefixes = new Hashtable();
            }

            XmlElement rootSchema = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SCHEMA, Keywords.XSDNS);
            _sRoot = rootSchema;
            WriteSchemaRoot(xd, rootSchema, _ds.Namespace);

            if (schFormat != SchemaFormat.Remoting) {
                namespaces[_ds.Namespace] = rootSchema;
                if (_ds.Namespace == "")
                    prefixes[_ds.Namespace] = null;
                else {
                    // generate a prefix for the dataset schema itself.
                    rootSchema.SetAttribute(Keywords.XMLNS_MSTNS, _ds.Namespace );
                    prefixes[_ds.Namespace] = "mstns";
                }
            }

            // Generate all the constraint names            
            GenerateConstraintNames(ds);
            // Setup AutoGenerated table
            if (schFormat != SchemaFormat.Remoting) 
                SetupAutoGenerated(ds);


            //
            // Output all top level elements, which will recursively invoke to other tables.
            //
            
            top = ds.TopLevelTables();
            if (top.Length == 0) {
                // return an empty schema for now.
                // probably we need to throw an exception
                FillDataSetElement(xd, ds);
                rootSchema.AppendChild(dsElement);
                AddXdoProperties(_ds, dsElement, xd );
                AddExtendedProperties(ds.extendedProperties, dsElement);
                return rootSchema;
            }
 
            // Fill out dataset element
            XmlElement dsCompositor = FillDataSetElement(xd, ds);

            constraintSeparator =  xd.CreateElement(Keywords.XSD_PREFIX, "SHOULDNOTBEHERE", Keywords.XSDNS);
            dsElement.AppendChild(constraintSeparator);
            // DataSet properties
            AddXdoProperties(_ds, dsElement, xd );
            AddExtendedProperties(ds.extendedProperties, dsElement);


            for (int i = 0; i < top.Length; i++) {
                XmlElement el = HandleTable(top[i], xd, rootSchema);
                if ((_ds.Namespace == top[i].Namespace) || (top[i].Namespace == "") || (schFormat == SchemaFormat.Remoting)) {
                    bool fNestedInDataset = top[i].fNestedInDataset;
                    
                    if ((_ds.Namespace != "") && (top[i].Namespace == ""))
                        fNestedInDataset = true;

                    if ((top[i].nestedParentRelation!= null) && (top[i].nestedParentRelation.ParentTable == top[i]))
                        fNestedInDataset = false;  

                    if(fNestedInDataset) { //deal with maxOccurs properly
	                if (top[i].MinOccurs != 1) {
	                    el.SetAttribute(Keywords.MINOCCURS, top[i].MinOccurs.ToString());
	                  }
	                if (top[i].MaxOccurs == -1){
	                    el.SetAttribute(Keywords.MAXOCCURS, Keywords.ZERO_OR_MORE);
	                  }
	                else if (top[i].MaxOccurs != 1){
	                    el.SetAttribute(Keywords.MAXOCCURS, top[i].MaxOccurs.ToString());
	                  }
                    }

                    if (!fNestedInDataset) {
                            rootSchema.AppendChild(el);
                            XmlElement node = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ELEMENT, Keywords.XSDNS);
                            if ((_ds.Namespace == top[i].Namespace)  || (top[i].Namespace == "") || (schFormat == SchemaFormat.Remoting))
                                node.SetAttribute(Keywords.REF, top[i].EncodedTableName);
                            else
                                node.SetAttribute(Keywords.REF, ((string)prefixes[top[i].Namespace])+':'+top[i].EncodedTableName);
                    
                            dsCompositor.AppendChild(node);
                        }
                    else
                        dsCompositor.AppendChild(el);
                    }
                else {
                    AppendChildWithoutRef(rootSchema, top[i].Namespace, el, Keywords.XSD_ELEMENT);
                    XmlElement node = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ELEMENT, Keywords.XSDNS);
                    node.SetAttribute(Keywords.REF, ((string)prefixes[top[i].Namespace])+':'+top[i].EncodedTableName);
                    dsCompositor.AppendChild(node);
                }
            }


            dsElement.RemoveChild(constraintSeparator);
            rootSchema.AppendChild(dsElement);

            // Output all non-heirarchical relations without constraints
            DataRelationCollection rels = ds.Relations;

            XmlElement nodeAnn = null;
            XmlElement nodeApp = null;

            for (int i = 0; i < rels.Count; ++i) {
                DataRelation rel = rels[i];

                if (!rel.Nested || fFlat) {
                    if (rel.ChildKeyConstraint == null) {
                        if (nodeAnn == null) {
                            nodeAnn = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ANNOTATION, Keywords.XSDNS);
                            rootSchema.AppendChild(nodeAnn);

                            nodeApp = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_APPINFO, Keywords.XSDNS);
                            nodeAnn.AppendChild(nodeApp);
                        }
                        Debug.Assert(nodeApp != null, "Need to create <application..> node first.");
                        nodeApp.AppendChild(HandleRelation(rel, xd));
                    }
                }
            }        


            XmlComment comment = null;
            if(schFormat != SchemaFormat.Remoting)
                foreach(string ns in namespaces.Keys)
                {
                    if (ns == _ds.Namespace || ns=="")
                        continue;
                    XmlElement _import =  xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_IMPORT, Keywords.XSDNS);
                    _import.SetAttribute(Keywords.XSD_NAMESPACE, ns);
                    if (schFormat != SchemaFormat.WebService)
                        _import.SetAttribute(Keywords.XSD_SCHEMALOCATION, fileName + "_" + prefixes[ns]+".xsd");
                    ((XmlNode)rootSchema).PrependChild((XmlNode)_import);

                    if (!genSecondary) {
                        if (comment == null)
                            comment = _dc.CreateComment("ATTENTION: This schema contains references to other imported schemas");
                        continue;
                    }

                    XmlTextWriter xw = new XmlTextWriter( filePath+ fileName + "_" + prefixes[ns]+".xsd", null );
                    try {
                        xw.Formatting = Formatting.Indented;
                        xw.WriteStartDocument(true);
                        XmlElement tNode = (XmlElement) namespaces[ns] ;
                        _dc.AppendChild( tNode );
                        
                        foreach(string imp_ns in namespaces.Keys)
                        {
                            if (ns == imp_ns)
                                continue; // don't write out yourself
                            string prefix = (string) prefixes[imp_ns];
                            if (prefix == null) // only for dataset.Namespace == empty
                                continue; // do nothing
                            tNode.SetAttribute("xmlns:"+prefix, imp_ns);
                            XmlElement _import2 =  _dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_IMPORT, Keywords.XSDNS);
                            _import2.SetAttribute(Keywords.XSD_NAMESPACE, imp_ns);
                            if (imp_ns == _ds.Namespace)
                                _import2.SetAttribute(Keywords.XSD_SCHEMALOCATION, fileName + fileExt); // for the dataset namespace don't append anything
                            else
                                _import2.SetAttribute(Keywords.XSD_SCHEMALOCATION, fileName + "_" + prefix +".xsd");
                            ((XmlNode)tNode).PrependChild((XmlNode)_import2);
                        }
                        _dc.Save(xw);
                        _dc.RemoveChild( tNode );
                        xw.WriteEndDocument();
                    }
                    finally {
                        xw.Close();
                    }
                }
        
            if (comment != null)
                ((XmlNode)rootSchema).PrependChild((XmlNode)comment);

            return rootSchema;
        }

        internal XmlElement SchemaTree(XmlDocument xd, DataTable dt) {
            dsElement = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ELEMENT, Keywords.XSDNS);
            ConstraintNames = new ArrayList();
            _ds = dt.DataSet;
            _dc = xd;
            if (schFormat != SchemaFormat.Remoting) {
                namespaces = new Hashtable();
                prefixes = new Hashtable();
                autogenerated = new Hashtable();
            }

            XmlElement rootSchema = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SCHEMA, Keywords.XSDNS);
            _sRoot = rootSchema;
            WriteSchemaRoot(xd, rootSchema, dt.Namespace);

            XmlElement dsCompositor = FillDataSetElement(xd, _ds);

            constraintSeparator =  xd.CreateElement(Keywords.XSD_PREFIX, "SHOULDNOTBEHERE", Keywords.XSDNS);
            dsElement.AppendChild(constraintSeparator);


            if (schFormat != SchemaFormat.Remoting) {
                namespaces[_ds.Namespace] = rootSchema;
                prefixes[_ds.Namespace] = null;
            }

            // Generate all the constraint names            
            GenerateConstraintNames(dt);

            //
            // Output all top level elements, which will recursively invoke to other tables.
            //
            
            XmlElement el = HandleTable(dt, xd, rootSchema, false);
            rootSchema.AppendChild(el);

            dsElement.RemoveChild(constraintSeparator);
            rootSchema.AppendChild(dsElement);

            return rootSchema;
        }

        internal XmlElement FillDataSetElement(XmlDocument xd, DataSet ds) {
            dsElement.SetAttribute(Keywords.NAME, XmlConvert.EncodeLocalName(ds.DataSetName));
            dsElement.SetAttribute(Keywords.MSD_ISDATASET, Keywords.MSDNS, Keywords.TRUE);
            
            // Add CaseSensitive and locale properties
            if (ds.CaseSensitive)
                dsElement.SetAttribute(Keywords.MSD_CASESENSITIVE, Keywords.MSDNS, Keywords.TRUE);
            if (!ds.Locale.Equals(new CultureInfo(0x409)))
                dsElement.SetAttribute(Keywords.MSD_LOCALE, Keywords.MSDNS, _ds.Locale.ToString());

            XmlElement type = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_COMPLEXTYPE, Keywords.XSDNS);
            dsElement.AppendChild(type);
            XmlElement compositor = xd.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_CHOICE, Keywords.XSDNS);
            compositor.SetAttribute(Keywords.MAXOCCURS, Keywords.ZERO_OR_MORE);
            type.AppendChild(compositor);

            return compositor;
        }
        
        internal void SetPath(XmlWriter xw){
            XmlTextWriter textw = xw as XmlTextWriter;
            if (textw == null)
                return;
            
            FileStream fs = textw.BaseStream as FileStream;

            if (fs == null)
                return;

            this.filePath = Path.GetDirectoryName(fs.Name);
            this.fileName = Path.GetFileNameWithoutExtension(fs.Name);
            this.fileExt = Path.GetExtension(fs.Name);
            if (this.filePath != String.Empty)
                this.filePath  = filePath + "\\";
        }
        
        internal void Save(DataSet ds, XmlWriter xw) {
            XmlDocument doc = new XmlDocument();
            SetPath(xw);
            XmlElement rootSchema = SchemaTree(doc, ds);
            doc.AppendChild( rootSchema );
            doc.Save(xw);
        }
        
        internal void Save(DataTable dt, XmlWriter xw) {
            XmlDocument doc = new XmlDocument();
            XmlElement rootSchema = SchemaTree(doc, dt);
            doc.AppendChild( rootSchema );
            doc.Save(xw);
        }

       
        internal XmlElement HandleRelation(DataRelation rel, XmlDocument dc) {
            XmlElement root = dc.CreateElement(Keywords.MSD, Keywords.MSD_RELATION, Keywords.MSDNS);

            // convert relation name to valid xml name 
            root.SetAttribute( Keywords.NAME,  XmlConvert.EncodeLocalName( rel.RelationName ));

            string text = null;

            root.SetAttribute(Keywords.MSD_PARENT, Keywords.MSDNS, rel.ParentKey.Table.EncodedTableName);
            root.SetAttribute(Keywords.MSD_CHILD, Keywords.MSDNS, rel.ChildKey.Table.EncodedTableName);

            DataColumn[] key = rel.ParentKey.columns;
            text = key[0].EncodedColumnName;
            for (int i = 1; i < key.Length; i++) {
                text += Keywords.MSD_KEYFIELDSEP + key[i].EncodedColumnName;
            }
            root.SetAttribute( Keywords.MSD_PARENTKEY, Keywords.MSDNS, text );

            key = rel.ChildKey.columns;
            text = key[0].EncodedColumnName;
            for (int i = 1; i < key.Length; i++) {
                text += Keywords.MSD_KEYFIELDSEP + key[i].EncodedColumnName;
            }
            root.SetAttribute( Keywords.MSD_CHILDKEY, Keywords.MSDNS, text);
            AddExtendedProperties(rel.extendedProperties, root);
            return root;                
        }

        private static XmlElement FindSimpleType(XmlElement schema, string name) {
            for (XmlNode n = schema.FirstChild; n != null; n = n.NextSibling) {
                if (n is XmlElement) {
                    XmlElement e = (XmlElement) n;
                    if(e.GetAttribute(Keywords.NAME) == name) {
                        return e;
                    }
                }
            }
            return null;
        }// FindSimpleType

        internal XmlElement GetSchema(string NamespaceURI) {
            XmlElement schemaEl = (XmlElement) namespaces[NamespaceURI];
            if (schemaEl == null) {
                schemaEl = _dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SCHEMA, Keywords.XSDNS);
                WriteSchemaRoot(_dc, schemaEl, NamespaceURI);
                if (NamespaceURI != "") {
                    string prefix = Keywords.APP+Convert.ToString(++prefixCount);
                    _sRoot.SetAttribute("xmlns:"+prefix, NamespaceURI);
                    schemaEl.SetAttribute("xmlns:"+prefix, NamespaceURI);
                    prefixes[NamespaceURI] = prefix;
                } 
                namespaces[NamespaceURI] = schemaEl;
            }
            return schemaEl;
        }

        internal void HandleColumnType(DataColumn col, XmlDocument dc, XmlElement root, XmlElement schema) {
            string keyword = Keywords.TYPE;
            if (col.ColumnMapping == MappingType.SimpleContent)
                keyword = Keywords.BASE; 

            if (col.SimpleType != null) {
                // generate simpleType node

                XmlNode type = col.SimpleType.ToNode(dc);
                string name = col.SimpleType.Name;

                if (name != null && name.Length != 0) {
                    root.SetAttribute(keyword, name);
                    XmlElement elmSimpeType = FindSimpleType(schema, name);
                    if(elmSimpeType == null) {
                        // if we don't have the defenition for this simpleType yet. Add it
                        schema.AppendChild(type);
                    }else {
#if DEBUG
// enzol: TO DO: replace the constructor with IsEqual(XmlElement)
//                        Debug.Assert(col.SimpleType.IsEqual(new SimpleType(elmSimpeType)), "simpleTypes with the same name have to be the same: "+name);
#endif
                    }
                }
                else {
                    root.AppendChild(type);
                }
            }
            else if (col.XmlDataType != null && col.XmlDataType.Length != 0 && XSDSchema.IsXsdType(col.XmlDataType)) {
                root.SetAttribute(keyword, XSDSchema.QualifiedName(col.XmlDataType));
            }
            else {
                string typeName = XmlDataTypeName(col.DataType);
                if (typeName == null || typeName.Length == 0)
                    typeName = "string";
                root.SetAttribute(keyword, XSDSchema.QualifiedName(typeName));
            }

        }

        internal void AddColumnProperties(DataColumn col, XmlElement root){
            
            if (col.DataType != typeof(String)) {
                string dt = XmlDataTypeName(col.DataType);
                if (dt.Length == 0) {
                    root.SetAttribute(Keywords.MSD_DATATYPE, Keywords.MSDNS, col.DataType.AssemblyQualifiedName);
                }
            }

            if (col.ReadOnly)
                root.SetAttribute("ReadOnly", Keywords.MSDNS, Keywords.TRUE);

            if (col.Expression != "")
                root.SetAttribute("Expression", Keywords.MSDNS, col.Expression);

            if (col.AutoIncrement) {
                root.SetAttribute("AutoIncrement", Keywords.MSDNS, Keywords.TRUE);
            }

            if (col.AutoIncrementSeed !=0 )
                root.SetAttribute("AutoIncrementSeed", Keywords.MSDNS, col.AutoIncrementSeed.ToString());

            if (col.AutoIncrementStep !=1 )
                root.SetAttribute("AutoIncrementStep", Keywords.MSDNS, col.AutoIncrementStep.ToString());

	    if (col.Caption != col.ColumnName)
                root.SetAttribute("Caption", Keywords.MSDNS, col.Caption);

            if (col.Prefix != "")
                root.SetAttribute("Prefix", Keywords.MSDNS, col.Prefix);

        }

        internal XmlElement HandleColumn(DataColumn col, XmlDocument dc, XmlElement schema, bool fWriteOrdinal) {
            XmlElement  root;
            int         minOccurs;

            Debug.Assert(col.ColumnMapping != MappingType.SimpleContent , "Illegal state");

            String refString = (col.ColumnMapping != MappingType.Element) ? Keywords.XSD_ATTRIBUTE : Keywords.XSD_ELEMENT;
            root = dc.CreateElement(Keywords.XSD_PREFIX, refString, Keywords.XSDNS);

            // First add any attributes.  
            root.SetAttribute( Keywords.NAME, col.EncodedColumnName);
            
            if (col.Namespace =="") {
                DataTable _table = col.Table;
                string tgNamespace = _table.typeName.IsEmpty ? _table.Namespace : _table.typeName.Namespace;
                while (tgNamespace == "") {
                    if (_table.nestedParentRelation == null){
                        tgNamespace = _ds.Namespace;
                        break;
                    }
                    if (_table.nestedParentRelation.ParentTable == _table)
                        break;
                        
                    _table = _table.nestedParentRelation.ParentTable;
                    tgNamespace = _table.typeName.IsEmpty ? _table.Namespace : _table.typeName.Namespace;
                }
                if (col.Namespace != tgNamespace)
                    root.SetAttribute( Keywords.FORM, Keywords.UNQUALIFIED);

            }

            if (col.GetType() != typeof(DataColumn))
                AddXdoProperties(col, root, dc);
            else
                AddColumnProperties(col, root);

            AddExtendedProperties(col.extendedProperties, root);
			HandleColumnType(col, dc, root, schema);
            if (col.ColumnMapping == MappingType.Hidden) {
                if (!col.AllowDBNull)
                    root.SetAttribute(Keywords.MSD_ALLOWDBNULL, Keywords.MSDNS, Keywords.FALSE);
                if (col.DefaultValue!=null && (col.DefaultValue != DBNull.Value))
                    if (col.DataType == typeof(bool))
                        root.SetAttribute(Keywords.MSD_DEFAULTVALUE, Keywords.MSDNS, (bool)(col.DefaultValue)? Keywords.TRUE : Keywords.FALSE);
                    else
                        root.SetAttribute(Keywords.MSD_DEFAULTVALUE, Keywords.MSDNS, col.ConvertObjectToXml(col.DefaultValue));
            }

            if (col.DefaultValue!=null && (col.DefaultValue != DBNull.Value) && (col.ColumnMapping != MappingType.Hidden) ) {
                if (col.ColumnMapping == MappingType.Attribute && !col.AllowDBNull ) {
                    if (col.DataType == typeof(bool))
                        root.SetAttribute(Keywords.MSD_DEFAULTVALUE, Keywords.MSDNS, (bool)(col.DefaultValue)? Keywords.TRUE : Keywords.FALSE);
                    else
                        root.SetAttribute(Keywords.MSD_DEFAULTVALUE, Keywords.MSDNS, col.ConvertObjectToXml(col.DefaultValue));
                }
                else {
                    if (col.DataType == typeof(bool))
                        root.SetAttribute(Keywords.DEFAULT, (bool)(col.DefaultValue)? Keywords.TRUE : Keywords.FALSE);
                    else
                        root.SetAttribute(Keywords.DEFAULT, col.ConvertObjectToXml(col.DefaultValue));
                }
            }

            if (schFormat == SchemaFormat.Remoting)
                root.SetAttribute( Keywords.TARGETNAMESPACE, Keywords.MSDNS, col.Namespace);

            else {

	            if ((col.Namespace != (col.Table.typeName.IsEmpty ? col.Table.Namespace : col.Table.typeName.Namespace)) && (col.Namespace != ""))
			 {
	                    XmlElement schNode = GetSchema(col.Namespace);
	                    if (FindTypeNode(schNode, col.EncodedColumnName) == null)
	                        schNode.AppendChild(root);
	                    root = _dc.CreateElement(Keywords.XSD_PREFIX, refString, Keywords.XSDNS);
	                    root.SetAttribute( Keywords.REF, prefixes[ col.Namespace]+":"+ col.EncodedColumnName);
	                    if (col.Table.Namespace!=_ds.Namespace) {
	                        string prefix = (string)prefixes[col.Namespace];
	                        XmlElement tNode = GetSchema(col.Table.Namespace);
	                }
	            	}
            	}


            minOccurs = (col.AllowDBNull) ? 0 : 1;
            
            
            // March 2001 change
            if (col.ColumnMapping == MappingType.Attribute && minOccurs != 0) 
                root.SetAttribute(Keywords.USE, Keywords.REQUIRED);

               
			if (col.ColumnMapping == MappingType.Hidden) {
				root.SetAttribute(Keywords.USE, Keywords.PROHIBITED);
			}
			else 			
                if (col.ColumnMapping != MappingType.Attribute && minOccurs != 1)
                    root.SetAttribute(Keywords.MINOCCURS, minOccurs.ToString());
			
			if ((col.ColumnMapping == MappingType.Element) && fWriteOrdinal)
				root.SetAttribute(Keywords.MSD_ORDINAL,Keywords.MSDNS, col.Ordinal.ToString());
            
            return root;
        }

       
        internal static string TranslateAcceptRejectRule( AcceptRejectRule rule ) {
            switch (rule) {
                case AcceptRejectRule.Cascade:  return "Cascade";
                case AcceptRejectRule.None:     return "None";
                default:                        return null;
            }
        }

        internal static string TranslateRule( Rule rule ) {
            switch (rule) {
                case Rule.Cascade:  return "Cascade";
                case Rule.None:     return "None";
                case Rule.SetNull:  return "SetNull";
                case Rule.SetDefault: return "SetDefault";
                default: return null;
            }
        }

        internal void AppendChildWithoutRef(XmlElement node, string Namespace, XmlElement el, string refString) {
            XmlElement schNode = GetSchema(Namespace);
            if (FindTypeNode(schNode, el.GetAttribute(Keywords.NAME)) == null)
                schNode.AppendChild(el);
        }

        internal XmlElement FindTypeNode(XmlQualifiedName qnType) {
            XmlElement node = null;
            if ((!qnType.IsEmpty) && schFormat != SchemaFormat.Remoting) {
                    node = (XmlElement) namespaces[qnType.Namespace];
                }
            else 
                node = _sRoot;

            return FindTypeNode (node, qnType.Name);
        }

        internal XmlElement FindTypeNode(XmlElement node, string strType) {
            if (node == null)
                return null;
                
            for (XmlNode n = node.FirstChild; n != null; n = n.NextSibling) {
                if (!(n is XmlElement))
                    continue;

                XmlElement child = (XmlElement) n;

                if (XSDSchema.FEqualIdentity(child, Keywords.XSD_ELEMENT, Keywords.XSDNS) || 
                    XSDSchema.FEqualIdentity(child, Keywords.XSD_ATTRIBUTE, Keywords.XSDNS) || 
                    XSDSchema.FEqualIdentity(child, Keywords.XSD_COMPLEXTYPE, Keywords.XSDNS) || 
                    XSDSchema.FEqualIdentity(child, Keywords.XSD_SIMPLETYPE, Keywords.XSDNS)) {
                    if (child.GetAttribute(Keywords.NAME) == strType)
                        return child;
                }
            }
            return null;
        }

        internal XmlElement HandleTable(DataTable table, XmlDocument dc, XmlElement schema) {
            return HandleTable(table, dc, schema, true);
        }
        
        // we write out column Ordinals only if the table contains columns
        // that map both to Attributes and Elements
        
        private bool HasMixedColumns(DataTable table) {
            bool hasAttributes = false;
            bool hasElements = false;
            foreach(DataColumn col in table.Columns) {
                if (!hasElements && col.ColumnMapping == MappingType.Element)
                    hasElements = true;
                if (!hasAttributes && (col.ColumnMapping == MappingType.Attribute || col.ColumnMapping == MappingType.Hidden))
                    hasAttributes = !AutoGenerated(col);
                if (hasAttributes && hasElements)
                    return true;
            }
            return false;
        }

        private bool AutoGenerated(DataColumn col) {
            // for now we use just this simple logic for the columns.

            if (col.ColumnMapping != MappingType.Hidden)
                return false;

            if (col.DataType != typeof(int))
                return false;
                
            string generatedname = col.Table.TableName+"_Id";
            
            if ((col.ColumnName == generatedname) || (col.ColumnName == generatedname+"_0"))
                return true;

            generatedname = "";

            foreach (DataRelation rel in col.Table.ParentRelations) {
                if (!rel.Nested)
                    continue;
                if (rel.ChildColumns.Length != 1)
                    continue;

                if (rel.ChildColumns[0] != col)
                    continue;

                if (rel.ParentColumns.Length != 1)
                    continue;
                
                //ok if we are here it means that we have a 1column-1column relation
                generatedname = rel.ParentColumns[0].Table.TableName+"_Id";
            }

            if ((col.ColumnName == generatedname) || (col.ColumnName == generatedname+"_0"))
                return true;

            return false;
        }
        private bool AutoGenerated(DataRelation rel) {
            string rName = rel.ParentTable.TableName + "_" + rel.ChildTable.TableName;
            if (!rel.RelationName.StartsWith(rName))
                return false;
            if (rel.ExtendedProperties.Count > 0)
                return false;
            return true;
        } 
        private bool AutoGenerated(UniqueConstraint unique) {
            // for now we use just this simple logic for the columns.
            if (!unique.ConstraintName.StartsWith("Constraint"))
                return false;
            if (unique.Key.Columns.Length !=1)
                return false;
            if (unique.ExtendedProperties.Count > 0)
                return false;
            return AutoGenerated(unique.Key.Columns[0]);
        }

        private bool AutoGenerated(ForeignKeyConstraint fk) {
            // for now we use just this simple logic for the columns.
            DataRelation rel = fk.FindParentRelation();
            if (rel == null)
                return false; // otherwise roundtrip will create column

            if (!AutoGenerated(rel))
                return false;

            if (rel.RelationName != fk.ConstraintName)
                return false;

            if (fk.ExtendedProperties.Count > 0)
                return false;

            if (fk.AcceptRejectRule != AcceptRejectRule.None)
                return false;
            if (fk.DeleteRule != Rule.Cascade)
                return false;
            if (fk.DeleteRule != Rule.Cascade)
                return false;

            
            if (fk.RelatedColumns.Length !=1)
                return false;
            return AutoGenerated(fk.RelatedColumns[0]);
        }

        private bool IsAutoGenerated(object o) {
            if (schFormat != SchemaFormat.Remoting)
                return autogenerated[o]!=null;
            return false;
        }

        internal XmlElement HandleTable(DataTable table, XmlDocument dc, XmlElement schema, bool genNested) {

            XmlElement root = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ELEMENT, Keywords.XSDNS);
            bool fWriteOrdinals = false;
            bool fUnqualified = false;

            if ((table.Namespace != _ds.Namespace) && (schFormat == SchemaFormat.Remoting))
                root.SetAttribute( Keywords.TARGETNAMESPACE, Keywords.MSDNS, table.Namespace);
            
            // First add any attributes.  
            root.SetAttribute( Keywords.NAME, table.EncodedTableName );

            if (table.Namespace =="") {
                DataTable _table = table;
                string tgNamespace = _table.Namespace;
                while (tgNamespace == "") {
                    if (_table.nestedParentRelation == null){
                        tgNamespace = _ds.Namespace;
                        break;
                    }
                    if (_table.nestedParentRelation.ParentTable == _table)
                        break;
                        
                    _table = _table.nestedParentRelation.ParentTable;
                    tgNamespace = _table.Namespace;
                }
                if (table.Namespace != tgNamespace) {
                    root.SetAttribute( Keywords.FORM, Keywords.UNQUALIFIED);
                    fUnqualified = true;
                }

            }


            if (!table.caseSensitiveAmbient)
                root.SetAttribute(Keywords.MSD_CASESENSITIVE, Keywords.MSDNS, table.CaseSensitive.ToString());
            if (table.culture!=null)
                root.SetAttribute(Keywords.MSD_LOCALE, Keywords.MSDNS, table.Locale.ToString());

            AddXdoProperties(table, root, dc);

            DataColumnCollection columns = table.Columns;

            int cCount = columns.Count;
            int realCount = 0;

            if (cCount ==1 || cCount ==2)
                for (int i = 0; i < cCount; i++) {
                    DataColumn col = columns[i];

                    if (col.ColumnMapping == MappingType.Hidden) {
                        DataRelationCollection childRelations = table.ChildRelations;
                        for (int j = 0; j < childRelations.Count; j++) {
                            if (childRelations[j].Nested && childRelations[j].ParentKey.columns.Length == 1 && childRelations[j].ParentKey.columns[0] == col)
                                    realCount++;
                        }
                    }
                    
                    if (col.ColumnMapping == MappingType.Element)
                        realCount++;
                }
                         
               
            if ((table.repeatableElement) && (realCount ==1)) {
                // I only have 1 column and that gives me
                // the type for this element
                DataColumn col = table.Columns[0];
                string _typeName = XmlDataTypeName(col.DataType);
                if (_typeName == null || _typeName.Length == 0)
                    _typeName = "string";

                root.SetAttribute(Keywords.TYPE, XSDSchema.QualifiedName(_typeName));
                return root;
            }
         
            // Now add the type information nested inside the element or global.
            XmlElement type = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_COMPLEXTYPE, Keywords.XSDNS);

            if (!table.typeName.IsEmpty && schFormat != SchemaFormat.Remoting) {
                XmlElement typeSchema = GetSchema(table.typeName.Namespace);
                if (table.typeName.Namespace == "")
                    typeSchema = fUnqualified ? GetSchema(_ds.Namespace) : GetSchema(table.Namespace);
                if (FindTypeNode(typeSchema, table.typeName.Name) == null) 
                    typeSchema.AppendChild(type);

                type.SetAttribute(Keywords.NAME, table.typeName.Name);
            }
            else {
                root.AppendChild(type);
            }

            if (!table.typeName.IsEmpty) {
                if (schFormat != SchemaFormat.Remoting)
                    root.SetAttribute( Keywords.TYPE, NewDiffgramGen.QualifiedName((string)prefixes[table.typeName.Namespace], table.typeName.Name) );
                else
                    root.SetAttribute( Keywords.TYPE,  table.typeName.Name );
            }

            XmlElement compositor = null;

            DataColumn colTxt = table.XmlText;

            if (colTxt != null) {
                XmlElement sc = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SIMPLECONTENT , Keywords.XSDNS);

                if (colTxt.GetType() != typeof(DataColumn))
                    AddXdoProperties(colTxt, sc, dc);
                else
                    AddColumnProperties(colTxt, sc);
                AddExtendedProperties(colTxt.extendedProperties, sc);

                 if (colTxt.AllowDBNull)
                     root.SetAttribute(Keywords.XSD_NILLABLE, String.Empty, Keywords.TRUE);
                if (colTxt.DefaultValue!=null && (colTxt.DefaultValue != DBNull.Value))
                    sc.SetAttribute(Keywords.MSD_DEFAULTVALUE, Keywords.MSDNS, colTxt.ConvertObjectToXml(colTxt.DefaultValue));
                    
                sc.SetAttribute(Keywords.MSD_COLUMNNAME, Keywords.MSDNS, colTxt.ColumnName);
				sc.SetAttribute(Keywords.MSD_ORDINAL, Keywords.MSDNS, colTxt.Ordinal.ToString());

                type.AppendChild (sc);
                XmlElement ext = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_EXTENSION, Keywords.XSDNS);
                sc.AppendChild(ext);
                HandleColumnType(colTxt, dc, ext, schema);
                type = ext;
            }

            compositor = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SEQUENCE, Keywords.XSDNS);
            type.AppendChild(compositor);

            fWriteOrdinals = HasMixedColumns(table);
 
            for (int i = 0; i < cCount; i++) {
                DataColumn col = columns[i];

                if (col.ColumnMapping == MappingType.SimpleContent)
                    continue;

                if (col.ColumnMapping == MappingType.Attribute || col.ColumnMapping == MappingType.Element || col.ColumnMapping == MappingType.Hidden ) {
                    if (IsAutoGenerated(col)) // skip automanifactured columns
                        continue; 
                    bool isAttribute = col.ColumnMapping != MappingType.Element;
                    XmlElement el = HandleColumn(col, dc, schema, fWriteOrdinals);

                    XmlElement node = isAttribute ? type : compositor;
                    //bool flag = isAttribute ? col.Namespace == "" : col.Namespace == table.Namespace;
                    node.AppendChild(el);
                }


            }
            
            if ((table.XmlText == null) && (genNested)) {

                DataRelationCollection childRelations = table.ChildRelations;

                for (int j = 0; j < childRelations.Count; j++) {
                    XmlElement NestedTable; 
            
                    if (!childRelations[j].Nested)
                        continue;

                    DataTable childTable = childRelations[j].ChildTable;

                    if (childTable == table) { // o-ho self join
                        NestedTable = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ELEMENT, Keywords.XSDNS);
            
                        NestedTable.SetAttribute( Keywords.REF, table.EncodedTableName );
                    } 
                    else
                        NestedTable = HandleTable(childTable, dc, schema);

                    if (childTable.Namespace == table.Namespace) {
				        NestedTable.SetAttribute(Keywords.MINOCCURS , "0");
				        NestedTable.SetAttribute(Keywords.MAXOCCURS , Keywords.ZERO_OR_MORE);
                    }

                    if ((childTable.Namespace == table.Namespace) || (childTable.Namespace == "") || schFormat == SchemaFormat.Remoting) {
                        compositor.AppendChild(NestedTable);
                    }
                    else {
                        GetSchema(childTable.Namespace).AppendChild(NestedTable);
                        NestedTable = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ELEMENT, Keywords.XSDNS);
                        NestedTable.SetAttribute( Keywords.REF, ((string)prefixes[childTable.Namespace])+':'+childTable.EncodedTableName);
                        compositor.AppendChild(NestedTable);
                    }

                    if (childRelations[j].ChildKeyConstraint != null)
                        continue; // we write the relation using the constraint

                    XmlElement nodeAnn = _dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_ANNOTATION, Keywords.XSDNS);
                    NestedTable.PrependChild(nodeAnn);

                    XmlElement nodeApp = _dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_APPINFO, Keywords.XSDNS);
                    nodeAnn.AppendChild(nodeApp);

                    nodeApp.AppendChild(HandleRelation(childRelations[j], dc));

                }
        
            }

            if (compositor != null)
                if (!compositor.HasChildNodes)
                    type.RemoveChild(compositor);

            // Output all constraints.


            ConstraintCollection constraints = table.Constraints;
            XmlElement selector, field;
            String xpathprefix = _ds.Namespace != String.Empty ? Keywords.MSTNS_PREFIX : String.Empty;
            if (schFormat != SchemaFormat.Remoting) {
                GetSchema(table.Namespace); // to ensure prefix handling
                xpathprefix = table.Namespace != String.Empty ? (string) prefixes[table.Namespace] +':' : String.Empty;
            }

            for (int i = 0; i < constraints.Count; i++) {
                XmlElement constraint = null;
                DataColumn[] fields;

                if (constraints[i] is UniqueConstraint) {

                    UniqueConstraint unique = (UniqueConstraint)constraints[i];

                    if (IsAutoGenerated(unique))
                        continue;

                    // special case of the ghosted constraints:
                    fields = unique.Key.Columns;
                
                    
                    constraint = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_UNIQUE, Keywords.XSDNS);

                    // convert constraint name to valid xml name
                    constraint.SetAttribute( Keywords.NAME, XmlConvert.EncodeLocalName( unique.SchemaName ));

                    if (unique.ConstraintName != unique.SchemaName)
                        constraint.SetAttribute(Keywords.MSD_CONSTRAINTNAME, Keywords.MSDNS, unique.ConstraintName);

                    AddExtendedProperties(unique.extendedProperties, constraint);


                    selector = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SELECTOR, Keywords.XSDNS);
                    selector.SetAttribute(Keywords.XSD_XPATH, ".//"+xpathprefix+table.EncodedTableName);

                    constraint.AppendChild(selector);
                    

                    if (unique.IsPrimaryKey)
                        constraint.SetAttribute(Keywords.MSD_PRIMARYKEY, Keywords.MSDNS, Keywords.TRUE);

                    for (int k = 0; k < fields.Length; k++) {
                        String EncodedName = xpathprefix+fields[k].EncodedColumnName ;
                        if (schFormat != SchemaFormat.Remoting) {
                            GetSchema(fields[k].Namespace);
                            String xpathcolprefix = fields[k].Namespace != String.Empty ? (string) prefixes[fields[k].Namespace]+':' : String.Empty;
                            EncodedName = xpathcolprefix+fields[k].EncodedColumnName ;
                        }
                        if ((fields[k].ColumnMapping == MappingType.Attribute) || (fields[k].ColumnMapping == MappingType.Hidden))
                            EncodedName = '@' +EncodedName;
                        field = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_FIELD, Keywords.XSDNS);
                        field.SetAttribute(Keywords.XSD_XPATH, EncodedName);

                        constraint.AppendChild(field);
                    }

                    dsElement.InsertBefore(constraint, constraintSeparator);
                }
                else if (constraints[i] is ForeignKeyConstraint && genNested) {
                    ForeignKeyConstraint foreign = (ForeignKeyConstraint)constraints[i];

                    if (IsAutoGenerated(foreign))
                        continue;
                        

                    DataRelation rel = foreign.FindParentRelation();

                    // special case of the ghosted constraints:
                    fields = foreign.RelatedColumns;


                    UniqueConstraint _constraint = (UniqueConstraint) foreign.RelatedTable.Constraints.FindConstraint( new UniqueConstraint( "TEMP", fields));

                    if (_constraint == null) {
                        constraint = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_KEY, Keywords.XSDNS);
                        constraint.SetAttribute( Keywords.NAME, XmlConvert.EncodeLocalName( foreign.SchemaName ));

                        selector = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SELECTOR, Keywords.XSDNS);
                        selector.SetAttribute(Keywords.XSD_XPATH, ".//"+xpathprefix+ foreign.RelatedTable.EncodedTableName);

                        constraint.AppendChild(selector);

                        for (int k = 0; k < fields.Length; k++) {
                            String EncodedName = xpathprefix+fields[k].EncodedColumnName ;
                            if (schFormat != SchemaFormat.Remoting) {
                                GetSchema(fields[k].Namespace);
                                String xpathcolprefix = fields[k].Namespace != String.Empty ? (string) prefixes[fields[k].Namespace]+':' : String.Empty;
                                EncodedName = xpathcolprefix+fields[k].EncodedColumnName ;
                            }
                            if ((fields[k].ColumnMapping == MappingType.Attribute) || (fields[k].ColumnMapping == MappingType.Hidden))
                                EncodedName = '@' +EncodedName;
                            field = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_FIELD, Keywords.XSDNS);
                            field.SetAttribute(Keywords.XSD_XPATH, EncodedName);

                            constraint.AppendChild(field);
                        }

                        dsElement.InsertBefore(constraint, constraintSeparator);
                    }
 
                    constraint = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_KEYREF, Keywords.XSDNS);
                    // convert constraint name to valid xml name
                    constraint.SetAttribute( Keywords.NAME,XmlConvert.EncodeLocalName(  foreign.SchemaName ));

                    if (_constraint == null) 
                        constraint.SetAttribute( Keywords.REFER, XmlConvert.EncodeLocalName( foreign.SchemaName ));
                    else
                        constraint.SetAttribute( Keywords.REFER, XmlConvert.EncodeLocalName( _constraint.SchemaName ));

                    AddExtendedProperties(foreign.extendedProperties, constraint, typeof(ForeignKeyConstraint));

                    if (foreign.ConstraintName != foreign.SchemaName)
                        constraint.SetAttribute(Keywords.MSD_CONSTRAINTNAME, Keywords.MSDNS, foreign.ConstraintName);

                    if (null == rel) {
                        constraint.SetAttribute(Keywords.MSD_CONSTRAINTONLY , Keywords.MSDNS, Keywords.TRUE );
                    }else {
                        if (rel.Nested)
                            constraint.SetAttribute(Keywords.MSD_ISNESTED, Keywords.MSDNS, Keywords.TRUE);

                        AddExtendedProperties(rel.extendedProperties, constraint, typeof(DataRelation));
                        if (foreign.ConstraintName != rel.RelationName) {
                            constraint.SetAttribute( Keywords.MSD_RELATIONNAME , Keywords.MSDNS, XmlConvert.EncodeLocalName( rel.RelationName ));
                        }
                    }

                    selector = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_SELECTOR, Keywords.XSDNS);
                    selector.SetAttribute(Keywords.XSD_XPATH, ".//"+xpathprefix+table.EncodedTableName);
 
                    constraint.AppendChild(selector);

                    if (foreign.AcceptRejectRule != ForeignKeyConstraint.AcceptRejectRule_Default)
                        constraint.SetAttribute(Keywords.MSD_ACCEPTREJECTRULE, Keywords.MSDNS, 
                                                TranslateAcceptRejectRule(foreign.AcceptRejectRule) );

                    if (foreign.UpdateRule != ForeignKeyConstraint.Rule_Default)
                        constraint.SetAttribute( Keywords.MSD_UPDATERULE, Keywords.MSDNS, TranslateRule(foreign.UpdateRule) );

                    if (foreign.DeleteRule != ForeignKeyConstraint.Rule_Default)
                        constraint.SetAttribute( Keywords.MSD_DELETERULE, Keywords.MSDNS, TranslateRule(foreign.DeleteRule) );

                    fields = foreign.Columns;

                    for (int k = 0; k < fields.Length; k++) {
                        String EncodedName =xpathprefix+ fields[k].EncodedColumnName;
                        if (schFormat != SchemaFormat.Remoting) {
                            GetSchema(fields[k].Namespace);
                            String xpathcolprefix = fields[k].Namespace != String.Empty ? (string) prefixes[fields[k].Namespace]+':' : String.Empty;
                            EncodedName =xpathcolprefix+ fields[k].EncodedColumnName;
                        }
                        if ((fields[k].ColumnMapping == MappingType.Attribute) || (fields[k].ColumnMapping == MappingType.Hidden))
                            EncodedName = '@' +EncodedName;
                        field = dc.CreateElement(Keywords.XSD_PREFIX, Keywords.XSD_FIELD, Keywords.XSDNS);
                        field.SetAttribute(Keywords.XSD_XPATH, EncodedName);

                        constraint.AppendChild(field);
                    }

                    dsElement.InsertAfter(constraint, constraintSeparator);
                }
            }

            AddExtendedProperties(table.extendedProperties, root);
            return root;
        }
    } 


  
 internal sealed class NewDiffgramGen {
        internal XmlDocument    _doc;
        internal DataSet        _ds;
        internal XmlWriter      _xmlw;
        private bool fBefore = false;
        private bool fErrors = false;
        internal Hashtable rowsOrder = null;
         

        internal NewDiffgramGen(DataSet ds) {
            _ds = ds;
            _doc = new XmlDocument();
            int rows = 0;
            for (int i = 0; i < ds.Tables.Count; i++) {
                rows += ds.Tables[i].Rows.Count ;
            }
            rowsOrder = new Hashtable(rows);
            for (int i = 0; i < ds.Tables.Count; i++) {
                DataTable dt = ds.Tables[i];
                DataRowCollection rc = dt.Rows;
                rows = rc.Count ;
                for (int j=0; j<rows; j++)
                  rowsOrder[rc[j]] = j;
            }
            
        }

        private bool EmptyDataSet(DataSet ds) {
            for (int i = 0; i < ds.Tables.Count; i++) {
                if (ds.Tables[i].Rows.Count > 0)
                    return false;
            }
            return true;
        }


        internal void Save(XmlWriter xmlw) {
			Save (xmlw, null);
		}

        internal void Save(XmlWriter xmlw, DataTable table) {
            _xmlw = xmlw;

            _xmlw.WriteStartElement(Keywords.DFF, Keywords.DIFFGRAM,  Keywords.DFFNS);
            _xmlw.WriteAttributeString(Keywords.XMLNS, Keywords.MSD, null, Keywords.MSDNS);
//            _xmlw.WriteAttributeString(Keywords.XMLNS, Keywords.UPDG, null, Keywords.UPDGNS);

            if (!EmptyDataSet(_ds))
            {   
                // write the datapart
                new XmlDataTreeWriter(_ds, table).SaveDiffgramData(_xmlw, rowsOrder);

                // Walk the xd using relational apis and create nodes in nodeRoot appropriately.                   

                if (table==null)
					for (int i = 0; i < _ds.Tables.Count; ++i) {
						GenerateTable(_ds.Tables[i]);
					}
				else
					GenerateTable(table);

                if (fBefore)
                    _xmlw.WriteEndElement();  //SQL_BEFORE
                
                if (table==null)
					for (int i = 0; i < _ds.Tables.Count; ++i) {
						GenerateTableErrors(_ds.Tables[i]);
					}
				else
					GenerateTableErrors(table);

                if (fErrors)
                    _xmlw.WriteEndElement();  //ERRORS
            }

            _xmlw.WriteEndElement();
            _xmlw.Flush();
        }

        private void GenerateTable(DataTable table) {
            int rowCount = table.Rows.Count;

            if (rowCount <= 0)
                return;

            for (int rowNum = 0; rowNum < rowCount; ++rowNum)
                GenerateRow(table.Rows[rowNum]);
        }


        private void GenerateTableErrors(DataTable table) {
            int rowCount = table.Rows.Count;
            int colCount = table.Columns.Count;

            if (rowCount <= 0)
                return;

            for (int rowNum = 0; rowNum < rowCount; ++rowNum) {
				bool tableName = false;
				
				DataRow row = table.Rows[rowNum];
                string rowIDString = table.TableName+row.rowID.ToString();
				string prefix = (table.Namespace != "") ? table.Prefix : String.Empty;
				if ((row.HasErrors) && (row.RowError.Length > 0)) {
					if (!fErrors) {
                        _xmlw.WriteStartElement( Keywords.DFF, Keywords.MSD_ERRORS, Keywords.DFFNS );
                        fErrors = true;
                    }
                    _xmlw.WriteStartElement( prefix, row.Table.EncodedTableName, row.Table.Namespace);
				    _xmlw.WriteAttributeString( Keywords.DFF, Keywords.DIFFID, Keywords.DFFNS, row.Table.TableName+row.rowID.ToString());
                    _xmlw.WriteAttributeString( Keywords.DFF, Keywords.MSD_ERROR, Keywords.DFFNS, row.RowError);
					tableName = true;
				}
				if (colCount <=0)
					continue;
	            for (int colNum = 0; colNum < colCount; ++colNum) {
					DataColumn column = table.Columns[colNum];
					string error = row.GetColumnError(column);
					string columnPrefix = (column.Namespace != "") ? column.Prefix : String.Empty;
					if (error == null || error.Length == 0) {
						continue;
					}

                    if (!tableName) {
						if (!fErrors) {
                            _xmlw.WriteStartElement( Keywords.DFF, Keywords.MSD_ERRORS, Keywords.DFFNS );
                            fErrors = true;
                        }
                            
                        _xmlw.WriteStartElement( prefix, row.Table.EncodedTableName, row.Table.Namespace);
				        _xmlw.WriteAttributeString( Keywords.DFF, Keywords.DIFFID, Keywords.DFFNS, row.Table.TableName+row.rowID.ToString());
						tableName = true;
                        
					}


					_xmlw.WriteStartElement( columnPrefix, column.EncodedColumnName, column.Namespace);
					_xmlw.WriteAttributeString( Keywords.DFF, Keywords.MSD_ERROR, Keywords.DFFNS, error);

					_xmlw.WriteEndElement();
					

				}

				if(tableName)
					_xmlw.WriteEndElement();
			}
        }

        private void GenerateRow(DataRow row) {
            DataRowState state = row.RowState;
            if ((state == DataRowState.Unchanged ) || (state  == DataRowState.Added)) {
                return;
            }
            if (!fBefore) {
                _xmlw.WriteStartElement( Keywords.DFF, Keywords.SQL_BEFORE, Keywords.DFFNS);
                fBefore = true;
            }

            DataTable table = row.Table;
            int colCount = table.Columns.Count;
            string rowIDString = table.TableName+row.rowID.ToString();
            string parentId = null;
            if ( (state == DataRowState.Deleted )  && (row.Table.nestedParentRelation != null)){
                DataRow parentRow = row.GetParentRow(row.Table.nestedParentRelation, DataRowVersion.Original);
                if (parentRow != null)
                    parentId = parentRow.Table.TableName+parentRow.rowID.ToString();
            }
                

            string tablePrefix = (table.Namespace != "") ? table.Prefix : String.Empty;

            // read value if the TextOnly column (if any)
            object val = (table.XmlText == null ? DBNull.Value : row[table.XmlText, DataRowVersion.Original]);

                    //old row
            _xmlw.WriteStartElement( tablePrefix, row.Table.EncodedTableName, row.Table.Namespace);
            
			_xmlw.WriteAttributeString( Keywords.DFF, Keywords.DIFFID, Keywords.DFFNS, rowIDString);

            if ( (state == DataRowState.Deleted ) && XmlDataTreeWriter.RowHasErrors(row))
				_xmlw.WriteAttributeString( Keywords.DFF, Keywords.HASERRORS, Keywords.DFFNS, Keywords.TRUE);
            
            if (parentId != null)
			    _xmlw.WriteAttributeString( Keywords.DFF, Keywords.DIFFPID, Keywords.DFFNS, parentId);
                        
			_xmlw.WriteAttributeString( Keywords.MSD, Keywords.ROWORDER, Keywords.MSDNS, rowsOrder[row].ToString());
            for (int colNum = 0; colNum < colCount; ++colNum) {
                if ((row.Table.Columns[colNum].ColumnMapping == MappingType.Attribute) ||
                    (row.Table.Columns[colNum].ColumnMapping == MappingType.Hidden))
                GenerateColumn(row,  row.Table.Columns[colNum], DataRowVersion.Original);
            }
            for (int colNum = 0; colNum < colCount; ++colNum) {
                if ((row.Table.Columns[colNum].ColumnMapping == MappingType.Element) ||
                    (row.Table.Columns[colNum].ColumnMapping == MappingType.SimpleContent))
                GenerateColumn(row,  row.Table.Columns[colNum], DataRowVersion.Original);
            }
            _xmlw.WriteEndElement();  //old row
        } 

        private void GenerateColumn(DataRow row, DataColumn col, DataRowVersion version) {
            string value = null;

            value = col.GetColumnValueAsString(row, version);
            if (value == null) {
                if (col.ColumnMapping == MappingType.SimpleContent)
                    _xmlw.WriteAttributeString(Keywords.XSI, Keywords.XSI_NIL, Keywords.XSINS, Keywords.TRUE);
                return;
            }
             
            string colPrefix = (col.Namespace != "") ? col.Prefix : String.Empty;
            switch (col.ColumnMapping) {

                case MappingType.Attribute:
                    _xmlw.WriteAttributeString(colPrefix, col.EncodedColumnName, col.Namespace, value);
                    break;

                case MappingType.Hidden:
                    _xmlw.WriteAttributeString(Keywords.MSD, "hidden"+col.EncodedColumnName, Keywords.MSDNS, value);
                    break;

                case MappingType.SimpleContent:
                    _xmlw.WriteString(value);
                    break;

                case MappingType.Element:
                    _xmlw.WriteStartElement( colPrefix, col.EncodedColumnName, col.Namespace);
                    _xmlw.WriteString(value);
                    _xmlw.WriteEndElement();
                    break;
            }
        }

        internal static string QualifiedName(string prefix, string name) {
            if (prefix != null)
                return prefix + ":" + name;

            return name;
        }
    }

    // DataTreeWriter
    internal sealed class XmlDataTreeWriter {
        XmlWriter _xmlw;
        DataSet _ds;
		    DataTable _dt=null;
        bool    isDiffgram = false;
        Hashtable rowsOrder = null;

        internal XmlDataTreeWriter(DataSet ds) {
          _ds = ds;
        }

        internal XmlDataTreeWriter(DataSet ds, DataTable dt) {
          _ds = ds;
			    _dt = dt;
        }
		
        internal static bool RowHasErrors(DataRow row) {
          int colCount = row.Table.Columns.Count;

			    if ((row.HasErrors) && (row.RowError.Length > 0)) 
            return true;

	        for (int colNum = 0; colNum < colCount; ++colNum) {
				      DataColumn column = row.Table.Columns[colNum];
				      string error = row.GetColumnError(column);
				      if (error == null || error.Length == 0) {
					      continue;
				      }
              return true;
            }
            
          return false;
        }

        // the following line writes the data part
        // for the new diffgram format 

        internal void SaveDiffgramData(XmlWriter xw, Hashtable rowsOrder) {
            _xmlw = xw; 
            isDiffgram = true;
            this.rowsOrder = rowsOrder;
           
            int countTopTable = _ds.TopLevelTables().Length;

            string prefix = ( _ds.Namespace == "" )? "" : _ds.Prefix;
            
			if (_ds.DataSetName == null || _ds.DataSetName.Length == 0)
				_xmlw.WriteStartElement(prefix, Keywords.DOCUMENTELEMENT, _ds.Namespace);
			else
				_xmlw.WriteStartElement(prefix, XmlConvert.EncodeLocalName(_ds.DataSetName), _ds.Namespace);

            // new XmlTreeGen(true).Save(_ds,_xmlw, false /* we don't care since we specified it's serialized */);


            if (_dt != null) {
                foreach (DataRow row in _dt.Rows) {
                    if (row.RowState == DataRowState.Deleted)
                        continue;
					if (row.GetNestedParent() == null)
					{
                        XmlDataRowWriter(row,_dt.EncodedTableName);
					}
                }

			}
			else 
				foreach (DataTable table in _ds.Tables) {

					foreach (DataRow row in table.Rows) {
						if (row.RowState == DataRowState.Deleted)
							continue;
						if (row.GetNestedParent() == null)
						{
							XmlDataRowWriter(row,table.EncodedTableName);
						}
					}
				}

			_xmlw.WriteEndElement();
            _xmlw.Flush();            

        }
   
        
        internal void Save(XmlWriter xw, bool writeSchema) {
            _xmlw = xw;
            int countTopTable = _ds.TopLevelTables().Length;
            bool fWriteDSElement = true;
            string prefix = ( _ds.Namespace == "" )? "" : _ds.Prefix;
            
            if (!writeSchema && _ds.fTopLevelTable && countTopTable == 1) {
                if (_ds.TopLevelTables()[0].Rows.Count == 1)
                    fWriteDSElement = false;
            }
            
            if (fWriteDSElement) {
                if (_ds.DataSetName == null || _ds.DataSetName.Length == 0)
                    _xmlw.WriteStartElement(prefix, Keywords.DOCUMENTELEMENT, _ds.Namespace);
                else
                    _xmlw.WriteStartElement(prefix, XmlConvert.EncodeLocalName(_ds.DataSetName), _ds.Namespace);
    
      			foreach (DataTable table in _ds.Tables) {
                    if (table.xmlText != null) {
                        _xmlw.WriteAttributeString(Keywords.XMLNS, Keywords.XSI, Keywords.XSD_XMLNS_NS, Keywords.XSINS);
                        break;
                    }
                }

                if (writeSchema) {
                    new XmlTreeGen(SchemaFormat.Public).Save(_ds,_xmlw);
                }
            }

			foreach (DataTable table in _ds.Tables) {

				foreach (DataRow row in table.Rows) {
					if (row.RowState == DataRowState.Deleted)
						continue;
					if (row.GetNestedParent() == null)
					{
						XmlDataRowWriter(row,table.EncodedTableName);
					}
				}
			}

            if (fWriteDSElement)
                _xmlw.WriteEndElement();
            _xmlw.Flush();            
        }
        
        private ArrayList GetNestedChildRelations(DataRow row) {
            ArrayList list = new ArrayList();

            foreach( DataRelation r in row.Table.ChildRelations ) {
                if (r.Nested)
                    list.Add(r);
            }

            return list;
        }


        internal void  XmlDataRowWriter(DataRow row, String encodedTableName) {

            object value;
            string prefix = (row.Table.Namespace == "") ? "" : row.Table.Prefix;

            _xmlw.WriteStartElement(prefix, encodedTableName, row.Table.Namespace);

            if (isDiffgram)  {
				_xmlw.WriteAttributeString( Keywords.DFF, Keywords.DIFFID, Keywords.DFFNS, row.Table.TableName+row.rowID.ToString());

                _xmlw.WriteAttributeString( Keywords.MSD, Keywords.ROWORDER, Keywords.MSDNS, rowsOrder[row].ToString());
				
				if (row.RowState == DataRowState.Added)
					_xmlw.WriteAttributeString( Keywords.DFF, Keywords.HASCHANGES, Keywords.DFFNS, Keywords.INSERTED);
				if (row.RowState == DataRowState.Modified)
					_xmlw.WriteAttributeString( Keywords.DFF, Keywords.HASCHANGES, Keywords.DFFNS, Keywords.MODIFIED);

				if (RowHasErrors(row))
					_xmlw.WriteAttributeString( Keywords.DFF, Keywords.HASERRORS, Keywords.DFFNS, Keywords.TRUE);

            }


                

            //write the attribute columns first, if any
            foreach( DataColumn col in row.Table.Columns ) 
            {
                if (col.columnMapping == MappingType.Attribute)
                {
                    value = row[col];
                    string colPrefix = (col.Namespace == "") ? "" : col.Prefix;

                    if (value != DBNull.Value){
                        _xmlw.WriteAttributeString(colPrefix, col.EncodedColumnName, col.Namespace, col.ConvertObjectToXml(value));
                    }
                }
                
                if (!isDiffgram)
                    continue;

                if (col.columnMapping == MappingType.Hidden)
                {
                    value = row[col];

                    if (value != DBNull.Value){
                        _xmlw.WriteAttributeString(Keywords.MSD, "hidden"+col.EncodedColumnName, Keywords.MSDNS, col.ConvertObjectToXml(value));
                    }
                }
            } //end foreach
                 
            foreach( DataColumn col in row.Table.Columns  ) 
            {
                if (col.columnMapping != MappingType.Hidden)
                {
                    value = row[col];
                    string colPrefix = (col.Namespace == "") ? "" : col.Prefix;

                    if ((value == DBNull.Value) && (col.ColumnMapping == MappingType.SimpleContent))
                        _xmlw.WriteAttributeString(Keywords.XSI, Keywords.XSI_NIL, Keywords.XSINS, Keywords.TRUE);
                    
                    if ((value != DBNull.Value) && (col.columnMapping != MappingType.Attribute)) {
                        if (col.columnMapping != MappingType.SimpleContent)
                            _xmlw.WriteStartElement(colPrefix, col.EncodedColumnName, col.Namespace);
                        _xmlw.WriteString( col.ConvertObjectToXml(value));
                        if (col.columnMapping != MappingType.SimpleContent)
                            _xmlw.WriteEndElement();
                    }
                }


            } //end foreach

			if (_dt == null)
				foreach( DataRelation dr in GetNestedChildRelations(row) ) {
					foreach( DataRow r in row.GetChildRows(dr) ) {                       					   
                       XmlDataRowWriter(r,dr.ChildTable.EncodedTableName);
					}
				}

            _xmlw.WriteEndElement();
        }
    }

} 
