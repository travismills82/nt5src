<docs>
  <doc for="DataDocumentNavigator.DataDocumentNavigator">
    <summary>
      <para>
       Initializes a new instance of the DataDocumentNavigator class to navigate
       over the specified XmlDataDocument.
    </para>
    </summary>
    <param name="doc">
    The XmlDataDocument on which you want to use DataDocumentNavigator.
 </param>
  </doc>
  <doc for="DataDocumentNavigator.Finalize">
    <nodoc />
    <summary>
    </summary>
  </doc>
  <doc for="DataDocumentNavigator.NodeType">
    <internalonly />
    <summary>
    Gets the type of the current node.
 </summary>
    <value>
      <para>One of the <see cref="System.Xml.XmlNodeType" /> values.</para>
    </value>
  </doc>
  <doc for="DataDocumentNavigator.SetPrefix">
    <summary>
      <para>Sets the namespace prefix associated with the current node.</para>
    </summary>
    <param name="value">The namespace prefix to associate with the current node.</param>
    <remarks>
    Setting this prefix has the same semantics
    as the W3C DOM.
 </remarks>
  </doc>
  <doc for="DataDocumentNavigator.HasValue">
    <summary>
      <para>
       Gets a value indicating whether <see cref="System.Xml.DocumentNavigator.Value" />
       has a value
       to return.
    </para>
    </summary>
    <value>
      <para>
        <see langword="true" /> if <see cref="System.Xml.DocumentNavigator.Value" /> has a value to return or if any 
       more content can be returned from the partial content read methods; otherwise,
    <see langword="false" />. 
    </para>
    </value>
  </doc>
  <doc for="DataDocumentNavigator.SetInnerText">
    <summary>
      <para>Sets the concatenated values of the current node and all its children.</para>
    </summary>
    <param name="value">The string value of the current node and all its children.</param>
    <remarks>
      <para>This method replaces the current node's
       children with the parsed contents of the given string.</para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.BaseURI">
    <summary>
      <para>Gets the base URI for the current node.</para>
    </summary>
    <value>
      <para>The base URI for the current node or empty string if there is no value. The returned string is also in the <see cref="System.Xml.XmlNavigator.NameTable" /> .</para>
    </value>
    <remarks>
      <para>A "networked" XML document is comprized of chunks of data aggregated using various W3C standard inclusion mechanisms and therefore contains nodes that come from different places. DTD Entities are an example of this, but this is not limited to DTD's. <see langword="BaseURI" /> tells you where these nodes originated.</para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.XmlSpace">
    <summary>
    Gets the xml:space scope.
 </summary>
    <value>
      <para>One of the <see cref="System.Xml.XmlSpace" /> values. </para>
    </value>
  </doc>
  <doc for="DataDocumentNavigator.XmlLang">
    <summary>
      <para>Gets the xml:lang scope for the current node.</para>
    </summary>
    <value>
      <para>The value of the xml:lang scope or empty string if the current node has no value to return.</para>
    </value>
    <remarks>
      <para>Using the XML text below, if the navigator were positioned on the "name" element, the user can call this property to find out that the name is in the scope of a "US English" xml:lang attribute. </para>
      <code>
 &lt;root xml:lang="en-us"&gt;
   &lt;name&gt;Fred&lt;/name&gt;
 &lt;/root&gt;
    </code>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.SetEmptyElement">
    <summary>
      <para>Sets a value indicating whether the current node is an 
      empty element (for example, &lt;MyElement/&gt;).</para>
    </summary>
    <param name="fEmpty">
      <see langword="true" /> to indicate the current node is an empty element (node ends with "/&gt;"); <see langword="false" /> if the current node is not an empty element.</param>
    <remarks>
      <para>This property enables you to determine the difference
      between <c>&lt;foo bar="123"&gt;</c> and <c>&lt;foo bar="123"/&gt;</c>. For newly
   created nodes, this property is <see langword="true" />. When the first child is
   inserted into a node this automatically reverts to <see langword="false" />.
   </para>
      <para> The following C# code creates the XML nodes
   <c>&lt;tmp&gt;&lt;/tmp&gt;</c>. </para>
      <code>
nav.InsertElement(TreePosition.After, "", "tmp", "");
nav.SetEmptyElement(false);
   </code>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.IsDefault">
    <summary>
      <para>
       Gets a value indicating whether the current node is an
       attribute that was generated from the default value defined
       in the DTD or schema.
    </para>
    </summary>
    <value>
      <para>
        <see langword="true" /> if the the 
       current node is an attribute whose value was generated from the default value
       defined in the DTD or schema.
    </para>
      <para>
        <see langword="false" /> if the attribute's value was explicitly 
       specified in the XML stream.
    </para>
    </value>
    <remarks>
      <para>
       This property applies only to an attribute node.
    </para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.NameTable">
    <summary>
      <para>
       Gets the XmlNameTable associated with this
       implementation.
    </para>
    </summary>
    <value>
      <para>
       XmlNameTable enabling you to get the atomized version of a string within the
       node.
    </para>
    </value>
    <remarks>
      <para>
       All node and attribute names returned from this class are atomized using this
       nametable. This means that when the same name is returned multiple times (like
       "Customer"), then the same String object will be returned for that name. This
       makes it possible for you to write efficient code that does object pointer
       comparisons on these strings instead of expensive string comparisons.
    </para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.HasAttributes">
    <summary>
      <para>
       Gets a
       value indicating whether the current node has any attributes.
    </para>
    </summary>
    <value>
      <para>
        <see langword="true" /> if the current node has attributes; otherwise, 
    <see langword="false" />. 
    </para>
    </value>
  </doc>
  <doc for="DataDocumentNavigator.AttributeCount">
    <summary>
      <para>
       Gets the number of attributes on the current node.
    </para>
    </summary>
    <value>
      <para>
       Count of attributes on the current node.
    </para>
    </value>
  </doc>
  <doc for="DataDocumentNavigator.HasAttribute">
    <overload>
      <para>Determines whether the current node has the specified attribute.</para>
    </overload>
    <summary>
      <para>Determines whether the current node has an attribute with 
       the specified <see cref="System.Xml.XmlNavigator.Name" />
       .</para>
    </summary>
    <param name="name">The name of the attribute to find. This is a qualified name that may or may not contain a colon. </param>
    <returns>
      <para>
        <see langword="true" /> if the current node has the specified attribute; 
    otherwise, <see langword="false" />.</para>
    </returns>
  </doc>
  <doc for="DataDocumentNavigator.HasAttribute1">
    <summary>
      <para>Determines whether the current node has an attribute with 
       the specified <see cref="System.Xml.XmlNavigator.LocalName" /> and <see cref="System.Xml.XmlNavigator.NamespaceURI" />
       .</para>
    </summary>
    <param name="localName">The localname of the attribute to find.</param>
    <param name="namespaceURI">The URN of the namespace of the attribute to find.</param>
    <returns>
      <para>
        <see langword="true" /> if the current node has the specified attribute; 
    otherwise, <see langword="false" />.</para>
    </returns>
  </doc>
  <doc for="DataDocumentNavigator.GetAttribute">
    <overload>
      <para>Gets the value of an attribute.</para>
    </overload>
    <summary>
      <para>Gets the value of the attribute with the specified <see cref="System.Xml.XmlNavigator.Name" /> .</para>
    </summary>
    <param name="name">The name of the attribute. This is a qualified name that may or may not contain a colon.</param>
    <returns>
      <para>The value of the specified attribute. Empty string if currentnode/record has no value to return 
       (never returns <see langword="null" /> ).</para>
    </returns>
  </doc>
  <doc for="DataDocumentNavigator.GetAttribute2">
    <summary>
      <para>Gets the value of the attribute with the specified index.</para>
    </summary>
    <param name="i">The index of the attribute. The index is zero-based (first attribute has index 0).</param>
    <returns>
      <para>The value of the specified attribute. Empty string if currentnode/record has no value to return 
       (never returns <see langword="null" /> ).</para>
    </returns>
    <exception cref="IndexOutOfRangeException">The <paramref name="i" /> parameter is less than 0 or greater than or equal to <see cref="System.Xml.DataDocumentNavigator.AttributeCount" />.</exception>
  </doc>
  <doc for="DataDocumentNavigator.SetAttribute">
    <overload>
      <para>Sets the value of the specified attribute.</para>
    </overload>
    <summary>
      <para>Sets the value of the attribute with the specified 
    <see cref="System.Xml.XmlNavigator.Name" /> 
    .</para>
    </summary>
    <param name="name">The name of the attribute. This is a qualified name that may or may not contain a colon.</param>
    <param name=" value">The value to set for the attribute.</param>
    <exception cref="InvalidOperationException">The navigator is not positioned on an element.</exception>
  </doc>
  <doc for="DataDocumentNavigator.SetAttribute1">
    <summary>
      <para>Sets the value of the attribute with the 
       specified <see cref="System.Xml.XmlNavigator.LocalName" /> and <see cref="System.Xml.XmlNavigator.NamespaceURI" />
       .</para>
    </summary>
    <param name="localName">The LocalName of the attribute.</param>
    <param name="namespaceURI">The URN of the namespace of the attribute.</param>
    <param name="value">The value to set for the attribute.</param>
    <exception cref="InvalidOperationException">The navigator is not positioned on an element.</exception>
    <remarks>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.SetAttribute2">
    <summary>
      <para>Sets the value of the attribute with the specified index.</para>
    </summary>
    <param name="i">The index of the attribute.</param>
    <param name="value">The value to set for the attribute.</param>
    <exception cref="IndexOutOfRangeException">The <paramref name="i" /> parameter is less than 0 or greater than <see cref="System.Xml.DataDocumentNavigator.AttributeCount" />.</exception>
    <exception cref="InvalidOperationException">The navigator is not positioned on an element.</exception>
  </doc>
  <doc for="DataDocumentNavigator.MoveToAttribute">
    <overload>
      <para>Moves to the specified attribute.</para>
    </overload>
    <summary>
      <para>Moves to the attribute with the specified <see cref="System.Xml.XmlNavigator.Name" /> and <see langword="null" /> 
 namespace.</para>
    </summary>
    <param name="name">The name of the attribute. This is a qualified name that may or may not contain a colon.</param>
    <returns>
      <para>
        <see langword="true" /> if the attribute is found; 
    otherwise, <see langword="false" />. If <see langword="false" />,
    the navigator's position does not change.</para>
    </returns>
    <remarks>
      <para>After calling <see langword="MoveToAttribute" />, the <see cref="System.Xml.XmlNavigator.Name" />, <see cref="System.Xml.XmlNavigator.NamespaceURI" /> and <see cref="System.Xml.XmlNavigator.Prefix" /> properties will reflect the 
    properties of that attribute.</para>
      <para>If you are positioned on an attribute, this method will 
    do an implicit <see cref="System.Xml.DataDocumentNavigator.MoveToElement" />
    before processing this method.</para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.MoveToAttribute1">
    <summary>
      <para>Move to the attribute with matching <see cref="System.Xml.XmlNavigator.LocalName" /> and <see cref="System.Xml.XmlNavigator.NamespaceURI" /> 
 .</para>
    </summary>
    <param name="localName">The LocalName of the attribute.</param>
    <param name="namespaceURI">The URN of the namespace of the attribute.</param>
    <returns>
      <para>
        <see langword="true" /> if the attribute is found; 
    otherwise, <see langword="false" />. If <see langword="false" />,
    the navigator's position does not change.</para>
    </returns>
    <remarks>
      <para>If you are positioned on an attribute, this method will 
       do an implicit <see cref="System.Xml.DataDocumentNavigator.MoveToElement" />
       before processing this method.</para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.MoveToAttribute2">
    <summary>
      <para>Moves to the attribute with the specified index.</para>
    </summary>
    <param name="i">The index of the attribute.</param>
    <returns>
      <para>
        <see langword="true" /> if the attribute is found; otherwise, 
 <see langword="false" />. If <see langword="false" />, the navigator's position does 
    not change.</para>
    </returns>
    <exception cref="IndexOutOfRangeException">The <paramref name="i" /> parameter is less than 0 or greater than <see cref="System.Xml.DataDocumentNavigator.AttributeCount" />.</exception>
    <remarks>
      <para>If you are positioned on an attribute, this method will 
       do an implicit <see cref="System.Xml.DataDocumentNavigator.MoveToElement" />
       before processing this method.</para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.MoveToFirstAttribute">
    <summary>
      <para>
       Moves to the first attribute.
    </para>
    </summary>
    <returns>
      <see langword="true" /> if the first attribute exists; otherwise, 
 <see langword="false" />.
 </returns>
    <remarks>
      <para>
       If you are positioned on an attribute, this method will do an implicit
       MoveToElement before processing this method.
    </para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.MoveToNextAttribute">
    <summary>
      <para>
       Moves to the next attribute.
    </para>
    </summary>
    <returns>
      <para>
        <see langword="true" /> if there is a next attribute; 
    <see langword="false" /> if there are no more attributes.
    </para>
    </returns>
    <remarks>
      <para>
       If the current node is an element node, this method
       is equivalent to MoveToFirstAttribute.
    </para>
      <para>
       If you are positioned on an attribute, this method will do an implicit
       MoveToElement before processing this method.
    </para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.MoveToElement">
    <summary>
      <para>
       Moves to the element that contains the current attribute node.
    </para>
    </summary>
    <returns>
      <para>
        <see langword="true" /> if the attribute is owned by 
       an element; <see langword="false" /> if the attribute you are positioned on
       has been removed from the owning element.
    </para>
    </returns>
    <exception cref="InvalidOperationException">
    The reader is not positioned on an attribute node.
 </exception>
    <remarks>
      <para>
       Use this method to return to an element after navigating through its
       attributes.
    </para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.IsReadOnly">
    <summary>
      <para>
       Gets a value indicating whether the current node is read-only.
    </para>
    </summary>
    <value>
      <para>
        <see langword="true" /> if the the current node is read-only. 
    </para>
      <para>
        <see langword="false" /> if the node is read/write. 
    </para>
    </value>
    <remarks>
      <para>
       A read-only node is one that you cannot change any of its properties,
       attributes, or children. But you can remove it from the tree and insert it
       somewhere else. For example, the node for an EntityReference is typically
       read-only because its children actually come from the DTD definition of that
       entity and typically the DTD is read-only.
    </para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.HasChildren">
    <summary>
      <para>
       Gets a value indicating whether
       the current node has child nodes.
    </para>
    </summary>
    <value>
      <para>
        <see langword="true" /> 
    if the current node has child nodes;
    otherwise, <see langword="false" />.
 </para>
    </value>
    <remarks>
      <para>
       This is potentially more efficient than using the <see cref="System.Xml.DataDocumentNavigator.ChildCount" /> property.
    </para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.ChildCount">
    <summary>
      <para>
       Gets the number of child nodes for the current node.
    </para>
    </summary>
    <value>
      <para>
       The number of child nodes for the current node.
    </para>
    </value>
  </doc>
  <doc for="DataDocumentNavigator.IndexInParent">
    <summary>
      <para>
       Gets the zero-based index of this node's position in its parent node.
    </para>
    </summary>
    <value>
      <para>
       The index position of this node within its parent node.
    </para>
      <para>
       Returns -1 if
       there is no parent node. You can, therefore, use this to find out
       whether there is a parent node for the current node.
    </para>
    </value>
    <remarks>
      <para>
       For attributes, this property returns the index in the list of attributes.
       For child elements, it returns the index in the list of child nodes.
       The following is always true (assuming the tree is not changed
       in the middle of the execution of this code):
    </para>
      <code lang="C#">
 DocumentNavigator other = this.Clone();
 other.MoveToParent();
 other.MoveToChild( this.IndexInParent );
 Assert(other.IsSame(this) == true);
    </code>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.MoveToNext">
    <summary>
      <para>
       Moves to the
       next sibling of the current node.
    </para>
    </summary>
    <returns>
      <para>
        <see langword="true" /> if there is a next sibling node; 
    <see langword="false" />
    if there are no more siblings.
 </para>
    </returns>
    <remarks>
      <para>
       If you are positioned on an attribute, this method will do an implicit call
       to MoveToElement before processing this method. In other words, attribute
       navigation is orthogonal to tree navigation.
    </para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.MoveToPrevious">
    <summary>
      <para>
       Moves to the
       previous sibling of the current node.
    </para>
    </summary>
    <returns>
      <para>
        <see langword="true" /> if there is a previous sibling node; 
    <see langword="false" /> if there is no previous sibling. 
    </para>
    </returns>
    <remarks>
      <para>
       If you are positioned on an attribute, this method will do an implicit call
       to MoveToElement before processing this method. In other words, attribute
       navigation is orthogonal to tree navigation.
    </para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.MoveToFirst">
    <summary>
      <para>
       Moves to the
       first sibling of the current node.
    </para>
    </summary>
    <returns>
      <para>
        <see langword="true" /> if there is a first sibling node; 
    <see langword="false" /> if there is no first sibling. 
    </para>
    </returns>
    <remarks>
      <para>
       If you are positioned on an attribute, this method will do an implicit call
       to MoveToElement before processing this method. In other words, attribute
       navigation is orthogonal to tree navigation.
    </para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.MoveToLast">
    <summary>Moves to the last sibling of the
    current node.
 </summary>
    <returns>
      <para>
        <see langword="true" /> if there is a last sibling node; 
    <see langword="false" /> if there is no last sibling. 
    </para>
    </returns>
    <remarks>
      <para>
       If you are positioned on an attribute, this method will do an implicit call
       to MoveToElement before processing this method. In other words, attribute
       navigation is orthogonal to tree navigation.
    </para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.MoveToFirstChild">
    <summary>
      <para>
       Moves to the first child of the current node.
    </para>
    </summary>
    <returns>
      <para>
        <see langword="true" /> if there is a first child node; 
    <see langword="false" /> if there are no child nodes. 
    </para>
    </returns>
  </doc>
  <doc for="DataDocumentNavigator.MoveToLastChild">
    <summary>
      <para>
       Moves to the last child of the current node.
    </para>
    </summary>
    <returns>
      <para>
        <see langword="true" /> if there is a last child node; 
    <see langword="false" /> if there are no child nodes. 
    </para>
    </returns>
  </doc>
  <doc for="DataDocumentNavigator.MoveToChild">
    <summary>Moves to the specified child node of the 
    current node (index 0 is the first child).
 </summary>
    <param name="i">
    The index of the child node.
 </param>
    <returns>
      <para>
        <see langword="true" /> if the specified child node exists; 
    <see langword="false" /> if the specified child node does not exist. 
    </para>
    </returns>
  </doc>
  <doc for="DataDocumentNavigator.MoveToParent">
    <summary>
      <para>Moves to the parent of the
       current node.</para>
    </summary>
    <returns>
      <para>
        <see langword="true" /> if a parent node exists.</para>
      <para>
        <see langword="false" /> if there is no 
 parent node. This can happen if the tree is being edited (i.e if the node the navigator is pointing to is removed from the tree).</para>
    </returns>
  </doc>
  <doc for="DataDocumentNavigator.MoveToDocument">
    <summary>
      <para>
       Moves to the document
       node that owns this node.
    </para>
    </summary>
    <remarks>
      <para>
       All nodes belong to one and only one document; therefore, this method is
       guaranteed to succeed.
    </para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.MoveToDocumentElement">
    <summary>
      <para>
       Moves to the child element node
       of the owning document.
    </para>
    </summary>
    <returns>
      <para>
        <see langword="true" /> if the document that owns this node currently has a child element node.
    </para>
      <para>
        <see langword="false" /> if the document that owns this node currently has no 
       child element node.
    </para>
    </returns>
  </doc>
  <doc for="DataDocumentNavigator.MoveToId">
    <summary>
      <para>Moves to the node with an ID attribute whose
       value matches the specified string.</para>
    </summary>
    <param name="id">The ID value of the node you want to move to.</param>
    <returns>
      <para>
        <see langword="true " />if the move was successful.</para>
      <see langword="false " />if the move was unsuccesful. 
 The navigator is returned to its position before the call.
 </returns>
    <remarks>
      <para>The argument does not need
       to be atomized. For example,
       suppose the DTD defined the following:</para>
      <para>&lt;!ATTLIST x a ID #REQUIRED &gt;</para>
      <para>and suppose the following XML data was loaded using this DTD:</para>
      <para>&lt;data&gt; &lt;x a="a1"/&gt; &lt;/data&gt;</para>
      <para>then the following would be true:</para>
      <code lang="C#">// "nav" pointing anywhere in the above data.
 nav.MoveToId("a1");
 // Now "nav" points to the element node named "x"
    </code>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.MoveToEntity">
    <summary>
      <para>Moves to the entity declaration node for the specified entity.</para>
    </summary>
    <param name="name">The name of the entity.</param>
    <returns>
      <para>
        <see langword="true" /> if the given 
    entity was found; otherwise <see langword="false" />. If <see langword="false" />,
    the navigator's position is unchanged.</para>
    </returns>
    <remarks>
      <para>If you had the following XML text,</para>
      <code>
 &lt;!DOCTYPE test [
 &lt;!ENTITY foo "&lt;a/&gt;&lt;b/&gt;"&gt;]&gt;
 &lt;test xmlns="urn:foo"&gt;
   &amp;foo;
 &lt;/test&gt;
    </code>
      <para>MoveToEntity("foo") would position the navigator on a node of type 
       XmlNodeType.Entity with the Name "foo", and InnerText equal to the entity
       replacement text "&lt;a/&gt;&lt;b/&gt;". </para>
      <para>These entity nodes also have children which result from parsing the 
       entity replacement text. In this case, a child element with name "a" and a child
       element with name "b". These children are parsed in a null namespace context,
       therefore in this case the child elements will have an empty NamespaceURI. This
       will be different in the case of the entity reference &amp;foo; shown above
       where the default namespace "urn:foo" is inherited from the containing "test"
       element. </para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.IsSamePosition">
    <summary>
      <para>
       Determines whether this XmlNavigator is at
       the same position as the specified XmlNavigator.
    </para>
    </summary>
    <param name="other">
    XmlNavigator with which you want to compare position.
 </param>
    <returns>
      <para>
        <see langword="true" /> if this XmlNavigator is at the same position as the 
       specified XmlNavigator; otherwise, <see langword="false" />.
    </para>
    </returns>
    <remarks>
      <para>
       This also implies the other XmlNavigator is the same
       kind of XmlNavigator pointing at the same document instance.
    </para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.IsSameRow">
    <summary>
      <para>Determines whether this navigator is at the same position as the specified DataRow.</para>
    </summary>
    <param name="row">DataRow with which you want to compare position</param>
    <returns>
      <para>
        <see langword="true" /> if this navigator is at the same position as the specified navigator; otherwise, <see langword="false" />.</para>
    </returns>
  </doc>
  <doc for="DataDocumentNavigator.LookupPrefix">
    <summary>
      <para>Looks up the prefix for the given namespace URI as
       defined higher up in the tree.</para>
    </summary>
    <param name="namespaceURI">Namespace URI look up.</param>
    <returns>
      <para>The prefix atomized string.
       Or <see langword="null" /> if not found.</para>
    </returns>
  </doc>
  <doc for="DataDocumentNavigator.Remove">
    <overload>
      <para>Removes the specified node(s).</para>
    </overload>
    <summary>
      <para>Removes the current node (and its entire subtree).</para>
    </summary>
    <remarks>
      <para>After this method is called, the parent pointer is 
       disconnected (so <see cref="System.Xml.DataDocumentNavigator.MoveToParent" /> will return
    <see langword="false" />) and the parent's <see cref="System.Xml.DataDocumentNavigator.ChildCount" /> 
    will be decremented
    by 1.</para>
      <para>This navigator then stays pointing at this removed node.</para>
      <para>If this node has already been removed and has no parent, this method has no
    effect.</para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.Remove1">
    <summary>
      <para>Removes the specified node (and its
       entire subtree) by relative position to the current node.</para>
    </summary>
    <param name="p">Treeposition indicating the node to remove.</param>
    <remarks>
      <para>After this method is called, the parent of the specified 
       node is set to <see langword="null" />
       . This navigator
       then stays pointing at this current node.</para>
      <para>The position of "None" makes this method behave the same as Remove() with no
       arguments.</para>
    </remarks>
    <seealso cref="System.Xml.TreePosition" />
  </doc>
  <doc for="DataDocumentNavigator.RemoveSelected">
    <summary>
      <para>Removes all the selected nodes.</para>
    </summary>
    <exception cref="InvalidOperationException">One of the selected nodes cannot be removed for some reason (for example the parent node is read only). In this case, the <see langword="RemoveSelected" /> operation stops at that node. In other words, all the nodes up to but not including the failed node are removed and the selection contains all the nodes that still remain.</exception>
    <remarks>
      <para>If there are no selected nodes, this method has no 
       effect. The navigator's position is unaffected by this operation.</para>
      <para>If the remove operation fails on one of the selected nodes, the tree 
       will be returned to its original state (previously removed nodes will be
       returned).</para>
    </remarks>
    <seealso cref="System.Xml.XmlNavigator.Select" />
    <seealso cref="System.Xml.XmlNavigator.MoveToNextSelected" />
  </doc>
  <doc for="DataDocumentNavigator.CreateDocumentFragment">
    <summary>
      <para>Creates a new document fragment node.</para>
    </summary>
    <remarks>
      <para>These nodes can never actually live inside the DOM tree, so this node has no parent.</para>
    </remarks>
    <seealso cref="System.Xml.XmlDocumentFragment" />
  </doc>
  <doc for="DataDocumentNavigator.Move">
    <summary>
      <para>Moves the entire subtree point to in the
       specified navigator to the specified position in this navigator.</para>
    </summary>
    <param name="p">The specified position where the new nodes will be moved. The position None does a replace operation.</param>
    <param name="other">XmlEditor containing the source of the new nodes.</param>
    <exception cref="ArgumentException">The other XmlEditor is pointing at read/only nodes (i.e. the children of an entity reference). It can point to an entity reference and thereby move the entire entity reference - but it cannot point at the children of an entity reference.</exception>
    <remarks>
      <para>This navigator's position is unaffected by this operation.</para>
      <para>The <paramref name="other" /> navigator remains pointing at the same node. This
    means it is essentially moved over to this tree in the process.</para>
    </remarks>
    <seealso cref="System.Xml.TreePosition" />
  </doc>
  <doc for="DataDocumentNavigator.CopyChildren">
    <summary>
      <para>Copies all
      the children from current position of the specified navigator and inserts them at
      the specified position in this navigator.</para>
    </summary>
    <param name="p">The specified position where the new nodes be copied. The position None does a replace operation.</param>
    <param name="other">The source of the new nodes.</param>
    <exception cref="InvalidOperationException">The operation would result in an invalid tree.</exception>
    <remarks>
      <para>The following table shows you what NodeType[row] is
      allowed inside another NodeType[column] according to the W3C 1.0 XML Spec (www.w3.org/TR/1998/REC-xml-19980210
      ).</para>
      <list type="table">
        <listheader>
          <term>
          </term>
          <description>Document</description>
          <description>DocType</description>
          <description>Declaration</description>
          <description>Element</description>
          <description>Attribute</description>
          <description>Text</description>
          <description>CDATA</description>
          <description>Markup</description>
          <description>EntityReference</description>
        </listheader>
        <item>
          <term>
            <see langword="Document" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="DocType" />
          </term>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="Declaration*" />
          </term>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="Element" />
          </term>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes***</description>
        </item>
        <item>
          <term>
            <see langword="Attribute" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="Text" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
        </item>
        <item>
          <term>
            <see langword="CDATA" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes***</description>
        </item>
        <item>
          <term>
            <see langword="Markup**" />
          </term>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="EntityReference" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
        </item>
      </list>
      <para> * Declaration includes Entity and Notation nodes.</para>
      <para>** Markup includes ProcessingInstruction and Comment nodes.</para>
      <para>*** Element and CDATA nodes are only allowed in EntityReference nodes when the EntityReference is outside an Attribute node.</para>
      <para>This navigator's position is unaffected by this operation.</para>
    </remarks>
    <seealso cref="System.Xml.TreePosition" />
  </doc>
  <doc for="DataDocumentNavigator.MoveChildren">
    <summary>
      <para>Moves all
      the children from current position of the specified navigator and inserts them at
      the specified position in this navigator.</para>
    </summary>
    <param name="p">The specified position where the new nodes will be copied. The position None does a Replace operation.</param>
    <param name="other">The source of the new nodes.</param>
    <exception cref="InvalidOperationException">The current node in the given navigator cannot be moved (for example, the node is read only). In this case no nodes are moved.</exception>
    <remarks>
      <para>The following table shows you what NodeType[row] is allowed inside another NodeType[column] according to the W3C 1.0 XML Spec (www.w3.org/TR/1998/REC-xml-19980210 ).</para>
      <list type="table">
        <listheader>
          <term>
          </term>
          <description>Document</description>
          <description>DocType</description>
          <description>Declaration</description>
          <description>Element</description>
          <description>Attribute</description>
          <description>Text</description>
          <description>CDATA</description>
          <description>Markup</description>
          <description>EntityReference</description>
        </listheader>
        <item>
          <term>
            <see langword="Document" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="DocType" />
          </term>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="Declaration*" />
          </term>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="Element" />
          </term>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes***</description>
        </item>
        <item>
          <term>
            <see langword="Attribute" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="Text" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
        </item>
        <item>
          <term>
            <see langword="CDATA" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes***</description>
        </item>
        <item>
          <term>
            <see langword="Markup**" />
          </term>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="EntityReference" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
        </item>
      </list>
      <para>* Declaration includes Entity and Notation nodes.</para>
      <para>** Markup includes ProcessingInstruction and Comment nodes.</para>
      <para>*** Element and CDATA nodes are only allowed in EntityReference nodes when the EntityReference is outside an Attribute node.</para>
      <para>This navigator's position is unaffected by this operation.</para>
    </remarks>
    <seealso cref="System.Xml.TreePosition" />
  </doc>
  <doc for="DataDocumentNavigator.MoveSelected">
    <summary>
      <para>Moves all the selected nodes from the specified
      navigator (as returned by <see cref="System.Xml.XmlNavigator.MoveToNextSelected" />
      )
      and inserts them at the specified position in this navigator.</para>
    </summary>
    <param name="p">The specified position where the new nodes will end up. The position None does a Replace operation.</param>
    <param name="other">The source of the new nodes.</param>
    <exception cref="InvalidOperationException">One of the nodes cannot be moved for some reason (for example the parent node is read only). In this case all the nodes up to but not including the failed node are moved. The rest of the nodes remain unmoved.</exception>
    <remarks>
      <para>The following table shows you what NodeType[row] is allowed inside another NodeType[column] according to the W3C 1.0 XML Spec (www.w3.org/TR/1998/REC-xml-19980210 ).</para>
      <list type="table">
        <listheader>
          <term>
          </term>
          <description>Document</description>
          <description>DocType</description>
          <description>Declaration</description>
          <description>Element</description>
          <description>Attribute</description>
          <description>Text</description>
          <description>CDATA</description>
          <description>Markup</description>
          <description>EntityReference</description>
        </listheader>
        <item>
          <term>
            <see langword="Document" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="DocType" />
          </term>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="Declaration*" />
          </term>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="Element" />
          </term>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes***</description>
        </item>
        <item>
          <term>
            <see langword="Attribute" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="Text" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
        </item>
        <item>
          <term>
            <see langword="CDATA" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes***</description>
        </item>
        <item>
          <term>
            <see langword="Markup**" />
          </term>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="EntityReference" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
        </item>
      </list>
      <para>* Declaration includes Entity and Notation nodes.</para>
      <para>** Markup includes ProcessingInstruction and Comment nodes.</para>
      <para>*** Element and CDATA nodes are only allowed in EntityReference nodes when the EntityReference is outside an Attribute node.</para>
      <para>This navigator's position is unaffected by this operation.</para>
      <para>If the move operation fails on one of the
   selected nodes, the tree will be returned to its original state (previously moved nodes will be reverted).</para>
    </remarks>
    <seealso cref="System.Xml.TreePosition" />
    <seealso cref="System.Xml.XmlNavigator.Select" />
  </doc>
  <doc for="DataDocumentNavigator.Node">
    <summary>
    Gets the XmlNode corresponding to the
    current position of the navigator.
 </summary>
    <returns>
      <para>Returns the XmlNode corresponding to the current position of the navigator or 
    <see langword="null" /> if the navigator is not positioned on any node 
       (NodeType=None).</para>
    </returns>
  </doc>
  <doc for="DataDocumentNavigator.SetInnerXml">
    <summary>
      <para>Sets the markup representing just the children of this node.</para>
    </summary>
    <param name="value">The markup representing the children of this node.</param>
    <remarks>
      <para>This method replaces the children of
       the current node with the parsed contents of the given string. The parsing is done in
       the current namespace context.</para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.RemoveChildren">
    <summary>
      <para>Removes all children of the current node.</para>
    </summary>
    <exception cref="InvalidOperationException">The current node is read only. No children are removed.</exception>
  </doc>
  <doc for="DataDocumentNavigator.PublicId">
    <internalonly />
    <summary>
    </summary>
  </doc>
  <doc for="DataDocumentNavigator.SystemId">
    <internalonly />
    <summary>
    </summary>
  </doc>
  <doc for="DataDocumentNavigator.InternalSubset">
    <internalonly />
    <summary>
    </summary>
  </doc>
  <doc for="DataDocumentNavigator.Encoding">
    <internalonly />
    <summary>
    </summary>
  </doc>
  <doc for="DataDocumentNavigator.Standalone">
    <internalonly />
    <summary>
    </summary>
  </doc>
  <doc for="DataDocumentNavigator.Version">
    <internalonly />
    <summary>
    </summary>
  </doc>
  <doc for="DataDocumentNavigator.DataRow">
    <summary>
      <para>Gets the <see cref="System.Data.DataRow" /> containing the current node.</para>
    </summary>
    <value>
      <para>The DataRow containing the
      current node or <see langword="null" /> if there is no mapping back to
      the <see cref="System.Data.DataSet" />
      in effect for the current node.</para>
    </value>
    <remarks>
      <para>
        <see cref="System.Xml.XmlNavigator" /> 
provides a powerful model
for performing XPath queries against data stored in a DataSet. This method provides
a way to get from the query
results (selected nodes in
the XmlNavigator) back to
the source
rows in the
DataSet.</para>
    </remarks>
    <example>
      <para>The following example does an XPath query to select all 
      the customers in the WA region and fills an <see cref="System.Collections.ArrayList" /> with the customer data. </para>
      <para> The sample uses the SQL Server 2000 Northwind database. </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.DataRow Example" SnippetID="1" />
    </example>
  </doc>
  <doc for="DataDocumentNavigator.MoveToRow">
    <summary>
      <para>Moves this DataDocumentNavigator to the specified DataRow.</para>
    </summary>
    <param name="row">The DataRow to move this navigator to</param>
    <returns>
      <para>
        <see langword="true" /> if the specified DataRow exists; otherwise <see langword="false" />. </para>
    </returns>
    <example>
      <para>The following example modifies the price of a book using the DataSet. </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.MoveToRow Example" SnippetID="1" />
      <para>The sample uses the input file </para>
      <para>
        <see langword="test.xsd" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.MoveToRow Example" SnippetID="2" />
    </example>
  </doc>
  <doc for="DataDocumentNavigator.OuterXml">
    <summary>
      <para>Gets the markup representing this node and
      all its children.</para>
    </summary>
    <value>
      <para>The markup containing this node and
      all its children.</para>
    </value>
    <example>
      <para>The following example modifies the price of a book using the DataSet. </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.OuterXml Example" SnippetID="1" />
      <para>The sample uses the input file </para>
      <para>
        <see langword="test.xsd" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.OuterXml Example" SnippetID="2" />
    </example>
  </doc>
  <doc for="DataDocumentNavigator.IsEmptyElement">
    <summary>
      <para> Gets a value indicating whether
      the current
      node is an empty element (for example, &lt;MyElement/&gt;).</para>
    </summary>
    <value>
      <para>
        <see langword="true" /> if the
   current node is an element (<see cref="System.Xml.XmlNavigator.NodeType" /> equals "Element") that ends
   with "/&gt;"; otherwise,<see langword=" false" /> .</para>
    </value>
    <remarks>
      <para>This property enables you to determine the
      difference between the following:</para>
      <para>
        <c>&lt;foo bar="123"/&gt;</c> (<see langword="IsEmptyElement" /> is <see langword="true" />).</para>
      <para>
        <c>&lt;foo bar="123"&gt;</c> (<see langword="IsEmptyElement" /> is <see langword="false" />)</para>
      <para>Note that a corresponding EndElement element is not generated for empty
   elements.</para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.MoveTo">
    <summary>
      <para>Moves to the same position as the specified <see cref="System.Xml.XmlNavigator" /> 
.</para>
    </summary>
    <param name="other">XmlNavigator with the position you want to move this XmlNavigator to.</param>
    <returns>
      <para>
        <see langword="true " />if successful; otherwise <see langword="false" />. If <see langword="false" /> , the navigator is returned to its position
   before the call.</para>
    </returns>
    <remarks>
      <para>The navigator is in the 'null' state when it temporarily
      points to no node. You can get out of this state by using
   <see langword="MoveTo" /> or <see cref="System.Xml.DataDocumentNavigator.MoveToDocument" />. The navigator is in the 'null' state
      when <see cref="System.Xml.XmlNavigator.NodeType" />
      returns 0.</para>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.Value">
    <summary>
      <para> Gets the text value of the current node.</para>
    </summary>
    <value>
      <para>The text value of the current node. If the current node 
      does not have a value, String.Empty is returned.</para>
    </value>
  </doc>
  <doc for="DataDocumentNavigator">
    <summary>
      <para> Provides an efficient means of examining and editing XML 
      or relational data in an <see cref="System.Xml.XmlDataDocument" /> using a cursor
      model.
      </para>
    </summary>
    <remarks>
      <para>
        <see langword="DataDocumentNavigator" /> is an implementation of
   the <see cref="System.Xml.XmlEditor" /> class. In addition to navigational and editing
   capabilities, it also provides support for XPath and can be used as the
   input mechanism to the <see cref="System.Xml.Xsl.XslTransform" /> class. This class has specific
   knowledge of the <see cref="System.Data.DataSet" /> storage and is able to walk the
<see langword="DataSet" /> for structured
   
   data.</para>
      <para> The <see cref="System.Xml.DocumentNavigator" /> class is an implementation of
<see langword="XmlEditor" /> for the <see cref="System.Xml.XmlDocument" /> class. It can be used in cases where it is not important to be able mix XML and relational views of the underlying data.</para>
      <para>For more information on the navigator classes, see the XmlNavigator conceptual topic.</para>
    </remarks>
    <seealso cref="System.Xml.XmlNavigator" />
  </doc>
  <doc for="DataDocumentNavigator.SetValue">
    <summary>
      <para>Sets the text value of the current node.</para>
    </summary>
    <param name="value">The text value of the current node.</param>
    <exception cref="ArgumentException">The value for XmlDeclaration is invalid.</exception>
    <exception cref="InvalidOperationException">The navigator is positioned on a node whose Value property is not settable (i.e an Element node).</exception>
    <remarks>
      <para>For XmlDeclaration nodes you can use this method to set the entire delcaration text (for example, <c>SetValue("value='1.0' encoding='utf-8'")</c>).</para>
   This method cannot be used to set the value
   of a DocumentType node.
</remarks>
    <seealso cref="System.Xml.XmlDeclaration" />
  </doc>
  <doc for="DataDocumentNavigator.CopySelected">
    <summary>
      <para>Copies all the selected nodes from the specified
      navigator (as returned by <see cref="System.Xml.XmlNavigator.Select" />
      ) and inserts them at the specified
      position in this tree.</para>
    </summary>
    <param name="p">The specified position where the new nodes will be copied. The position None does a Replace operation.</param>
    <param name="other">The source of the new nodes.</param>
    <exception cref="InvalidOperationException">The operation would result in an invalid tree.</exception>
    <remarks>
      <para>The following table shows you what NodeType[row] is
      allowed inside another NodeType[column] according to the W3C 1.0 XML Spec (www.w3.org/TR/1998/REC-xml-19980210
      ).</para>
      <list type="table">
        <listheader>
          <term>
          </term>
          <description>Document</description>
          <description>DocType</description>
          <description>Declaration</description>
          <description>Element</description>
          <description>Attribute</description>
          <description>Text</description>
          <description>CDATA</description>
          <description>Markup</description>
          <description>EntityReference</description>
        </listheader>
        <item>
          <term>
            <see langword="Document" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="DocType" />
          </term>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="Declaration*" />
          </term>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="Element" />
          </term>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes***</description>
        </item>
        <item>
          <term>
            <see langword="Attribute" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="Text" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
        </item>
        <item>
          <term>
            <see langword="CDATA" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes***</description>
        </item>
        <item>
          <term>
            <see langword="Markup**" />
          </term>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="EntityReference" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
        </item>
      </list>
      <para> * Declaration includes Entity and Notation nodes.</para>
      <para>** Markup includes ProcessingInstruction and Comment nodes.</para>
      <para>*** Element and CDATA nodes are only allowed in EntityReference nodes when the EntityReference is outside an Attribute node.</para>
      <para>This navigator's position is unaffected by this operation.</para>
      <para>If the copy operation fails on one of the selected nodes, the tree will be returned to its original state (previously copied nodes will be reverted).</para>
    </remarks>
    <example>
      <para>The following example loads a customer table and copies 
      all customers in the WA region into an <see cref="System.Xml.XmlDocument" />
      .
      </para>
      <para>The sample uses the SQL Server 2000 Northwind database.</para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.CopySelected Example" SnippetID="1" />
    </example>
    <seealso cref="System.Xml.TreePosition" />
    <seealso cref="System.Xml.XmlNavigator.Select" />
  </doc>
  <doc for="DataDocumentNavigator.InsertObject">
    <summary>
      <para>Inserts a copy of the node or nodes represented by <paramref name="obj" /> into the specified position in this tree relative to the current position and moves the navigator to point at the root of the newly inserted nodes.</para>
    </summary>
    <param name="p">The relative position of the new node. The position "None" means the new node is not inserted into the tree - but instead is left dangling with no parent. This is a valid way to create DocumentFragment nodes using the navigator.</param>
    <param name="obj">The XmlNavigator object that contains the new nodes to be inserted.</param>
    <param name="type">The type of object. This argument is optional and is only used to result which interface on the object to use if the object implements multiple interfaces. If <see langword="null" /> is passed then the "instanceof" operator is used to determine the type.</param>
    <exception cref="XmlException">The XML being parsed during insert is invalid.</exception>
    <exception cref="ArgumentException">The object specifies a node with an XmlNodeType that can not be inserted at position <paramref name="p" /> . Refer to the table below for specifics. </exception>
    <remarks>
      <para>The following table shows you what NodeType[row] is allowed inside another NodeType[column] according to the W3C 1.0 XML Spec (www.w3.org/TR/1998/REC-xml-19980210 ).</para>
      <list type="table">
        <listheader>
          <term>
          </term>
          <description>Document</description>
          <description>DocType</description>
          <description>Declaration</description>
          <description>Element</description>
          <description>Attribute</description>
          <description>Text</description>
          <description>CDATA</description>
          <description>Markup</description>
          <description>EntityReference</description>
        </listheader>
        <item>
          <term>
            <see langword="Document" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="DocType" />
          </term>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="Declaration*" />
          </term>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="Element" />
          </term>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes***</description>
        </item>
        <item>
          <term>
            <see langword="Attribute" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="Text" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
        </item>
        <item>
          <term>
            <see langword="CDATA" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes***</description>
        </item>
        <item>
          <term>
            <see langword="Markup**" />
          </term>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
        </item>
        <item>
          <term>
            <see langword="EntityReference" />
          </term>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
          <description>yes</description>
          <description>no</description>
          <description>no</description>
          <description>no</description>
          <description>yes</description>
        </item>
      </list>
      <para>* Declaration includes Entity and Notation nodes.</para>
      <para>** Markup includes ProcessingInstruction and Comment nodes.</para>
      <para>*** Element and CDATA nodes are only allowed in EntityReference nodes when the EntityReference is outside an Attribute node.</para>
      <para>This navigator's position is unaffected by this operation.</para>
    </remarks>
    <example>
      <para> The following example inserts a new customer to the 
      current <see cref="System.Data.DataSet" />
      .
      
   </para>
      <para>The sample uses the SQL Server 2000 Northwind database. </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.InsertObject Example" SnippetID="1" />
    </example>
    <seealso cref="System.Xml.TreePosition" />
  </doc>
  <doc for="DataDocumentNavigator.InsertCDataSection">
    <summary>
      <para>Creates a CDataSection node, inserts it at the specified position and moves the navigator to the root of the newly inserted node.</para>
    </summary>
    <param name="p">The relative position of the new node. The position "None" means the new node is not inserted into the tree - but instead is left dangling with no parent. This is a valid way to create DocumentFragment nodes using the navigator.</param>
    <param name="value">The value of the node.</param>
    <exception cref="ArgumentException">The node can not be inserted at the specified position.</exception>
    <remarks>
      <para>According to the W3C 1.0 XML Spec (www.w3.org/TR/1998/REC-xml-19980210), CDataSection nodes are allowed within Element nodes and in EntityReference nodes when the EntityReference is outside an Attribute node.</para>
    </remarks>
    <seealso cref="System.Xml.TreePosition" />
  </doc>
  <doc for="DataDocumentNavigator.InsertWhitespace">
    <summary>
      <para>Creates a Whitespace node, inserts it at the specified position and moves the navigator to the root of the newly inserted node.</para>
    </summary>
    <param name="p">The relative position of the new node. The position "None" means the new node is not inserted into the tree - but instead is left dangling with no parent. This is a valid way to create DocumentFragment nodes using the navigator.</param>
    <param name="value">The value of the node.</param>
    <exception cref="ArgumentException">The node can not be inserted at the specified position.</exception>
    <remarks>
      <para>Whitespace nodes are skipped during validation.</para>
    </remarks>
    <seealso cref="System.Xml.TreePosition" />
  </doc>
  <doc for="DataDocumentNavigator.InsertSignificantWhitespace">
    <summary>
      <para>Creates a SignificantWhitespace node, inserts it at the specified position and moves the navigator to the root of the newly inserted node.</para>
    </summary>
    <param name="p">The relative position of the new node. The position "None" means the new node is not inserted into the tree - but instead is left dangling with no parent. This is a valid way to create DocumentFragment nodes using the navigator.</param>
    <param name="value">The value of the node.</param>
    <exception cref="ArgumentException">The node can not be inserted at the specified position.</exception>
    <remarks>
      <para>SignificantWhitespace nodes are skipped during validation.</para>
    </remarks>
    <seealso cref="System.Xml.TreePosition" />
  </doc>
  <doc for="DataDocumentNavigator.InsertEntityReference">
    <summary>
      <para>Creates an EntityReference node, inserts it at the specified position and moves the navigator to the root of the newly inserted node.</para>
      <para>XmlEntityReference nodes cannot be created for XmlDataDocument. Calling this
      method will throw an exception.</para>
    </summary>
    <param name="p">The relative position of the new node. The position "None" means the new node is not inserted into the tree - but instead is left dangling with no parent.</param>
    <param name="name">The name of the entity reference. The children of this entity reference will be automatically expanded only if the tree you are inserting into has the necessary DTD information to do so.</param>
    <exception cref="NotSupportedException">Calling this method.</exception>
    <seealso cref="System.Xml.TreePosition" />
  </doc>
  <doc for="DataDocumentNavigator.InsertDocumentType">
    <summary>
      <para>Creates a DocumentType node, inserts it at the specified position and moves the navigator to the root of the newly inserted node.</para>
    </summary>
    <param name="p">The relative position of the new node. The position "None" means the new node is not inserted into the tree - but instead is left dangling with no parent. This is a valid way to create DocumentFragment nodes using the navigator.</param>
    <param name="name">The name of the DocumentType node.</param>
    <param name="pubid">The public identifier, or <see langword="null" />.</param>
    <param name="sysid">The system identifier, or <see langword="null" />.</param>
    <param name="internalSubset">The internal DTD subset, or <see langword="null" />.</param>
    <exception cref="ArgumentException">The node can not be inserted at the specified position.</exception>
    <remarks>
      <para>According to the W3C 1.0 XML Spec (www.w3.org/TR/1998/REC-xml-19980210), DocumentType nodes are only allowed within Document nodes.</para>
    </remarks>
    <seealso cref="System.Xml.TreePosition" />
  </doc>
  <doc for="DataDocumentNavigator.InnerText">
    <summary>
      <para> Gets the concatenated values of the current node and
      all its children.
      </para>
    </summary>
    <value>
      <para> The concatenated values of the current node and all its children.
      </para>
    </value>
  </doc>
  <doc for="DataDocumentNavigator.InnerXml">
    <summary>
      <para> Gets the markup representing just
      the children of this node.</para>
    </summary>
    <value>
      <para>The markup of the children of
      this node.</para>
    </value>
  </doc>
  <doc for="DataDocumentNavigator.PushPosition">
    <summary>
      <para>Saves the current position.</para>
    </summary>
    <remarks>
      <para> You can later return to this position by calling <see cref="System.Xml.DataDocumentNavigator.PopPosition" /> .
   Push has the same semantics as if you used <see cref="System.Xml.DataDocumentNavigator.Clone" />
   and remembered
   the cloned XmlNavigators on your own stack.</para>
    </remarks>
    <example>
      <para>The following example inserts nodes into an <see langword="XmlDataDocument" />. </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="1" />
      <para>The sample uses the following two input files.</para>
      <para>
        <see langword="book.xml" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="2" />
      <para>
        <see langword="test.xsd" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="3" />
    </example>
  </doc>
  <doc for="DataDocumentNavigator.PopPosition">
    <summary>
      <para> Moves the XmlNavigator back to a previously pushed position
      and pops that saved position off the stack.
      </para>
    </summary>
    <returns>
      <para>
        <see langword="true" /> if XmlNavigator moved to previous push position;
<see langword="false" /> if there is no more to pop.
   </para>
    </returns>
    <example>
      <para>The following example inserts nodes into an <see langword="XmlDataDocument" />. </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="1" />
      <para>The sample uses the following two input files.</para>
      <para>
        <see langword="book.xml" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="2" />
      <para>
        <see langword="test.xsd" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="3" />
    </example>
  </doc>
  <doc for="DataDocumentNavigator.InsertElement">
    <summary>
      <para>Creates an Eement node with the given <see cref="System.Xml.XmlNavigator.Prefix" />, <see cref="System.Xml.XmlNavigator.LocalName" /> and <see cref="System.Xml.XmlNavigator.NamespaceURI" /> and inserts it at the specified position. The navigator moves to the root of the newly inserted node.</para>
    </summary>
    <param name="p">The relative position of the new node. The position "None" means the new node is not inserted into the tree - but instead is left dangling with no parent. This is a valid way to create DocumentFragment nodes using the navigator. </param>
    <param name="prefix">The namespace prefix of the new node (if any). You can use <see cref="System.Xml.XmlNavigator.LookupPrefix" /> to find the prefix for a given namespace URI. The navigator does not do this automatically performance reasons. String.Empty and <see langword="null" /> are equivalent.</param>
    <param name="localName">The local name of the new node.</param>
    <param name="ns">The namespace URI for the new node (if any). String.Empty and <see langword="null" /> are equivalent</param>
    <exception cref="ArgumentException">The node can not be inserted at the specified position.</exception>
    <remarks>
      <para>According to the W3C 1.0 XML Spec (www.w3.org/TR/1998/REC-xml-19980210), Element nodes are allowed within Document and Element nodes, and in EntityReference nodes when the EntityReference is outside an Attribute node.</para>
    </remarks>
    <example>
      <para>The following example inserts nodes into an 
   <see langword="XmlDataDocument" /> . </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="1" />
      <para>The sample uses the following two input files.</para>
      <para>
        <see langword="book.xml" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="2" />
      <para>
        <see langword="test.xsd" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="3" />
    </example>
    <seealso cref="System.Xml.TreePosition" />
  </doc>
  <doc for="DataDocumentNavigator.InsertAttribute">
    <summary>
      <para>Creates an Attribute node with the given <see cref="System.Xml.XmlNavigator.Prefix" />, <see cref="System.Xml.XmlNavigator.LocalName" /> and <see cref="System.Xml.XmlNavigator.NamespaceURI" /> and inserts it at the specified position. The navigator moves the root of the newly inserted node.</para>
    </summary>
    <param name="p">The relative position of the new node. The position "None" means the new node is not inserted into the tree - but instead is left dangling with no parent. This is a valid way to create DocumentFragment nodes using the navigator. </param>
    <param name="prefix">The namespace prefix of the new node (if any). You can use <see cref="System.Xml.XmlNavigator.LookupPrefix" /> to find the prefix for a given namespace URI. The navigator does not do this automatically performance reasons. String.Empty and <see langword="null" /> are equivalent.</param>
    <param name="localName">The local name of the new node.</param>
    <param name="ns">The namespace URI for the new node (if any). String.Empty and <see langword="null" /> are equivalent</param>
    <exception cref="ArgumentException">The node can not be inserted at the specified position.</exception>
    <remarks>
      <para>According to the W3C 1.0 XML Spec (www.w3.org/TR/1998/REC-xml-19980210), Attribute nodes are only allowed within an Element node.</para>
    </remarks>
    <example>
      <para>The following example inserts nodes into an 
   <see langword="XmlDataDocument" /> . </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="1" />
      <para>The sample uses the following two input files.</para>
      <para>
        <see langword="book.xml" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="2" />
      <para>
        <see langword="test.xsd" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="3" />
    </example>
    <seealso cref="System.Xml.TreePosition" />
  </doc>
  <doc for="DataDocumentNavigator.InsertComment">
    <summary>
      <para>Creates a Comment node, inserts it at the specified position and moves the navigator to the root of the newly inserted node.</para>
    </summary>
    <param name="p">The relative position of the new node. The position "None" means the new node is not inserted into the tree - but instead is left dangling with no parent. This is a valid way to create DocumentFragment nodes using the navigator.</param>
    <param name="value">The text of the comment.</param>
    <exception cref="ArgumentException">The node can not be inserted at the specified position.</exception>
    <remarks>
      <para> According to the W3C 1.0 XML Spec (www.w3.org/TR/1998/REC-xml-19980210), Comment nodes are only allowed within Document and Element nodes.</para>
    </remarks>
    <example>
      <para>The following example inserts nodes into an <see langword="XmlDataDocument" />. </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="1" />
      <para>The sample uses the following two input files.</para>
      <para>
        <see langword="book.xml" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="2" />
      <para>
        <see langword="test.xsd" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="3" />
    </example>
    <seealso cref="System.Xml.TreePosition" />
  </doc>
  <doc for="DataDocumentNavigator.InsertText">
    <summary>
      <para>Creates a Text node, inserts it at the specified position and moves the navigator to the root of the newly inserted node.</para>
    </summary>
    <param name="p">The relative position of the new node. The position "None" means the new node is not inserted into the tree - but instead is left dangling with no parent. This is a valid way to create DocumentFragment nodes using the navigator.</param>
    <param name="value">The value of the node.</param>
    <exception cref="ArgumentException">The node can not be inserted at the specified position.</exception>
    <remarks>
      <para>According to the W3C 1.0 XML Spec (www.w3.org/TR/1998/REC-xml-19980210), Text nodes are only allowed within Element, Attribute and EntityReference nodes.</para>
    </remarks>
    <example>
      <para>The following example inserts nodes into an <see langword="XmlDataDocument" />. </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="1" />
      <para>The sample uses the following two input files.</para>
      <para>
        <see langword="book.xml" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="2" />
      <para>
        <see langword="test.xsd" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="3" />
    </example>
    <seealso cref="System.Xml.TreePosition" />
  </doc>
  <doc for="DataDocumentNavigator.InsertProcessingInstruction">
    <summary>
      <para>Creates a ProcessingInstruction node, inserts it at the specified position and moves the navigator to the root of the newly inserted node.</para>
    </summary>
    <param name="p">The relative position of the new node. The position "None" means the new node is not inserted into the tree - but instead is left dangling with no parent. This is a valid way to create DocumentFragment nodes using the navigator.</param>
    <param name="name">The target name of the processing instruction.</param>
    <param name="value">The value of the processing instruction.</param>
    <exception cref="ArgumentException">The node can not be inserted at the specified position.</exception>
    <remarks>
      <para> According to the W3C 1.0 XML Spec (www.w3.org/TR/1998/REC-xml-19980210), ProcessingInstruction nodes are only allowed within Document and Element nodes.</para>
    </remarks>
    <example>
      <para>The following example inserts nodes into an <see langword="XmlDataDocument" />. </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="1" />
      <para>The sample uses the following two input files.</para>
      <para>
        <see langword="book.xml" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="2" />
      <para>
        <see langword="test.xsd" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="3" />
    </example>
    <seealso cref="System.Xml.TreePosition" />
  </doc>
  <doc for="DataDocumentNavigator.InsertXmlDeclaration">
    <summary>
      <para>Creates a XmlDeclaration node, inserts it at the specified position and moves the navigator to the root of the newly inserted node.</para>
    </summary>
    <param name="p">The relative position of the new node. The position "None" means the new node is not inserted into the tree - but instead is left dangling with no parent.</param>
    <param name="version">The version attribute, for example "1.0".</param>
    <param name="encoding">The encoding attribute, for example "UTF-8". If this is <see langword="null" /> then no encoding attribue is created.</param>
    <param name="standalone">The standalone attribute. If this is <see langword="null" /> then no standalone attribue is created.</param>
    <exception cref="ArgumentException">The node can not be inserted at the specified position.</exception>
    <remarks>
      <para>The XmlDeclaration node must be the first node in the
      document. It can have no children. It is a child of the root node.</para>
    </remarks>
    <example>
      <para>The following example inserts nodes into an <see langword="XmlDataDocument" />. </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="1" />
      <para>The sample uses the following two input files.</para>
      <para>
        <see langword="book.xml" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="2" />
      <para>
        <see langword="test.xsd" />
      </para>
      <codelink SampleID="Classic WebData DataDocumentNavigator.PushPosition Example" SnippetID="3" />
    </example>
  </doc>
  <doc for="DataDocumentNavigator.Clone">
    <summary>
      <para> Creates a new <see cref="System.Xml.XmlNavigator" /> positioned at the same node as this 
<see langword="DataDocumentNavigator" /> 
.</para>
    </summary>
    <returns>
      <para> A new <see langword="XmlNavigator" /> object.
   </para>
    </returns>
    <remarks>
      <para>The cloned <see langword="XmlNavigator" /> is not affected by subsequent changes 
   to this <see langword="DataDocumentNavigator" /> .</para>
This method does not clone the selection and push/pop states.
</remarks>
  </doc>
  <doc for="DataDocumentNavigator.GetAttribute1">
    <summary>
      <para>Gets the value of the attribute with the
      specified <see cref="System.Xml.XmlNavigator.LocalName" /> and <see cref="System.Xml.XmlNavigator.NamespaceURI" /> .</para>
    </summary>
    <param name="localName">The LocalName of the attribute.</param>
    <param name="namespaceURI">The URN of the namespace of the attribute.</param>
    <returns>
      <para>The value of the specified attribute. Empty string if currentnode/record has no value to return
      (never returns <see langword="null" /> ).</para>
    </returns>
    <remarks>
      <para>The following XML contains an attribute in a specific
      namespace: <c>&lt;test
      xmlns:dt="urn:datatypes" dt:type="int"/&gt;</c>
   .</para>
      <para>You can lookup the dt:type attribute using one argument (using the qualified name) or using two arguments (<paramref name="localName" /> and <paramref name="namespaceURI" /> 
): </para>
      <code>
String dt = nav.GetAttribute("dt:type"); 
String dt2 = nav.GetAttribute("type","urn:datatypes");
</code>
      <para>To lookup the xmlns attribute, do one of the 
   following:
   </para>
      <code>
String dt3 = nav.GetAttribute("xmlns:dt"); 
String dt4 = nav.GetAttribute("dt","http://www.w3.org/2000/xmlns/");
</code>
    </remarks>
  </doc>
  <doc for="DataDocumentNavigator.LocalName">
    <internalonly />
    <summary>
      <para>Gets the name of the node without the namespace prefix.</para>
    </summary>
    <value>
      <para>The name of the node with the prefix removed. For example, LocalName is yyy for the element &lt;xxx:yyy&gt;.</para>
      <para>The value returned depends on the <see cref="System.Xml.DataDocumentNavigator.NodeType" /> of the current node. The following node types return the listed values; all other node types return String.Empty</para>
      <list type="table">
        <listheader>
          <term>XmlNodeType</term>
          <description>Property Value</description>
        </listheader>
        <item>
          <term> Attribute</term>
          <description>Contains the local name of the attribute.</description>
        </item>
        <item>
          <term> DocumentType</term>
          <description>Contains the name of the document type; for example, xxx in &lt;!DOCTYPE xxx ...&gt;.</description>
        </item>
        <item>
          <term> Element</term>
          <description>Contains the local name of the XML tag.</description>
        </item>
        <item>
          <term> Entity</term>
          <description>Contains the name of the entity.</description>
        </item>
        <item>
          <term> EntityReference</term>
          <description>Contains the name of the entity referenced. Note that the name does not include the leading ampersand or the trailing semicolon.</description>
        </item>
        <item>
          <term> Notation</term>
          <description>Contains the name of the notation.</description>
        </item>
        <item>
          <term> ProcessingInstruction</term>
          <description>Contains the target; the first token following the &lt;? characters.</description>
        </item>
        <item>
          <term> XmlDeclaration</term>
          <description>Contains the literal string "xml".</description>
        </item>
        <item>
          <term> All other node types</term>
          <description>String.Empty</description>
        </item>
      </list>
    </value>
  </doc>
  <doc for="DataDocumentNavigator.Name">
    <internalonly />
    <summary>
      <para>Gets the name of the current node, including
      the namespace prefix.</para>
    </summary>
    <value>
      <para>The qualified name of the current node. The name returned depends on
      the <see cref="System.Xml.DataDocumentNavigator.NodeType" /> of the
      current node. The following node types return the listed values; all other
      node types return String.Empty</para>
      <list type="table">
        <listheader>
          <term>XmlNodeType</term>
          <description>Property Value</description>
        </listheader>
        <item>
          <term> Attribute</term>
          <description>Contains the name of the attribute.</description>
        </item>
        <item>
          <term> DocumentType</term>
          <description>Contains the name of the document type; for example, xxx in &lt;!DOCTYPE xxx ...&gt;.</description>
        </item>
        <item>
          <term> Element</term>
          <description>Contains the name of the XML tag, with any namespace prefix included if present.</description>
        </item>
        <item>
          <term> Entity</term>
          <description>Contains the name of the entity.</description>
        </item>
        <item>
          <term> EntityReference</term>
          <description>Contains the name of the entity referenced. Note that the name does not include the leading ampersand or the trailing semicolon. The name includes the namespace if one is present.</description>
        </item>
        <item>
          <term> Notation</term>
          <description>Contains the name of the notation.</description>
        </item>
        <item>
          <term> ProcessingInstruction</term>
          <description>Contains the target; the first token following the &lt;? characters.</description>
        </item>
        <item>
          <term> XmlDeclaration</term>
          <description>Contains the literal string "xml".</description>
        </item>
        <item>
          <term> All other node types</term>
          <description>String.Empty</description>
        </item>
      </list>
    </value>
  </doc>
  <doc for="DataDocumentNavigator.NamespaceURI">
    <internalonly />
    <summary>
      <para> Gets the namespace URI (as defined in the W3C Namespace Specification) of the current node.</para>
    </summary>
    <value>
      <para> The namespace URI of the current node or
      an empty string if if there is no namespace.</para>
    </value>
  </doc>
  <doc for="DataDocumentNavigator.Prefix">
    <internalonly />
    <summary>
      <para> Gets the prefix associated with the current node.</para>
    </summary>
    <value>
      <para> The prefix associated with the current node.</para>
      <para> String.Empty if current node/record has no prefix to
      return (never returns <see langword="null" /> ).</para>
    </value>
    <seealso cref="System.Xml.DataDocumentNavigator.SetPrefix" />
  </doc>
  <doc for="DataDocumentNavigator.SetEncoding">
    <summary>
      <para>Sets the encoding level of the document.</para>
    </summary>
    <param name="value">The value of the encoding attribute.</param>
    <exception cref="InvalidOperationException">The navigator is positioned on a node whose encoding property is not settable. </exception>
    <remarks>
      <para>The most commonly supported character encoding names for XML are the following:</para>
      <list type="table">
        <listheader>
          <term>Category</term>
          <description>Encoding Names</description>
        </listheader>
        <item>
          <term> Unicode</term>
          <description>"UTF-8", "UTF-16"</description>
        </item>
        <item>
          <term> ISO 10646</term>
          <description>"ISO-10646-UCS-2", "ISO-10646-UCS-4"</description>
        </item>
        <item>
          <term> ISO 8859</term>
          <description>"ISO-8859-n" (where "n" is a digit from 1 to 9)</description>
        </item>
        <item>
          <term> JIS X-0208-1997</term>
          <description>"ISO-2022-JP", "Shift_JIS", "EUC-JP"</description>
        </item>
      </list>
      <para>This attribute is optional. XML version 1.0 specifies that if this attribute is not included, "UTF-8" or "UTF-16" encoding is assumed, depending on the format of the initial "&lt;?xml" string. </para>
      <para>If the navigator is positioned on an XmlDocument NodeType and there is no XmlDeclaration node, one will be created.</para>
    </remarks>
    <seealso cref="System.Xml.XmlNavigator.Encoding" />
  </doc>
  <doc for="DataDocumentNavigator.SetStandalone">
    <summary>
      <para> Sets the standalone attribute for the
      document.</para>
    </summary>
    <param name="value">"yes" if all entity declarations required by the XML document are contained within the document; "no" if an external DTD is required.</param>
    <exception cref="InvalidOperationException">The navigator is positioned on a node whose standalone property is not settable. </exception>
    <remarks>
      <para>If the navigator is positioned on an XmlDocument NodeType and there is no XmlDeclaration node, one will be created.</para>
    </remarks>
    <seealso cref="System.Xml.DataDocumentNavigator.Standalone" />
  </doc>
</docs>