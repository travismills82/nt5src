<docs>
	<doc for="Application.eventHandlers">
		<summary>
     Hash table for our event list
 </summary>
	</doc>
	<doc for="Application.exiting">
		<summary>
     in case Application.exit gets called recursively
 </summary>
	</doc>
	<doc for="Application.EVENT_APPLICATIONEXIT">
		<summary>
     Events the user can hook into
 </summary>
	</doc>
	<doc for="Application.Application">
		<summary>
     This class is static, there is no need to ever create it.
 </summary>
	</doc>
	<doc for="Application.BeginModalMessageLoop">
		<summary>
     Called immediately before we begin pumping messages for a modal message loop.
     Does not actually start a message pump; that's the caller's responsibility.
 </summary>
	</doc>
	<doc for="Application.CollectAllGarbage">
		<summary>
     Garbage collects until there isn't anything left to collect.
 </summary>
	</doc>
	<doc for="Application.EndModalMessageLoop">
		<summary>
     Called immediately after we stop pumping messages for a modal message loop.
     Does not actually kill the message pump itself.
 </summary>
	</doc>
	<doc for="Application.GetAppFileVersionInfo">
		<summary>
     Retrieves the FileVersionInfo associated with the main module for
     the application.
 </summary>
	</doc>
	<doc for="Application.GetAppMainType">
		<summary>
     Retrieves the Type that contains the "Main" method.
 </summary>
	</doc>
	<doc for="Application.GetDataPath">
		<summary>
     Returns a string that is the combination of the
     basePath + CompanyName + ProducName + ShortProductVersion. This
     will also create the directory if it doesn't exist.
 </summary>
	</doc>
	<doc for="Application.RaiseExit">
		<summary>
     Called by the last thread context before it shuts down.
 </summary>
	</doc>
	<doc for="Application.RaiseThreadExit">
		<summary>
     Called by the each thread context before it shuts down.
 </summary>
	</doc>
	<doc for="Application.GetParkingWindow">
		<summary>
			<para>Retrieves the parking window for the thread that owns the <paramref name="control"/>.</para>
		</summary>
		<param name="control">
			<see cref="System.Windows.Forms.Control"/> representing the control to get the parking form for.
                </param>
		<returns>
			<para>a Form object.</para>
		</returns>
		<remarks>
			<para>The parking form is an internal form that is used by the .NET Framework as a
                               holding place for controls that have no parent.
                        </para>
		</remarks>
	</doc>
	<doc for="Application.RunDialog">
		<summary>
     Runs a modal dialog.  This starts a special type of message loop that runs until
     the dialog has a valid DialogResult.  This is called internally by a form
     when an application calls System.Windows.Forms.Form.ShowDialog().
 </summary>
		<param name="form">
     The System.Windows.Forms.Form to show modally.
 </param>
	</doc>
	<doc for="Application.ComponentManager">
		<summary>
      This is our implementation of the MSO ComponentManager.  The Componoent Manager is
      an object that is responsible for handling all message loop activity in a process.
      The idea is that someone in the process implements the component manager and then
      anyone who wants access to the message loop can get to it.  We implement this
      so we have good interop with office and VS.  The first time we need a
      component manager, we search the OLE message filter for one.  If that fails, we
      create our own and install it in the message filter.

      This class is not used when running inside the Visual Studio shell.
 </summary>
	</doc>
	<doc for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.QueryService">
		<summary>
      Return in *ppvObj an implementation of interface iid for service
      guidService (same as IServiceProvider::QueryService).
      Return NOERROR if the requested service is supported, otherwise return
      NULL in *ppvObj and an appropriate error (eg E_FAIL, E_NOINTERFACE).
 </summary>
	</doc>
	<doc for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FDebugMessage">
		<summary>
      Standard FDebugMessage method.
      Since IMsoComponentManager is a reference counted interface, 
      MsoDWGetChkMemCounter should be used when processing the 
      msodmWriteBe message.
 </summary>
	</doc>
	<doc for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FRegisterComponent">
		<summary>
      Register component piComponent and its registration info pcrinfo with
      this component manager.  Return in *pdwComponentID a cookie which will
      identify the component when it calls other IMsoComponentManager
      methods.
      Return TRUE if successful, FALSE otherwise.
 </summary>
	</doc>
	<doc for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FRevokeComponent">
		<summary>
      Undo the registration of the component identified by dwComponentID
      (the cookie returned from the FRegisterComponent method).
      Return TRUE if successful, FALSE otherwise.
 </summary>
	</doc>
	<doc for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FUpdateComponentRegistration">
		<summary>
      Update the registration info of the component identified by
      dwComponentID (the cookie returned from FRegisterComponent) with the
      new registration information pcrinfo.
      Typically this is used to update the idle time registration data, but
      can be used to update other registration data as well.
      Return TRUE if successful, FALSE otherwise.
 </summary>
	</doc>
	<doc for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FOnComponentActivate">
		<summary>
      Notify component manager that component identified by dwComponentID
      (cookie returned from FRegisterComponent) has been activated.
      The active component gets the chance to process messages before they
      are dispatched (via IMsoComponent::FPreTranslateMessage) and typically
      gets first crack at idle time after the host.
      This method fails if another component is already Exclusively Active.
      In this case, FALSE is returned and SetLastError is set to 
      msoerrACompIsXActive (comp usually need not take any special action
      in this case).
      Return TRUE if successful.
 </summary>
	</doc>
	<doc for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FSetTrackingComponent">
		<summary>
      Called to inform component manager that  component identified by 
      dwComponentID (cookie returned from FRegisterComponent) wishes
      to perform a tracking operation (such as mouse tracking).
      The component calls this method with fTrack == TRUE to begin the
      tracking operation and with fTrack == FALSE to end the operation.
      During the tracking operation the component manager routes messages
      to the tracking component (via IMsoComponent::FPreTranslateMessage)
      rather than to the active component.  When the tracking operation ends,
      the component manager should resume routing messages to the active
      component.  
      Note: component manager should perform no idle time processing during a
              tracking operation other than give the tracking component idle
              time via IMsoComponent::FDoIdle.
      Note: there can only be one tracking component at a time.
      Return TRUE if successful, FALSE otherwise.
 </summary>
	</doc>
	<doc for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.OnComponentEnterState">
		<summary>
      Notify component manager that component identified by dwComponentID
      (cookie returned from FRegisterComponent) is entering the state
      identified by uStateID (msocstateXXX value).  (For convenience when
      dealing with sub CompMgrs, the host can call this method passing 0 for
      dwComponentID.)  
      Component manager should notify all other interested components within
      the state context indicated by uContext (a msoccontextXXX value),
      excluding those within the state context of a CompMgr in rgpicmExclude,
      via IMsoComponent::OnEnterState (see "Comments on State Contexts", 
      above).
      Component Manager should also take appropriate action depending on the 
      value of uStateID (see msocstate comments, above).
      dwReserved is reserved for future use and should be zero.
      
      rgpicmExclude (can be NULL) is an array of cpicmExclude CompMgrs (can
      include root CompMgr and/or sub CompMgrs); components within the state
      context of a CompMgr appearing in this     array should NOT be notified of 
      the state change (note: if uContext        is msoccontextMine, the only 
      CompMgrs in rgpicmExclude that are checked for exclusion are those that 
      are sub CompMgrs of this Component Manager, since all other CompMgrs 
      are outside of this Component Manager's state context anyway.)
      
      Note: Calls to this method are symmetric with calls to 
      FOnComponentExitState. 
      That is, if n OnComponentEnterState calls are made, the component is
      considered to be in the state until n FOnComponentExitState calls are
      made.  Before revoking its registration a component must make a 
      sufficient number of FOnComponentExitState calls to offset any
      outstanding OnComponentEnterState calls it has made.
      
      Note: inplace objects should not call this method with
      uStateID == msocstateModal when entering modal state. Such objects
      should call IOleInPlaceFrame::EnableModeless instead.
 </summary>
	</doc>
	<doc for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FOnComponentExitState">
		<summary>
      Notify component manager that component identified by dwComponentID
      (cookie returned from FRegisterComponent) is exiting the state
      identified by uStateID (a msocstateXXX value).  (For convenience when
      dealing with sub CompMgrs, the host can call this method passing 0 for
      dwComponentID.)
      uContext, cpicmExclude, and rgpicmExclude are as they are in 
      OnComponentEnterState.
      Component manager  should notify all appropriate interested components
      (taking into account uContext, cpicmExclude, rgpicmExclude) via
      IMsoComponent::OnEnterState (see "Comments on State Contexts", above). 
      Component Manager should also take appropriate action depending on
      the value of uStateID (see msocstate comments, above).
      Return TRUE if, at the end of this call, the state is still in effect
      at the root of this component manager's state context
      (because the host or some other component is still in the state),
      otherwise return FALSE (ie. return what FInState would return).
      Caller can normally ignore the return value.
      
      Note: n calls to this method are symmetric with n calls to 
      OnComponentEnterState (see OnComponentEnterState comments, above).
 </summary>
	</doc>
	<doc for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FInState">
		<summary>
      Return TRUE if the state identified by uStateID (a msocstateXXX value)
      is in effect at the root of this component manager's state context, 
      FALSE otherwise (see "Comments on State Contexts", above).
      pvoid is reserved for future use and should be NULL.
 </summary>
	</doc>
	<doc for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FContinueIdle">
		<summary>
      Called periodically by a component during IMsoComponent::FDoIdle.
      Return TRUE if component can continue its idle time processing, 
      FALSE if not (in which case component returns from FDoIdle.) 
 </summary>
	</doc>
	<doc for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FPushMessageLoop">
		<summary>
      Component identified by dwComponentID (cookie returned from 
      FRegisterComponent) wishes to push a message loop for reason uReason.
      uReason is one the values from the msoloop enumeration (above).
      pvLoopData is data private to the component.
      The component manager should push its message loop, 
      calling IMsoComponent::FContinueMessageLoop(uReason, pvLoopData)
      during each loop iteration (see IMsoComponent::FContinueMessageLoop
      comments).  When IMsoComponent::FContinueMessageLoop returns FALSE, the
      component manager terminates the loop.
      Returns TRUE if component manager terminates loop because component
      told it to (by returning FALSE from IMsoComponent::FContinueMessageLoop),
      FALSE if it had to terminate the loop for some other reason.  In the 
      latter case, component should perform any necessary action (such as 
      cleanup).
 </summary>
	</doc>
	<doc for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FCreateSubComponentManager">
		<summary>
      Cause the component manager to create a "sub" component manager, which
      will be one of its children in the hierarchical tree of component
      managers used to maintiain state contexts (see "Comments on State
      Contexts", above).
      piunkOuter is the controlling unknown (can be NULL), riid is the
      desired IID, and *ppvObj returns   the created sub component manager.
      piunkServProv (can be NULL) is a ptr to an object supporting
      IServiceProvider interface to which the created sub component manager
      will delegate its IMsoComponentManager::QueryService calls. 
      (see objext.h or docobj.h for definition of IServiceProvider).
      Returns TRUE if successful.
 </summary>
	</doc>
	<doc for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FGetParentComponentManager">
		<summary>
      Return in *ppicm an AddRef'ed ptr to this component manager's parent
      in the hierarchical tree of component managers used to maintain state
      contexts (see "Comments on State   Contexts", above).
      Returns TRUE if the parent is returned, FALSE if no parent exists or
      some error occurred.
 </summary>
	</doc>
	<doc for="Application.ComponentManager.UnsafeNativeMethods.IMsoComponentManager.FGetActiveComponent">
		<summary>
      Return in *ppic an AddRef'ed ptr to the current active or tracking
      component (as indicated by dwgac (a msogacXXX value)), and
      its registration information in *pcrinfo.  ppic and/or pcrinfo can be
      NULL if caller is not interested these values.  If pcrinfo is not NULL,
      caller should set pcrinfo-&gt;cbSize before calling this method.
      Returns TRUE if the component indicated by dwgac exists, FALSE if no 
      such component exists or some error occurred.
      dwReserved is reserved for future use and should be zero.
 </summary>
	</doc>
	<doc for="Application.ThreadContext">
		<summary>
     This class is the embodiment of TLS for WinForms.  We do not expose this to end users because
     TLS is really just an unfortunate artifact of using Win 32.  We want the world to be free
     threaded.
 </summary>
	</doc>
	<doc for="Application.ThreadContext.ThreadContext">
		<summary>
     Creates a new thread context object.
 </summary>
	</doc>
	<doc for="Application.ThreadContext.ComponentManager">
		<summary>
      Retrieves the component manager for this process.  If there is no component manager
      currently installed, we install our own.
 </summary>
	</doc>
	<doc for="Application.ThreadContext.AddMessageFilter">
		<summary>
     Allows you to setup a message filter for the application's message pump.  This
     installs the filter on the current thread.
 </summary>
		<param name="f">
     The filter you want to install.
 </param>
	</doc>
	<doc for="Application.ThreadContext.Dispose">
		<summary>
     Disposes this thread context object.  Note that this will marshal to the owning thread.
 </summary>
	</doc>
	<doc for="Application.ThreadContext.DisposeParkingWindow">
		<summary>
     Disposes of this thread's parking form.
 </summary>
	</doc>
	<doc for="Application.ThreadContext.DisposeThreadWindows">
		<summary>
     Gets rid of all windows in this thread context.  Nulls out
     window objects that we hang on to.
 </summary>
	</doc>
	<doc for="Application.ThreadContext.EnsureTLS">
		<summary>
      Ensures that our TLS has been appropriately setup.
 </summary>
	</doc>
	<doc for="Application.ThreadContext.ExitApplication">
		<summary>
     Exits the program by disposing of all thread contexts and message loops.
 </summary>
	</doc>
	<doc for="Application.ThreadContext.Finalize">
		<summary>
     Our finalization.  All we do here is dispose ourselves.
 </summary>
	</doc>
	<doc for="Application.ThreadContext.FromCurrent">
		<summary>
     Retrieves a ThreadContext object for the current thread
 </summary>
		<returns>
     ThreadContext object for the current thread.
 </returns>
	</doc>
	<doc for="Application.ThreadContext.FromId">
		<summary>
     Retrieves a ThreadContext object for the given thread ID
 </summary>
		<returns>
     ThreadContext object for the given thread ID.
 </returns>
	</doc>
	<doc for="Application.ThreadContext.GetAllowQuit">
		<summary>
      Determines if it is OK to allow an application to quit and shutdown
      the runtime.  We only allow this if we own the base message pump.
 </summary>
		<returns>
     true if a message loop exists, or false
     if not.
 </returns>
	</doc>
	<doc for="Application.ThreadContext.GetHandle">
		<summary>
     Retrieves the handle to this thread.
 </summary>
		<returns>
     the thread handle.
 </returns>
	</doc>
	<doc for="Application.ThreadContext.GetId">
		<summary>
     Retrieves the ID of this thread.
 </summary>
		<returns>
     the Win32 thread ID of this thread.
 </returns>
	</doc>
	<doc for="Application.ThreadContext.GetCulture">
		<summary>
     Retrieves the culture for this thread.
 </summary>
		<returns>
     culture object for this thread.
 </returns>
	</doc>
	<doc for="Application.ThreadContext.GetMessageLoop">
		<summary>
     Determines if a message loop exists on this thread.
 </summary>
		<returns>
     true if a message loop exists, or false
     if not.
 </returns>
	</doc>
	<doc for="Application.ThreadContext.OnThreadException">
		<summary>
     Called when an untrapped exception occurs in a thread.  This allows the
     programmer to trap these, and, if left untrapped, throws a standard error
     dialog.
 </summary>
		<param name="t">
     The throwable event that occurred.
 </param>
	</doc>
	<doc for="Application.ThreadContext.SetCulture">
		<summary>
     Sets the culture for this thread.
 </summary>
		<param name="culture">
     The culture object that this thread should be associated with.
 </param>
	</doc>
	<doc for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.FDebugMessage">
		<summary>
      Standard FDebugMessage method.
      Since IMsoComponentManager is a reference counted interface, 
      MsoDWGetChkMemCounter should be used when processing the 
      msodmWriteBe message.
 </summary>
	</doc>
	<doc for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.FPreTranslateMessage">
		<summary>
      Give component a chance to process the message pMsg before it is
      translated and dispatched. Component can do TranslateAccelerator
      do IsDialogMessage, modify pMsg, or take some other action.
      Return TRUE if the message is consumed, FALSE otherwise.
 </summary>
	</doc>
	<doc for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.OnEnterState">
		<summary>  
      Notify component when app enters or exits (as indicated by fEnter)
      the state identified by uStateID (a value from olecstate enumeration).
      Component should take action depending on value of uStateID
       (see olecstate comments, above).

      Note: If n calls are made with TRUE fEnter, component should consider 
      the state to be in effect until n calls are made with FALSE fEnter.
      
     Note: Components should be aware that it is possible for this method to
     be called with FALSE fEnter more    times than it was called with TRUE 
     fEnter (so, for example, if component is maintaining a state counter
     (incremented when this method is called with TRUE fEnter, decremented
     when called with FALSE fEnter), the counter should not be decremented
     for FALSE fEnter if it is already at zero.)  
 </summary>
	</doc>
	<doc for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.OnAppActivate">
		<summary>  
      Notify component when the host application gains or loses activation.
      If fActive is TRUE, the host app is being activated and dwOtherThreadID
      is the ID of the thread owning the window being deactivated.
      If fActive is FALSE, the host app is being deactivated and 
      dwOtherThreadID is the ID of the thread owning the window being 
      activated.
      Note: this method is not called when both the window being activated
      and the one being deactivated belong to the host app.
 </summary>
	</doc>
	<doc for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.OnLoseActivation">
		<summary>      
      Notify the active component that it has lost its active status because
      the host or another component has become active.
 </summary>
	</doc>
	<doc for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.OnActivationChange">
		<summary> 
      Notify component when a new object is being activated.
      If pic is non-NULL, then it is the component that is being activated.
      In this case, fSameComponent is TRUE if pic is the same component as
      the callee of this method, and pcrinfo is the reg info of pic.
      If pic is NULL and fHostIsActivating is TRUE, then the host is the
      object being activated, and pchostinfo is its host info.
      If pic is NULL and fHostIsActivating is FALSE, then there is no current
      active object.

      If pic is being activated and pcrinfo-&gt;grf has the 
      olecrfExclusiveBorderSpace bit set, component should hide its border
      space tools (toolbars, status bars, etc.);
      component should also do this if host is activating and 
      pchostinfo-&gt;grfchostf has the olechostfExclusiveBorderSpace bit set.
      In either of these cases, component should unhide its border space
      tools the next time it is activated.

      if pic is being activated and pcrinfo-&gt;grf has the
      olecrfExclusiveActivation bit is set, then pic is being activated in
      "ExclusiveActive" mode.  
      Component should retrieve the top frame window that is hosting pic
      (via pic-&gt;HwndGetWindow(olecWindowFrameToplevel, 0)).  
      If this window is different from component's own top frame window, 
         component should disable its windows and do other things it would do
         when receiving OnEnterState(olecstateModal, TRUE) notification. 
      Otherwise, if component is top-level, 
         it should refuse to have its window activated by appropriately
         processing WM_MOUSEACTIVATE (but see WM_MOUSEACTIVATE NOTE, above).
      Component should remain in one of these states until the 
      ExclusiveActive mode ends, indicated by a future call to 
      OnActivationChange with ExclusiveActivation bit not set or with NULL
      pcrinfo.
 </summary>
	</doc>
	<doc for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.FDoIdle">
		<summary> 
      Give component a chance to do idle time tasks.  grfidlef is a group of
      bit flags taken from the enumeration of oleidlef values (above),
      indicating the type of idle tasks to perform.  
      Component may periodically call IOleComponentManager::FContinueIdle; 
      if this method returns FALSE, component should terminate its idle 
      time processing and return.  
      Return TRUE if more time is needed to perform the idle time tasks, 
      FALSE otherwise.
      Note: If a component reaches a point where it has no idle tasks
      and does not need FDoIdle calls, it should remove its idle task
      registration via IOleComponentManager::FUpdateComponentRegistration.
      Note: If this method is called on while component is performing a 
      tracking operation, component should only perform idle time tasks that
      it deems are appropriate to perform during tracking.
 </summary>
	</doc>
	<doc for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.FContinueMessageLoop">
		<summary>         
      Called during each iteration of a message loop that the component
      pushed. uReason and pvLoopData are the reason and the component private 
      data that were passed to IOleComponentManager::FPushMessageLoop.
      This method is called after peeking the next message in the queue
      (via PeekMessage) but before the message is removed from the queue.
      The peeked message is passed in the pMsgPeeked param (NULL if no
      message is in the queue).  This method may be additionally called when
      the next message has already been removed from the queue, in which case
      pMsgPeeked is passed as NULL.
      Return TRUE if the message loop should continue, FALSE otherwise.
      If FALSE is returned, the component manager terminates the loop without
      removing pMsgPeeked from the queue. 
 </summary>
	</doc>
	<doc for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.FQueryTerminate">
		<summary> 
      Called when component manager wishes to know if the component is in a
      state in which it can terminate.  If fPromptUser is FALSE, component
      should simply return TRUE if it can terminate, FALSE otherwise.
      If fPromptUser is TRUE, component should return TRUE if it can
      terminate without prompting the user; otherwise it should prompt the
      user, either 1.) asking user if it can terminate and returning TRUE
      or FALSE appropriately, or 2.) giving an indication as to why it
      cannot terminate and returning FALSE. 
 </summary>
	</doc>
	<doc for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.Terminate">
		<summary>     
      Called when component manager wishes to terminate the component's
      registration.  Component should revoke its registration with component
      manager, release references to component manager and perform any
      necessary cleanup. 
 </summary>
	</doc>
	<doc for="Application.ThreadContext.UnsafeNativeMethods.IMsoComponent.HwndGetWindow">
		<summary> 
      Called to retrieve a window associated with the component, as specified
      by dwWhich, a olecWindowXXX value (see olecWindow, above).
      dwReserved is reserved for future use and should be zero.
      Component should return the desired window or NULL if no such window
      exists. 
 </summary>
	</doc>
	<doc for="Application.ParkingWindow">
		<summary>
     This class embodies our parking window, which we create when the
     first message loop is pushed onto the thread.
 </summary>
	</doc>
	<doc for="Application.ThreadWindows">
		<summary>
     This class enables or disables all windows in the current thread.  We use this to
     disable other windows on the thread when a modal dialog is to be shown.  It can also
     be used to dispose all windows in a thread, which we do before returning from a message
     loop.
 </summary>
	</doc>
	<doc for="Application.CompanyName">
		<summary>
			<para>Gets the company name associated with the application.</para>
		</summary>
		<value>
			<para>The company
      name.</para>
		</value>
		<example>
			<para>The following example gets this property and displays its
      value in a text box. The example assumes that <c>textBox1</c> has been placed on a form.</para>
			<codelink SampleID="Classic Application.CompanyName Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Windows.Forms.Application.ProductName"/>
		<seealso cref="System.Windows.Forms.Application.ProductVersion"/>
		<seealso cref="System.Reflection.AssemblyCompanyAttribute"/>
	</doc>
	<doc for="Application.ProductName">
		<summary>
			<para> Gets
      the product name associated with this application.
      </para>
		</summary>
		<value>
			<para> The product
      name.
      </para>
		</value>
		<example>
			<para> The following example gets this property and displays
      its value in a text box. The example assumes that <c>textBox1</c> has been placed on a form.
   </para>
			<codelink SampleID="Classic Application.ProductName Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Windows.Forms.Application.ProductVersion"/>
		<seealso cref="System.Windows.Forms.Application.CompanyName"/>
		<seealso cref="System.Reflection.AssemblyProductAttribute"/>
	</doc>
	<doc for="Application.ProductVersion">
		<summary>
			<para> Gets
      the product version associated with this application.
      </para>
		</summary>
		<value>
			<para> The product version.
      </para>
		</value>
		<remarks>
			<para> Typically, a version number displays as "major number.minor number.build
      number.private part number".
      </para>
		</remarks>
		<example>
			<para> The following example gets this property and displays
      its value in a text box. The example assumes that <c>textBox1</c> has been placed on a form.
   </para>
			<codelink SampleID="Classic Application.ProductVersion Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Windows.Forms.Application.ProductName"/>
		<seealso cref="System.Windows.Forms.Application.CompanyName"/>
		<seealso cref="System.Reflection.AssemblyVersionAttribute"/>
	</doc>
	<doc for="Application.OleRequired">
		<summary>
			<para> Initializes OLE on the current thread.
      </para>
		</summary>
		<returns>
			<para>One of the <see cref="System.Threading.ApartmentState"/> values.</para>
		</returns>
		<remarks>
			<para> Call this method
      before calling any <see langword="Microsoft.Win32"/> method that requires
      OLE. <see cref="System.Windows.Forms.Application.OleRequired"/>
      first checks to see if OLE has been initialized on the current
      thread. If not, it initializes the thread for OLE.
      </para>
			<note type="note">
      Unless a
      thread calls OLE methods directly, you
      do not need to call this method.
      
   </note>
		</remarks>
	</doc>
	<doc for="Application.Idle">
		<summary>
			<para> Occurs when the application finishes processing and is about to enter the
      idle state.
      </para>
		</summary>
		<remarks>
			<para> 
      If
      you have tasks that you must perform before the thread becomes idle, attach them
      to this event.
      </para>
		</remarks>
	</doc>
	<doc for="Application.OnThreadException">
		<summary>
			<para>Raises the <see cref="System.Windows.Forms.Application.ThreadException"/> event.</para>
		</summary>
		<param name="t"><para>An <see cref="System.Exception"/> that represents the exception that was thrown. </para></param>
		<remarks>
			<para> This event enables an
      application to handle an exception intelligently. A window procedure calls this event when it receives
      a thread exception. Attach your event handlers
      to this event.</para>
			<para>Raising an event invokes the event handler through a delegate. For an
      overview, see <see topic="cpconEventsDelegates"/>.</para>
			<note type="inheritinfo">
      When overriding <see cref="System.Windows.Forms.Application.OnThreadException"/>
      in a derived class, be sure to
      call the <see cref="System.Windows.Forms.Application.OnThreadException"/>
      method of the base
      class.
      
   </note>
		</remarks>
		<example>
			<para> The following example raises a <see cref="System.Windows.Forms.Application.ThreadException"/>
event by clicking <c>button1</c>
on a form. The example creates two classes. The <c>ErrorHandler</c> class creates the form
and button that raises the event. The <c>CustomExceptionHandler</c> class provides the methods to handle the exception.</para>
			<para>In <c>Main</c> in the <c>ErrorHandler</c> class, the code creates a new instance of the
exception handling class, that is, an instance of the <c>CustomExceptionHandler</c>. Then the instance is
added to the event, and the application is run.</para>
			<para> In the <c>OnThreadException</c> method in the <c>CustomExceptionHandler</c> class, the example uses
a <see langword="try...catch...finally "/>statement to process the exception. The
<c>ShowThreadExceptionDialog</c>
method creates the message to display, and displays it in a message box.</para>
			<codelink SampleID="Classic Application.OnThreadException Example" SnippetID="1"/>
		</example>
	</doc><doc for="Application.RemoveMessageFilter">
		<summary>
			<para>Removes a message filter from
      the message pump of the application.</para>
		</summary>
		<param name="value">The implementation of the <see cref="System.Windows.Forms.IMessageFilter"/> to remove from the application.</param>
		<remarks>
			<para>You can remove a message filter when you
      no longer want to capture Windows messages before they are
      dispatched.</para>
		</remarks>
		<example>
			<para>Before you can use a message filter, you must provide an implementation for
      the <see cref="System.Windows.Forms.IMessageFilter"/> interface. The following class creates a
      message filter called <c>TestMessageFilter</c>. This filter blocks all messages relating to the
   left mouse button.</para>
			<codelink SampleID="Classic Application.RemoveMessageFilter Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Windows.Forms.Application.AddMessageFilter"/>
	</doc><doc for="Application.ThreadExit">
		<summary>
			<para>Occurs when a thread is about to shut down. When the
      main thread for an application is about to be shut down, this event is
      raised first, followed by an <see cref="System.Windows.Forms.Application.ApplicationExit"/>
      
      event.</para>
		</summary>
		<remarks>
			<para> You must attach the event handlers to the
   <see cref="System.Windows.Forms.Application.ThreadExit"/> 
   event
   to perform any unhandled, required tasks
   before the thread stops running. Close files opened by this thread, or dispose of objects
   that the garbage collector did not reclaim.</para>
		</remarks>
		<seealso cref="System.Windows.Forms.Application.ExitThread"/>
	</doc><doc for="Application.MessageLoop">
		<summary>
			<para> Gets a value indicating whether a message loop exists on this thread.
      </para>
		</summary>
		<value>
			<para><see langword="true "/>if a message loop exists;
   otherwise, <see langword="false"/>.
   </para>
		</value>
	</doc><doc for="Application.AllowQuit">
		<summary>
			<para> Gets a value indicating whether the caller can quit this application.
 </para>
		</summary>
		<value>
			<para><see langword="true"/> if the caller can quit
 this application; otherwise, <see langword="false"/> .</para>
		</value>
		<remarks>
			<para>This property returns <see langword="false"/> if it is called from
 a <see cref="System.Windows.Forms.Control"/> being hosted within a Web browser. Thus,
 the <see cref="System.Windows.Forms.Control"/> cannot quit the <see cref="System.Windows.Forms.Application"/>.</para>
		</remarks>
	</doc><doc for="Application.SafeTopLevelCaptionFormat">
		<summary>
			<para> Gets or sets the format string to apply to top-level window captions
 when they are displayed with a warning banner.</para>
		</summary>
		<value>
			<para> The format string to
 apply to top-level
 window captions.</para>
		</value>
		<permission cref="System.Security.Permissions.UIPermission">for all windows to set this property. Associated enumeration: <see cref="System.Security.Permissions.UIPermissionWindow.AllWindows" qualify="true"/>
		</permission>
	</doc><doc for="Application.CurrentCulture">
		<summary>
			<para> Gets or sets the culture information for the current thread.</para>
		</summary>
		<value>
			<para>A <see cref="System.Globalization.CultureInfo"/> representing the culture information for the
 current thread.</para>
		</value>
		<permission cref="System.Security.Permissions.UIPermission"><para>for all windows to set this property. Associated enumeration: <see cref="System.Security.Permissions.UIPermissionWindow.AllWindows" qualify="true"/>
			</para></permission>
		<example>
			<para>The following example gets this property and displays
 its value in a text box. The example assumes that <c>textBox1</c> has been placed on a form.</para>
			<codelink SampleID="Classic Application.CurrentCulture Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Windows.Forms.InputLanguage"/>
	</doc><doc for="Application.DoEvents">
		<summary>
			<para>Processes
      all Windows messages currently in the message queue.</para>
		</summary>
		<remarks>
			<para> When you run a Windows
      Form, it creates the new form, which then waits for events to handle. Each time the form handles an event, it
      processes all the code associated with that event. All other events wait in the queue.
      While your code handles the event, your application does not respond. For example, the window does
      not repaint if another window is dragged on top.</para>
			<para> If you call <see cref="System.Windows.Forms.Application.DoEvents"/> in your code, your application can handle the other events. For example, if you
   have a form that adds data to a <see cref="System.Windows.Forms.ListBox"/> and
   add <see cref="System.Windows.Forms.Application.DoEvents"/> to your code, your form
   repaints when another window is dragged over it. If you remove <see cref="System.Windows.Forms.Application.DoEvents"/>
   from your code, your form will not repaint
   until the click event handler of the button is finished executing.</para>
			<para>Typically, you use this method in a loop to process messages.</para>
			<note type="caution">
   Calling this method can cause code
   to be re-entered if a message raises an event.
   
</note>
		</remarks>
		<seealso cref="System.Windows.Forms.Application.Exit"/>
		<seealso cref="System.Windows.Forms.Application.ExitThread"/>
		<seealso cref="System.Windows.Forms.Application.Run"/>
	</doc>
	<doc for="Application.ThreadException">
		<summary>
			<para>Occurs when an untrapped thread exception is thrown.</para>
		</summary>
		<remarks>
			<para> This event enables an application
      to handle an exception intelligently when it receives a thread exception from a window procedure.
      Attach your event handlers to the <see cref="System.Windows.Forms.Application.ThreadException"/> event
      to deal with the exception. An appropriate event handler does not terminate
      the thread, and allow your application to continue executing.</para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">for the immediate caller to call unmanaged code when adding a handler to this event. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/></permission>
		<example>
			<para> The following example raises a <see cref="System.Windows.Forms.Application.ThreadException"/>
event by clicking <c>button1</c>
on a form. The example creates two classes. The <c>ErrorHandler</c> class creates the form
and button that raises the event. The <c>CustomExceptionHandler</c> class provides the methods to handle the exception.</para>
			<para>In <c>Main</c> in the <c>ErrorHandler</c> class, the code creates a new instance of the
exception handling class, that is, an instance of the <c>CustomExceptionHandler</c>. Then the instance is
added to the event, and the application is run.</para>
			<para> In the <c>OnThreadException</c> method in the <c>CustomExceptionHandler</c> class, the example uses
a <see langword="try...catch...finally "/>statement to process the exception. The
<c>ShowThreadExceptionDialog</c>
method creates the message to display, and displays it in a message box.</para>
			<codelink SampleID="Classic Application.ThreadException Example" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Application.Exit">
		<summary>
			<para> Informs all message pumps that they must terminate, and
      then closes all application windows after the messages have been processed.</para>
		</summary>
		<remarks>
			<para>This method stops all running message loops on all
      threads and closes all windows of the application. This method does not force
      the application to exit. The <see cref="System.Windows.Forms.Application.Exit"/> method is
      typically called from within a message loop,
      and forces <see cref="System.Windows.Forms.Application.Run"/>
      to return. To exit a message loop for the current
      thread only, call <see cref="System.Windows.Forms.Application.ExitThread"/>.</para>
			<note type="caution">
      The <see cref="System.Windows.Forms.Form.Closed" qualify="true"/> and <see cref="System.Windows.Forms.Form.Closing" qualify="true"/> events are not
      raised when the <see cref="System.Windows.Forms.Application.Exit" qualify="true"/> method is called to exit your
      application. If you have validation code in either of these events that must be
      executed, you should call the <see cref="System.Windows.Forms.Form.Close" qualify="true"/> method for each open form
      individually before calling the <see cref="System.Windows.Forms.Application.Exit"/> method.
      
      </note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">for the immediate caller to call unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/></permission>
		<example>
			<para>The following example lists numbers in a list box on a
      form. Each time you click <c>button1</c> , the application adds another number to the list.</para>
			<para>The <c>Main</c> method calls <see cref="System.Windows.Forms.Application.Run"/> to start the application, which creates the form, <c>listBox1</c>, and <c>button1</c>. When the user clicks <c>button1</c> , the <c>button1_Click</c> method adds numbers one to three to the list box, and displays a <see cref="System.Windows.Forms.MessageBox"/>. If
the user clicks <see langword="No"/> on the <see cref="System.Windows.Forms.MessageBox"/>, the <c>button1_Click</c> method adds another number to
the list. If the user clicks <see langword="Yes"/> , the application calls <see cref="System.Windows.Forms.Application.Exit"/>, to process all remaining messages in the queue and then to quit.</para>
			<para>The example assumes that <c>listBox1</c> and <c>button1</c> have been instantiated and placed on a form.</para>
			<codelink SampleID="Classic Application.Exit Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Windows.Forms.Application.ExitThread"/>
		<seealso cref="System.Windows.Forms.Application.Run"/>
	</doc>
	<doc for="Application.ExitThread">
		<summary>
			<para>Exits the message loop on the
      current thread and closes all windows on the thread.</para>
		</summary>
		<remarks>
			<para> Use this method to exit the message loop of the
      current thread. This method causes the call to <see cref="System.Windows.Forms.Application.Run"/> for the current thread to return. To exit the entire application, call <see cref="System.Windows.Forms.Application.Exit"/>.</para>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">for the immediate caller to call unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/></permission>
		<seealso cref="System.Windows.Forms.Application.Exit"/>
	</doc>
	<doc for="Application.Run">
		<overload>
			<para>Begins running a standard application message loop on the current thread.</para>
		</overload>
		<summary>
			<para>Begins running a
      standard
      application message loop on the current thread,
      without a form.</para>
		</summary>
		<exception cref="System.InvalidOperationException">A main message loop is already running on this thread.</exception>
		<remarks>
			<para> The message loop runs until <see cref="System.Windows.Forms.Application.Exit"/>
or <see cref="System.Windows.Forms.Application.ExitThread"/> is called.</para>
		</remarks>
		<seealso cref="System.Windows.Forms.Application.Exit"/>
		<seealso cref="System.Windows.Forms.Application.ExitThread"/>
		<seealso cref="System.Windows.Forms.Application.DoEvents"/>
	</doc>
	<doc for="Application.CurrentInputLanguage">
		<summary>
			<para>Gets or
      sets the current input language for the current thread.</para>
		</summary>
		<value>
			<para>An <see cref="System.Windows.Forms.InputLanguage"/> representing the current input
   language for the
   current thread.</para>
		</value>
		<permission cref="System.Security.Permissions.SecurityPermission">for the immediate caller to call unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/></permission>
		<example>
			<para>The following example gets this property and displays
      its value in a text box. The example assumes that <c>textBox1</c> has been placed on a form.</para>
			<codelink SampleID="Classic Application.CurrentInputLanguage Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Globalization.CultureInfo"/>
		<seealso cref="System.Windows.Forms.InputLanguage"/>
	</doc>
	<doc for="Application">
		<summary>
			<para>Provides <see langword="static "/>methods
   and properties to manage an application, such as methods to start and stop an application,
   to process Windows messages, and properties to get information about an application. This
   class cannot be inherited.</para>
		</summary>
		<remarks>
			<para>The <see cref="System.Windows.Forms.Application"/> class has methods to start and
   stop applications and threads, and to process Windows messages. Call <see cref="System.Windows.Forms.Application.Run"/> to
   start an application message loop on the current
   thread and, optionally, to make a form visible. Call <see cref="System.Windows.Forms.Application.Exit"/> or <see cref="System.Windows.Forms.Application.ExitThread"/> to stop a message loop.
   Call <see cref="System.Windows.Forms.Application.DoEvents"/>
   to process messages while your program is in a loop.
   Call <see cref="System.Windows.Forms.Application.AddMessageFilter"/> to add
   a message filter to the application message pump to monitor Windows
   messages. An <see cref="System.Windows.Forms.IMessageFilter"/> lets you stop
   an event from being raised or perform special operations
   before invoking an event handler.</para>
			<para>This class has <see cref="System.Windows.Forms.Application.CurrentCulture"/> and <see cref="System.Windows.Forms.Application.CurrentInputLanguage"/>
properties to get or set culture
information for the current thread.</para>
			<para>You cannot create an instance of this class.</para>
		</remarks>
		<example>
			<para>The following example lists numbers in a list box on a
      form. Each time you click <c>button1</c>
   , the application adds another number
   to the list.</para>
			<para>The <c>Main</c> method calls <see cref="System.Windows.Forms.Application.Run"/> to start the application,
which creates the form, <c>listBox1</c> and <c>button1</c>. When the user clicks <c>button1</c>
, the <c>button1_Click</c> method adds numbers
one to three to the list box, and displays a <see cref="System.Windows.Forms.MessageBox"/>. If
the user clicks <see langword="No"/> on
the <see cref="System.Windows.Forms.MessageBox"/>, the <c>button1_Click</c> method adds another number to
the list. If the user clicks <see langword="Yes"/>
, the application calls <see cref="System.Windows.Forms.Application.Exit"/> to process all remaining
messages in the queue and then to quit.</para>
			<para> The example assumes that <c>listBox1</c> and <c>button1</c> have been created and
placed on a form.</para>
			<codelink SampleID="Classic Application Example" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Application.AddMessageFilter">
		<summary>
			<para>Adds a message filter to monitor Windows messages as they are routed to their
      destinations.</para>
		</summary>
		<param name="value">The implementation of the <see cref="System.Windows.Forms.IMessageFilter"/> interface you want to install.</param>
		<remarks>
			<para>Use a message filter to prevent specific events from
      being raised or to perform special operations for an event before it is passed to an event handler.
      Message filters are unique to a specific thread.</para>
			<para>To prevent a message from being dispatched, the <paramref name="value "/>
parameter instance that you pass to this method must override the <see cref="System.Windows.Forms.IMessageFilter.PreFilterMessage"/> method with the code to handle
the message. The method must return <see langword="false"/>.</para>
			<note type="caution">
   
   Adding message filters to the message pump for an application can degrade
   performance.
   
</note>
		</remarks>
		<permission cref="System.Security.Permissions.SecurityPermission">for the immediate caller to call unmanaged code. Associated enumeration: <see cref="System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" qualify="true"/></permission>
		<example>
			<para>Before you can use a message filter, you must provide an implementation for
      the <see cref="System.Windows.Forms.IMessageFilter"/> interface. The following class creates a
      message filter called <c>TestMessageFilter</c>. This filter blocks all messages relating to the
   left mouse button.</para>
			<codelink SampleID="Classic Application.RemoveMessageFilter Example" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Application.UserAppDataRegistry">
		<summary>
			<para> Gets the
      registry key for the application data of a user.</para>
		</summary>
		<value>
			<para>A <see cref="Microsoft.Win32.RegistryKey"/> representing the registry key for the 
   application data specific
   to the
   user.</para>
		</value>
		<remarks>
			<para>If the key does not exist, it is created in the following format:</para>
			<para>CurrentUser\Software\<see cref="System.Windows.Forms.Application.CompanyName"/>\<see cref="System.Windows.Forms.Application.ProductName"/>\<see cref="System.Windows.Forms.Application.ProductVersion"/></para>
			<para>Data stored in this key is part of user profile that is enabled for roaming. 
   A roaming user works on more than one computer in a network. The user profile
   for a roaming user is kept on a server on the network and is loaded onto a
   system when the user logs on. For a user profile to be considered for roaming,
   the operating system must support roaming profiles and it must be enabled.</para>
		</remarks>
		<seealso cref="System.Windows.Forms.SystemInformation"/>
	</doc>
	<doc for="Application.CommonAppDataRegistry">
		<summary>
			<para>Gets the registry
      key for the application data that is shared among all users.</para>
		</summary>
		<value>
			<para>A <see cref="T:Microsoft.Win32.RegistryKey"/> representing the registry key of the 
   application data that
   is shared among all users.</para>
		</value>
		<remarks>
			<para>If the key does not exist, it is created in the following format:</para>
			<para>LocalMachine\Software\<see cref="System.Windows.Forms.Application.CompanyName"/>\<see cref="System.Windows.Forms.Application.ProductName"/>\<see cref="System.Windows.Forms.Application.ProductVersion"/></para>
		</remarks>
	</doc>
	<doc for="Application.CommonAppDataPath">
		<summary>
			<para>Gets
      the path for the application data that is shared among all users.</para>
		</summary>
		<value>
			<para>The path for
      the application data that is shared among all users.</para>
		</value>
		<remarks>
			<para> If a path does not exist, one is created in the
      following format:</para>
			<para>Base Path\<see cref="System.Windows.Forms.Application.CompanyName"/>\<see cref="System.Windows.Forms.Application.ProductName"/>\<see cref="System.Windows.Forms.Application.ProductVersion"/></para>
			<para>A typical Base Path, as identified in the path above, is C:\Documents and 
   Settings\<paramref name="username"/>\Application Data. </para>
		</remarks>
		<seealso cref="System.Windows.Forms.Application.CommonAppDataRegistry"/>
	</doc>
	<doc for="Application.ApplicationExit">
		<summary>
			<para>Occurs when the application is about to shut down.</para>
		</summary>
		<remarks>
			<para> You must attach the event handlers to the
   <see cref="System.Windows.Forms.Application.Exit"/> event
      to perform unhandled, required tasks before
      the application stops running. You can close files opened by this application, or dispose of
      objects that garbage collection did not reclaim.</para>
		</remarks>
		<example>
			<para> The example displays two forms and exits the application
      when both forms are closed. When the application starts and exists, the position
      of each form is remembered. This example demonstrates using the <see cref="System.Windows.Forms.Application.ApplicationExit"/>
      event to know when the form positions should be persisted to the file, and when the FileStream should be closed.</para>
			<para> The class <c>MyApplicationContext</c> inherits from <see cref="System.Windows.Forms.ApplicationContext"/> and keeps
track of when each form is closed, and exits the current thread when they both
are. The class remembers the position of each form when it is closed. When the
<see cref="System.Windows.Forms.Application.ApplicationExit"/> 
event occurs, the class writes
the positions of each for for the user to the file. The form position data is stored in a file
titled <c>appdata.txt</c> that
is created in the location determined by <see cref="System.Windows.Forms.Application.UserAppDataPath"/>. The <c>Main</c> method
calls <see langword="Application.Run(context)"/> to start the application
given the <see cref="System.Windows.Forms.ApplicationContext"/>.</para>
			<para>This code is an excerpt from the example shown in
   the <see cref="System.Windows.Forms.ApplicationContext"/> class overview. Some code is not shown for the purpose of brevity. See <see cref="System.Windows.Forms.ApplicationContext"/> for the whole code listing. </para>
			<codelink SampleID="Application" SnippetID="5"/>
		</example>
		<seealso cref="System.Windows.Forms.Application.Exit"/>
	</doc>
	<doc for="Application.LocalUserAppDataPath">
		<summary>
			<para> Gets the path for the application data of a local, non-roaming
      user.</para>
		</summary>
		<value>
			<para> The
      path for the application data of a local, non-roaming user.</para>
		</value>
		<remarks>
			<para>A local user is one whose user profile
      is stored on the system
      on which the user logged on. If a path does not exist, one is created in
      the following format:</para>
			<para>Base Path\<see cref="System.Windows.Forms.Application.CompanyName"/>\<see cref="System.Windows.Forms.Application.ProductName"/>\<see cref="System.Windows.Forms.Application.ProductVersion"/></para>
			<para>A typical Base Path, as identified in the path above, is C:\Documents and
   Settings\<paramref name="username"/>\Local Settings\Application Data.</para>
		</remarks>
		<example>
			<para> The example displays two forms and exits the application
      when both forms are closed. When the application starts and exists, the position
      of each form is remembered. Although this example demonstrates using the <see cref="System.Windows.Forms.Application.UserAppDataPath"/>
      property to store application data for the user, the <see cref="System.Windows.Forms.Application.LocalUserAppDataPath"/>
      can be used instead.</para>
			<para> The class <c>MyApplicationContext</c> inherits from <see cref="System.Windows.Forms.ApplicationContext"/> and keeps track when each form is closed,
and exits the current thread when they both are. The class stores the positions
of each form for the user. The form position data is stored in a file
titled <c>Appdata.txt</c> that
is created in the location determined by <see cref="System.Windows.Forms.Application.UserAppDataPath"/>. The <c>Main</c> method
calls <see langword="Application.Run(context)"/> to start the application
given the <see cref="System.Windows.Forms.ApplicationContext"/>.</para>
			<para>This code is an excerpt from the example shown in
   the <see cref="System.Windows.Forms.ApplicationContext"/> class overview. Some code is not shown for the purpose of brevity. See <see cref="System.Windows.Forms.ApplicationContext"/> for the whole code listing. </para>
			<codelink SampleID="Application" SnippetID="5"/>
		</example>
	</doc>
	<doc for="Application.Run2">
		<summary>
			<para>Begins running a standard application message loop on the
      current thread, with an <see cref="System.Windows.Forms.ApplicationContext"/>
      .</para>
		</summary>
		<param name="context">An <see cref="System.Windows.Forms.ApplicationContext"/> in which the application is run.</param>
		<exception cref="System.InvalidOperationException">A main message loop is already running on this thread.</exception>
		<remarks>
			<para> The message loop runs until <see cref="System.Windows.Forms.Application.Exit"/>
or <see cref="System.Windows.Forms.Application.ExitThread"/> is called or the <see cref="System.Windows.Forms.Application.ThreadExit"/> event is raised on the context object.</para>
		</remarks>
		<example>
			<para> The example displays two forms and exits the
      application when both forms are closed. When the application starts and exists,
      the position of each form is remembered. This example demonstrates how to use an
   <see cref="System.Windows.Forms.ApplicationContext"/>, along with
      the <see langword="Application.Run(context)"/>
      method, to
      display multiple forms when the application starts. </para>
			<para> The class <c>MyApplicationContext</c> inherits from <see cref="System.Windows.Forms.ApplicationContext"/> and keeps track when each form is closed,
and exits the current thread when they both are. The class stores the positions
of each form for the user. The form position data is stored in a file
titled <c>Appdata.txt</c> that
is created in the location determined by <see cref="System.Windows.Forms.Application.UserAppDataPath"/>. The <c>Main</c> method
calls <see langword="Application.Run(context)"/> to start the application
given the <see cref="System.Windows.Forms.ApplicationContext"/>.</para>
			<para>The code for the <c>AppForm1</c> and <c>AppForm2</c>
forms is not shown for the purpose of brevity. See
the <see cref="System.Windows.Forms.ApplicationContext"/> class overview for the whole code listing. </para>
			<codelink SampleID="Application" SnippetID="2"/>
		</example>
		<seealso cref="System.Windows.Forms.Application.Exit"/>
		<seealso cref="System.Windows.Forms.Application.ExitThread"/>
		<seealso cref="System.Windows.Forms.Application.DoEvents"/>
	</doc>
	<doc for="Application.UserAppDataPath">
		<summary>
			<para> Gets the path for the application data of a
      user.</para>
		</summary>
		<value>
			<para> The path for the application data of a user.</para>
		</value>
		<remarks>
			<para> If a path does not exist, one is created in the
      following format:</para>
			<para>Base Path\<see cref="System.Windows.Forms.Application.CompanyName"/>\<see cref="System.Windows.Forms.Application.ProductName"/>\<see cref="System.Windows.Forms.Application.ProductVersion"/></para>
			<para>Data stored in this path is part of user profile that is
   enabled for roaming. A roaming user works on more than one computer in a
   network. The user profile for a roaming user is kept on a server on the network and is loaded onto a system when the user logs on. For
   a user profile to be considered for roaming, the operating system must support roaming profiles and it
   must be enabled.</para>
			<para>A typical Base Path, as identified in the path above, is C:\Documents
   and Settings\<paramref name="username"/>\Application Data. </para>
		</remarks>
		<example>
			<para> The example displays two forms and exits the application
      when both forms are closed. When the application starts and exists, the position
      of each form is remembered. This example demonstrates using the <see cref="System.Windows.Forms.Application.UserAppDataPath"/>
      property to store application data for the user.</para>
			<para> The class <c>MyApplicationContext</c> inherits from <see cref="System.Windows.Forms.ApplicationContext"/> and keeps track when each form is closed,
and exits the current thread when they both are. The class stores the positions
of each form for the user. The form position data is stored in a file
titled <c>Appdata.txt</c> that
is created in the location determined by <see cref="System.Windows.Forms.Application.UserAppDataPath"/>. The <c>Main</c> method
calls <see langword="Application.Run(context)"/> to start the application
given the <see cref="System.Windows.Forms.ApplicationContext"/>.</para>
			<para>This code is an excerpt from the example shown in
   the <see cref="System.Windows.Forms.ApplicationContext"/> class overview. Some code is not shown for the purpose of brevity. See <see cref="System.Windows.Forms.ApplicationContext"/> for the whole code listing. </para>
			<codelink SampleID="Application" SnippetID="5"/>
		</example>
		<seealso cref="System.Windows.Forms.Application.UserAppDataRegistry"/>
	</doc>
	<doc for="Application.ExecutablePath">
		<summary>
			<para>Gets the path for the executable file that started the application, including the executable name.</para>
		</summary>
		<value>
			<para>The path and executable name for the executable file that started the application.</para>
		</value>
		<permission cref="System.Security.Permissions.FileIOPermission">for getting the path. Associated enumeration: <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/></permission>
	</doc>
	<doc for="Application.StartupPath">
		<summary>
			<para> Gets the path for the executable file
      that started the application, not including the executable name.
      </para>
		</summary>
		<value>
			<para> The
      path for the executable file that started the
      application.
      </para>
		</value>
		<permission cref="System.Security.Permissions.FileIOPermission">for getting the path. Associated enumeration: <see cref="System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" qualify="true"/></permission>
		<example>
			<para> The following example gets this property and displays
      its value in a text box. The example assumes that <c>textBox1</c> has been placed on a form.
   </para>
			<codelink SampleID="Classic Application.StartupPath Example" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Application.Run1">
		<summary>
			<para>Begins running a standard application message loop on the current
      thread, and makes the specified form visible.</para>
		</summary>
		<param name="mainForm"><para>A <see cref="System.Windows.Forms.Form"/> that represents the form to make visible.</para></param>
		<exception cref="System.InvalidOperationException">A main message loop is already running on the current thread.</exception>
		<remarks>
			<para>Typically, the main function of an application calls this method and passes
      to it the main window of the application.</para>
			<para>This method adds an event handler to the <paramref name="mainForm"/> parameter for the <see cref="System.Windows.Forms.Form.Closed"/> event.
   The event handler calls <see cref="System.Windows.Forms.Application.ExitThread"/> to clean
   up the application.</para>
			<note type="note">
   The <see cref="System.Windows.Forms.Control.Dispose"/> method of the <see cref="System.Windows.Forms.Form"/> class
   will be called prior to the return of this method.
</note>
		</remarks>
		<example>
			<para>The following example lists numbers in a list box on a
      form. Each time you click <c>button1</c> , the application adds another number to the list.</para>
			<para>The <c>Main</c> method calls <see cref="System.Windows.Forms.Application.Run"/> to start the application, which creates the form, <c>listBox1</c>, and <c>button1</c>. When the user clicks <c>button1</c> , the <c>button1_Click</c> method adds numbers one to three to the list box, and displays a <see cref="System.Windows.Forms.MessageBox"/>. If
the user clicks <see langword="No"/> on the <see cref="System.Windows.Forms.MessageBox"/>, the <c>button1_Click</c> method adds another number to
the list. If the user clicks <see langword="Yes"/> , the application calls <see cref="System.Windows.Forms.Application.Exit"/> to process all remaining messages in the queue and then to quit.</para>
			<para>The example assumes that <c>listBox1</c> and <c>button1</c> have been created and placed on a form.</para>
			<codelink SampleID="Classic Application.Exit Example" SnippetID="1"/>
		</example>
		<seealso cref="System.Windows.Forms.Application.Exit"/>
		<seealso cref="System.Windows.Forms.Application.ExitThread"/>
		<seealso cref="System.Windows.Forms.Application.DoEvents"/>
	</doc>
	<doc for="Application.EnableVisualStyles">
		<summary>
			<para>Enables Windows XP visual styles for the application.</para>
		</summary>
		<remarks>
			<para> This method enables Windows XP visual styles for the
      application. Controls will draw with visual styles if the control and the
      operating system supports it. To have an effect, <see cref="System.Windows.Forms.Application.EnableVisualStyles"/> must be called before creating
      any controls in the application; typically, <see cref="System.Windows.Forms.Application.EnableVisualStyles"/>
      is the first line in the
   <see langword="Main"/>function. A separate manifest is not required to
      enable visual styles when calling <see langword="EnableVisualStyles"/>
      . </para>
			<para> Be sure to set the <see langword="FlatStyle"/> property 
   to the <see cref="System.Windows.Forms.FlatStyle.System" qualify="true"/> value for the controls that support
   the <see langword="FlatStyle"/>
   property.</para>
			<note type="note">
   This call will have no effect for controls in the browser.
   
</note>
		</remarks>
		<platnote platform="XP"><para>Visual styles are only supported on Windows XP Home Edition, Windows XP Professional, and the Windows .NET Server family.</para>
		</platnote>
		<example>
			<para>The following example demonstrates calling <see cref="System.Windows.Forms.Application.EnableVisualStyles"/> in the <see langword="Main"/> function to enable visual styles for the application.</para>
			<codelink SampleID="System.Windows.Forms.Application.EnableVisualStyles" SnippetID="1"/>
		</example>
		<seealso cref="System.Windows.Forms.FlatStyle"/>
	</doc>
</docs>
