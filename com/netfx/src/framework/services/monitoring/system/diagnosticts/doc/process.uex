<docs>
	<doc for="Process.Associated">
		<summary>
     Returns whether this process component is associated with a real process.
 </summary>
	</doc>
	<doc for="Process.ReleaseProcessHandle">
		<summary>
     Close the process handle if it has been removed.
 </summary>
	</doc>
	<doc for="Process.CompletionCallback">
		<summary>
     This is called from the threadpool when a proces exits.
 </summary>
	</doc>
	<doc for="Process.Dispose">
		<summary>
			<para>
       Free any resources associated with this component.
    </para>
		</summary>
	</doc>
	<doc for="Process.EnsureState">
		<summary>
     Helper method for checking preconditions when accessing properties.
 </summary>
	</doc>
	<doc for="Process.EnsureWatchingForExit">
		<summary>
     Make sure we are watching for a process exit.
 </summary>
	</doc>
	<doc for="Process.EnsureWorkingSetLimits">
		<summary>
			<para>Make sure we have obtained the min and max working set limits.</para>
		</summary>
	</doc>
	<doc for="Process.GetProcessHandle">
		<summary>
     Gets a short-term handle to the process, with the given access.  If a handle exists,
     then it is reused.
 </summary>
	</doc>
	<doc for="Process.GetProcessHandle1">
		<summary>
     Gets a short-term handle to the process, with the given access.  If a handle exists,
     then it is reused.  If the process has exited, it throws an exception.
 </summary>
	</doc>
	<doc for="Process.OpenProcessHandle">
		<summary>
     Opens a long-term handle to the process, with all access.  If a handle exists,
     then it is reused.  If the process has exited, it throws an exception.
 </summary>
	</doc>
	<doc for="Process.RaiseOnExited">
		<summary>
     Raise the Exited event, but make sure we don't do it more than once.
 </summary>
	</doc>
	<doc for="Process.SetProcessHandle">
		<summary>
     Helper to associate a process handle with this component.
 </summary>
	</doc>
	<doc for="Process.SetProcessId">
		<summary>
     Helper to associate a process id with this component.
 </summary>
	</doc>
	<doc for="Process.SetWorkingSetLimits">
		<summary>
     Helper to set minimum or maximum working set limits.
 </summary>
	</doc>
	<doc for="Process.StopWatchingForExit">
		<summary>
     Make sure we are not watching for process exit.
 </summary>
	</doc>
	<doc for="ProcessInfo">
		<summary>
     This data structure contains information about a process that is collected
     in bulk by querying the operating system.  The reason to make this a separate
     structure from the process component is so that we can throw it away all at once
     when Refresh is called on the component.
 </summary>
	</doc>
	<doc for="ThreadInfo">
		<summary>
     This data structure contains information about a thread in a process that
     is collected in bulk by querying the operating system.  The reason to
     make this a separate structure from the ProcessThread component is so that we
     can throw it away all at once when Refresh is called on the component.
 </summary>
	</doc>
	<doc for="ModuleInfo">
		<summary>
     This data structure contains information about a module in a process that
     is collected in bulk by querying the operating system.  The reason to
     make this a separate structure from the ProcessModule component is so that we
     can throw it away all at once when Refresh is called on the component.
 </summary>
	</doc>
	<doc for="MainWindowFinder">
		<summary>
     This class finds the main window of a process.  It needs to be
     class because we need to store state while searching the set
     of windows.
 </summary>
	</doc>
	<doc for="ProcessManager">
		<summary>
     This static class is a platform independent Api for querying information
     about processes, threads and modules.  It delegates to the platform
     specific classes WinProcessManager for Win9x and NtProcessManager
     for WinNt.
 </summary>
	</doc>
	<doc for="WinProcessManager">
		<summary>
     This static class provides the process api for the Win9x platform.
     We use the toolhelp32 api to query process, thread and module information.
 </summary>
	</doc>
	<doc for="NtProcessManager">
		<summary>
     This static class provides the process api for the WinNt platform.
     We use the performance counter api to query process and thread
     information.  Module information is obtained using PSAPI.
 </summary>
	</doc>
	<doc for="NtProcessMetadata">
		<summary>
     When querying the performance counter api for processes, we must first
     query the registry to learn the indices of the counters we are interested
     in.  This object contains the information about the indices.
 </summary>
	</doc>
	<doc for="EnvironmentBlock">
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc>
	<doc for="EnvironmentBlock.toStringDictionary">
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc>
	<doc for="EnvironmentBlock.ToByteArray">
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc>
	<doc for="Process.processTracing">
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc><doc for="Process.processTracing1">
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc><doc for="Process.Finalize">
		<nodoc/>
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc><doc for="Process.Dispose1">
		<summary>
			<para>[To be supplied.]</para>
		</summary>
	</doc><doc for="Process">
		<summary>
			<para> Provides access to local and remote processes and
      enables you to start and stop local system processes.
      </para>
		</summary>
		<remarks>
			<para> A <see cref="System.Diagnostics.Process"/>
component
provides access
to a process that is running on a computer. A process, in the
simplest terms, is a running application. A thread is the basic unit
to which the operating system allocates processor time. A thread can execute any
part of the code of the process, including parts currently being executed
by
another thread.</para>
			<para> The <see cref="System.Diagnostics.Process"/>
component is a useful tool for starting, stopping, controlling, and monitoring
applications. Using the <see cref="System.Diagnostics.Process"/> component, you can obtain a
list of the processes that are running or start a new process. A <see cref="System.Diagnostics.Process"/>
component is used to access system processes. After a <see cref="System.Diagnostics.Process"/> component has been initialized, it can be used to obtain information about the
running process. Such information includes the set of threads, the loaded modules (.dll and .exe
files), and performance information such
as the amount of memory the process is
using.</para>
			<para>If you have a path variable declared in your system using quotes, you must
   fully qualify that path when starting any process found in that location.
   Otherwise, the system will not find the path. For example, if <c>c:\mypath</c> is not in your path, and
you add it using quotation marks: <c>path = %path%;"c:\mypath"</c>, you must fully qualify any process in
<c>c:\mypath</c> when starting 
it.</para>
			<para> The
   
   process component obtains information about a group of properties all at once.
   After the <see cref="System.Diagnostics.Process"/> component has obtained
   information about one member of any group, it will cache
   the values for the other properties in that group and not obtain new information about the other
   members of the group until you call the <see cref="System.Diagnostics.Process.Refresh"/> method. Therefore, a property value
   is not guaranteed to be any newer than the last call to the <see cref="System.Diagnostics.Process.Refresh"/> method. The group breakdowns are
   operating-system dependent. </para>
			<para> A system process is uniquely identified on the system by its process identifier.
   Like many Windows resources, a process is also identified by its handle, which might not be
   unique on the computer. A handle is the generic term for an identifier of a resource.
   The operating system persists the process handle, which is accessed through the
<see cref="System.Diagnostics.Process.Handle"/> property of the <see cref="System.Diagnostics.Process"/>
component, even when the
process has exited. Thus, you can get the process's administrative information, such as the
<see cref="System.Diagnostics.Process.ExitCode"/> (usually either zero for success or a nonzero error
code) and the <see cref="System.Diagnostics.Process.ExitTime"/> . Handles are an extremely valuable
resource, so leaking handles is more virulent than leaking
memory.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<example>
			<para>The following example uses an instance of the <see cref="System.Diagnostics.Process"/>
class to start a process.</para>
			<codelink SampleID="Process.Start_instance" SnippetID="1"/>
			<para>The following example uses the <see cref="System.Diagnostics.Process"/> class itself and a static 
<see cref="System.Diagnostics.Process.Start"/> method to start a process.</para>
			<codelink SampleID="Process.Start_static" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.Process.Start"/>
		<seealso cref="System.Diagnostics.ProcessStartInfo"/>
		<seealso cref="System.Diagnostics.Process.CloseMainWindow"/>
		<seealso cref="System.Diagnostics.Process.Kill"/>
		<seealso cref="System.Diagnostics.ProcessThread"/>
	</doc>
	<doc for="Process.Process">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Diagnostics.Process"/> class.</para>
		</summary>
		<remarks>
			<para>If you do not specify the <see cref="System.Diagnostics.Process.MachineName"/> property, the default is the local
   computer, (".").</para>
			<para>You have two options for associating a new <see cref="System.Diagnostics.Process"/> component with
a process
on the computer. The first option is to use the constructor to
create the <see cref="System.Diagnostics.Process"/> component, set the appropriate
members of the <see cref="System.Diagnostics.Process.StartInfo"/> property and call <see cref="System.Diagnostics.Process.Start"/> to associate the <see cref="System.Diagnostics.Process"/> with a new system process. The
second option is to associate the <see cref="System.Diagnostics.Process"/> with a running system process
by using <see cref="System.Diagnostics.Process.GetProcessById"/> or one of the <see cref="System.Diagnostics.Process.GetProcesses"/>
return values.</para>
			<para>If you use a <see langword="static "/>overload of
the <see cref="System.Diagnostics.Process.Start"/> method to start a new system process, the
method creates a new <see cref="System.Diagnostics.Process"/> component and
associates it with the process.</para>
			<para>When the <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute" qualify="true"/> property is set to its default
value, <see langword="true"/>, you can start applications and documents
in a way that is similar to using
the <see langword="Run"/> dialog box of the Windows <see langword="Start "/>menu. When
<see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute" qualify="true"/> is <see langword="false"/>, you can start 
only executables.</para>
			<para> Any executable file that you can
   call from the command line can be started in one of two ways: by setting the
   appropriate members of the <see cref="System.Diagnostics.Process.StartInfo"/> property and calling the
<see cref="System.Diagnostics.Process.Start"/> method 
   with no parameters, or by passing the appropriate parameter
   to the <see langword="static "/><see cref="System.Diagnostics.Process.Start"/>
   member.</para>
			<para> You can create a <see cref="System.Diagnostics.Process"/> component by using
the constructor, one of the static <see cref="System.Diagnostics.Process.Start"/>
overloads, or any of the <see cref="System.Diagnostics.Process.GetProcessById"/>, <see cref="System.Diagnostics.Process.GetProcesses"/>, or <see cref="System.Diagnostics.Process.GetProcessesByName"/> methods. After you have done so, you have a view
into the associated process. This is not a dynamic view that updates itself
automatically when the process properties have changed in memory. Instead,
you must call <see cref="System.Diagnostics.Process.Refresh"/> for
the component to update the <see cref="System.Diagnostics.Process"/>
property information in your application.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.BasePriority">
		<summary>
			<para> Gets the base priority of
      the associated process.
      </para>
		</summary>
		<value>
			<para> The base priority, which is computed from the <see cref="System.Diagnostics.Process.PriorityClass"/> of the associated process.
   </para>
		</value>
		<exception cref="System.InvalidOperationException"><para>The process has exited.</para>
			<para>-or-</para>
			<para>The process has not started, so there is no process ID.</para></exception>
		<remarks>
			<para> The <see cref="System.Diagnostics.Process.BasePriority"/> of the process is the starting priority for
   threads created within the associated process. You can view information about the base
   priority through the System Monitor's Priority Base counter.
   </para>
			<para> Based on the time elapsed or other boosts, the operating system can
   change the base priority when a process should be placed ahead of
   others.
   </para>
			<para> The <see cref="System.Diagnostics.Process.BasePriority"/> property lets you view the starting priority assigned
to a process. However, because it is read-only, you cannot use the <see cref="System.Diagnostics.Process.BasePriority"/> to
set the priority of the process. To change the priority, use the <see cref="System.Diagnostics.Process.PriorityClass"/> property. The <see cref="System.Diagnostics.Process.BasePriority"/> is viewable using the System Monitor, while the <see cref="System.Diagnostics.Process.PriorityClass"/> is not. Both the <see cref="System.Diagnostics.Process.BasePriority"/> and
the <see cref="System.Diagnostics.Process.PriorityClass"/> can
be viewed programmatically. The following table shows the relationship between <see cref="System.Diagnostics.Process.BasePriority"/> values and <see cref="System.Diagnostics.Process.PriorityClass"/> values.</para>
			<list type="table">
				<listheader>
					<term> BasePriority</term>
					<description> PriorityClass</description>
				</listheader>
				<item>
					<term> 4</term>
					<description><see cref="System.Diagnostics.ProcessPriorityClass.Idle"/></description>
				</item>
				<item>
					<term> 8</term>
					<description><see cref="System.Diagnostics.ProcessPriorityClass.Normal"/></description>
				</item>
				<item>
					<term> 13</term>
					<description><see cref="System.Diagnostics.ProcessPriorityClass.High"/></description>
				</item>
				<item>
					<term> 24</term>
					<description><see cref="System.Diagnostics.ProcessPriorityClass.RealTime"/></description>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<platnote platform="Win98">This property is not available on this platform if you started the process with <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute" qualify="true"/> set to <see langword="true"/>.
</platnote>
		<example>
			<para>The following example starts an instance of the Notepad utility. It
      then retrieves the associated process's physical memory
      usage, base priority, processor time, privileged processor time,
      total processor time, name, and whether it has exited or is
      responding to the UI.</para>
			<codelink SampleID="process_sample" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.Process.PriorityClass"/>
		<seealso cref="System.Diagnostics.ProcessPriorityClass"/>
		<seealso cref="System.Diagnostics.ThreadPriorityLevel"/>
	</doc>
	<doc for="Process.ExitCode">
		<summary>
			<para> Gets the value that the associated process specified when it terminated.</para>
		</summary>
		<value>
			<para> The code that the associated process
      specified when it terminated.</para>
		</value>
		<exception cref="System.InvalidOperationException"><para> The process has not exited.</para>
			<para>-or-</para>
			<para>The process <see cref="System.Diagnostics.Process.Handle"/> is not valid.</para></exception>
		<remarks>
			<para>Use <see cref="System.Diagnostics.Process.ExitCode"/>
to get the status that the system process returned
when it exited. You can use the exit code much like an integer return
value from a <c>main()</c> procedure. How you choose to implement it is
specific to your
application.</para>
			<para> Developers usually indicate a successful exit by an <see cref="System.Diagnostics.Process.ExitCode"/> value of
zero, and designate errors by nonzero values that the calling method can use
to identify the cause of an abnormal process termination. It is not necessary
to follow these guidelines,
but they are the
convention.</para>
			<para>If you try to get the <see cref="System.Diagnostics.Process.ExitCode"/> before the process has exited, the
attempt throws an exception. Examine the
<see cref="System.Diagnostics.Process.HasExited"/> property first to verify
whether the associated process has terminated.</para>
			<para>You can use the <see cref="System.Diagnostics.Process.CloseMainWindow"/> or the <see cref="System.Diagnostics.Process.Kill"/>
method to cause an associated process
to exit.</para>
			<para>There are two ways of being notified when
   the associated process exits: synchronously and asynchronously. Synchronous notification relies on calling
   the <see cref="System.Diagnostics.Process.WaitForExit"/> method
   to pause the processing of your application until the associated component
   exits. Asynchronous notification relies on the <see cref="System.Diagnostics.Process.Exited"/>
   event. In either case, <see cref="System.Diagnostics.Process.EnableRaisingEvents"/> must be set to <see langword="true"/> for
   the <see cref="System.Diagnostics.Process"/>
   component to receive notification that the process
   has exited.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.HasExited"/>
		<seealso cref="System.Diagnostics.Process.CloseMainWindow"/>
		<seealso cref="System.Diagnostics.Process.Kill"/>
		<seealso cref="System.Diagnostics.Process.WaitForExit"/>
		<seealso cref="System.Diagnostics.Process.EnableRaisingEvents"/>
	</doc>
	<doc for="Process.HasExited">
		<summary>
			<para>Gets a
      value indicating whether the associated process has been terminated.</para>
		</summary>
		<value>
			<para><see langword="true "/>if the operating system process referenced by the
<see cref="System.Diagnostics.Process"/> component has terminated; otherwise,
<see langword="false"/>.</para>
		</value>
		<exception cref="System.InvalidOperationException">There is no process associated with the object.</exception>
		<exception cref="System.ComponentModel.Win32Exception">The exit code for the process could not be retrieved.</exception>
		<remarks>
			<para>A value of <see langword="true "/>for <see cref="System.Diagnostics.Process.HasExited"/>
indicates that the associated process has terminated, either normally or
abnormally. You can request or force the associated process to exit by calling
<see cref="System.Diagnostics.Process.CloseMainWindow"/> or <see cref="System.Diagnostics.Process.Kill"/> . If a handle is open to the 
process, the
operating system releases the process
memory when the process has exited, but retains administrative information about the
process, such as the handle, exit code, and exit time. To
get this information, you can use the <see cref="System.Diagnostics.Process.ExitCode"/> and <see cref="System.Diagnostics.Process.ExitTime"/>
properties. These properties are populated automatically
for processes that were started by this component. The administrative information is
released when all the <see cref="System.Diagnostics.Process"/> components that
are associated
with the system process are destroyed and hold no more handles to the exited process.</para>
			<para>A process can terminate independently of your code. If
   you started the process using this component, the system updates the value of <see cref="System.Diagnostics.Process.HasExited"/>
   automatically, even if the associated process exits independently.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.ExitCode"/>
		<seealso cref="System.Diagnostics.Process.ExitTime"/>
		<seealso cref="System.Diagnostics.Process.WaitForExit"/>
		<seealso cref="System.Diagnostics.Process.EnableRaisingEvents"/>
		<seealso cref="System.Diagnostics.Process.OnExited"/>
	</doc>
	<doc for="Process.ExitTime">
		<summary>
			<para> Gets the time that the associated process exited.
      </para>
		</summary>
		<value>
			<para> A <see cref="System.DateTime"/>
that indicates when the associated process was terminated.</para>
		</value>
		<exception cref="System.PlatformNotSupportedException">You are accessing this member using Windows 98.</exception>
		<remarks>
			<para> If the process has not terminated, attempting to retrieve the <see cref="System.Diagnostics.Process.ExitTime"/> property
   throws an exception. Use <see cref="System.Diagnostics.Process.HasExited"/> before getting the <see cref="System.Diagnostics.Process.ExitTime"/> property
   to determine whether the associated process has terminated.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.Handle"/>
		<seealso cref="System.Diagnostics.Process.ExitCode"/>
	</doc>
	<doc for="Process.Handle">
		<summary>
			<para> Returns the associated process's native handle.
      </para>
		</summary>
		<value>
			<para> The handle that the operating system
      assigned to the associated process when the process was started. The system uses this handle to
      keep track of process attributes.
      </para>
		</value>
		<exception cref="System.InvalidOperationException"><para>The process has not been started. The <see cref="System.Diagnostics.Process.Handle"/> property cannot be read because there is no process associated with this <see cref="System.Diagnostics.Process"/> instance.</para>
			<para>-or-</para>
			<para>The <see cref="System.Diagnostics.Process"/> instance has been attached to a running process but you do not have the necessary permissions to get a handle with full access rights.</para></exception>
		<exception cref="System.NotSupportedException">You are trying to access the <see cref="System.Diagnostics.Process.Handle"/> property for a process running on a remote computer.</exception>
		<remarks>
			<para> An application can obtain a handle to a process that can
      be used as a parameter to many process-information and control functions. You
      can use this handle to initialize a <see cref="System.Threading.WaitHandle"/> or to call native methods with platform invoke.
      </para>
			<para> This process handle is private to an
      application--in other words, process handles cannot be shared. A process also has a process <see cref="System.Diagnostics.Process.Id"/>
      which, unlike the <see cref="System.Diagnostics.Process.Handle"/>, is unique and, therefore, valid
      throughout the system. </para>
			<para> Only processes started through a call to <see cref="System.Diagnostics.Process.Start"/>set the <see cref="System.Diagnostics.Process.Handle"/> property of the corresponding
<see cref="System.Diagnostics.Process"/>
instances.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.Id"/>
		<seealso cref="System.Diagnostics.Process.ExitCode"/>
		<seealso cref="System.Diagnostics.Process.ExitTime"/>
		<seealso cref="System.Diagnostics.Process.HandleCount"/>
		<seealso cref="System.Diagnostics.Process.Start"/>
		<seealso cref="System.Diagnostics.Process.Refresh"/>
	</doc>
	<doc for="Process.HandleCount">
		<summary>
			<para> Gets the number of handles opened
      by the process.
      </para>
		</summary>
		<value>
			<para> The number of operating system handles the process has opened.
      </para>
		</value>
		<remarks>
			<para> Handles provide a way for a process
      to refer to objects. A process can obtain handles to files, resources,
      message queues, and many other operating system objects. The operating
      system reclaims the memory associated with the process only when the handle
      count is zero.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<platnote platform="Win98">This property is not available on this platform if you started the process with <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute" qualify="true"/> set to <see langword="true"/>.
</platnote>
		<seealso cref="System.Diagnostics.Process.Handle"/>
		<seealso cref="System.Diagnostics.Process.Start"/>
		<seealso cref="System.Diagnostics.Process.CloseMainWindow"/>
		<seealso cref="System.Diagnostics.Process.Kill"/>
	</doc>
	<doc for="Process.Id">
		<summary>
			<para> Gets
      the unique identifier for the associated process.
      </para>
		</summary>
		<value>
			<para> The system-generated unique identifier of the process
      that is referenced by this <see cref="System.Diagnostics.Process"/>
      instance.
      </para>
		</value>
		<exception cref="System.InvalidOperationException"><para>The process's <see cref="System.Diagnostics.Process.Id"/> property has not been set.</para>
			<para>-or-</para>
			<para>There is no process associated with this <see cref="System.Diagnostics.Process"/> object. </para></exception>
		<remarks>
			<para> The process <see cref="System.Diagnostics.Process.Id"/> does not exist if
   the associated process is not running. Therefore, you should either ensure that
   the process is running before attempting to retrieve the <see cref="System.Diagnostics.Process.Id"/> property or handle the exception that will be thrown
   if the process has not been started. Until the process terminates,
   the process identifier uniquely identifies the process throughout the system.
   </para>
			<para> You can connect a
   process that is running on a local or remote computer to a new <see cref="System.Diagnostics.Process"/> instance by passing the
   process identifier to the <see cref="System.Diagnostics.Process.GetProcessById"/> method. <see cref="System.Diagnostics.Process.GetProcessById"/> is a <see langword="static "/>method that
   creates a new component and sets the <see cref="System.Diagnostics.Process.Id"/> property for the new
<see cref="System.Diagnostics.Process"/> instance 
   automatically.</para>
			<para> Process identifiers can be reused by the system. The
<see cref="System.Diagnostics.Process.Id"/> property 
   value is unique only while the associated process is running. After the
   process has terminated, the system can reuse the <see cref="System.Diagnostics.Process.Id"/>
   property value for an unrelated process.
   </para>
			<para> Because the identifier is unique on
   the system, you can pass it to other threads as an alternative to passing a <see cref="System.Diagnostics.Process"/>
   instance. This action can
   save system resources yet guarantee that the process is correctly identified.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<platnote platform="Win98">This property is not available on this platform if you started the process with <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute" qualify="true"/> set to <see langword="true"/>.
</platnote>
		<seealso cref="System.Diagnostics.Process.Handle"/>
		<seealso cref="System.Diagnostics.Process.GetProcessById"/>
	</doc>
	<doc for="Process.MachineName">
		<summary>
			<para> Gets the name of the computer the associated process is running on.
      </para>
		</summary>
		<value>
			<para> The name of the computer that the associated process is running on.
      </para>
		</value>
		<exception cref="System.InvalidOperationException">There is no process associated with this <see cref="System.Diagnostics.Process"/> object. </exception>
		<remarks>
			<para> You can view statistical data and
      process information for processes running on remote computers but you cannot call
      <see cref="System.Diagnostics.Process.Start"/>, <see cref="System.Diagnostics.Process.CloseMainWindow"/>, or <see cref="System.Diagnostics.Process.Kill"/>
   on remote computers.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<example>
			<para>The following example starts the Notepad utility in a remote machine
      specified by the user in the console. It then retrieves all instances of Notepad
      running on that remote machine, and displays their respective <see cref="System.Diagnostics.Process.ProcessName"/>, <see cref="System.Diagnostics.Process.Id"/> and <see cref="System.Diagnostics.Process.MachineName"/>.</para>
			<codelink SampleID="process_GetProcessesByName2_2" SnippetID="2"/>
		</example>
		<seealso cref="System.Diagnostics.Process.GetProcesses"/>
		<seealso cref="System.Diagnostics.Process.GetProcessById"/>
		<seealso cref="System.Diagnostics.Process.GetProcessesByName"/>
	</doc>
	<doc for="Process.MainWindowHandle">
		<summary>
			<para> Gets the window handle of the main window of the associated process.
      </para>
		</summary>
		<value>
			<para> The system-generated window handle of the main window of the
      associated process.
      </para>
		</value>
		<exception cref="System.InvalidOperationException"><para> The <see cref="System.Diagnostics.Process.MainWindowHandle"/> is not defined because the process has exited.</para></exception>
		<exception cref="System.NotSupportedException">You are attempting to retrieve the <see cref="System.Diagnostics.Process.MainWindowHandle"/> for a process that is running on a remote computer.</exception>
		<remarks>
			<para> You can get the <see cref="System.Diagnostics.Process.MainWindowHandle"/> property only for processes that are running on the local computer. The <see cref="System.Diagnostics.Process.MainWindowHandle"/> property is a value that uniquely identifies the window that
   is associated with the process.</para>
			<para> A process has a main window associated with it
   only if the process has a graphical interface. If the associated process does not
   have a main window, the <see cref="System.Diagnostics.Process.MainWindowHandle"/> value is zero. If you
   have just started a process and want to use its main window handle, consider
   using the <see cref="System.Diagnostics.Process.WaitForInputIdle"/> method
   to allow the process to finish starting, ensuring
   that the main window handle has been created. Otherwise,
   an exception will be thrown.
   </para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<platnote platform="Win98">This property is not available on this platform if you started the process with <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute" qualify="true"/> set to <see langword="true"/>.
</platnote>
		<seealso cref="System.Diagnostics.Process.MainWindowTitle"/>
		<seealso cref="System.Diagnostics.Process.MainModule"/>
	</doc>
	<doc for="Process.MainWindowTitle">
		<summary>
			<para> Gets the caption of the main window
      of the process.</para>
		</summary>
		<value>
			<para>The process's main window title. </para>
		</value>
		<remarks>
			<para>A process has a main window associated with it only if the process has a
      graphical interface. If the associated process does not have a main window (so
      that <see cref="System.Diagnostics.Process.MainWindowHandle"/> is zero), <see cref="System.Diagnostics.Process.MainWindowTitle"/> is an
      empty string (""). If you have just started a process and want to use its main
      window title, consider using the <see cref="System.Diagnostics.Process.WaitForInputIdle"/> method to allow the
      process to finish starting, ensuring that the main window handle has been
      created. Otherwise, the system
      throws an exception. </para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<platnote platform="Win98">This property is not available on this platform if you started the process with <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute" qualify="true"/> set to <see langword="true"/>.
</platnote>
		<example>
			<para>The following example starts an instance of the Notepad utility and retrieves
      the caption of the main window of the process.</para>
			<codelink SampleID="process_MainWindowTitle" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Process.MainModule">
		<summary>
			<para> Gets
      the main module for the associated process.
      </para>
		</summary>
		<value>
			<para> The <see cref="System.Diagnostics.ProcessModule"/>
that was used to start the process.</para>
		</value>
		<exception cref="System.NotSupportedException"> You are attempting to access this property for a process on a remote computer. </exception>
		<remarks>
			<para> A process module represents a .dll or .exe file that is loaded into a
      particular process. The <see cref="System.Diagnostics.Process.MainModule"/> property lets you view
      information about the executable used to start the
      process, including the module name, file name, and module memory
      details.
      </para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<platnote platform="Win98">This property is not available on this platform if you started the process with <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute" qualify="true"/> set to <see langword="true"/>.
</platnote>
		<seealso cref="System.Diagnostics.Process.Modules"/>
	</doc>
	<doc for="Process.MaxWorkingSet">
		<summary>
			<para> Gets or sets the maximum allowable working set size for the associated
      process.
      </para>
		</summary>
		<value>
			<para> The maximum working set size that is allowed in memory for the process.
      </para>
		</value>
		<exception cref="Win32Exception"><para>Working set information could not be retrieved from the associated process resource.</para>
			<para>-or-</para>
			<para> The process identifier or process handle is zero. (The process has not been started.)</para></exception>
		<exception cref="System.NotSupportedException">You are attempting to access the <see cref="System.Diagnostics.Process.MaxWorkingSet"/> property for a process that is running on a remote computer. The property is available only for processes running on the local computer.</exception>
		<exception cref="System.InvalidOperationException"><para>The process <see cref="System.Diagnostics.Process.Id"/> is not available.</para>
			<para>-or-</para>
			<para>The process has exited.</para></exception>
		<exception cref="System.PlatformNotSupportedException">You are accessing this member using Windows 98.</exception>
		<remarks>
			<para> The working set of a program is a collection
      of those pages in the program's virtual address space that have recently been referenced.
      </para>
			<para> The working set includes both shared and private data. The shared data includes the pages that contain all the
      instructions that your application executes, including the pages in your .dll files and
      the system .dll files. As the working set size increases, memory demand increases.
      </para>
			<para> A process has minimum and maximum working set sizes. Each time
      a process resource is created, the system reserves
      an amount of memory equal to the minimum working set size for the
      process. The virtual memory manager attempts to keep at least this amount of memory resident when
      the process is active, but it never keeps more than the maximum size.
      </para>
			<para> The system sets the default working set
      sizes. You can modify these sizes using the <see cref="System.Diagnostics.Process.MaxWorkingSet"/> and <see cref="System.Diagnostics.Process.MinWorkingSet"/> members. However, setting these
      values does not guarantee that the memory will be reserved or
      resident.
      
      </para>
			<note type="note">
      Be careful
      about requesting a minimum or
      maximum working set size that is too large, because doing so can degrade system
      performance.
      
      </note>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.MinWorkingSet"/>
	</doc>
	<doc for="Process.MinWorkingSet">
		<summary>
			<para> Gets or sets the minimum allowable working set size for the associated
      process.
      </para>
		</summary>
		<value>
			<para> The minimum requested working set size of memory for the process.
      </para>
		</value>
		<exception cref="Win32Exception"><para>Working set information could not be retrieved from the associated process resource.</para>
			<para>-or-</para>
			<para> The process identifier or process handle is zero. (The process has not been started.)</para></exception>
		<exception cref="System.SystemException"><para>You are attempting to access the <see cref="System.Diagnostics.Process.MaxWorkingSet"/> property for a process that is running on a remote computer. The property is available only for processes running on the local computer.</para>
			<para>-or-</para>
			<para>The process <see cref="System.Diagnostics.Process.Id"/> is not available.</para>
			<para>-or-</para>
			<para>The process has exited.</para></exception>
		<exception cref="System.PlatformNotSupportedException"> You are accessing this member using Windows 98.</exception>
		<remarks>
			<para>The working set of a program is a collection of those pages in the program's
      virtual address space that have recently been referenced. </para>
			<para>The working set includes both shared and private data. The shared data
      includes the pages that contain all the instructions that your application
      executes, including the pages in your .dll files and the system .dll files. As
      the working set size increases, memory demand increases. </para>
			<para>A process has minimum and maximum working set sizes. Each time a process
      resource is created, the system reserves an amount of memory equal to the
      minimum working set size for the process. The virtual memory manager attempts to
      keep at least this amount of memory resident when the process is active, but it
      never keeps more than the maximum size. </para>
			<para>The system sets the default working set sizes. You can modify these sizes
      using the <see cref="System.Diagnostics.Process.MaxWorkingSet"/> and <see cref="System.Diagnostics.Process.MinWorkingSet"/> members. However, setting these
      values does not guarantee that the memory will be reserved or resident.
      </para>
			<note type="note">
      Be careful about requesting a minimum
      or maximum working set size that is too large, because doing so can degrade
      system performance.
      
      </note>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.MaxWorkingSet"/>
	</doc>
	<doc for="Process.Modules">
		<summary>
			<para> Gets
      the modules that have been loaded by the associated process.
      </para>
		</summary>
		<value>
			<para> An array of type <see cref="System.Diagnostics.ProcessModule"/> that represents the modules that have been
   loaded by the associated process.
   </para>
		</value>
		<exception cref="System.SystemException"><para>You are attempting to access the <see cref="System.Diagnostics.Process.Modules"/> property for a process that is running on a remote computer. The property is available only for processes running on the local computer.</para>
			<para>-or-</para>
			<para>The process <see cref="System.Diagnostics.Process.Id"/> is not available.</para></exception>
		<remarks>
			<para> A process module represents a .dll or .exe file that is
      loaded into a particular process. A <see cref="System.Diagnostics.ProcessModule"/> instance lets you view information
      about a module, including the module name, file name, and module memory details.
      </para>
			<para> A process can load multiple modules into memory.
      For example, .exe files that load additional .dll
      files have multiple modules.
      </para>
			<para>After starting the process, this collection is empty until the system has
      loaded the process. If the process has a main window, you can
      call <see cref="System.Diagnostics.Process.WaitForInputIdle"/> before retrieving this property to
      ensure that the collection is nonempty when you get the list. </para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<platnote platform="Win98">This property is not available on this platform if you started the process with <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute" qualify="true"/> set to <see langword="true"/>.
</platnote>
		<seealso cref="System.Diagnostics.ProcessModule"/>
	</doc>
	<doc for="Process.NonpagedSystemMemorySize">
		<summary>
			<para> Gets the nonpaged system memory size allocated to this process.</para>
		</summary>
		<value>
			<para> The amount of memory the system has allocated for
      the associated process that cannot be written to the virtual memory paging
      file.</para>
		</value>
		<exception cref="System.PlatformNotSupportedException">You are accessing this member using Windows 98.</exception>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.PagedMemorySize">
		<summary>
			<para> Gets the paged memory size.</para>
		</summary>
		<value>
			<para> The amount of memory allocated by the associated process that can be
      written to the virtual memory paging file.</para>
		</value>
		<exception cref="System.PlatformNotSupportedException"> You are accessing this member using Windows 98.</exception>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.PagedSystemMemorySize">
		<summary>
			<para> Gets the paged system memory
      size.</para>
		</summary>
		<value>
			<para> The amount of memory the system has allocated for the
      associated process that can be written to the virtual memory paging file.</para>
		</value>
		<exception cref="System.PlatformNotSupportedException"> You are accessing this member using Windows 98.</exception>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.PeakPagedMemorySize">
		<summary>
			<para> Gets the peak paged memory size.
      </para>
		</summary>
		<value>
			<para> The maximum amount of memory allocated by the associated process that
      could be written to the virtual memory paging file.</para>
		</value>
		<exception cref="System.PlatformNotSupportedException"> You are accessing this member using Windows 98.</exception>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.PeakWorkingSet">
		<summary>
			<para> Gets the
      peak working set size.
      </para>
		</summary>
		<value>
			<para>The maximum amount of physical memory that the associated process has
      required all at once.</para>
		</value>
		<exception cref="System.PlatformNotSupportedException"> You are accessing this member using Windows 98.</exception>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.PeakVirtualMemorySize">
		<summary>
			<para> Gets the peak
      virtural memory size.</para>
		</summary>
		<value>
			<para>The maximum amount of virtual memory that the associated process has
      requested.</para>
		</value>
		<exception cref="System.PlatformNotSupportedException"> You are accessing this member using Windows 98.</exception>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.PriorityBoostEnabled">
		<summary>
			<para> Gets or sets a value indicating whether the associated process priority
      should temporarily be boosted by the operating system when the main window has
      the focus.
      </para>
		</summary>
		<value>
			<para><see langword="true "/>if dynamic boosting of the process priority should take place
   for a process when it is taken out of the wait state; otherwise,
<see langword="false"/>. The default is <see langword="false"/>.
   </para>
		</value>
		<exception cref="Win32Exception"><para>Priority boost information could not be retrieved from the associated process resource.</para></exception>
		<exception cref="System.PlatformNotSupportedException"><para> You are accessing this member using Windows 98.</para>
			<para>-or-</para>
			<para> The process identifier or process handle is zero. (The process has not been started.)</para></exception>
		<exception cref="System.SystemException"><para>You are attempting to access the <see cref="System.Diagnostics.Process.PriorityBoostEnabled"/> property for a process that is running on a remote computer. The property is available only for processes running on the local computer.</para>
			<para>-or-</para>
			<para>The process <see cref="System.Diagnostics.Process.Id"/> is not available.</para></exception>
		<remarks>
			<para> When a thread runs in a process for which the priority class has one of the
      dynamic priority enumeration values (<see cref="System.Diagnostics.ProcessPriorityClass.Normal"/>,
      <see cref="System.Diagnostics.ProcessPriorityClass.High"/>, or <see cref="System.Diagnostics.ProcessPriorityClass.RealTime"/>), the system temporarily boosts
      the thread's priority when it is taken out of a wait state. This action prevents
      other processes from interrupting the processing of the current thread. The
      <see cref="System.Diagnostics.Process.PriorityBoostEnabled"/> setting
      affects all the existing threads and any
      threads subsequently created by the process. To restore normal behavior, set the
      <see cref="System.Diagnostics.Process.PriorityBoostEnabled"/> property to <see langword="false"/>.
      </para>
			<note type="note">
      Boosting the priority too high can drain resources from essential operating
      system and network functions, causing problems with other operating system tasks.
      
      </note>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.PriorityClass"/>
		<seealso cref="System.Diagnostics.Process.BasePriority"/>
	</doc>
	<doc for="Process.PriorityClass">
		<summary>
			<para> Gets or sets the overall priority category for the
      associated process.
      </para>
		</summary>
		<value>
			<para> The priority category for the associated process, from
      which the <see cref="System.Diagnostics.Process.BasePriority"/> of the
      process is calculated.
      </para>
		</value>
		<exception cref="T:System.ComponentModel.Win32Exception"><para>Process priority information could not be set or retrieved from the associated process resource.</para>
			<para>-or-</para>
			<para> The process identifier or process handle is zero. (The process has not been started.)</para></exception>
		<exception cref="System.SystemException"><para>You are attempting to access the <see cref="System.Diagnostics.Process.PriorityClass"/> property for a process that is running on a remote computer. The property is available only for processes running on the local computer.</para>
			<para>-or-</para>
			<para>The process <see cref="System.Diagnostics.Process.Id"/> was not available.</para></exception>
		<exception cref="System.PlatformNotSupportedException">You have set the <see cref="System.Diagnostics.Process.PriorityClass"/> to <see langword="AboveNormal"/> or <see langword="BelowNormal"/> when using Windows 98. These platforms do not support those values for the priority class.</exception>
		<remarks>
			<para> A process priority class encompasses a range of thread
      priority levels. Threads with different priorities that are running in the
      process run relative to the priority class of the process. Win32 uses
      four priority classes with seven base priority levels per class. These
      process priority classes are captured in the <see cref="System.Diagnostics.ProcessPriorityClass"/>
      enumeration, which lets you
      set the process priority to
      <see cref="System.Diagnostics.ProcessPriorityClass.Idle"/>, <see cref="System.Diagnostics.ProcessPriorityClass.Normal"/>, <see cref="System.Diagnostics.ProcessPriorityClass.High"/>, <see cref="System.Diagnostics.ProcessPriorityClass.High"/>,
      <see cref="System.Diagnostics.ProcessPriorityClass.BelowNormal"/>, or
      <see cref="System.Diagnostics.ProcessPriorityClass.RealTime"/>. Based on the time elapsed or other boosts, the
      base priority level can be changed by the operating system when a process needs
      to be put ahead of others for access to the processor. In addition, you can
      set the <see cref="System.Diagnostics.Process.PriorityBoostEnabled"/> to
      temporarily
      boost the priority level of threads that have been
      taken out of the wait state. The priority is reset when the process returns
      to the wait state.
      </para>
			<para> The <see cref="System.Diagnostics.Process.BasePriority"/> property lets you view the starting priority that is assigned
   to a process. However, because it is read-only, you cannot use the <see cref="System.Diagnostics.Process.BasePriority"/> property
   to set the priority of a process. To change the priority, use the <see cref="System.Diagnostics.Process.PriorityClass"/> property, which gets or sets the overall
   priority category for the process.
   </para>
			<para> The priority class cannot be viewed using System
   Monitor. The following table shows the relationship between the <see cref="System.Diagnostics.Process.BasePriority"/> and <see cref="System.Diagnostics.Process.PriorityClass"/>
   values.
   </para>
			<list type="table">
				<listheader>
					<term> BasePriority</term>
					<description> PriorityClass</description>
				</listheader>
				<item>
					<term> 4</term>
					<description><see cref="System.Diagnostics.ProcessPriorityClass.Idle"/></description>
				</item>
				<item>
					<term> 8</term>
					<description><see cref="System.Diagnostics.ProcessPriorityClass.Normal"/></description>
				</item>
				<item>
					<term> 13</term>
					<description><see cref="System.Diagnostics.ProcessPriorityClass.High"/></description>
				</item>
				<item>
					<term> 24</term>
					<description><see cref="System.Diagnostics.ProcessPriorityClass.RealTime"/></description>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<platnote platform="Win98">Setting the priority class to <see cref="System.Diagnostics.ProcessPriorityClass.AboveNormal"/> or <see cref="System.Diagnostics.ProcessPriorityClass.BelowNormal"/> causes an exception to be thrown.
</platnote>
		<seealso cref="System.Diagnostics.Process.BasePriority"/>
		<seealso cref="System.Diagnostics.Process.PriorityBoostEnabled"/>
	</doc>
	<doc for="Process.PrivateMemorySize">
		<summary>
			<para> Gets the private memory size.</para>
		</summary>
		<value>
			<para> The number of bytes allocated by the associated process that cannot be
      shared with other processes.</para>
		</value>
		<exception cref="System.PlatformNotSupportedException"> You are accessing this member using Windows 98.</exception>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.PrivilegedProcessorTime">
		<summary>
			<para> Gets the privileged processor time for
      this process.</para>
		</summary>
		<value>
			<para>A <see cref="System.TimeSpan"/> that indicates the amount of time that the process has spent running code inside the operating
   system core.</para>
		</value>
		<exception cref="System.PlatformNotSupportedException">You are accessing this member using Windows 98.</exception>
		<example>
			<para>The following example starts an instance of the Notepad utility. It then
      retrieves the associated process's physical memory usage, base priority,
      processor time, privileged processor time, total processor time, name, and
      whether it has exited or is responding to the UI.</para>
			<codelink SampleID="process_sample" SnippetID="1"/>
		</example>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.UserProcessorTime"/>
		<seealso cref="System.Diagnostics.Process.PrivilegedProcessorTime"/>
	</doc>
	<doc for="Process.ProcessName">
		<summary>
			<para> Gets the name of the process.
      </para>
		</summary>
		<value>
			<para> The name that the system uses to identify the process to the
      user.
      </para>
		</value>
		<exception cref="System.SystemException"><para>The process does not have an identifier, or no process is associated with the <see cref="System.Diagnostics.Process"/>.</para>
			<para>-or-</para>
			<para>The associated process has exited.</para></exception>
		<remarks>
			<para> The <see cref="System.Diagnostics.Process.ProcessName"/>
property holds an
executable file name, such as Outlook, that does not include the .exe extension or the
path. It
is helpful for getting and manipulating all
the processes that are associated with the same executable file.</para>
			<note type="note">
   The <see cref="System.Diagnostics.Process.ProcessName"/> property holds up to fifteen
   characters.
</note>
			<para>   You can call <see cref="System.Diagnostics.Process.GetProcessesByName"/>, passing it an executable file
name, to retrieve an array that contains every running instance on the specified
computer. You can use this array, for example, to shut down all the running
instances of the executable file.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<platnote platform="Win98">This property is not available on this platform if you started the process with <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute" qualify="true"/> set to <see langword="true"/>.
</platnote>
		<seealso cref="System.Diagnostics.Process.GetProcessesByName"/>
	</doc>
	<doc for="Process.ProcessorAffinity">
		<summary>
			<para> Gets or
      sets the processors on which the threads in this process can be scheduled to run.
      </para>
		</summary>
		<value>
			<para> A bitmask representing the processors that the threads in
      the associated process can run on. The default depends on the number of
      processors on the computer. The default value is 2<superscript term="n"/>
      -1, where n is the number of processors.
      </para>
		</value>
		<exception cref="Win32Exception"><para>
				<see cref="System.Diagnostics.Process.ProcessorAffinity"/> information could not be set or retrieved from the associated process resource.</para>
			<para>-or-</para>
			<para> The process identifier or process handle is zero. (The process has not been started.)</para></exception>
		<exception cref="System.SystemException"><para>The process <see cref="System.Diagnostics.Process.Id"/> was not available.</para>
			<para>-or-</para>
			<para>The process has exited.</para></exception>
		<remarks>
			<para> In Windows 2000 and later, a thread in a process can
      migrate from processor to processor, with each migration reloading the processor
      cache. Under heavy system loads, specifying which processor should run a specific thread
      can improve performance by reducing the number of times the processor cache is reloaded. The
      association between a processor and a thread is called the processor affinity.
      </para>
			<para> Each processor is
      represented as a bit. Bit 0 is processor one, bit 1 is processor two, and
      so forth. If you set a bit to to the value 1, the corresponding processor
      is selected for thread assignment. When you set the <see cref="System.Diagnostics.Process.ProcessorAffinity"/> value to zero, the operating system's scheduling
      algorithms set the thread's affinity. When the <see cref="System.Diagnostics.Process.ProcessorAffinity"/> value is set to any nonzero value, the value is
      interpreted as a bitmask that specifies those processors eligible for
      selection.
      </para>
			<para> The following table shows a selection of <see cref="System.Diagnostics.Process.ProcessorAffinity"/> values for an eight-processor
   system.
   </para>
			<list type="table">
				<listheader>
					<term> Bitmask</term>
					<description> Binary value</description>
					<description> Eligible processors</description>
				</listheader>
				<item>
					<term> 0x0001</term>
					<description> 00000000 00000001</description>
					<description> 1</description>
				</item>
				<item>
					<term> 0x0003</term>
					<description> 00000000 00000011</description>
					<description> 1 and 2</description>
				</item>
				<item>
					<term> 0x0007</term>
					<description> 00000000 00000111</description>
					<description> 1, 2 and 3</description>
				</item>
				<item>
					<term> 0x0009</term>
					<description> 00000000 00001001</description>
					<description> 1 and 4</description>
				</item>
				<item>
					<term> 0x007F</term>
					<description> 00000000 01111111</description>
					<description> 1, 2, 3, 4, 5, 6 and 7</description>
				</item>
			</list>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.Responding">
		<summary>
			<para> Gets a value indicating whether the user
      interface of the process is responding.
      </para>
		</summary>
		<value>
			<para><see langword="true"/> if the user interface of the associated process is
   responding to the system; otherwise, <see langword="false"/>.
   </para>
		</value>
		<remarks>
			<para>If a process has a user interface, the
      <see cref="System.Diagnostics.Process.Responding"/> property
      
      contacts the user interface to determine whether the process is responding
      to user input. If the interface does not respond immediately, the <see cref="System.Diagnostics.Process.Responding"/> property returns <see langword="false"/> . Use this property to determine whether the
      interface of the associated process has stopped responding. </para>
			<para> If the process does not have a <see cref="System.Diagnostics.Process.MainWindowHandle"/>
, this property returns
<see langword="true"/>.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<platnote platform="Win98">This property is not available on this platform if you started the process with <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute" qualify="true"/> set to <see langword="true"/>.
</platnote>
		<seealso cref="System.Diagnostics.Process.MainWindowHandle"/>
	</doc>
	<doc for="Process.StartInfo">
		<summary>
			<para> Gets or sets the properties to pass to the <see cref="System.Diagnostics.Process.Start"/> method of the <see cref="System.Diagnostics.Process"/>
.</para>
		</summary>
		<value>
			<para> The <see cref="System.Diagnostics.ProcessStartInfo"/> that represents
   the data with which
   to start the process. These arguments include the name of the executable file or document used to start the
   process.</para>
		</value>
		<exception cref="System.ArgumentException">The value that specifies the <see cref="System.Diagnostics.Process.StartInfo"/> is <see langword="null"/>. </exception>
		<remarks>
			<para><see cref="System.Diagnostics.Process.StartInfo"/> represents
   the set of parameters to use to start a process. When
<see cref="System.Diagnostics.Process.Start"/> is
   called, the <see cref="System.Diagnostics.Process.StartInfo"/> is used to specify the process to
   start.</para>
			<para> The only necessary <see cref="System.Diagnostics.Process.StartInfo"/> member to set is the <see cref="System.Diagnostics.ProcessStartInfo.FileName"/>
property. Starting a process
by specifying the <see cref="System.Diagnostics.ProcessStartInfo.FileName"/> property is similar to typing the
information in the <see langword="Run "/>dialog box of the Windows
<see langword="Start "/>menu. Therefore, the <see cref="System.Diagnostics.ProcessStartInfo.FileName"/> 
property
does not need to represent an executable file. It can be of any file type for
which the extension has been associated with an application installed on the
system. For example the <see cref="System.Diagnostics.ProcessStartInfo.FileName"/> can have
a .txt extension if you have associated text
files with an editor, such as Notepad, or it can have a .doc if you
have associated .doc files with a word processing tool, such as Microsoft Word.
Similarly, in the same way that the <see langword="Run "/>dialog box can accept an executable file name with or without the .exe
extension, the .exe extension is optional in the <see cref="System.Diagnostics.ProcessStartInfo.FileName"/> member. For example, you can set the <see cref="System.Diagnostics.ProcessStartInfo.FileName"/> property to either "Notepad.exe" or "Notepad".</para>
			<para> If the file name involves a nonexecutable file, such as
   a .doc file, you can include a verb specifying what action to take on
   the file. For example, you could set the <see cref="System.Diagnostics.ProcessStartInfo.Verb"/> to "Print" for a file
   ending in the .doc extension. The file name specified in the <see cref="System.Diagnostics.ProcessStartInfo.FileName"/> property does not need to have an extension
   if you manually enter a value for the <see cref="System.Diagnostics.ProcessStartInfo.Verb"/> property. However, if you use the <see cref="System.Diagnostics.ProcessStartInfo.Verbs"/> property to determine what verbs are available, you must include the
   extension.</para>
			<para> When the process is started, the file name
   is the file that populates the (read-only) <see cref="System.Diagnostics.Process.MainModule"/>
   property. If you want to retrieve the executable file
   that is associated with the process after the process has started, use the <see cref="System.Diagnostics.Process.MainModule"/> property. If you want to set
   the executable file of a <see cref="System.Diagnostics.Process"/> instance for which an associated process
   has not been started, use the <see cref="System.Diagnostics.Process.StartInfo"/> property's <see cref="System.Diagnostics.ProcessStartInfo.FileName"/> member. Because the members of
   the <see cref="System.Diagnostics.Process.StartInfo"/> property are arguments that are
   passed to the <see cref="System.Diagnostics.Process.Start"/> method of a process, changing the
<see cref="System.Diagnostics.ProcessStartInfo.FileName"/> property after the associated process
   has started will not reset the <see cref="System.Diagnostics.Process.MainModule"/> property. These properties are used
   only to initialize the associated process.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<example>
			<para>The following example populates a <see cref="System.Diagnostics.Process.StartInfo"/> with the file to execute, the action
   performed on it and whether it should displays a user interface. </para>
			<codelink SampleID="Process.Start_instance" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.Process.Start"/>
		<seealso cref="System.Diagnostics.ProcessStartInfo.FileName"/>
	</doc>
	<doc for="Process.StartTime">
		<summary>
			<para>Gets the time that the associated process was started.</para>
		</summary>
		<value>
			<para>A <see cref="System.DateTime"/>
that indicates when the process started. This only has meaning for started
processes.</para>
		</value>
		<exception cref="System.PlatformNotSupportedException"> You are accessing this member using Windows 98.</exception>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.SynchronizingObject">
		<summary>
			<para> Gets or sets the object used to
      marshal the event handler calls that are issued as a result
      of a process exit event.</para>
		</summary>
		<value>
			<para>The <see cref="System.ComponentModel.ISynchronizeInvoke"/> used to
   marshal event handler calls that
   are issued as a result of an <see cref="System.Diagnostics.Process.Exited"/> event on the process.</para>
		</value>
		<remarks>
			<para>When <see cref="System.Diagnostics.EventLog.SynchronizingObject"/> is <see langword="null"/>, methods
   handling the <see cref="System.Diagnostics.Process.Exited"/> event are called on a thread from
   the system thread pool. For more information on system thread pools, see <see cref="System.Threading.ThreadPool"/>.</para>
			<para>When the <see cref="System.Diagnostics.Process.Exited"/> event is handled by a visual Windows
Forms component, such as a <see cref="T:System.Windows.Forms.Button"/>, accessing the component through the
system thread pool might not work, or might result in an exception. Avoid this by
setting <see cref="System.Diagnostics.Process.SynchronizingObject"/> to a Windows Forms component, which
causes the methods handling the <see cref="System.Diagnostics.Process.Exited"/> event to be called on the same
thread on which the component was created.</para>
			<para>If the <see cref="System.Diagnostics.Process"/> is used inside Visual Studio .NET in a
Windows Forms designer, <see cref="System.Diagnostics.Process.SynchronizingObject"/> is automatically
set to the control containing the <see cref="System.Diagnostics.Process"/>. For example, if you place
a <see cref="System.Diagnostics.Process"/> on a designer for Form1 (which inherits from
<see cref="T:System.Windows.Forms.Form"/>) the <see cref="System.Diagnostics.Process.SynchronizingObject"/> property of <see cref="System.Diagnostics.Process"/> is 
set to the instance of Form1.</para>
			<para> Typically, this property is set when the component is placed inside
   a control or form, because those components are bound to a specific thread.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<example>
			<codelink SampleID="Process_SynchronizingObject" SnippetID="1"/>
		</example>
	</doc>
	<doc for="Process.Threads">
		<summary>
			<para> Gets the set of threads that are running in the associated
      process.
      </para>
		</summary>
		<value>
			<para> An array of type <see cref="System.Diagnostics.ProcessThread"/> representing the operating system threads
   currently running in the associated process.
   </para>
		</value>
		<exception cref="System.SystemException"><para>The process does not have an <see cref="System.Diagnostics.Process.Id"/> , or no process is associated with the <see cref="System.Diagnostics.Process"/> instance.</para>
			<para>-or-</para>
			<para>The associated process has exited.</para></exception>
		<remarks>
			<para> A
      thread executes code in a process. Each process is started with a
      single thread, its primary thread. Any thread can create additional threads. Threads within
      a process share the address space of the process.
      </para>
			<para> Use <see cref="System.Diagnostics.ProcessThread"/>
to get all the threads associated with the
current process. The primary thread is not necessarily at index zero in the
array.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<platnote platform="Win98">This property is not available on this platform if you started the process with <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute" qualify="true"/> set to <see langword="true"/>.
</platnote>
		<seealso cref="System.Diagnostics.ProcessThread"/>
		<seealso cref="System.Diagnostics.Process.BasePriority"/>
	</doc>
	<doc for="Process.TotalProcessorTime">
		<summary>
			<para>Gets the total processor time for this process.</para>
		</summary>
		<value>
			<para>A <see cref="System.TimeSpan"/> that
   indicates the amount of time that the associated process has spent utilizing the
   CPU. This value is the sum of the <see cref="System.Diagnostics.Process.UserProcessorTime"/> and
   the <see cref="System.Diagnostics.Process.PrivilegedProcessorTime"/>.</para>
		</value>
		<exception cref="System.PlatformNotSupportedException">You are accessing this member using Windows 98.</exception>
		<example>
			<para>The following example starts an instance of the Notepad utility. It then
      retrieves the associated process's physical memory usage, base priority,
      processor time, privileged processor time, total processor time, name, and
      whether it has exited or is responding to the UI.</para>
			<codelink SampleID="process_sample" SnippetID="1"/>
		</example>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.UserProcessorTime"/>
		<seealso cref="System.Diagnostics.Process.PrivilegedProcessorTime"/>
	</doc>
	<doc for="Process.UserProcessorTime">
		<summary>
			<para> Gets the user processor time for this process.</para>
		</summary>
		<value>
			<para>A <see cref="System.TimeSpan"/> that indicates the amount of time that the associated process has spent running
   code inside the application portion of the process (not inside the operating
   system core).</para>
		</value>
		<exception cref="System.PlatformNotSupportedException">You are accessing this member using Windows 98.</exception>
		<example>
			<para>The following example starts an instance of the Notepad utility. It then
      retrieves the associated process's physical memory usage, base priority,
      processor time, privileged processor time, total processor time, name, and
      whether it has exited or is responding to the UI.</para>
			<codelink SampleID="process_sample" SnippetID="1"/>
		</example>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.UserProcessorTime"/>
		<seealso cref="System.Diagnostics.Process.PrivilegedProcessorTime"/>
	</doc>
	<doc for="Process.VirtualMemorySize">
		<summary>
			<para> Gets the size of the process's virtual memory.</para>
		</summary>
		<value>
			<para>The amount of virtual memory that the associated process has requested.</para>
		</value>
		<exception cref="System.PlatformNotSupportedException"> You are accessing this member using Windows 98.</exception>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.EnableRaisingEvents">
		<summary>
			<para>Gets or sets whether the <see cref="System.Diagnostics.Process.Exited"/> event should be raised
   when the process terminates.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Diagnostics.Process.Exited"/> event should be raised when the associated
   process is terminated (through either an exit or a call to <see cref="System.Diagnostics.Process.Kill"/>
   ); otherwise,
<see langword="false"/>. The default is <see langword="false"/>.</para>
		</value>
		<remarks>
			<para>The <see cref="System.Diagnostics.Process.EnableRaisingEvents"/> property indicates whether the
   component should be notified when the operating system has shut down a process.
   The <see cref="System.Diagnostics.Process.EnableRaisingEvents"/> property is used in asynchronous processing to notify your
   application that a process has exited. To force your application to synchronously wait for
   an exit event (which interrupts processing of the application
   until the exit event has occurred), use the <see cref="System.Diagnostics.Process.WaitForExit"/>
   method.</para>
			<note type="note">
   If you are using Visual Studio
   and double-click a <see cref="System.Diagnostics.Process"/> component in your project, an <see cref="System.Diagnostics.Process.Exited"/> event
   delegate and event handler are automatically generated. Additional code sets the
<see cref="System.Diagnostics.Process.EnableRaisingEvents"/> property to <see langword="false"/>. You must change this property to <see langword="true "/> for your event handler to be executed when the
   associated process exits.
   
</note>
			<para>When an associated process exits after being shut down by
   the operation system either through a normal or abnormal termination, the
   operating system notifies each process component to which the process was
   associated, as long as the component's <see cref="System.Diagnostics.Process.EnableRaisingEvents"/>
   value is <see langword="true"/> . If a component started the process,
   the component can then access the administrative information for the
   associated process, which is still being stored by the operating system. Such information
   includes the <see cref="System.Diagnostics.Process.ExitTime"/>, and the <see cref="System.Diagnostics.Process.ExitCode"/> .</para>
			<para> After the associated process exits, the <see cref="System.Diagnostics.Process.Handle"/> of the component no longer
points to an existing process resource. Instead, it can be used only to access
the operating system's information about the process resource. The operating
system is aware that there are handles to exited processes that have not been
released by <see cref="System.Diagnostics.Process"/> components, so it keeps the <see cref="System.Diagnostics.Process.ExitTime"/> and <see cref="System.Diagnostics.Process.Handle"/>
information
in memory.</para>
			<para>There is a cost associated with watching for a process to
   exit. If <see cref="System.Diagnostics.Process.EnableRaisingEvents"/> is
<see langword="true"/>,
   the <see cref="System.Diagnostics.Process.Exited"/> event is raised when the associated process
   terminates. The procedures that you have specified for the <see cref="System.Diagnostics.Process.Exited"/>
   event run at that time.</para>
			<para> Sometimes, your application starts a process but
   does not need to be notified of its closure. For example, your application
   can start Notepad to allow the user to perform text editing, but make no further
   use of the Notepad application. You can choose to not be notified when
   the process exits, because it is not relevant to the continued operation
   of your application. Setting <see cref="System.Diagnostics.Process.EnableRaisingEvents"/> to <see langword="false "/>
   saves system resources.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.WaitForExit"/>
		<seealso cref="System.Diagnostics.Process.Exited"/>
		<seealso cref="System.Diagnostics.Process.CloseMainWindow"/>
		<seealso cref="System.Diagnostics.Process.Kill"/>
		<seealso cref="System.Diagnostics.Process.Handle"/>
		<seealso cref="System.Diagnostics.Process.ExitTime"/>
		<seealso cref="System.Diagnostics.Process.HasExited"/>
	</doc>
	<doc for="Process.StandardInput">
		<summary>
			<para> Gets a stream
      used to write the application's input. </para>
		</summary>
		<value>
			<para>A <see cref="System.IO.StreamWriter"/> that can be used to write the
   application's standard input stream.</para>
		</value>
		<exception cref="System.InvalidOperationException">The <see cref="System.Diagnostics.Process.StandardInput"/> value has not been defined. The <see cref="System.Diagnostics.Process.StartInfo"/> property's <see cref="System.Diagnostics.ProcessStartInfo.RedirectStandardInput"/> might be <see langword="false"/> .</exception>
		<remarks>
			<para> In order to use <see cref="System.Diagnostics.Process.StandardInput"/>,
   you must have specified <see langword="true"/> for the <see cref="System.Diagnostics.Process.StartInfo"/> property's <see cref="System.Diagnostics.ProcessStartInfo.RedirectStandardInput"/> property. Otherwise, reading the <see cref="System.Diagnostics.Process.StandardInput"/> property throws an exception.</para>
			<note type="note">
				<see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute"/> on the <see cref="System.Diagnostics.Process.StartInfo"/> property must be
<see langword="false"/> if you want to set <see cref="System.Diagnostics.Process.StandardInput"/> to
<see langword="true"/>.
   
</note>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.StandardOutput"/>
		<seealso cref="System.Diagnostics.Process.StandardError"/>
		<seealso cref="System.Diagnostics.ProcessStartInfo.RedirectStandardInput" qualify="true"/>
	</doc>
	<doc for="Process.StandardOutput">
		<summary>
			<para> Gets a stream
      used to read the application's output. </para>
		</summary>
		<value>
			<para>A <see cref="System.IO.StreamReader"/> that can be used to read the
   application's standard output stream.</para>
		</value>
		<exception cref="System.InvalidOperationException">The <see cref="System.Diagnostics.Process.StandardOutput"/> value has not been defined. The <see cref="System.Diagnostics.Process.StartInfo"/> property's <see cref="System.Diagnostics.ProcessStartInfo.RedirectStandardOutput"/> might be <see langword="false"/> .</exception>
		<remarks>
			<para>In order to use <see cref="System.Diagnostics.Process.StandardOutput"/>
,
you must have specified <see langword="true"/> for the <see cref="System.Diagnostics.Process.StartInfo"/> property's <see cref="System.Diagnostics.ProcessStartInfo.RedirectStandardOutput"/> property. Otherwise, reading the <see cref="System.Diagnostics.Process.StandardOutput"/> property
throws an exception.</para>
			<note type="note">
				<see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute"/> on the
<see cref="System.Diagnostics.Process.StartInfo"/> property must be
<see langword="false"/> if you want to set <see cref="System.Diagnostics.Process.StandardOutput"/> to
<see langword="true"/>.
   
</note>
			<para>The <see cref="System.Diagnostics.Process"/>
component communicates
with
a child process using a pipe. If a child process writes enough data to the pipe to
fill the buffer, the child will block until the parent reads the data from the
pipe. This can cause deadlock if your application is reading all output to standard error and standard
output. The following C# code, for example, could be problematic.</para>
			<code>
Process p = new Process();
p.StartInfo.UseShellExecute = false;
p.StartInfo.RedirectStandardOutput = true;
p.StartInfo.FileName = "test.exe";
p.Start();
p.WaitForExit();
string output = p.StandardOutput.ReadToEnd();
</code>
			<para> In this
   instance, both the parent and the child processes would
   be blocked, as the filled pipe prevents the child process from completing, while the parent process is waiting
   indefinitely for the child process to exit.</para>
			<para>This problem can be solved by moving the <c>ReadToEnd()</c> before the <c>WaitForExit()</c>, as follows. </para>
			<code>
Process p = new Process();
p.StartInfo.UseShellExecute = false;
p.StartInfo.RedirectStandardOutput = true;
p.StartInfo.FileName = "test.exe";
p.Start();
string output = p.StandardOutput.ReadToEnd();
p.WaitForExit();
</code>
			<para>A similar problem arises if you redirect both standard output and standard
   error and then try to read both, for example using the following C# code.</para>
			<code>
string output = p.StandardOutput.ReadToEnd();
string error = p.StandardError.ReadToEnd();
p.WaitForExit();
</code>
			<para>In this case, if the child process writes any text
   to standard error it will block the process, because the parent
   process cannot read from standard error until it has finished reading from standard output.
   However, the parent process will not read from standard output until the process ends.
   A recommended solution to this situation is to create two threads so that your application can
   read the output of each stream on a separate thread.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<example>
			<para>The following example spawns a new user-defined
      executable and reads its standard output. The output is then displayed in the
      console.</para>
			<codelink SampleID="Process_StandardOutput" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.Process.StandardInput"/>
		<seealso cref="System.Diagnostics.Process.StandardError"/>
		<seealso cref="System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" qualify="true"/>
	</doc>
	<doc for="Process.StandardError">
		<summary>
			<para> Gets a stream used
      to read the application's error output. </para>
		</summary>
		<value>
			<para>A <see cref="System.IO.StreamReader"/> that can be used to read the application's standard
   error stream.</para>
		</value>
		<exception cref="System.InvalidOperationException">The <see cref="System.Diagnostics.Process.StandardError"/> value has not been defined. The <see cref="System.Diagnostics.Process.StartInfo"/> property's <see cref="System.Diagnostics.ProcessStartInfo.RedirectStandardError"/> might be <see langword="false"/> .</exception>
		<remarks>
			<para>In order to use the <see cref="System.Diagnostics.Process.StandardError"/>
property,
you must have specified <see langword="true"/> for the <see cref="System.Diagnostics.Process.StartInfo"/> property's <see cref="System.Diagnostics.ProcessStartInfo.RedirectStandardError"/> property. Otherwise, reading the <see cref="System.Diagnostics.Process.StandardError"/> property throws an exception.</para>
			<note type="note">
				<see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute"/> on the <see cref="System.Diagnostics.Process.StartInfo"/> property must be
<see langword="false"/> if you want to set <see cref="System.Diagnostics.Process.StandardError"/> to
<see langword="true"/>.
   
</note>
			<para>The <see cref="System.Diagnostics.Process"/>
component communicates with a child process using a pipe. If a child process writes enough data to the
pipe to fill the buffer, the child will block until the parent reads the data
from the pipe. This can cause deadlock if your application is reading all output to standard error
and standard output. The following C# code, for example, could be problematic.</para>
			<code>
Process p = new Process();
p.StartInfo.UseShellExecute = false;
p.StartInfo.RedirectStandardError = true;
p.StartInfo.FileName = "test.exe";
p.Start();
p.WaitForExit();
string output = p.StandardError.ReadToEnd();
</code>
			<para> In this
   instance, both the parent and the child processes would
   be blocked, as the filled pipe prevents the child process from completing, while the parent process is waiting
   indefinitely for the child process to exit.</para>
			<para>This problem can be solved by moving the <c>ReadToEnd()</c> before the <c>WaitForExit()</c>, as follows. </para>
			<code>
Process p = new Process();
p.StartInfo.UseShellExecute = false;
p.StartInfo.RedirectStandardError = true;
p.StartInfo.FileName = "test.exe";
p.Start();
string output = p.StandardError.ReadToEnd();
p.WaitForExit();
</code>
			<para>A similar problem arises if you redirect both standard output and standard
   error and then try to read both, for example using the following C# code.</para>
			<code>
string output = p.StandardOutput.ReadToEnd();
string error = p.StandardError.ReadToEnd();
p.WaitForExit();
</code>
			<para>In this case, if the child process writes any text
   to standard error it will block the process, because the parent
   process cannot read from standard error until it has finished reading from standard output.
   However, the parent process will not read from standard output until the process ends.
   A recommended solution to this situation is to create two threads so that your application can
   read the output of each stream on a separate thread.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<example>
			<para>The following example uses the <paramref name="net use"/> command together with a
   user supplied argument to map a network resource. It then reads the standard error of net.exe and writes it on to console.</para>
			<codelink SampleID="Process_StandardError" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.Process.StandardInput"/>
		<seealso cref="System.Diagnostics.Process.StandardOutput"/>
		<seealso cref="System.Diagnostics.ProcessStartInfo.RedirectStandardError" qualify="true"/>
	</doc>
	<doc for="Process.WorkingSet">
		<summary>
			<para> Gets the associated process's physical memory usage.</para>
		</summary>
		<value>
			<para>The total amount of physical memory the associated process is using.</para>
		</value>
		<exception cref="System.PlatformNotSupportedException">You are accessing this member using Windows 98.</exception>
		<example>
			<para>The following example starts an instance of the Notepad utility. It then
      retrieves the associated process's physical memory usage, base priority,
      processor time, privileged processor time, total processor time, name, and
      whether it has exited or is responding to the UI.</para>
			<codelink SampleID="process_sample" SnippetID="1"/>
		</example>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.Exited">
		<summary>
			<para>Occurs when a process exits.</para>
		</summary>
		<remarks>
			<para>The <see cref="System.Diagnostics.Process.Exited"/>
event indicates that the associated process exited. This occurrence means either that the process
terminated (aborted) or successfully closed. When the operating system shuts down a
process, any process component that is waiting for an exit is notified. The component
can then access the associated process information that is still resident
in the operating system memory (such as <see cref="System.Diagnostics.Process.ExitTime"/> property) by using the handle
that
it has to the process.</para>
			<para>Because the associated process has exited, the <see cref="System.Diagnostics.Process.Handle"/>
property of the component no longer points to an existing process
resource. Instead, it can be used only to access the operating system's information
about the process resource. The system is aware of handles to exited processes
that have not been released by <see cref="System.Diagnostics.Process"/> components, so it keeps the <see cref="System.Diagnostics.Process.ExitTime"/> and <see cref="System.Diagnostics.Process.Handle"/> property
information in memory
until the <see cref="System.Diagnostics.Process"/>
component specifically frees the resources.</para>
			<note type="note">
   Even if you have a handle to an exited
   process, you cannot call <see cref="System.Diagnostics.Process.Start"/> again to reconnect to the same process.
   Calling <see cref="System.Diagnostics.Process.Start"/> automatically releases the associated
   process and connects to a process with the same file but an entirely new
<see cref="System.Diagnostics.Process.Handle"/>
.
</note>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.CloseMainWindow">
		<summary>
			<para> Closes a process that has a user interface by sending a close message
      to its main window.
      </para>
		</summary>
		<returns>
			<para><see langword="true "/>if the close message was
   successfully sent; <see langword="false"/> if
   the associated process does not have
   a main window or if the main window is disabled (for example if a modal
   dialog is being shown).
   </para>
		</returns>
		<remarks>
			<para> When a process is executing, its message
      loop is in a wait state. The message loop executes every time a Windows message
      is sent to the process by the operating system. Calling <see cref="System.Diagnostics.Process.CloseMainWindow"/> sends a request to close to the main
      window, which, in a well-formed application, closes child windows and revokes all running message loops for
      the application. The request to exit the process by calling
      <see cref="System.Diagnostics.Process.CloseMainWindow"/> does not force the application to quit. The application
      can ask for user verification before quitting, or it can refuse to quit. To force
      the application to quit, use the <see cref="System.Diagnostics.Process.Kill"/> method. The behavior of <see cref="System.Diagnostics.Process.CloseMainWindow"/>
      is identical to that of a user
      closing an application's main window using the system menu. Therefore, the request to exit the process
      by closing the main window does not force the application to quit
      immediately.
      </para>
			<para> Data edited by
      the process or resources allocated to the process can be lost if
      you call <see cref="System.Diagnostics.Process.Kill"/>. <see cref="System.Diagnostics.Process.Kill"/> causes an abnormal process termination, and should be
      used only when necessary. <see cref="System.Diagnostics.Process.CloseMainWindow"/> enables an orderly
      termination of the process and closes all windows, so it is preferable for applications
      with an interface. If <see cref="System.Diagnostics.Process.CloseMainWindow"/> fails, you can use <see cref="System.Diagnostics.Process.Kill"/> to terminate the process. <see cref="System.Diagnostics.Process.Kill"/> is the only way to terminate
      processes that do not have graphical interfaces.
      </para>
			<para> You can call <see cref="System.Diagnostics.Process.Kill"/> and <see cref="System.Diagnostics.Process.CloseMainWindow"/> only for processes
   that are running on the local computer. You cannot cause processes on
   remote computers to exit. You can only view
   information for processes running on remote computers.
   </para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.Close">
		<summary>
			<para> Frees all the resources that are associated with this component.
      </para>
		</summary>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.EnterDebugMode">
		<summary>
			<para>Puts a <see cref="System.Diagnostics.Process"/> component in state to interact with
   operating system processes that run in a special mode by
   enabling the native property SetDebugPriviledge on the current thread.</para>
		</summary>
		<remarks>
			<para>Some operating system processes run in a special mode. Attempting to read
      properties of or attach to these processes is not possible unless you have
      called <see cref="System.Diagnostics.Process.EnterDebugMode"/> on the component. Call <see cref="System.Diagnostics.Process.LeaveDebugMode"/> when
      you no longer need access to these processes that run in special mode.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.LeaveDebugMode"/>
	</doc>
	<doc for="Process.LeaveDebugMode">
		<summary>
			<para>Takes a <see cref="System.Diagnostics.Process"/> component out of the state that lets it interact with
   operating system processes that run in a special mode.</para>
		</summary>
		<remarks>
			<para>Some operating system processes run in a special mode. Attempting to read
      properties of or attach to these processes is not possible unless you have
      called <see cref="System.Diagnostics.Process.EnterDebugMode"/> on the component. Call <see cref="System.Diagnostics.Process.LeaveDebugMode"/> when
      you no longer need access to these processes that run in special mode.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.EnterDebugMode"/>
	</doc>
	<doc for="Process.GetProcessById">
		<overload>
			<para> Creates a new <see cref="System.Diagnostics.Process"/> component, and associates it with the
   existing process resource that you
   specify.
   </para>
		</overload>
		<summary>
			<para> Returns a new <see cref="System.Diagnostics.Process"/> component, given a process identifier and
   the name of a computer on the network.
   </para>
		</summary>
		<param name="processId">The system-unique identifier of a process resource. </param>
		<param name=" machineName">The name of a computer on the network. </param>
		<returns>
			<para> A <see cref="System.Diagnostics.Process"/>
component that is associated with a remote process resource identified by the
<paramref name="processId"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException"><para>The process specified by the <paramref name="processId"/> parameter is not running. The identifier might be expired.</para>
			<para>-or-</para>
			<para>The <paramref name="machineName"/> parameter syntax is invalid. The name might have length zero (0).</para></exception>
		<exception cref="System.ArgumentNullException">The <paramref name="machineName"/> parameter is <see langword="null"/>.</exception>
		<remarks>
			<para>Use this method to create a new <see cref="System.Diagnostics.Process"/> component and associate it
   with a process resource on a remote computer on the network. The process
   resource must already exist on the specified computer, because <see cref="System.Diagnostics.Process.GetProcessById"/> does not create a system resource,
   but rather associates a resource with an application-generated <see cref="System.Diagnostics.Process"/>
   component. A process <see cref="System.Diagnostics.Process.Id"/> can be retrieved only for a process
   that is currently running on the computer. After the process terminates, <see cref="System.Diagnostics.Process.GetProcessById"/> throws
   an exception if you pass it an expired identifier.</para>
			<para>On any particular computer, the identifier of a process is unique. <see cref="System.Diagnostics.Process.GetProcessById"/> returns one process at most. If you
want to get all the processes running a particular application, use <see cref="System.Diagnostics.Process.GetProcessesByName"/>. If multiple processes exist on the
computer running the specified application, <see cref="System.Diagnostics.Process.GetProcessesByName"/> returns
an array containing all the associated processes. You can query each of these
processes in turn for its identifier. The process identifier can be
viewed in the <see langword="Processes "/>panel of the Windows Task Manager. The
<see langword="PID "/>column displays the process identifier that is assigned to 
a process.</para>
			<para> If you do not specify a <paramref name="machineName"/>, the local computer is used.
Alternatively, you can specify the local computer by setting <paramref name="machineName "/>to the
value "." or to an empty string ("").</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<platnote platform="Win98">The <paramref name="machineName"/> parameter is not supported on Windows 98.
</platnote>
		<example>
			<para>The following example retrieves information of the current process,
      all instances of Notepad running on the local computer, all instances
      of Notepad running on a specific computer using the computer
      alias and an IP address, all processes running on the local computer
      and a remote computer, a specific process on the local computer or a remote
      computer using the process id.</para>
			<codelink SampleID="Process.GetProcesses_noexception" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.Process.Id"/>
		<seealso cref="System.Diagnostics.Process.MachineName"/>
		<seealso cref="System.Diagnostics.Process.GetProcessesByName"/>
		<seealso cref="System.Diagnostics.Process.GetProcesses"/>
		<seealso cref="System.Diagnostics.Process.GetCurrentProcess"/>
	</doc>
	<doc for="Process.GetProcessById1">
		<summary>
			<para> Returns a new <see cref="System.Diagnostics.Process"/> component, given the
   identifier of a process on the local computer.
   </para>
		</summary>
		<param name="processId">The system-unique identifier of a process resource. </param>
		<returns>
			<para> A <see cref="System.Diagnostics.Process"/>
component that is associated with the local process resource
identified by the <paramref name="processId"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentException">The process specified by the <paramref name="processId"/> parameter is not running. The identifier might be expired.</exception>
		<remarks>
			<para> Use this method to create a new <see cref="System.Diagnostics.Process"/>
component and
associate it with a process resource on the local computer. The process resource
must already exist on the computer, because <see cref="System.Diagnostics.Process.GetProcessById"/> does not create a system resource, but rather
associates a resource with an application-generated <see cref="System.Diagnostics.Process"/>
component. A process <see cref="System.Diagnostics.Process.Id"/> can be retrieved only for a process that is
currently running on the computer. After the process terminates, <see cref="System.Diagnostics.Process.GetProcessById"/> throws
an exception if you pass it an expired identifier.</para>
			<para> On any particular computer, the identifier of a process is
   unique. <see cref="System.Diagnostics.Process.GetProcessById"/> returns
   one process at most. If you want
   to get all the processes running a particular application, use <see cref="System.Diagnostics.Process.GetProcessesByName"/>. If multiple processes exist on
   the computer running the specified application, <see cref="System.Diagnostics.Process.GetProcessesByName"/> returns
   an array containing all the associated processes. You can query each of these
   processes in turn for its identifier. The process identifier can
   be viewed in the <see langword="Processes "/>panel of the
   Windows Task Manager. The <see langword="PID "/>column
   displays the process identifier that is assigned
   to a process.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<example>
			<para>The following example retrieves information of the current process,
      all instances of Notepad running on the local computer, all instances
      of Notepad running on a specific computer using the computer
      alias and an IP address, all processes running on the local computer
      and a remote computer, a specific process on the local computer or a remote
      computer using the process id.</para>
			<codelink SampleID="Process.GetProcesses_noexception" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.Process.Id"/>
		<seealso cref="System.Diagnostics.Process.GetProcessesByName"/>
		<seealso cref="System.Diagnostics.Process.GetProcesses"/>
		<seealso cref="System.Diagnostics.Process.GetCurrentProcess"/>
	</doc>
	<doc for="Process.GetProcessesByName">
		<overload>
			<para> Creates an array of new <see cref="System.Diagnostics.Process"/> components and associates them with the
   existing process resources that all share the specified process name.
   </para>
		</overload>
		<summary>
			<para> Creates an array of new <see cref="System.Diagnostics.Process"/> components
   and associates
   them with all the process resources
   on the local computer that share the specified process name.
   </para>
		</summary>
		<param name="processName">The friendly name of the process. </param>
		<returns>
			<para> An array of type <see cref="System.Diagnostics.Process"/> that represents the process resources running the
   specified application or file.
   </para>
		</returns>
		<exception cref="System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
		<remarks>
			<para> Use this method to create an array of new <see cref="System.Diagnostics.Process"/> components and associate
   them with all the process resources
   that are running the same executable file on the local computer. The
   process resources must already exist on the computer, because <see cref="System.Diagnostics.Process.GetProcessesByName"/> does not create system resources but
   rather associates them with application-generated <see cref="System.Diagnostics.Process"/> components. A
<paramref name="processName "/>
can be specified for an executable file that is not currently running
on the local computer, so the array the method returns can be empty.</para>
			<para> The process name is a friendly name for the process, such as Outlook,
   that does not include the .exe extension or the path. <see cref="System.Diagnostics.Process.GetProcessesByName"/> is
   helpful for getting and manipulating all the processes that
   are associated with the same executable file. For example, you can pass an
   executable file name as the <paramref name="processName"/> parameter, in
   order to shut down all the running instances of that executable file.
   </para>
			<para> Although a process <see cref="System.Diagnostics.Process.Id"/> is unique to a single process
resource on the system, multiple processes on the local computer can be running
the application specified by the <paramref name="processName "/>
parameter. Therefore,
<see cref="System.Diagnostics.Process.GetProcessById"/> returns one process at most, but <see cref="System.Diagnostics.Process.GetProcessesByName"/> returns 
an array containing all the associated processes. If you need to manipulate the
process using standard API calls, you can query each of these processes in turn
for its identifier. You cannot
access process resources through the process name alone but, once you have
retrieved an array of <see cref="System.Diagnostics.Process"/>
components that have been associated with the process resources, you can start, terminate, and otherwise manipulate the system resources.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<example>
			<para>The following example retrieves information of the current process,
      all instances of Notepad running on the local computer, all instances
      of Notepad running on a specific computer using the computer
      alias and an IP address, all processes running on the local computer
      and a remote computer, a specific process on the local computer or a remote
      computer using the process id.</para>
			<codelink SampleID="Process.GetProcesses_noexception" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.Process.ProcessName"/>
		<seealso cref="System.Diagnostics.Process.GetProcessById"/>
		<seealso cref="System.Diagnostics.Process.GetProcesses"/>
		<seealso cref="System.Diagnostics.Process.GetCurrentProcess"/>
	</doc>
	<doc for="Process.GetProcessesByName1">
		<summary>
			<para> Creates an array of new <see cref="System.Diagnostics.Process"/> components and associates them with all the process resources
   on a remote computer that share the specified process name.
   </para>
		</summary>
		<param name="processName">The friendly name of the process. </param>
		<param name=" machineName">The name of a computer on the network. </param>
		<returns>
			<para> An array of type <see cref="System.Diagnostics.Process"/> that represents the process resources
   running the specified application or file.
   </para>
		</returns>
		<exception cref="System.ArgumentException">The <paramref name="machineName"/> parameter syntax is invalid. It might have length zero (0).</exception>
		<exception cref="System.ArgumentNullException">The <paramref name="machineName"/> parameter is <see langword="null"/>.</exception>
		<exception cref="System.PlatformNotSupportedException"><para>The operating system platform does not support this operation on remote computers. </para></exception>
		<exception cref="System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
		<exception cref="System.ComponentModel.Win32Exception">A problem occurred accessing an underlying system API.</exception>
		<remarks>
			<para>Use this method to create an array of new <see cref="System.Diagnostics.Process"/> components and
   associate them with all the process resources that are running the same
   executable file on the specified computer. The process resources must already
   exist on the computer, because <see cref="System.Diagnostics.Process.GetProcessesByName"/> does not
   create system resources but rather associates them with application-generated
<see cref="System.Diagnostics.Process"/> components. A <paramref name="processName "/>can be specified for an executable file 
   that is not currently running on the local computer, so the array the method returns
   can be empty.</para>
			<para>The process name is a friendly name for the process,
   such as Outlook, that does not include the .exe extension or the path. <see cref="System.Diagnostics.Process.GetProcessesByName"/> is
   helpful for getting and manipulating all the processes that are associated with
   the same executable file. For example, you can pass an executable file name as
   the <paramref name="processName"/> parameter, in order to shut down all
   the running instances of that executable file. </para>
			<para>Although a process <see cref="System.Diagnostics.Process.Id"/> is unique to a single process
resource on the system, multiple processes on the local computer can be running
the application specified by the <paramref name="processName
"/>parameter. Therefore, <see cref="System.Diagnostics.Process.GetProcessById"/> returns one process at most, but
<see cref="System.Diagnostics.Process.GetProcessesByName"/> returns 
an array containing all the associated processes. If you need to manipulate the
process using standard API calls, you can query each of these processes in turn
for its identifier. You cannot access process resources
through the process name alone but, once you have retrieved an array of <see cref="System.Diagnostics.Process"/> components that
have been associated with the process resources, you can start, terminate, and
otherwise manipulate the system resources.</para>
			<para>You can use this overload to get processes on the local
   computer as well as on a remote computer. Use "." to specify the local computer.
   Another overload exists that uses the local computer by default.</para>
			<para> You can access
   processes on remote computers only to view information, such as statistics,
   about the processes. You cannot close, terminate (using <see cref="System.Diagnostics.Process.Kill"/>
   
   ), or start processes on remote computers.
   </para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<platnote platform="Win98">The <paramref name="machineName"/> parameter is not supported on Windows 98.
</platnote>
		<example>
			<para>The following example retrieves information of the current process,
      all instances of Notepad running on the local computer, all instances
      of Notepad running on a specific computer using the computer
      alias and an IP address, all processes running on the local computer
      and a remote computer, a specific process on the local computer or a remote
      computer using the process id.</para>
			<codelink SampleID="Process.GetProcesses_noexception" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.Process.ProcessName"/>
		<seealso cref="System.Diagnostics.Process.MachineName"/>
		<seealso cref="System.Diagnostics.Process.GetProcessById"/>
		<seealso cref="System.Diagnostics.Process.GetProcesses"/>
		<seealso cref="System.Diagnostics.Process.GetCurrentProcess"/>
	</doc>
	<doc for="Process.GetProcesses">
		<overload>
			<para> Creates an array of new <see cref="System.Diagnostics.Process"/>
components
and associates them with existing process resources.</para>
		</overload>
		<summary>
			<para> Creates a new <see cref="System.Diagnostics.Process"/>
component for each process resource on the local computer.</para>
		</summary>
		<returns>
			<para> An array of type <see cref="System.Diagnostics.Process"/> that represents all the process resources
   running on the local computer.
   </para>
		</returns>
		<remarks>
			<para> Use this method to create an array of new <see cref="System.Diagnostics.Process"/> components and associate
   them with all the process resources on the local computer. The process
   resources must already exist on the local computer, because <see cref="System.Diagnostics.Process.GetProcesses"/> does not create system resources
   but rather associates resources with application-generated <see cref="System.Diagnostics.Process"/> components. Because
   the operating system itself is running background processes, this array is
   never empty.
   </para>
			<para> If you do not want to retrieve all the processes running
   on the computer, you can restrict their number by using the <see cref="System.Diagnostics.Process.GetProcessById"/> or <see cref="System.Diagnostics.Process.GetProcessesByName"/> method. <see cref="System.Diagnostics.Process.GetProcessById"/> creates a <see cref="System.Diagnostics.Process"/> component that
   is associated with the process identified on the system by the process
   identifier that you pass to the method. <see cref="System.Diagnostics.Process.GetProcessesByName"/> creates an array of <see cref="System.Diagnostics.Process"/> components whose
   associated process resources share the executable file you pass to the method.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<example>
			<para>The following example retrieves information of the current process,
      all instances of Notepad running on the local computer, all instances
      of Notepad running on a specific computer using the computer
      alias and an IP address, all processes running on the local computer
      and a remote computer, a specific process on the local computer or a remote
      computer using the process id.</para>
			<codelink SampleID="Process.GetProcesses_noexception" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.Process.MachineName"/>
		<seealso cref="System.Diagnostics.Process.GetProcessById"/>
		<seealso cref="System.Diagnostics.Process.GetProcessesByName"/>
		<seealso cref="System.Diagnostics.Process.GetCurrentProcess"/>
	</doc>
	<doc for="Process.GetProcesses1">
		<summary>
			<para> Creates a new <see cref="System.Diagnostics.Process"/>
component for each
process resource on the specified computer.</para>
		</summary>
		<param name="machineName">The computer from which to read the list of processes.</param>
		<returns>
			<para> An array of type <see cref="System.Diagnostics.Process"/> that represents all the process resources
   running on the specified computer.
   </para>
		</returns>
		<exception cref="System.ArgumentException">The <paramref name="machineName"/> parameter syntax is invalid. It might have length zero (0).</exception>
		<exception cref="System.ArgumentNullException">The <paramref name="machineName"/> paramter is <see langword="null"/>.</exception>
		<exception cref="System.PlatformNotSupportedException"><para>The operating system platform does not support this operation on remote computers.</para></exception>
		<exception cref="System.InvalidOperationException">There are problems accessing the performance counter API's used to get process information. This exception is specific to Windows NT, Windows 2000, and Windows XP.</exception>
		<exception cref="System.ComponentModel.Win32Exception">A problem occurred accessing an underlying system API.</exception>
		<remarks>
			<para>Use this method to create an array of new <see cref="System.Diagnostics.Process"/> components and associate
   them with all the process resources on the specified (usually remote)
   computer. The process resources must already exist on the local computer,
   because <see cref="System.Diagnostics.Process.GetProcesses"/> does not create system resources but
   rather associates resources with application-generated <see cref="System.Diagnostics.Process"/>
   components. Because the operating system itself is running background processes,
   this array is never empty. </para>
			<para>If you do not want to retrieve all the processes running on the computer, you
   can restrict their number by using the <see cref="System.Diagnostics.Process.GetProcessById"/> or <see cref="System.Diagnostics.Process.GetProcessesByName"/> method. <see cref="System.Diagnostics.Process.GetProcessById"/> creates a <see cref="System.Diagnostics.Process"/>
   component that is associated with the process identified on the system by the
   process identifier that you pass to the method. <see cref="System.Diagnostics.Process.GetProcessesByName"/> creates an array of <see cref="System.Diagnostics.Process"/>
   components whose associated process resources share the executable file you pass
   to the method.</para>
			<para> This overload of the <see cref="System.Diagnostics.Process.GetProcesses"/>
method is generally used to retrieve the list of process resources running
on a remote computer on the network, but you can
specify the local computer by passing ".".</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<platnote platform="Win98">The <paramref name="machineName"/> parameter is not supported on Windows 98.
</platnote>
		<example>
			<para>The following example retrieves information of the current process,
      all instances of Notepad running on the local computer, all instances
      of Notepad running on a specific computer using the computer
      alias and an IP address, all processes running on the local computer
      and a remote computer, a specific process on the local computer or a remote
      computer using the process id.</para>
			<codelink SampleID="Process.GetProcesses_noexception" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.Process.MachineName"/>
		<seealso cref="System.Diagnostics.Process.GetProcessById"/>
		<seealso cref="System.Diagnostics.Process.GetProcessesByName"/>
		<seealso cref="System.Diagnostics.Process.GetCurrentProcess"/>
	</doc>
	<doc for="Process.GetCurrentProcess">
		<summary>
			<para> Gets a new <see cref="System.Diagnostics.Process"/>
component and associates it with the currently active process.</para>
		</summary>
		<returns>
			<para> A new <see cref="System.Diagnostics.Process"/> component associated with the process
   resource that is running the calling application.
   </para>
		</returns>
		<remarks>
			<para> Use this method to create a new <see cref="System.Diagnostics.Process"/> instance and associate it with
   the process resource on the local
   computer.
   </para>
			<para> Like the similar <see cref="System.Diagnostics.Process.GetProcessById"/>, <see cref="System.Diagnostics.Process.GetProcessesByName"/>, and <see cref="System.Diagnostics.Process.GetProcesses"/> methods, <see cref="System.Diagnostics.Process.GetCurrentProcess"/>
associates an existing resource with
a new <see cref="System.Diagnostics.Process"/> component.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<example>
			<para>The following example retrieves information of the current process,
      all instances of Notepad running on the local computer, all instances
      of Notepad running on a specific computer using the computer
      alias and an IP address, all processes running on the local computer
      and a remote computer, a specific process on the local computer or a remote
      computer using the process id.</para>
			<codelink SampleID="Process.GetProcesses_noexception" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.Process.GetProcessById"/>
		<seealso cref="System.Diagnostics.Process.GetProcessesByName"/>
		<seealso cref="System.Diagnostics.Process.GetProcesses"/>
	</doc>
	<doc for="Process.OnExited">
		<summary>
			<para> Raises the <see cref="System.Diagnostics.Process.Exited"/> event.
   </para>
		</summary>
		<remarks>
			<para><see cref="System.Diagnostics.Process.OnExited"/> is the API method that raises the <see cref="System.Diagnostics.Process.Exited"/> event. Calling <see cref="System.Diagnostics.Process.OnExited"/> causes the <see cref="System.Diagnostics.Process.Exited"/> event to occur and is the only way to
   raise the event using the <see cref="System.Diagnostics.Process"/> component. <see cref="System.Diagnostics.Process.OnExited"/> is primarily used when deriving classes from the component.
   </para>
			<para> As an alternative to <see cref="System.Diagnostics.Process.OnExited"/>
, you
can write your own event handler. You create your own event handler
delegate and your own event-handling method.</para>
			<note type="note">
   If you are using
   the Visual Studio environment, an event
   handler delegate (AddOnExited) and an event-handling method (Process1_Exited) are
   created for you when you drag a <see cref="System.Diagnostics.Process"/> component onto a form and double-click the
   icon. The code you create to run when the <see cref="System.Diagnostics.Process.Exited"/> event occurs is
   entered into the Process1_Exited procedure. You do not need to create the
<see cref="System.Diagnostics.Process.OnExited"/> member, because it is implemented for you.
   
</note>
			<para> Raising an event invokes the event handler through a delegate. For an
   overview, see <see topic="cpconProvidingEventFunctionality"/>.
   </para>
			<note type="inheritinfo">
   When overriding
<see cref="System.Diagnostics.Process.OnExited"/> in a derived class, be sure to call the
   base class's <see cref="System.Diagnostics.Process.OnExited"/> method.
   
</note>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.Exited"/>
	</doc>
	<doc for="Process.Refresh">
		<summary>
			<para>
      Discards any information about the associated
      process that has been cached inside the process component.
      </para>
		</summary>
		<remarks>
			<para>After <see cref="System.Diagnostics.Process.Refresh"/> is called, the first request for
   information about each property causes the process component to obtain a new
   value from the associated process.</para>
			<para> When a <see cref="System.Diagnostics.Process"/> component is associated with a process
resource, the property values of the <see cref="System.Diagnostics.Process"/> are immediately populated
according to the status of the associated process. If the information about the
associated process subsequently changes, those changes are not reflected in the
<see cref="System.Diagnostics.Process"/> component's cached values. The <see cref="System.Diagnostics.Process"/>
component is a snapshot of the process resource at the time they are associated.
To view the current values for the associated process, call the <see cref="System.Diagnostics.Process.Refresh"/>
method.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.Start">
		<overload>
			<para> Starts a process resource and associates it with a
      <see cref="System.Diagnostics.Process"/>
   component.
   </para>
		</overload>
		<summary>
			<para> Starts (or reuses) the process resource that is specified by the <see cref="System.Diagnostics.Process.StartInfo"/> property of this <see cref="System.Diagnostics.Process"/> component and
   associates it with the
   component.</para>
		</summary>
		<returns>
			<para><see langword="true "/>if a process resource is started; <see langword="false "/>if no new
   process resource is started (for example, if an existing process is reused).
   </para>
		</returns>
		<exception cref="System.InvalidOperationException"><para>No file name was specified in the <see cref="System.Diagnostics.Process"/> component's <see cref="System.Diagnostics.Process.StartInfo"/>. </para>
			<para>-or-</para>
			<para>The <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute" qualify="true"/> member of the <see cref="System.Diagnostics.Process.StartInfo"/> property is <see langword="true"/> while <see cref="System.Diagnostics.ProcessStartInfo.RedirectStandardInput" qualify="true"/>, <see cref="System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" qualify="true"/>, or <see cref="System.Diagnostics.ProcessStartInfo.RedirectStandardError" qualify="true"/> is <see langword="true"/>. </para></exception>
		<exception cref="T:System.ComponentModel.Win32Exception">There was an error in opening the associated file. </exception>
		<exception cref="System.ObjectDisposedException">The process object has already been disposed.</exception>
		<remarks>
			<para> Use this overload to start a process resource and
      associate it with the current <see cref="System.Diagnostics.Process"/> component. The return value
      <see langword="true "/>indicates that a new process resource was started. If the
      process resource specified by the <see cref="System.Diagnostics.ProcessStartInfo.FileName"/> member of the <see cref="System.Diagnostics.Process.StartInfo"/> property is already
      running on the computer, no additional process resource is started. Instead, the
      running process resource is reused and <see langword="false "/>
      is returned.
      </para>
			<note type="note">
      If you are using Visual Studio, this overload of the <see cref="System.Diagnostics.Process.Start"/> method
      is the one that you insert into your code after you drag a <see cref="System.Diagnostics.Process"/>
      component onto the designer. Use the
      <see langword="Properties "/>window to expand the <see langword="StartInfo "/>category and write the appropriate value into the <see langword="FileName "/>
   property. Your changes will appear in the form's
   InitializeComponent procedure.
   
</note>
			<para> This overload of <see cref="System.Diagnostics.Process.Start"/> is not a
<see langword="static "/>method. You must call it for an instance of the <see cref="System.Diagnostics.Process"/>
class. Before calling <see cref="System.Diagnostics.Process.Start"/>, you must first specify <see cref="System.Diagnostics.Process.StartInfo"/> property information for this <see cref="System.Diagnostics.Process"/>instance, because that
information is used to determine the process resource to
start.</para>
			<para> The other overloads of the <see cref="System.Diagnostics.Process.Start"/> method are <see langword="static "/>members.
You do not need to create an instance of the <see cref="System.Diagnostics.Process"/> component before you call
those overloads of the method. Instead, you can call <see cref="System.Diagnostics.Process.Start"/> for the <see cref="System.Diagnostics.Process"/> class itself, and a new
<see cref="System.Diagnostics.Process"/> component is created if the process was
started. Or, <see langword="null "/>is returned if a process was reused. The
process resource is automatically associated with the new <see cref="System.Diagnostics.Process"/>
component that is returned by the <see cref="System.Diagnostics.Process.Start"/>
method.</para>
			<para> The <see cref="System.Diagnostics.Process.StartInfo"/> members can be used to duplicate the
functionality of the <see langword="Run"/> dialog box of the Windows
<see langword="Start "/>menu. 
Anything that can be typed into a command
line can be started by setting the appropriate values in the <see cref="System.Diagnostics.Process.StartInfo"/> property. The only <see cref="System.Diagnostics.Process.StartInfo"/> property that must be set
is the <see cref="System.Diagnostics.ProcessStartInfo.FileName"/>
property. The <see cref="System.Diagnostics.ProcessStartInfo.FileName"/> property
does not have to be an executable file. It can be of any file type for
which the extension has been associated with an application that is
installed on the system. For example, the <see cref="System.Diagnostics.ProcessStartInfo.FileName"/>
property can have
a .txt extension
if you have associated text files with an editor, such as Notepad, or it
can have a .doc extension if you have associated .doc files with a word processing tool, such as Microsoft Word.</para>
			<para> In the command line, you can specify actions to take for certain types of
   files. For example, you can print documents or edit text files. Specify these
   actions using the <see cref="System.Diagnostics.ProcessStartInfo.Verb"/> member of the <see cref="System.Diagnostics.Process.StartInfo"/> property. For other types of files,
   you can specify command line arguments when you start the file from the
<see langword="Run"/>
dialog box. For example, you can pass a URL as an argument if
you specify your browser as the <see cref="System.Diagnostics.ProcessStartInfo.FileName"/>. These arguments can be
specified in the <see cref="System.Diagnostics.Process.StartInfo"/> property's <see cref="System.Diagnostics.ProcessStartInfo.Arguments"/> member.</para>
			<para>If you have a path variable declared in your system using quotes, you must
   fully qualify that path when starting any process found in that location.
   Otherwise, the system will not find the path. For example, if <c>c:\mypath</c> is not in your path, and
you add it using quotation marks: <c>path = %path%;"c:\mypath"</c>, you must fully qualify any process in
<c>c:\mypath</c> when starting 
it</para>
			<para> Whenever you use <see cref="System.Diagnostics.Process.Start"/> to start a process, you might
need to close it or you risk losing system resources. Close processes using
<see cref="System.Diagnostics.Process.CloseMainWindow"/> or <see cref="System.Diagnostics.Process.Kill"/>
.</para>
			<para>A note about apartment states in managed threads is necessary here. When
<see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute"/> is <see langword="true"/> on the process 
   component's <see cref="System.Diagnostics.Process.StartInfo"/> property, make sure you have set a threading
   model on your application by setting the attribute <c>[STAThread]</c> on the <c>main()</c> method. Otherwise, a managed thread can be in
an <see langword="unknown"/> state or put in the <see langword="MTA"/> state, the
latter of which conflicts with <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute"/> being <see langword="true"/>. Some methods
require that the apartment state not be <see langword="unknown"/>. If the state
is not explicitly set, when the application encounters such a method, it
defaults to <see langword="MTA"/>, and once set, the apartment state cannot be
changed. However, <see langword="MTA"/> causes an exception to be thrown when the
operating system shell is managing the thread. </para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<example>
			<para>The following example uses an instance of the <see cref="System.Diagnostics.Process"/> class to start a
   process.</para>
			<codelink SampleID="Process.Start_instance" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.Process.StartInfo"/>
		<seealso cref="System.Diagnostics.ProcessStartInfo.FileName"/>
		<seealso cref="System.Diagnostics.ProcessStartInfo"/>
		<seealso cref="System.Diagnostics.Process.CloseMainWindow"/>
		<seealso cref="System.Diagnostics.Process.Kill"/>
	</doc>
	<doc for="Process.Start1">
		<summary>
			<para> Starts a process resource by specifying the name of a
      document or application file and associates the resource with a new <see cref="System.Diagnostics.Process"/>
      component.
      </para>
		</summary>
		<param name="fileName">The name of a document or application file to run in the process. </param>
		<returns>
			<para> A new <see cref="System.Diagnostics.Process"/>
component that is associated with the process
resource, or <see langword="null"/>, if
no process resource is started (for example, if an existing process is reused).</para>
		</returns>
		<exception cref="System.ArgumentException">The <paramref name="fileName "/>parameter is <see langword="null"/>. </exception>
		<exception cref="T:System.ComponentModel.Win32Exception">There was an error in opening the associated file. </exception>
		<exception cref="System.ObjectDisposedException">The process object has already been disposed.</exception>
		<remarks>
			<para> Use this overload to start a process resource by
      specifying its file name. The overload associates the resource with a new
      <see cref="System.Diagnostics.Process"/> component. If the process is already
      running, no additional process resource is started. Instead, the existing
      process resource is reused and no new <see cref="System.Diagnostics.Process"/> component is created. In
      such a case, instead of returning a new <see cref="System.Diagnostics.Process"/> component, <see cref="System.Diagnostics.Process.Start"/> returns <see langword="null "/>
      to the calling procedure.
      </para>
			<para> This overload lets you start a process without first
      creating a new <see cref="System.Diagnostics.Process"/>
      instance. The overload is an alternative to the explicit steps
      of creating a new <see cref="System.Diagnostics.Process"/> instance, setting the <see cref="System.Diagnostics.ProcessStartInfo.FileName"/> member of the <see cref="System.Diagnostics.Process.StartInfo"/> property, and calling <see cref="System.Diagnostics.Process.Start"/> for the <see cref="System.Diagnostics.Process"/>
      instance.
      </para>
			<para> Starting a process by specifying its file name
      is similar to typing the information in the <see langword="Run "/>dialog box
      of the Windows <see langword="Start "/>menu. Therefore, the file name does not need to
      represent an executable file. It can be of any file type for which the extension has
      been associated with an application installed on the system. For example the
      file name can have a .txt extenstion if you have associated text files with
      an editor, such as Notepad, or it can have a .doc if you have associated .doc
      files with a word processing tool, such as Microsoft Word. Similarly, in the
      same way that the <see langword="Run "/>dialog box can accept an executable file
      name with or without the .exe extension, the .exe extension is optional in the
      <paramref name="fileName"/> parameter. For example, you can set the <paramref name="fileName"/>
   parameter
   to either "Notepad.exe" or "Notepad".
   </para>
			<para>Unlike the other overloads, the overload of <see cref="System.Diagnostics.Process.Start"/> that has no
parameters is not a <see langword="static "/>member. Use that overload when you
have already created a <see cref="System.Diagnostics.Process"/> instance, specified start information
(including the file name), and want to start a process resource and associate it
with the existing <see cref="System.Diagnostics.Process"/> instance. Use one of the
<see langword="static"/> overloads when you want to create a new <see cref="System.Diagnostics.Process"/> 
component rather than start a process for an existing component. Both this
overload and the overload that has no parameters allow you to specify the file
name of the process resource to start.</para>
			<para>If you have a path variable declared in your system using quotes, you must
   fully qualify that path when starting any process found in that location.
   Otherwise, the system will not find the path. For example, if <c>c:\mypath</c> is not in your path, and
you add it using quotation marks: <c>path = %path%;"c:\mypath"</c>, you must fully qualify any process in
<c>c:\mypath</c> when starting 
it</para>
			<para>Whenever you use <see cref="System.Diagnostics.Process.Start"/> to start a process, you might need
to close it or you risk losing system resources. Close processes using <see cref="System.Diagnostics.Process.CloseMainWindow"/> or <see cref="System.Diagnostics.Process.Kill"/> .</para>
			<para>A note about apartment states in managed threads is necessary here. When
<see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute"/> is <see langword="true"/> on the process 
   component's <see cref="System.Diagnostics.Process.StartInfo"/> property, make sure you have set a threading
   model on your application by setting the attribute <c>[STAThread]</c> on the <c>main()</c> method. Otherwise, a managed thread can be in
an <see langword="unknown"/> state or put in the <see langword="MTA"/> state, the
latter of which conflicts with <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute"/> being <see langword="true"/>. Some methods
require that the apartment state not be <see langword="unknown"/>. If the state
is not explicitly set, when the application encounters such a method, it
defaults to <see langword="MTA"/>, and once set, the apartment state cannot be
changed. However, <see langword="MTA"/> causes an
exception to be thrown when the operating system shell is managing the thread. </para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<example>
			<para>The following example first spawns an instance of Internet Explorer and
      displays the contents of the favorites folder in the browser. It then
      starts some other instances of IE and displays some specific pages or
      sites. Finally it starts IE with the window being minimized while navigating to
      a specific site.</para>
			<codelink SampleID="Process.Start_static" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.ProcessStartInfo.FileName"/>
		<seealso cref="System.Diagnostics.Process.StartInfo"/>
		<seealso cref="System.Diagnostics.Process.CloseMainWindow"/>
		<seealso cref="System.Diagnostics.Process.Kill"/>
	</doc>
	<doc for="Process.Start2">
		<summary>
			<para> Starts a process resource by specifying the name of an
      application and a set of command line arguments, and associates the resource
      with a new <see cref="System.Diagnostics.Process"/>
      component.
      </para>
		</summary>
		<param name="fileName">The name of an application file to run in the process. </param>
		<param name=" arguments">Command line arguments to pass when starting the process. </param>
		<returns>
			<para> A new <see cref="System.Diagnostics.Process"/> component that is associated with the
   process, or <see langword="null"/>, if no process resource is started (for
   example, if an existing process is reused).
   </para>
		</returns>
		<exception cref="System.ArgumentException">The <paramref name="fileName "/>or <paramref name="arguments "/> parameter is <see langword="null"/>. </exception>
		<exception cref="T:System.ComponentModel.Win32Exception">There was an error in opening the associated file. </exception>
		<exception cref="System.ObjectDisposedException">The process object has already been disposed.</exception>
		<remarks>
			<para> Use this overload to start a process resource by
      specifying its file name and command line arguments. The overload associates the
      resource with a new <see cref="System.Diagnostics.Process"/> component. If the process is
      already running, no additional process is started. Instead, the existing
      process resource is reused and no new <see cref="System.Diagnostics.Process"/> component is created. In
      such a case, instead of returning a new <see cref="System.Diagnostics.Process"/> component, <see cref="System.Diagnostics.Process.Start"/> returns <see langword="null "/>
      to the calling
      procedure.
      </para>
			<para> This overload lets you start a process without first creating a new <see cref="System.Diagnostics.Process"/>
instance. The overload is an alternative to the explicit steps of creating a new <see cref="System.Diagnostics.Process"/>
instance, setting the <see cref="System.Diagnostics.ProcessStartInfo.FileName"/> and <see cref="System.Diagnostics.ProcessStartInfo.Arguments"/> members of the <see cref="System.Diagnostics.Process.StartInfo"/> property, and calling <see cref="System.Diagnostics.Process.Start"/> for the <see cref="System.Diagnostics.Process"/> instance.</para>
			<para>Starting a process by specifying its file name and arguments is similar
   to typing the file name and command line arguments in the <see langword="Run "/>dialog box of the Windows <see langword="Start "/>menu. Therefore, the file name
   does not need to represent an executable file. It can be of any file type for
   which the extension has been associated with an application installed on the
   system. For example the file name can have a .txt extenstion if you have associated text
   files with an editor, such as Notepad, or it can have a .doc if you have
   associated .doc files with a word processing tool, such as Microsoft Word.
   Similarly, in the same way that the <see langword="Run "/>dialog box can accept
   an executable file name with or without the .exe extension, the .exe extension
   is optional in the <paramref name="fileName"/> parameter. For example, you can set the
<paramref name="fileName"/> parameter to either "Notepad.exe" or "Notepad". If the 
<paramref name="fileName"/> parameter represents an executable file, the 
<paramref name="arguments"/> parameter might represent a file to act upon, such as the text 
   file in <c>Notepad.exe
   myfile.txt</c> .</para>
			<para>Unlike the other overloads, the overload of <see cref="System.Diagnostics.Process.Start"/> that has no
parameters is not a <see langword="static "/>member. Use that overload when you
have already created a <see cref="System.Diagnostics.Process"/> instance, specified start information
(including the file name), and want to start a process resource and associate it
with the existing <see cref="System.Diagnostics.Process"/> instance. Use one of the
<see langword="static"/> overloads when you want to create a new <see cref="System.Diagnostics.Process"/> 
component rather than start a process for an existing component. Both this
overload and the overload that has no parameters allow you to specify the file
name of the process resource to start and command line arguments to
pass.</para>
			<para>If you have a path variable declared in your system using quotes, you must
   fully qualify that path when starting any process found in that location.
   Otherwise, the system will not find the path. For example, if <c>c:\mypath</c> is not in your path, and
you add it using quotation marks: <c>path = %path%;"c:\mypath"</c>, you must fully qualify any process in
<c>c:\mypath</c> when starting 
it</para>
			<para>Whenever you use <see cref="System.Diagnostics.Process.Start"/> to start a process, you might need
to close it or you risk losing system resources. Close processes using <see cref="System.Diagnostics.Process.CloseMainWindow"/> or <see cref="System.Diagnostics.Process.Kill"/> .</para>
			<para>A note about apartment states in managed threads is necessary here. When
<see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute"/> is <see langword="true"/> on the process 
   component's <see cref="System.Diagnostics.Process.StartInfo"/> property, make sure you have set a threading
   model on your application by setting the attribute <c>[STAThread]</c> on the <c>main()</c> method. Otherwise, a managed thread can be in
an <see langword="unknown"/> state or put in the <see langword="MTA"/> state, the
latter of which conflicts with <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute"/> being <see langword="true"/>. Some methods
require that the apartment state not be <see langword="unknown"/>. If the state
is not explicitly set, when the application encounters such a method, it
defaults to <see langword="MTA"/>, and once set, the apartment state cannot be
changed. However, <see langword="MTA"/> causes an exception to be thrown when the
operating system shell is managing the thread. </para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<example>
			<para>The following example first spawns an instance of Internet Explorer and
      displays the contents of the favorites folder in the browser. It then starts
      some other instances of IE and displays some specific pages or sites. Finally it
      starts IE with the window being minimized while navigating to a specific
      site.</para>
			<codelink SampleID="Process.Start_static" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.ProcessStartInfo.FileName"/>
		<seealso cref="System.Diagnostics.Process.StartInfo"/>
		<seealso cref="System.Diagnostics.ProcessStartInfo"/>
		<seealso cref="System.Diagnostics.Process.CloseMainWindow"/>
		<seealso cref="System.Diagnostics.Process.Kill"/>
	</doc>
	<doc for="Process.Start3">
		<summary>
			<para> Starts the process resource that is specified by the parameter
      containing process start information (for example, the file name of the process to start)
      and associates the resource with a new <see cref="System.Diagnostics.Process"/>
      component.
      </para>
		</summary>
		<param name="startInfo">The <see cref="System.Diagnostics.ProcessStartInfo"/> that contains the information that is used to start the process, including the file name and any command line arguments. </param>
		<returns>
			<para> A new <see cref="System.Diagnostics.Process"/>
component that is associated with the process
resource, or <see langword="null"/> if no process resource is started (for
example, if an existing process is reused).</para>
		</returns>
		<exception cref="System.InvalidOperationException"><para>No file name was specified in the <paramref name="startInfo"/> parameter's <see cref="System.Diagnostics.ProcessStartInfo.FileName"/> property. </para>
			<para>-or-</para>
			<para>The <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute" qualify="true"/> member of the <paramref name="startInfo"/> parameter is <see langword="true"/> while <see cref="System.Diagnostics.ProcessStartInfo.RedirectStandardInput" qualify="true"/>, <see cref="System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" qualify="true"/>, or <see cref="System.Diagnostics.ProcessStartInfo.RedirectStandardError" qualify="true"/> is <see langword="true"/>. </para></exception>
		<exception cref="System.ArgumentException">The <paramref name="startInfo "/>parameter is <see langword="null"/>. </exception>
		<exception cref="T:System.ComponentModel.Win32Exception">There was an error in opening the associated file. </exception>
		<exception cref="System.ObjectDisposedException">The process object has already been disposed.</exception>
		<remarks>
			<para> Use this overload to start a process resource by
      specifying a <see cref="System.Diagnostics.ProcessStartInfo"/>
      instance. The overload associates the resource with a new
      <see cref="System.Diagnostics.Process"/>
   component. If the process is already
   running, no additional process resource is started. Instead, the existing process resource is reused and no
   new <see cref="System.Diagnostics.Process"/> component is created. In such a case,
   instead of returning a new <see cref="System.Diagnostics.Process"/> component, <see cref="System.Diagnostics.Process.Start"/> returns <see langword="null "/>
   to the calling
   procedure.
   </para>
			<para> This overload lets you start a process without first creating a new <see cref="System.Diagnostics.Process"/>
instance. Using this overload with a <see cref="System.Diagnostics.ProcessStartInfo"/>
parameter is an alternative
to the explicit steps of creating a new <see cref="System.Diagnostics.Process"/> instance, setting its <see cref="System.Diagnostics.Process.StartInfo"/>
properties, and calling <see cref="System.Diagnostics.Process.Start"/> for the <see cref="System.Diagnostics.Process"/> instance.</para>
			<para> Using a <see cref="System.Diagnostics.ProcessStartInfo"/> instance as the parameter lets you call
<see cref="System.Diagnostics.Process.Start"/> with the most control over what is
passed into the call to start the process. If you need to pass only a file name
or a file name and arguments, it is not necessary to create a new <see cref="System.Diagnostics.ProcessStartInfo"/> instance,
although that is an option. The only <see cref="System.Diagnostics.Process.StartInfo"/> property that must
be set is the <see cref="System.Diagnostics.ProcessStartInfo.FileName"/>
property. The <see cref="System.Diagnostics.ProcessStartInfo.FileName"/> property
does not need to represent an executable file. It can be of any file
type for which the extension has been associated with an application that
is installed on the system. For example, the <see cref="System.Diagnostics.ProcessStartInfo.FileName"/>
property can have
a .txt extension if you have associated text files with an
editor, such as Notepad, or it can have a .doc extension if you have associated
.doc files with a word processing tool, such as Microsoft Word.</para>
			<para> Unlike the other overloads, the overload of <see cref="System.Diagnostics.Process.Start"/> that has no parameters is not a <see langword="static "/> member. Use that overload when you have
already created a <see cref="System.Diagnostics.Process"/> instance, specified start information
(including the file name), and want to start a process resource and associate it
with the existing <see cref="System.Diagnostics.Process"/> instance. Use one of the <see langword="static"/>
overloads when you want to create a new <see cref="System.Diagnostics.Process"/> component rather
than start a
process for an existing component. Both this overload and the overload that has
no parameters allow you to specify the start information for the process resource
by using a <see cref="System.Diagnostics.ProcessStartInfo"/>
instance.</para>
			<para>If you have a path variable declared in your system using quotes, you must
   fully qualify that path when starting any process found in that location.
   Otherwise, the system will not find the path. For example, if <c>c:\mypath</c> is not in your path, and
you add it using quotation marks: <c>path = %path%;"c:\mypath"</c>, you must fully qualify any process in
<c>c:\mypath</c> when starting 
it</para>
			<para> Whenever you use <see cref="System.Diagnostics.Process.Start"/> to start a process,
you might need to close it or you risk losing system resources. Close processes
using <see cref="System.Diagnostics.Process.CloseMainWindow"/> or <see cref="System.Diagnostics.Process.Kill"/>
.</para>
			<para>A note about apartment states in managed threads is necessary here. When
<see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute"/> is <see langword="true"/> on the <paramref name="startInfo"/> parameter, make sure you have set a threading
   model on your application by setting the attribute <c>[STAThread]</c> on the <c>main()</c> method. Otherwise, a managed thread can be in
an <see langword="unknown"/> state or put in the <see langword="MTA"/> state, the
latter of which conflicts with <see cref="System.Diagnostics.ProcessStartInfo.UseShellExecute"/> being <see langword="true"/>. Some methods
require that the apartment state not be <see langword="unknown"/>. If the state
is not explicitly set, when the application encounters such a method, it
defaults to <see langword="MTA"/>, and once set, the apartment state cannot be
changed. However, <see langword="MTA"/> causes an exception to be thrown when the
operating system shell is managing the thread. </para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<example>
			<para>The following example first spawns an instance of Internet Explorer and
      displays the contents of the favorites folder in the browser. It then starts
      some other instances of IE and displays some specific pages or sites. Finally it
      starts IE with the window being minimized while navigating to a specific
      site.</para>
			<codelink SampleID="Process.Start_static" SnippetID="1"/>
		</example>
		<seealso cref="System.Diagnostics.Process.StartInfo"/>
		<seealso cref="System.Diagnostics.ProcessStartInfo.FileName"/>
		<seealso cref="System.Diagnostics.ProcessStartInfo"/>
		<seealso cref="System.Diagnostics.Process.CloseMainWindow"/>
		<seealso cref="System.Diagnostics.Process.Kill"/>
	</doc>
	<doc for="Process.Kill">
		<summary>
			<para> Immediately stops
      the associated process.
      </para>
		</summary>
		<exception cref="T:System.ComponentModel.Win32Exception">The associated process could not be terminated. </exception>
		<exception cref="System.SystemException"><para>No process <see cref="System.Diagnostics.Process.Id"/> has been set, and a <see cref="System.Diagnostics.Process.Handle"/> from which the <see cref="System.Diagnostics.Process.Id"/> property can be determined does not exist.</para>
			<para>-or-</para>
			<para>There is no process associated with this <see cref="System.Diagnostics.Process"/> object. </para>
			<para>-or-</para>
			<para>You are attempting to call <see cref="System.Diagnostics.Process.Kill"/> for a process that is running on a remote computer. The method is available only for processes running on the local computer. </para></exception>
		<exception cref="System.InvalidOperationException">The process has already exited.</exception>
		<remarks>
			<para><see cref="System.Diagnostics.Process.Kill"/> forces a termination of the process, while <see cref="System.Diagnostics.Process.CloseMainWindow"/> only
   requests a termination. When a process with a graphical interface is executing,
   its message loop is in a wait state. The message loop executes every time a
   Windows message is sent to the process by the operating system. Calling <see cref="System.Diagnostics.Process.CloseMainWindow"/> sends a
   request to close to the main window, which, in a well-formed application, closes child windows and
   revokes all running message loops for the application. The request to exit the process by
   calling <see cref="System.Diagnostics.Process.CloseMainWindow"/>
   does not force the application to quit. The application can ask for user
   verification before quitting, or it can refuse to quit. To force the application to quit, use
   the <see cref="System.Diagnostics.Process.Kill"/> method. The behavior of <see cref="System.Diagnostics.Process.CloseMainWindow"/> is identical to that of a user
   closing an application's main window using the system menu. Therefore, the
   request to exit the process by closing the main window does not force
   the application to quit immediately.</para>
			<para>Data edited by the process or resources allocated to the process can be lost
   if you call <see cref="System.Diagnostics.Process.Kill"/>. <see cref="System.Diagnostics.Process.Kill"/> causes an abnormal
   process termination and should be used only when necessary. <see cref="System.Diagnostics.Process.CloseMainWindow"/> enables an orderly termination of
   the process and closes all windows, so it is preferable for applications with an
   interface. If <see cref="System.Diagnostics.Process.CloseMainWindow"/> fails, you can use <see cref="System.Diagnostics.Process.Kill"/>
   to terminate the process. <see cref="System.Diagnostics.Process.Kill"/> is the only way to terminate
   processes that do not have graphical interfaces. </para>
			<para>You can call <see cref="System.Diagnostics.Process.Kill"/> and <see cref="System.Diagnostics.Process.CloseMainWindow"/> only for processes
that are running on the local computer. You cannot cause processes on
remote computers to exit. You can only view information for processes running on
remote computers.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.CloseMainWindow"/>
		<seealso cref="System.Diagnostics.Process.Start"/>
	</doc>
	<doc for="Process.ToString">
		<summary>
			<para>Formats the process's name as a string, combined with the parent component type, if applicable.</para>
		</summary>
		<returns>
			<para>The <see cref="System.Diagnostics.Process.ProcessName"/>, combined with the base component's
<see cref="System.Object.ToString"/> return value.</para>
		</returns>
		<example>
			<para>The following example starts an instance of the Notepad utility. It then
      retrieves the associated process's physical memory usage, base priority,
      processor time, privileged processor time, total processor time, name, and
      whether it has exited or is responding to the UI.</para>
			<codelink SampleID="process_sample" SnippetID="1"/>
		</example>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
	</doc>
	<doc for="Process.WaitForExit">
		<overload>
			<para>Sets the period of time to wait for the associated process to exit,
      and blocks the current thread of
      execution
      until the time has elapsed or the process has exited.</para>
		</overload>
		<summary>
			<para>Instructs the <see cref="System.Diagnostics.Process"/> component to wait the specified number of milliseconds for the associated process to exit.</para>
		</summary>
		<param name="milliseconds">The amount of time, in milliseconds, to wait for the associated process to exit. The maximum is the largest possible value of a 32-bit integer, which represents infinity to the operating system.</param>
		<returns>
			<para><see langword="true "/>if the associated process has exited; otherwise,
<see langword="false"/> .</para>
		</returns>
		<exception cref="T:System.ComponentModel.Win32Exception">The wait setting could not be accessed.</exception>
		<exception cref="System.SystemException"><para>No process <see cref="System.Diagnostics.Process.Id"/> has been set, and a <see cref="System.Diagnostics.Process.Handle"/> from which the <see cref="System.Diagnostics.Process.Id"/> property can be determined does not exist.</para>
			<para>-or-</para>
			<para>There is no process associated with this <see cref="System.Diagnostics.Process"/> object. </para>
			<para>-or-</para>
			<para>You are attempting to call <see cref="System.Diagnostics.Process.WaitForExit"/> for a process running on a remote computer. The method is only available for processes that are running on the local computer. </para></exception>
		<remarks>
			<para><see cref="System.Diagnostics.Process.WaitForExit"/>
is used to make the current thread wait until the associated process
terminates.</para>
			<para>This overload of <see cref="System.Diagnostics.Process.WaitForExit"/> instructs the <see cref="System.Diagnostics.Process"/>
component to wait a finite amount of time for the process to exit. If the
associated process does not exit by the end of the interval because the request
to terminate is denied, <see langword="false "/>is returned to the calling
procedure. You can specify a negative number for <paramref name="milliseconds"/> , but it is
treated by <see cref="System.Diagnostics.Process.WaitForExit"/> as a very large positive number. If
you pass zero to the method, it returns <see langword="true "/>only if the
process has already exited.</para>
			<para>When an associated process exits (is shut down by the operation system
   through a normal or abnormal termination), the system stores administrative
   information about the process and returns to the component that had called
<see cref="System.Diagnostics.Process.WaitForExit"/>. The <see cref="System.Diagnostics.Process"/> component can then access 
   the information, which includes the <see cref="System.Diagnostics.Process.ExitTime"/> , by using the
<see cref="System.Diagnostics.Process.Handle"/> to the exited process.</para>
			<para>Because the associated process has exited, the <see cref="System.Diagnostics.Process.Handle"/> property of the
component no longer points to an existing process resource. Instead, the
handle can be used only to access the operating system's information about
the process resource. The system is aware of handles to exited processes that
have not been released by <see cref="System.Diagnostics.Process"/> components, so it keeps the <see cref="System.Diagnostics.Process.ExitTime"/> and <see cref="System.Diagnostics.Process.Handle"/> information in
memory until the <see cref="System.Diagnostics.Process"/> component specifically frees the resources.
For this reason, any time you call <see cref="System.Diagnostics.Process.Start"/> for a <see cref="System.Diagnostics.Process"/> instance, call <see cref="System.Diagnostics.Process.Close"/> when the associated process has
terminated and you no longer need any administrative information about it.
<see cref="System.Diagnostics.Process.Close"/> frees the memory allocated to the 
exited process.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.CloseMainWindow"/>
		<seealso cref="System.Diagnostics.Process.Kill"/>
		<seealso cref="System.Diagnostics.Process.Handle"/>
		<seealso cref="System.Diagnostics.Process.ExitTime"/>
		<seealso cref="System.Diagnostics.Process.EnableRaisingEvents"/>
		<seealso cref="System.Diagnostics.Process.HasExited"/>
		<seealso cref="System.Diagnostics.Process.Exited"/>
	</doc>
	<doc for="Process.WaitForExit1">
		<summary>
			<para>Instructs the <see cref="System.Diagnostics.Process"/> component to wait
   indefinitely for the associated process to exit.</para>
		</summary>
		<exception cref="T:System.ComponentModel.Win32Exception">The wait setting could not be accessed.</exception>
		<exception cref="System.SystemException"><para>No process <see cref="System.Diagnostics.Process.Id"/> has been set, and a <see cref="System.Diagnostics.Process.Handle"/> from which the <see cref="System.Diagnostics.Process.Id"/> property can be determined does not exist.</para>
			<para>-or-</para>
			<para>There is no process associated with this <see cref="System.Diagnostics.Process"/> object. </para>
			<para>-or-</para>
			<para>You are attempting to call <see cref="System.Diagnostics.Process.WaitForExit"/> for a process running on a remote computer. The method is available only for processes that are running on the local computer. </para></exception>
		<remarks>
			<para><see cref="System.Diagnostics.Process.WaitForExit"/>
is used to make the current thread wait
until the
associated process terminates.</para>
			<para>This overload of <see cref="System.Diagnostics.Process.WaitForExit"/> instructs the <see cref="System.Diagnostics.Process"/> component to wait an infinite amount of time
for the process to exit. This can cause an application to stop responding. For
example, if you call <see cref="System.Diagnostics.Process.CloseMainWindow"/> for a process
that has a user interface, the request to the operating system
to terminate the associated process might not be handled if the
process is written to never enter its message
loop.</para>
			<para> When an associated process exits (is shut down by the
   operation system through a normal or abnormal termination), the system stores
   administrative information about the process and returns to the component that had
   called <see cref="System.Diagnostics.Process.WaitForExit"/>. The <see cref="System.Diagnostics.Process"/>
   
   component can then access the information, which
   includes the <see cref="System.Diagnostics.Process.ExitTime"/> , by using the <see cref="System.Diagnostics.Process.Handle"/> to the
   exited process.</para>
			<para>Because the associated process has exited, the <see cref="System.Diagnostics.Process.Handle"/> property of the component no longer points to an existing process
resource. Instead, the handle can be used only to access the operating system's information about
the process resource. The system is aware of handles to exited processes that
have not been released by <see cref="System.Diagnostics.Process"/> components, so it keeps the <see cref="System.Diagnostics.Process.ExitTime"/> and <see cref="System.Diagnostics.Process.Handle"/> information in
memory until the <see cref="System.Diagnostics.Process"/> component specifically frees the resources.
For this reason, any time you call <see cref="System.Diagnostics.Process.Start"/> for a <see cref="System.Diagnostics.Process"/> instance, call <see cref="System.Diagnostics.Process.Close"/> when the associated process has
terminated and you no longer need any administrative information about it. <see cref="System.Diagnostics.Process.Close"/>
frees the memory
allocated to the exited process.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.CloseMainWindow"/>
		<seealso cref="System.Diagnostics.Process.Kill"/>
		<seealso cref="System.Diagnostics.Process.Handle"/>
		<seealso cref="System.Diagnostics.Process.ExitTime"/>
		<seealso cref="System.Diagnostics.Process.EnableRaisingEvents"/>
		<seealso cref="System.Diagnostics.Process.HasExited"/>
		<seealso cref="System.Diagnostics.Process.Exited"/>
	</doc>
	<doc for="Process.WaitForInputIdle">
		<overload>
			<para> Causes the <see cref="System.Diagnostics.Process"/>
component to wait for the associated process to enter an idle
state.</para>
		</overload>
		<summary>
			<para> Causes the <see cref="System.Diagnostics.Process"/> component to wait the specified
   number of milliseconds for the associated process to enter an idle
   state. This
   overload applies only to processes with a user interface and,
   therefore, a message loop.
   </para>
		</summary>
		<param name="milliseconds">The amount of time, in milliseconds, to wait for the associated process to become idle. The maximum is the largest possible value of a 32-bit integer, which represents infinity to the operating system. </param>
		<returns>
			<para><see langword="true "/>if the associated process has reached an idle
   state; otherwise, <see langword="false"/>
   .
   </para>
		</returns>
		<remarks>
			<para>Use <see cref="System.Diagnostics.Process.WaitForInputIdle"/> to force the processing of your
   application to wait until the message loop has returned to the idle state. When
   a process with a user interface is executing, its message loop executes every
   time a Windows message is sent to the process by the operating system. The
   process then returns to the message loop. A process is said to be in an idle
   state when it is waiting for messages inside of a message loop. This state is
   useful, for example, when your application needs to wait for a starting process
   to finish creating its main window before the application communicates with that
   window.</para>
			<para>If a process does not have a message loop, <see cref="System.Diagnostics.Process.WaitForInputIdle"/> immediately returns
<see langword="false"/> .</para>
			<para> This overload of <see cref="System.Diagnostics.Process.WaitForInputIdle"/> instructs the <see cref="System.Diagnostics.Process"/> component to wait a finite
amount of time for the process to become idle in the message loop. If the
associated process has not become idle by the end of the interval because the
loop is still processing messages, <see langword="false "/>
is returned
to the calling procedure.</para>
			<para> For more information about handling events, see <see topic="cpconEventsOverview"/>
.</para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.Start"/>
		<seealso cref="System.Diagnostics.Process.CloseMainWindow"/>
	</doc>
	<doc for="Process.WaitForInputIdle1">
		<summary>
			<para> Causes the <see cref="System.Diagnostics.Process"/> component to wait indefinitely for the associated process to enter an
   idle state. This overload applies only to processes with a user interface and, therefore, a message loop.
   </para>
		</summary>
		<returns>
			<para><see langword="true "/>if the associated process has reached
   an idle state; otherwise, <see langword="false"/>
   .
   </para>
		</returns>
		<remarks>
			<para> Use <see cref="System.Diagnostics.Process.WaitForInputIdle"/> to force the processing
   of your application to wait until the message loop
   has returned to the idle state. When a process with a user interface is
   executing, its message loop executes every time a Windows message is sent to the
   process by the operating system. The process then returns to the message loop. A
   process is said to be in an idle state when it is waiting for messages inside of
   a message loop. This state is useful, for example, when your application needs to
   wait for a starting process to finish creating its main window
   before the
   application communicates with that window.</para>
			<para> If a process does not have a message loop, <see cref="System.Diagnostics.Process.WaitForInputIdle"/> immediately returns
<see langword="false"/>
.</para>
			<para> This overload of <see cref="System.Diagnostics.Process.WaitForInputIdle"/> instructs the <see cref="System.Diagnostics.Process"/> component to wait indefinitely for the
process to become idle in the message loop. This instruction can cause an application to
stop responding. For example, if the process is written to always exit
its message loop immediately, as in the code fragment <c>while(true)</c>
. </para>
		</remarks>
		<permission cref="System.Security.SecurityPermission">for calling any members of <see cref="System.Diagnostic.Process"/>with full trust . Associated enumeration: <see cref="System.Security.Permissions.PermissionState.Unrestricted" qualify="true"/></permission>
		<seealso cref="System.Diagnostics.Process.Start"/>
		<seealso cref="System.Diagnostics.Process.CloseMainWindow"/>
	</doc>
</docs>
