<docs>
	<doc for="MessageQueue.InfiniteTimeout">
		<summary>
			<para> 
       Specifies
       that no time-out exists for methods that peek or receive messages.</para>
		</summary>
		<remarks>
			<para>
				<see cref="System.Messaging.MessageQueue"/> supports two types of message retrieval: 
    synchronous and asynchronous. The synchronous methods, <see cref="System.Messaging.MessageQueue.Peek"/> and <see cref="System.Messaging.MessageQueue.Receive"/>, cause the process thread to wait a specified
    time interval for a new message to arrive in the queue. If the specified time interval is <see cref="System.Messaging.MessageQueue.InfiniteTimeout"/>, the process thread remains
    blocked until a new message is available. On the other hand, <see cref="System.Messaging.MessageQueue.BeginPeek"/> and <see cref="System.Messaging.MessageQueue.BeginReceive"/> (the asynchronous methods), allow
    the main application tasks to continue in
    a separate thread until a message arrives in the queue.</para>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
		<seealso cref="System.Messaging.MessageQueue.PeekById"/>
		<seealso cref="System.Messaging.MessageQueue.PeekByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
	</doc>
	<doc for="MessageQueue.MessageQueue3">
	</doc>
	<doc for="MessageQueue.ComputerName">
	</doc>
	<doc for="MessageQueue.Properties">
	</doc>
	<doc for="MessageQueue.PropertyFilter">
	</doc>
	<doc for="MessageQueue.QueuePath">
	</doc>
	<doc for="MessageQueue.CreateMessageQueuesSnapshot">
	</doc>
	<doc for="MessageQueue.CreateMessageQueuesSnapshot1">
	</doc>
	<doc for="MessageQueue.Finalize">
		<summary>
			<para>Frees the resources associated with this <see cref="System.Messaging.MessageQueue"/> instance.</para>
		</summary>
		<remarks>
			<para>The garbage collector calls the <see cref="System.Messaging.MessageQueue.Finalize"/> method to free 
    all resources associated with the <see cref="System.Messaging.MessageQueue"/>. <see cref="System.Messaging.MessageQueue.Finalize"/> calls <c>base.Finalize</c> and <c>this.Close</c>.</para>
			<note type="inheritinfo">
    When overriding
 <see cref="System.Messaging.MessageQueue.Finalize"/> in a derived class, be sure to 
    call the base class's <see cref="System.Messaging.MessageQueue.Finalize"/> method.
 </note>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.Dispose"/>
		<seealso cref="System.Messaging.MessageQueue.Close"/>
	</doc>
	<doc for="MessageQueue.GenerateQueueProperties">
	</doc>
	<doc for="MessageQueue.GetMessageQueueEnumerator2">
	</doc>
	<doc for="MessageQueue.GetPublicQueuesByLabel1">
	</doc>
	<doc for="MessageQueue.IsCanonicalPath">
	</doc>
	<doc for="MessageQueue.IsFatalError">
	</doc>
	<doc for="MessageQueue.IsMemoryError">
	</doc>
	<doc for="MessageQueue.OnRequestCompleted">
		<summary>
    Used for component model event support. 
 </summary>
	</doc>
	<doc for="MessageQueue.ReceiveAsync">
	</doc>
	<doc for="MessageQueue.ReceiveBy">
	</doc>
	<doc for="MessageQueue.ReceiveCurrent">
	</doc>
	<doc for="MessageQueue.SaveQueueProperties">
	</doc>
	<doc for="MessageQueue.SendInternal">
	</doc>
	<doc for="MessageQueue.ResolveQueueFromLabel">
	</doc>
	<doc for="MessageQueue.ValidatePath">
	</doc>
	<doc for="MessageQueue.SizeConverter.CanConvertFrom">
		<summary>
      Determines if this converter can convert an object in the given source
      type to the native type of the converter.
 </summary>
		<param name="context">
      A formatter context.  This object can be used to extract additional information
      about the environment this converter is being invoked from.  This may be null,
      so you should always check.  Also, properties on the context object may also
      return null.
 </param>
		<param name="sourceType">
      The type you wish to convert from.
 </param>
		<returns>
      True if this object can perform the conversion.
 </returns>
	</doc>
	<doc for="MessageQueue.SizeConverter.ConvertFrom">
		<summary>
      Converts the given object to the converter's native type.
 </summary>
		<param name="context">
      A formatter context.  This object can be used to extract additional information
      about the environment this converter is being invoked from.  This may be null,
      so you should always check.  Also, properties on the context object may also
      return null.
 </param>
		<param name="culture">
      Culture to use to perform the conversion
 </param>
		<param name="value">
      The object to convert.
 </param>
		<returns>
      The converted object.  This will throw an excetpion if the converson
      could not be performed.
 </returns>
	</doc>
	<doc for="MessageQueue.SizeConverter.ConvertTo">
		<summary>
      Converts the given object to another type.  The most common types to convert
      are to and from a string object.  The default implementation will make a call
      to ToString on the object if the object is valid and if the destination
      type is string.  If this cannot convert to the desitnation type, this will
      throw a NotSupportedException.
 </summary>
		<param name="context">
      A formatter context.  This object can be used to extract additional information
      about the environment this converter is being invoked from.  This may be null,
      so you should always check.  Also, properties on the context object may also
      return null.
 </param>
		<param name="culture">
      Culture to use to perform the conversion
 </param>
		<param name="value">
      The object to convert.
 </param>
		<param name="destinationType">
      The type to convert the object to.
 </param>
		<returns>
      The converted object.
 </returns>
	</doc>
	<doc for="MessageQueue.QueuePropertyFilter">
	</doc>
	<doc for="MessageQueue.AsynchronousRequest">
		<summary>
    This class is used in asynchronous operations,
    it keeps the context under which the asynchronous
    request was posted.
 </summary>
	</doc>
	<doc for="MessageQueue.AsynchronousRequest.AsynchronousRequest">
		<summary>
    Creates a new asynchronous request that 
    represents a pending asynchronous operation.
 </summary>
	</doc>
	<doc for="MessageQueue.AsynchronousRequest.Action">
	</doc>
	<doc for="MessageQueue.AsynchronousRequest.AsyncObject">
		<summary>
    IAsyncResult implementation        
 </summary>
	</doc>
	<doc for="MessageQueue.AsynchronousRequest.AsyncState">
		<summary>
    IAsyncResult implementation        
 </summary>
	</doc>
	<doc for="MessageQueue.AsynchronousRequest.AsyncWaitHandle">
		<summary>
    IAsyncResult implementation        
 </summary>
	</doc>
	<doc for="MessageQueue.AsynchronousRequest.CompletedSynchronously">
		<summary>
    IAsyncResult implementation        
 </summary>
	</doc>
	<doc for="MessageQueue.AsynchronousRequest.IsCompleted">
		<summary>
    IAsyncResult implementation        
 </summary>
	</doc>
	<doc for="MessageQueue.AsynchronousRequest.BeginRead">
		<summary>
   Does the actual asynchronous receive posting.
 </summary>
	</doc>
	<doc for="MessageQueue.AsynchronousRequest.End">
		<summary>
   Waits until the request has been completed.
 </summary>
	</doc>
	<doc for="MessageQueue.AsynchronousRequest.OnCompletionStatusChanged">
		<summary>
   Thread pool IOCompletionPort bound callback.
 </summary>
	</doc>
	<doc for="MessageQueue.AsynchronousRequest.OnMessageReceived">
		<summary>
   MSMQ APC based callback.
 </summary>
	</doc>
	<doc for="MessageQueue.AsynchronousRequest.RaiseCompletionEvent">
	</doc>
	<doc for="MessageQueue.InfiniteQueueSize">
		<summary>
			<para>Specifies that no size restriction exists for a queue.</para>
		</summary>
		<remarks>
			<para>This field is frequently used when setting <see cref="System.Messaging.MessageQueue.MaximumJournalSize"/> or <see cref="System.Messaging.MessageQueue.MaximumQueueSize"/> 
.</para>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.MaximumJournalSize"/>
		<seealso cref="System.Messaging.MessageQueue.MaximumQueueSize"/>
	</doc>
	<doc for="MessageQueue.Dispose">
		<nodoc/>
		<summary>
			<para>Disposes of the resources (other than memory) used by the <see cref="System.Messaging.MessageQueue"/>.</para>
		</summary>
		<remarks>
			<para>Call <see cref="System.Messaging.MessageQueue.Dispose"/> when you are finished using
   the <see cref="System.Messaging.MessageQueue"/>. The <see cref="System.Messaging.MessageQueue.Dispose"/> method leaves the <see cref="System.Messaging.MessageQueue"/>
   in an unusable state. After calling <see cref="System.Messaging.MessageQueue.Dispose"/>, you must release all
   references to the <see cref="System.Messaging.MessageQueue"/> so the memory it was occupying can be
   reclaimed by garbage collection.</para>
			<note type="note">
   You
   should call <see cref="System.Messaging.MessageQueue.Dispose"/> before you release your last reference to the
<see cref="System.Messaging.MessageQueue"/>. Otherwise, the resources the <see cref="System.Messaging.MessageQueue"/>
is using will not be freed until garbage collection calls the <see cref="System.Messaging.MessageQueue"/>
object's destructor.
</note>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.Close"/>
	</doc><doc for="MessageQueue.SynchronizingObject">
		<summary>
			<para> Gets or sets the object
      that marshals the event-handler call resulting from a <see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> or <see cref="System.Messaging.MessageQueue.PeekCompleted"/>
      event.</para>
		</summary>
		<value>
			<para>An <see cref="System.ComponentModel.ISynchronizeInvoke"/>,
   which represents the object that marshals the event-handler call resulting from a <see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> or <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event. The default is
<see langword="null"/>. </para>
		</value>
		<remarks>
			<para>A <see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> or <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event results from a <see cref="System.Messaging.MessageQueue.BeginReceive"/> or <see cref="System.Messaging.MessageQueue.BeginPeek"/> 
request, respectively, to a specific thread. Typically, the <see cref="System.Messaging.MessageQueue.SynchronizingObject"/> is
set when its related component is placed inside a
control or a form, because those components are bound to a specific thread.</para>
			<para> Typically, the synchronizing object marshals a method call into a single thread.</para>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.PeekCompleted"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveCompleted"/>
	</doc><doc for="MessageQueue.MessageQueue1">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Messaging.MessageQueue"/> class that references the Message Queuing
   queue at the specified path.</para>
		</summary>
		<param name="path">The location of the queue referenced by this <see cref="System.Messaging.MessageQueue"/> . For information on the proper syntax for this parameter, see the Remarks section.</param>
		<exception cref="System.ArgumentException">The <see cref="System.Messaging.MessageQueue.Path"/> property is invalid, possibly because it has not been set.</exception>
		<remarks>
			<para> Use
      this overload when you want to tie the new <see cref="System.Messaging.MessageQueue"/> instance to a particular Message Queuing
      queue, for which you know the path, format name, or label. If you want to
      grant exclusive access to the first application that references the queue, you must
      set the <see cref="System.Messaging.MessageQueue.DenySharedReceive"/> property to <see langword="true "/> or use the constructor that passes a read-access
      restriction parameter.</para>
			<note type="note">
      The <see cref="System.Messaging.MessageQueue()"/>
      constructor instantiates a new instance of the <see cref="System.Messaging.MessageQueue"/> class; it does not create a new Message
      Queuing queue. To create a new queue in Message Queuing, use <see cref="System.Messaging.MessageQueue.Create"/> .
      
   </note>
			<para>The syntax of the <paramref name="path"/> parameter depends on
   the type of queue it references. </para>
			<list type="table">
				<listheader>
					<term>Queue Type</term>
					<description>Syntax</description>
				</listheader>
				<item>
					<term> Public queue</term>
					<description><paramref name="MachineName"/>\<paramref name="QueueName"/></description>
				</item>
				<item>
					<term> Private queue</term>
					<description><paramref name="MachineName"/>\<see langword="Private$"/>\<paramref name="QueueName"/></description>
				</item>
				<item>
					<term> Journal queue</term>
					<description><paramref name="MachineName"/>\<paramref name="QueueName"/>\<see langword="Journal$"/></description>
				</item>
				<item>
					<term> Machine journal queue</term>
					<description><paramref name="MachineName"/>\<see langword="Journal$"/></description>
				</item>
				<item>
					<term> Machine dead-letter queue</term>
					<description><paramref name="MachineName"/>\<see langword="Deadletter$"/></description>
				</item>
				<item>
					<term> Machine transactional dead-letter queue</term>
					<description><paramref name="MachineName"/>\<see langword="XactDeadletter$"/></description>
				</item>
			</list>
			<para>Alternatively, you can use the <see cref="System.Messaging.MessageQueue.FormatName"/>
or <see cref="System.Messaging.MessageQueue.Label"/>
to describe the queue
path.</para>
			<list type="table">
				<listheader>
					<term>Reference</term>
					<description>Syntax</description>
					<description>Example</description>
				</listheader>
				<item>
					<term> Format
         name</term>
					<description><see langword="FormatName:"/>[<paramref name="format name"/>
   ]</description>
					<description>
						<para><see langword="FormatName:Public="/>5A5F7535-AE9A-41d4-935C-845C2AFF7112</para>
						<para><see langword="FormatName:DIRECT=SPX:"/><paramref name="NetworkNumber"/>;<paramref name="HostNumber"/>\<paramref name="QueueName"/></para>
						<para><see langword="FormatName:DIRECT=TCP:"/><paramref name="IPAddress"/>\<paramref name="QueueName"/></para>
						<para><see langword="FormatName:DIRECT=OS:"/><paramref name="MachineName"/>\<paramref name="QueueName"/></para></description>
				</item>
				<item>
					<term> Label</term>
					<description><see langword="Label:"/>[<paramref name="label"/>]</description>
					<description><see langword="Label:"/>TheLabel</description>
				</item>
			</list>
			<para>To work offline, you must use the format name syntax, not
   the path name syntax for the constructor. Otherwise, an exception is thrown
   because the primary domain controller is not available to resolve the
   path to the format name.</para>
			<para>The following table shows initial property values for an
   instance of <see cref="System.Messaging.MessageQueue"/>
   . These values are based on the properties of the Message Queuing queue
   with the path specified by the <paramref name="path"/> parameter.</para>
			<list type="table">
				<listheader>
					<term>Property</term>
					<description>Initial Value</description>
				</listheader>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.Authenticate"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.BasePriority"/></term>
					<description> 0</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.Category"/></term>
					<description><see cref="System.Guid.Empty"/></description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/></term>
					<description>The values set by the
      default constructor of the <see cref="System.Messaging.DefaultPropertiesToSend"/>
      class.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.EncryptionRequired"/></term>
					<description><see langword="true"/> , if the
   Message Queuing queue's PrivLevel setting is "Body"; otherwise,
<see langword="false."/></description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.Formatter"/></term>
					<description><see cref="System.Messaging.XmlMessageFormatter"/></description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.Label"/></term>
					<description><see cref="System.String.Empty"/></description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.MachineName"/></term>
					<description> The value of the Message Queuing queue's computer name
      property.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.MaximumJournalSize"/></term>
					<description><see cref="System.Messaging.MessageQueue.InfiniteQueueSize"/></description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.MaximumQueueSize"/></term>
					<description><see cref="System.Messaging.MessageQueue.InfiniteQueueSize"/></description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.MessageReadPropertyFilter"/></term>
					<description>The values set by the
      default constructor of the <see cref="System.Messaging.MessagePropertyFilter"/>
      class.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.Path"/></term>
					<description><see cref="System.String.Empty"/> , if not set by the constructor.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.QueueName"/></term>
					<description><see cref="System.String.Empty"/> , if not set by the
   constructor.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.DenySharedReceive"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.UseJournalQueue"/></term>
					<description><see langword="true"/>, if the Message Queuing object's
   journal setting is enabled; otherwise,
<see langword="false"/>.</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example creates new <see cref="System.Messaging.MessageQueue"/> objects using various path name syntax
   types. In each case, it sends a message to the queue whose path is
   defined in the constructor.</para>
			<codelink SampleID="MessageQueue.Path" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.FormatName"/>
		<seealso cref="System.Messaging.MessageQueue.Label"/>
		<seealso cref="System.Messaging.MessageQueue.QueueName"/>
		<seealso cref="System.Messaging.MessageQueue.Path"/>
		<seealso cref="System.Messaging.MessageQueue.Create"/>
	</doc><doc for="MessageQueue.MessageQueue2">
		<summary>
			<para>Initializes a new instance of the <see cref="System.Messaging.MessageQueue"/> class that references the Message Queuing
   queue at the specified path
   and with the specified read-access restriction.</para>
		</summary>
		<param name="path">The location of the queue referenced by this <see cref="System.Messaging.MessageQueue"/> , which can be "." for the local computer. For information on the proper syntax for this parameter, see the Remarks section.</param>
		<param name="sharedModeDenyReceive"><see langword="true"/> to grant exclusive read access to the first application that accesses the queue; otherwise, <see langword="false"/> .</param>
		<exception cref="System.ArgumentException">The <see cref="System.Messaging.MessageQueue.Path"/> property is invalid, possibly because it has not been set.</exception>
		<remarks>
			<para> Use this overload when you want to tie the new <see cref="System.Messaging.MessageQueue"/> to a
   particular Message Queuing queue, for which you know the path, format name, or
   label. If you want to grant exclusive access to the first application that
   references the queue, set the <paramref name="sharedModeDenyReceive"/> parameter to
<see langword="true"/>. Otherwise, set <paramref name="sharedModeDenyReceive"/>
to <see langword="false "/> or use the constructor that has
only a <paramref name="path"/> parameter.</para>
			<para>Setting <paramref name="sharedModeDenyReceive"/> to <see langword="true"/> affects all
objects that access the Message Queuing queue, including other applications. The
effects of the parameter are not restricted to this application.</para>
			<note type="note">
   The <see cref="System.Messaging.MessageQueue()"/> constructor creates a
   new instance of the <see cref="System.Messaging.MessageQueue"/> class; it does not create a new Message
   Queuing queue. To create a new queue in Message Queuing, use <see cref="System.Messaging.MessageQueue.Create"/> .
</note>
			<para>The syntax of the <paramref name="path"/>
parameter depends on the type of queue.</para>
			<list type="table">
				<listheader>
					<term>Queue Type</term>
					<description>Syntax</description>
				</listheader>
				<item>
					<term> Public queue</term>
					<description><paramref name="MachineName"/>\<paramref name="QueueName"/></description>
				</item>
				<item>
					<term> Private queue</term>
					<description><paramref name="MachineName"/>\<see langword="Private$"/>\<paramref name="QueueName"/></description>
				</item>
				<item>
					<term> Journal queue</term>
					<description><paramref name="MachineName"/>\<paramref name="QueueName"/>\<see langword="Journal$"/></description>
				</item>
				<item>
					<term> Machine journal queue</term>
					<description><paramref name="MachineName"/>\<see langword="Journal$"/></description>
				</item>
				<item>
					<term> Machine dead-letter queue</term>
					<description><paramref name="MachineName"/>\<see langword="Deadletter$"/></description>
				</item>
				<item>
					<term> Machine transactional dead-letter queue</term>
					<description><paramref name="MachineName"/>\<see langword="XactDeadletter$"/></description>
				</item>
			</list>
			<para>Alternatively, you can use the format name or label
   of a Message Queuing queue to describe
   the queue path.</para>
			<list type="table">
				<listheader>
					<term>Reference</term>
					<description>Syntax</description>
					<description>Example</description>
				</listheader>
				<item>
					<term> Format
         name</term>
					<description><see langword="FormatName:"/>[<paramref name="format name"/>
   ]</description>
					<description>
						<para><see langword="FormatName:Public="/>5A5F7535-AE9A-41d4-935C-845C2AFF7112</para>
						<para><see langword="FormatName:DIRECT=SPX:"/><paramref name="NetworkNumber"/>;<paramref name="HostNumber"/>\<paramref name="QueueName"/></para>
						<para><see langword="FormatName:DIRECT=TCP:"/><paramref name="IPAddress"/>\<paramref name="QueueName"/></para>
						<para><see langword="FormatName:DIRECT=OS:"/><paramref name="MachineName"/>\<paramref name="QueueName"/></para></description>
				</item>
				<item>
					<term> Label</term>
					<description><see langword="Label:"/>[<paramref name="label"/>]</description>
					<description><see langword="Label:"/>TheLabel</description>
				</item>
			</list>
			<para> To work offline, you must use the format name syntax, rather than
   the friendly name syntax. Otherwise, an exception is thrown because the
   primary domain controller (on which Active Directory resides) is not available to
   resolve the path to the format name. </para>
			<para>If a <see cref="System.Messaging.MessageQueue"/> opens a queue with the
<paramref name="sharedModeDenyReceive"/> parameter set to <see langword="true"/>, any <see cref="System.Messaging.MessageQueue"/> 
that subsequently tries to read from the queue generates a <see cref="System.Messaging.MessageQueueException"/> because of a sharing violation. A <see cref="System.Messaging.MessageQueueException"/> is also thrown if a <see cref="System.Messaging.MessageQueue"/>
tries to access the queue in exclusive mode while another <see cref="System.Messaging.MessageQueue"/>
already has nonexclusive access to the queue. </para>
			<para>The following table shows initial property values for an instance of <see cref="System.Messaging.MessageQueue"/> .
These values are based on the properties of the Message Queuing queue, with the
path specified by the <paramref name="path"/> parameter. </para>
			<list type="table">
				<listheader>
					<term>Property</term>
					<description>Initial Value</description>
				</listheader>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.Authenticate"/></term>
					<description><see langword="false"/>.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.BasePriority"/></term>
					<description> 0.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.Category"/></term>
					<description><see cref="System.Guid.Empty"/>.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/></term>
					<description>The values set by the
      default constructor of the <see cref="System.Messaging.DefaultPropertiesToSend"/>
      class.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.EncryptionRequired"/></term>
					<description><see langword="true"/> , if the
   Message Queuing queue's PrivLevel setting is "Body"; otherwise,
<see langword="false"/>.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.Formatter"/></term>
					<description><see cref="System.Messaging.XmlMessageFormatter"/>.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.Label"/></term>
					<description><see cref="System.String.Empty"/>.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.MachineName"/></term>
					<description> The value of the Message Queuing queue's computer name
      property.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.MaximumJournalSize"/></term>
					<description><see cref="System.Messaging.MessageQueue.InfiniteQueueSize"/>.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.MaximumQueueSize"/></term>
					<description><see cref="System.Messaging.MessageQueue.InfiniteQueueSize"/>.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.MessageReadPropertyFilter"/></term>
					<description>The values set by the
      default constructor of the <see cref="System.Messaging.MessagePropertyFilter"/>
      class.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.Path"/></term>
					<description><see cref="System.String.Empty"/> , if not set by the constructor.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.QueueName"/></term>
					<description><see cref="System.String.Empty"/> , if not set by the
   constructor.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.DenySharedReceive"/></term>
					<description>The value of the <paramref name="sharedModeDenyReceive"/>
parameter.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.UseJournalQueue"/></term>
					<description><see langword="true"/>, if the Message Queuing object's
   journal setting is enabled; otherwise,
<see langword="false"/>.</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example creates a new <see cref="System.Messaging.MessageQueue"/>
with exclusive access, sets its path, and sends a message
to the queue.</para>
			<codelink SampleID="MessageQueue.ctor_PathSharedModeDenyReceive" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.FormatName"/>
		<seealso cref="System.Messaging.MessageQueue.Label"/>
		<seealso cref="System.Messaging.MessageQueue.Path"/>
		<seealso cref="System.Messaging.MessageQueue.QueueName"/>
		<seealso cref="System.Messaging.MessageQueue.Create"/>
		<seealso cref="System.Messaging.MessageQueue.DenySharedReceive"/>
	</doc><doc for="MessageQueue.PeekCompleted">
		<summary>
			<para>Occurs when a message is read without being removed
      from the queue. This is a result of the asynchronous operation, <see cref="System.Messaging.MessageQueue.BeginPeek"/>
      .</para>
		</summary>
		<remarks>
			<para><see cref="System.Messaging.MessageQueue.BeginPeek"/> is used in asynchronous
   processing to raise the <see cref="E:System.Messaging.MessageQueue.PeekCompleted"/> event when a message is
   available in the queue.</para>
			<para><see cref="System.Messaging.MessageQueue.EndPeek"/> is used to complete the operation
initiated by a call to <see cref="System.Messaging.MessageQueue.BeginPeek"/> and peek the message when the
<see cref="System.Messaging.MessageQueue.PeekCompleted"/> event is raised.</para>
			<para>When you create a <see cref="System.Messaging.PeekCompletedEventHandler"/> delegate, you identify the
method that will handle the event. To associate the event with your event
handler, add an instance of the delegate to the event. The event handler is
called whenever the event occurs, unless you remove the delegate. For more
information about event handler delegates, see <see topic="cpconEventsDelegates"/>.</para>
		</remarks>
		<example>
			<para>The following example creates an event handler named <c>MyPeekCompleted</c> , attaches it to the <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event handler delegate, and calls 
<see cref="System.Messaging.MessageQueue.BeginPeek"/> to initiate an asynchronous peek 
operation on the queue that is located at the path ".\myQueue". When a <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event is raised, the example
peeks the message and writes its body to the screen. The example then calls
<see cref="System.Messaging.MessageQueue.BeginPeek"/> again to initiate a new 
asynchronous peek operation</para>
			<codelink SampleID="MessageQueue.BeginPeek_noparms" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
		<seealso cref="System.Messaging.MessageQueue.EndPeek"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveCompleted"/>
		<seealso cref="System.TimeSpan"/>
		<seealso cref="System.AsyncCallback"/>
		<seealso cref="System.IAsyncResult"/>
	</doc><doc for="MessageQueue.Authenticate">
		<summary>
			<para> Gets or sets a value indicating whether the queue accepts only authenticated
      messages.</para>
		</summary>
		<value>
			<para><see langword="true "/> if the queue accepts only authenticated messages;
   otherwise, <see langword="false"/>. The default is <see langword="false"/>.</para>
		</value>
		<exception cref="System.Messaging.MessageQueueException"><para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para> Message authentication provides a way to ensure message
      integrity and to verify who sent the message. To request authentication, the
      sending application sets the message's authentication level.</para>
			<note type="note">
      When you set <see cref="System.Messaging.MessageQueue.Authenticate"/> to <see langword="true"/>, you are
      restricting access to the queue on the server, not only to this
   <see cref="System.Messaging.MessageQueue"/> instance. All clients working against the
      same Message Queuing queue will be affected.
      
   </note>
			<para> A queue that accepts
      only authenticated messages will reject a nonauthenticated message. To request
      notification of message rejection, a sending application can set the <see cref="System.Messaging.Message.AcknowledgeType"/> property of the message. Because no
      other indication of message rejection exists, the sending application can lose
      the message unless you request that it be sent to the dead-letter queue.</para>
			<para> The following table shows whether this property is available in 
      various Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term> Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Local computer + direct format name</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer + direct format name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.Message.UseDeadLetterQueue"/>
		<seealso cref="System.Messaging.Message.AcknowledgeType"/>
	</doc>
	<doc for="MessageQueue.BasePriority">
		<summary>
			<para> Gets or sets the base priority Message
      Queuing uses to route a public queue's messages over the network.</para>
		</summary>
		<value>
			<para>The single base priority for all messages sent to the (public) queue. The default is zero (0).</para>
		</value>
		<exception cref="System.ArgumentException">The base priority was set to an invalid value.</exception>
		<exception cref="System.Messaging.MessageQueueException"><para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>A message queue's base priority specifies how
      a message en route to that queue is treated as it
      travels through the network. You can set the <see cref="System.Messaging.MessageQueue.BasePriority"/>
      property to confer a higher or lower priority to all messages sent to the
      specified queue than those sent to other queues. Setting this property modifies
      the Message Queuing queue. Therefore, any other <see cref="System.Messaging.MessageQueue"/>
      instances are
      affected by the change.</para>
			<para>A message queue's <see cref="System.Messaging.MessageQueue.BasePriority"/> is not related to the <see cref="System.Messaging.Message.Priority"/> property of a message, which specifies
   the order in which an incoming message is placed in the queue.</para>
			<para><see cref="System.Messaging.MessageQueue.BasePriority"/> applies only to public queues
whose paths are specified using the format name. The base priority of a private
queue is always zero (0).</para>
			<para> The following table shows whether this property is available in 
   various Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term> Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.FormatName"/>
	</doc>
	<doc for="MessageQueue.CanRead">
		<summary>
			<para> Gets a value indicating whether the <see cref="System.Messaging.MessageQueue"/>
can be read.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Messaging.MessageQueue"/> exists and the application
   can read from it; otherwise, <see langword="false"/>.</para>
		</value>
		<remarks>
			<para><see cref="System.Messaging.MessageQueue.CanRead"/> indicates whether the application
   is able to peek or receive messages from the queue. If <see cref="System.Messaging.MessageQueue.CanRead"/> is <see langword="true"/>, the <see cref="System.Messaging.MessageQueue"/>can receive or peek messages from the queue. Otherwise, it cannot. </para>
			<para><see cref="System.Messaging.MessageQueue.CanRead"/> is
<see langword="false"/> if a queue is already open with exclusive read 
access (or if it's open with nonexclusive access and this <see cref="System.Messaging.MessageQueue"/>
requests exclusive access), or if the application does
not have sufficient rights to access it. If your application tries to
read from a queue when <see cref="System.Messaging.MessageQueue.CanRead"/> is
<see langword="false"/> , access is denied. </para>
			<para> The following table shows whether this property is available in 
   various Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term> Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.CanWrite"/>
		<seealso cref="System.Messaging.MessageQueue.ReadHandle"/>
	</doc>
	<doc for="MessageQueue.CanWrite">
		<summary>
			<para> Gets a value indicating whether the <see cref="System.Messaging.MessageQueue"/> can
   be written to.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the <see cref="System.Messaging.MessageQueue"/> exists and the
   application can write to it; otherwise,
<see langword="false"/>.</para>
		</value>
		<remarks>
			<para><see cref="System.Messaging.MessageQueue.CanWrite"/> indicates whether the application
   is able to send messages to the queue. If <see cref="System.Messaging.MessageQueue.CanWrite"/> is <see langword="true"/>, the
<see cref="System.Messaging.MessageQueue"/> can send messages to the queue. Otherwise, it cannot. </para>
			<para><see cref="System.Messaging.MessageQueue.CanWrite"/> is <see langword="false"/> if a
queue is already open with exclusive write access (or if it's open with
nonexclusive access and this <see cref="System.Messaging.MessageQueue"/> requests exclusive
access), or if the application does not have sufficient rights to access it. If
your application tries to write to a queue when <see cref="System.Messaging.MessageQueue.CanWrite"/> is
<see langword="false"/>
, access is denied.</para>
			<para><see langword=""/>
			</para>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.WriteHandle"/>
		<seealso cref="System.Messaging.MessageQueue.CanRead"/>
	</doc>
	<doc for="MessageQueue.Category">
		<summary>
			<para>Gets or sets the queue category.</para>
		</summary>
		<value>
			<para>A <see cref="System.Guid"/>
that represents the queue category (Message Queuing
type identifier),
which allows an application
to categorize its queues. The default is <see langword="Guid.empty"/>
.</para>
		</value>
		<exception cref="System.ArgumentException">The queue category was set to an invalid value.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>The queue category allows an application to categorize
      its queues. For example, you can place
      all Billing queues in one category and
      all Order queues in another.</para>
			<para>The <see cref="System.Messaging.MessageQueue.Category"/> property provides access to the
   Message Queuing Type ID property (which is read/write), accessible through the
<see langword="Queue Properties"/> 
dialog box on the Computer Management Console.
You can define a new category. Although you can use
<see cref="M:System.Guid.NewGuid"/>
to create a category value that is unique across all <see cref="System.Guid"/> values, such an
action is unnecessary. The category value needs to be distinct only from other
categories, not from all other <see cref="System.Guid"/> values. For
example, you can assign
{00000000-0000-0000-0000-000000000001} as the <see cref="System.Messaging.MessageQueue.Category"/> for one set of queues and
{00000000-0000-0000-0000-000000000002} as the <see cref="System.Messaging.MessageQueue.Category"/>
for another
set.</para>
			<para>It is not necessary to set the <see cref="System.Messaging.MessageQueue.Category"/>. The value can be
<see langword="null"/> 
. </para>
			<para>Setting this property modifies the Message Queuing queue. Therefore, any
   other <see cref="System.Messaging.MessageQueue"/> instances are affected by the change. </para>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term> Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.Id"/>
		<seealso cref="System.Messaging.MessageQueue.Label"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByCategory"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueues"/>
	</doc>
	<doc for="MessageQueue.CreateTime">
		<summary>
			<para>Gets the time and date that the queue was created in Message Queuing.</para>
		</summary>
		<value>
			<para>A <see cref="System.DateTime"/> representing the
   date and time at which the queue was
   created. </para>
		</value>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para><see cref="System.Messaging.MessageQueue.CreateTime"/>
refers to the queue on the
Message Queuing server, not the <see cref="System.Messaging.MessageQueue"/>
instance.</para>
			<para> If
   the queue exists, this property represents the time the queue was created, adjusted to
   the local time of the server on which the queue exists.</para>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term> Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.LastModifyTime"/>
		<seealso cref="System.Messaging.MessageQueue.Create"/>
	</doc>
	<doc for="MessageQueue.DefaultPropertiesToSend">
		<summary>
			<para>Gets or sets the message property values to be used by
      default when the application sends messages to the
      queue.</para>
		</summary>
		<value>
			<para>A <see cref="System.Messaging.DefaultPropertiesToSend"/> containing the
   default Message Queuing message property
   values used when the application sends objects other than <see cref="System.Messaging.Message"/>
   instances to the
   queue.</para>
		</value>
		<exception cref="System.ArgumentException">The default properties could not be set for the queue, possibly because one of the properties is invalid.</exception>
		<remarks>
			<para>When you send any object that is not of type <see cref="System.Messaging.Message"/> to the queue, the
<see cref="System.Messaging.MessageQueue"/> inserts the object into a Message Queuing
   message. At that time, the <see cref="System.Messaging.MessageQueue"/> applies to the
   message the property values
   you specify in the <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>
   property. Conversely, if you send a <see cref="System.Messaging.Message"/>
   to the queue, these properties are already specified for the
   instance itself, so <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/> is ignored for the <see cref="System.Messaging.Message"/>
   . </para>
			<para>Although you set the properties through the <see cref="System.Messaging.MessageQueue"/>
object, the <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>
refers to the properties
of the messages that are sent to the queue, not the queue
itself.</para>
			<para>The default values for the properties are represented in the following
   table.</para>
			<list type="table">
				<listheader>
					<term>Property</term>
					<description> Default Value</description>
				</listheader>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.AcknowledgeType"/></term>
					<description><see langword="AcknowledgeType.None"/>.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.AdministrationQueue"/></term>
					<description><see langword="null"/>.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.AppSpecific"/></term>
					<description>Zero (0).</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.AttachSenderId"/></term>
					<description><see langword="true"/>.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm"/></term>
					<description><see langword="EncryptionAlgorithm.RC2"/>.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.Extension"/></term>
					<description>A zero-length array of
   bytes.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.HashAlgorithm"/></term>
					<description><see langword="HashAlgorithm.MD5"/>.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.Label"/></term>
					<description>Empty
   string
   ("").</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.Priority"/></term>
					<description><see langword="MessagePriority.Normal"/>.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.Recoverable"/></term>
					<description><see langword="false"/>.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.ResponseQueue"/></term>
					<description><see langword="null"/>.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.TimeToBeReceived"/></term>
					<description><see langword="Message.InfiniteTimeout"/>.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.TimeToReachQueue"/></term>
					<description><see langword="Message.InfiniteTimeout"/>.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue"/></term>
					<description><see langword="null"/>.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.UseAuthentication"/></term>
					<description><see langword="false"/>.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue"/></term>
					<description><see langword="false"/>.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.UseEncryption"/></term>
					<description><see langword="false"/>.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.UseJournalQueue"/></term>
					<description><see langword="false"/>.</description>
				</item>
				<item>
					<term><see cref="System.Messaging.DefaultPropertiesToSend.UseTracing"/></term>
					<description><see langword="false"/>.</description>
				</item>
			</list>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example uses the priority of a message to determine
      default properties to send for the message.</para>
			<codelink SampleID="MessageQueue.DefaultPropertiesToSend" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.Message"/>
		<seealso cref="System.Messaging.AcknowledgeTypes"/>
		<seealso cref="System.Messaging.EncryptionAlgorithm"/>
		<seealso cref="System.Messaging.HashAlgorithm"/>
		<seealso cref="System.Messaging.Message.InfiniteTimeout"/>
	</doc>
	<doc for="MessageQueue.DenySharedReceive">
		<summary>
			<para>Gets or sets a value indicating whether this <see cref="System.Messaging.MessageQueue"/> has exclusive access to receive messages from the Message Queuing queue.</para>
		</summary>
		<value>
			<para><see langword="true"/> if this
<see cref="System.Messaging.MessageQueue"/> has exclusive rights to receive messages from the
   queue; otherwise, <see langword="false"/>
   . The default is <see langword="false"/> .</para>
		</value>
		<remarks>
			<para><see cref="System.Messaging.MessageQueue.DenySharedReceive"/> specifies the shared mode of the
   queue referenced by this <see cref="System.Messaging.MessageQueue"/> . Set <see cref="System.Messaging.MessageQueue.DenySharedReceive"/> to
<see langword="true"/> to indicate that only this <see cref="System.Messaging.MessageQueue"/> should have access to peek or receive messages from the queue with the specified
<see cref="System.Messaging.MessageQueue.Path"/> . If another <see cref="System.Messaging.MessageQueue"/> 
or another application is associated with the same queue resource, that instance or application will not be
able to peek or receive messages, but it can still send them.</para>
			<para>If <see cref="System.Messaging.MessageQueue.DenySharedReceive"/> is <see langword="false"/>, the queue
is available to multiple applications for sending, peeking, or receiving messages. </para>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="M:System.Messaging.MessageQueue.#ctor"/>
		<seealso cref="System.Messaging.MessageQueue.EnableConnectionCache"/>
	</doc>
	<doc for="MessageQueue.EnableConnectionCache">
		<summary>
			<para>Gets or sets a value indicating whether a cache of
      connections will be maintained by the application.</para>
		</summary>
		<value>
			<para><see langword="true"/> to create and use a connection cache; otherwise,
<see langword="false"/>.</para>
		</value>
		<remarks>
			<para>A connection cache is a list of references to structures
      that contain read or write handles to queues. When <see cref="System.Messaging.MessageQueue.EnableConnectionCache"/> is <see langword="true"/>, the <see cref="System.Messaging.MessageQueue"/> borrows
      handles from the cache each time you call <see cref="System.Messaging.MessageQueue.Send"/>, <see cref="System.Messaging.MessageQueue.Peek"/>, or <see cref="System.Messaging.MessageQueue.Receive"/>
      , rather than open new handles. This can improve performance.
      Using a connection cache also insulates the <see cref="System.Messaging.MessageQueue"/>
      from changes in the network
      topology.</para>
			<para>If you create a new connection to a queue when
      the connection cache is full, the <see cref="System.Messaging.MessageQueue"/> overwrites the least
      recently accessed structure with the new connection. You can clear the cache
      entirely by calling <see cref="System.Messaging.MessageQueue.ClearConnectionCache"/>, for example if the format
      names of the queues you are working with have changed so that the previous read
      and write handles are no longer valid.</para>
			<para>The following table shows whether this property is available in various 
      Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
            name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer + direct format 
            name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.ClearConnectionCache"/>
	</doc>
	<doc for="MessageQueue.EncryptionRequired">
		<summary>
			<para>Gets or sets a value indicating whether the queue accepts only nonprivate
      (nonencrypted) messages.</para>
		</summary>
		<value>
			<para>One of
      the <see cref="System.Messaging.EncryptionRequired"/> values. The default is
   <see langword="None"/> .</para>
		</value>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para> When you specify that encryption is required for the messages sent
      to a queue, only the message bodies are encrypted. The other members (for example, the
   <see cref="System.Messaging.Message.Label"/> and <see cref="System.Messaging.Message.SenderId"/> properties) cannot be
      encrypted.</para>
			<para>Setting this property modifies the Message Queuing queue. Therefore, any
      other <see cref="System.Messaging.MessageQueue"/> instances are affected by the change.</para>
			<para> Encrypting a message makes the message private.
      You can specify the queue's encryption requirement
      to be <see langword="None"/>, <see langword="Body"/>, or
   <see langword="Optional"/> by setting the
   <see cref="System.Messaging.MessageQueue.EncryptionRequired"/> property appropriately. The
   <see cref="System.Messaging.Message.UseEncryption"/> setting of the message must correspond to
      the encryption requirement of the queue. If the message is not encrypted but the queue
      specifies <see langword="Body"/>, or if the message is encrypted but the queue
      specifies <see langword="None"/>
      , the message is rejected by the queue. If the sending application requests
      a negative acknowledgment message in this event, Message Queuing indicates the
      message's rejection to the sending application. If the <see cref="System.Messaging.Message.UseDeadLetterQueue"/> property
      is <see langword="true"/>
      , a message that
      fails encryption is sent to the dead-letter queue. Otherwise, the message is
      lost.</para>
			<para>The following table shows whether this property is available in various 
      Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
            name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
            name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.Acknowledgment"/>
		<seealso cref="System.Messaging.Message.UseEncryption"/>
	</doc>
	<doc for="MessageQueue.FormatName">
		<summary>
			<para>Gets the unique queue name that Message Queuing generated at the time of the queue's creation.</para>
		</summary>
		<value>
			<para> The name for the queue,
      which is unique on the network.</para>
		</value>
		<exception cref="System.Messaging.MessageQueueException"><para>The <see cref="System.Messaging.MessageQueue.Path"/> is not set.</para>
			<para> -or-</para>
			<para> An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>The <see cref="System.Messaging.MessageQueue.FormatName"/> property contains the format name of
   the queue. Message Queuing uses the format name to identify which queue to open and how
   to access it. Unlike most of a queue's characteristics, the format name is not
   a Message Queuing application queue property, so you cannot access it through the Message Queuing management
   tool. The format name is simply a unique name for the queue, which Message Queuing generates
   when it creates the queue or which the application generates later.</para>
			<para> If you specify a path using the path name syntax (such
   as <c>myComputer\myQueue</c>
) rather than
using the format name syntax when you read or write to
the queue, the primary domain controller (which uses Active Directory) translates
the <see cref="System.Messaging.MessageQueue.Path"/> into the associated <see cref="System.Messaging.MessageQueue.FormatName"/> before accessing the
queue. If your application is working offline, you must use the
format name syntax; otherwise, the primary domain controller will not be available to perform the path translation. </para>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.Path"/>
		<seealso cref="System.Messaging.MessageQueue.Label"/>
		<seealso cref="System.Messaging.MessageQueue"/>
	</doc>
	<doc for="MessageQueue.Id">
		<summary>
			<para>Gets the unique Message Queuing identifier of the queue.</para>
		</summary>
		<value>
			<para>An <see cref="System.Messaging.MessageQueue.Id"/> that represents the
   message identifier generated by the Message Queuing application.</para>
		</value>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para> Message Queuing sets the <see cref="System.Messaging.MessageQueue.Id"/>
property when it creates the queue.</para>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.Category"/>
		<seealso cref="System.Messaging.MessageQueue.PeekById"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.PeekByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
	</doc>
	<doc for="MessageQueue.Label">
		<summary>
			<para>Gets or sets the queue description.</para>
		</summary>
		<value>
			<para>The
      label for the message queue. The
      default is an empty string ("").</para>
		</value>
		<exception cref="System.ArgumentException">The label was set to an invalid value.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para> The maximum length of a message queue label
      is 124 characters.</para>
			<para>The <see cref="System.Messaging.MessageQueue.Label"/> property does not need to be
   unique across all queues. However, if
   multiple queues share the same <see cref="System.Messaging.MessageQueue.Label"/>
   , you cannot use the <see cref="System.Messaging.MessageQueue.Send"/> method
   to broadcast a message to all of them. If you use the label syntax for the <see cref="System.Messaging.MessageQueue.Path"/>
   property when you send the message, an exception will be
   thrown if the <see cref="System.Messaging.MessageQueue.Label"/>
   is not unique.</para>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.Path"/>
		<seealso cref="System.Messaging.MessageQueue.FormatName"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByLabel"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueues"/>
		<seealso cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/>
	</doc>
	<doc for="MessageQueue.MachineName">
		<summary>
			<para>Gets or sets the name of the computer where the Message
      Queuing queue
      is located.</para>
		</summary>
		<value>
			<para> The
      name of the computer where the queue is located. The Message Queuing default is ".", the local computer.</para>
		</value>
		<exception cref="System.ArgumentException">The <see cref="System.Messaging.MessageQueue.MachineName"/> is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException">The name of the computer is invalid, possibly because the syntax is incorrect.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>The <see cref="System.Messaging.MessageQueue.MachineName"/> is an integral component of the
   friendly name syntax of the queue <see cref="System.Messaging.MessageQueue.Path"/>
   . The following table shows the syntax you should use
   for a queue of a specified type when you want to identify the queue path
   using its friendly name.</para>
			<list type="table">
				<listheader>
					<term>Queue Type</term>
					<description>Syntax</description>
				</listheader>
				<item>
					<term> Public queue</term>
					<description><paramref name="MachineName"/>\<paramref name="QueueName"/></description>
				</item>
				<item>
					<term> Private queue</term>
					<description><paramref name="MachineName"/>\<see langword="Private$"/>\<paramref name="QueueName"/></description>
				</item>
				<item>
					<term> Journal queue</term>
					<description><paramref name="MachineName"/>\<paramref name="QueueName"/>\<see langword="Journal$"/></description>
				</item>
				<item>
					<term> Machine journal queue</term>
					<description><paramref name="MachineName"/>\<see langword="Journal$"/></description>
				</item>
				<item>
					<term> Machine dead-letter queue</term>
					<description><paramref name="MachineName"/>\<see langword="Deadletter$"/></description>
				</item>
				<item>
					<term> Machine transactional dead-letter queue</term>
					<description><paramref name="MachineName"/>\<see langword="XactDeadletter$"/></description>
				</item>
			</list>
			<para>Use "." for the local computer when specifying the
<see cref="System.Messaging.MessageQueue.MachineName"/> . 
   Only the computer name is recognized for this property, for example, <c>Server0</c>. The <see cref="System.Messaging.MessageQueue.MachineName"/> property does not support the IP address
format.</para>
			<para> If
   you define the <see cref="System.Messaging.MessageQueue.Path"/> in terms of the <see cref="System.Messaging.MessageQueue.MachineName"/> , the application throws an exception
   when working offline because the domain controller is required for
   path translation. Therefore, you
   must use the <see cref="System.Messaging.MessageQueue.FormatName"/> for the <see cref="System.Messaging.MessageQueue.Path"/>
   syntax when working offline.</para>
			<note type="note">
   The <see cref="System.Messaging.MessageQueue.MachineName"/>, <see cref="System.Messaging.MessageQueue.Path"/>, and <see cref="System.Messaging.MessageQueue.QueueName"/> properties are related. Changing the <see cref="System.Messaging.MessageQueue.MachineName"/> property causes the <see cref="System.Messaging.MessageQueue.Path"/>
   property to change. It is built from the new
<see cref="System.Messaging.MessageQueue.MachineName"/> and the <see cref="System.Messaging.MessageQueue.QueueName"/>. Changing the <see cref="System.Messaging.MessageQueue.Path"/> (for example, to use the format name syntax) 
   resets the <see cref="System.Messaging.MessageQueue.MachineName"/> and <see cref="System.Messaging.MessageQueue.QueueName"/> properties to refer to the new
   queue. If the <see cref="System.Messaging.MessageQueue.QueueName"/> property is empty, the <see cref="System.Messaging.MessageQueue.Path"/> is set to the Journal queue of the computer you
   specify.
</note>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.QueueName"/>
		<seealso cref="System.Messaging.MessageQueue.Path"/>
		<seealso cref="System.Messaging.MessageQueue.FormatName"/>
		<seealso cref="System.Messaging.MessageQueue.GetMachineId"/>
		<seealso cref="System.Messaging.MessageQueue.GetPrivateQueuesByMachine"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByMachine"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueues"/>
		<seealso cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/>
	</doc>
	<doc for="MessageQueue.MaximumJournalSize">
		<summary>
			<para>Gets or sets the maximum size of the journal queue.</para>
		</summary>
		<value>
			<para>The maximum size, in
      kilobytes, of the journal queue.
      The Message Queuing default specifies that no limit exists.</para>
		</value>
		<exception cref="System.ArgumentException">The maximum journal queue size was set to an invalid value.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para><see cref="System.Messaging.MessageQueue.MaximumJournalSize"/>
provides access to the Message Queuing journal storage limit. It is
relevant only when <see cref="System.Messaging.MessageQueue.UseJournalQueue"/> is <see langword="true"/> . Setting this property modifies the
Message Queuing queue. Therefore, any other <see cref="System.Messaging.MessageQueue"/> instances are affected by the
change</para>
			<para> If you store messages in a journal or dead-letter
   queue, you should periodically clear the queue to remove messages that are no
   longer needed. Messages in such a queue count toward the message quota for
   the computer where the queue resides. (The administrator sets the computer quota.)</para>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.UseJournalQueue"/>
		<seealso cref="System.Messaging.MessageQueue.MaximumQueueSize"/>
		<seealso cref="System.Messaging.MessageQueue.InfiniteQueueSize"/>
	</doc>
	<doc for="MessageQueue.MaximumQueueSize">
		<summary>
			<para>Gets or sets the maximum size of the queue.</para>
		</summary>
		<value>
			<para>The maximum size, in
      kilobytes, of the queue. The
      Message Queuing default specifies that no limit exists.</para>
		</value>
		<exception cref="System.ArgumentException">The maximum queue size contains a negative value.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>The<see cref="System.Messaging.MessageQueue.MaximumQueueSize"/>
provides access to the Message Queuing message storage limit, which is separate
from the computer's message quota that the administrator defines. For more
information on the message quota, see <see cref="System.Messaging.MessageQueue.MaximumJournalSize"/>.</para>
			<para>Setting this property modifies the Message Queuing queue. Therefore, any
   other <see cref="System.Messaging.MessageQueue"/> instances are affected by the change</para>
			<para> If an attempt is made to exceed either the maximum queue size
   or the computer message quota, messages might be lost. When the queue
   quota is reached, Message Queuing notifies the administration queue of the sending application
   to indicate that the queue is full, by returning a negative acknowledgment
   message. Message Queuing continues to send negative acknowledgments until the total
   size of the messages in the queue drops below the limit.</para>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.MaximumJournalSize"/>
		<seealso cref="System.Messaging.MessageQueue.InfiniteQueueSize"/>
	</doc>
	<doc for="MessageQueue.MessageReadPropertyFilter">
		<summary>
			<para>Gets or sets the property filter for receiving
      or peeking messages.</para>
		</summary>
		<value>
			<para>The <see cref="System.Messaging.MessagePropertyFilter"/> used by the queue
   to filter the set of properties it receives or peeks for each message.</para>
		</value>
		<exception cref="System.ArgumentException">The filter is <see langword="null"/> .</exception>
		<remarks>
			<para>This filter is a set of Boolean values restricting the
      message properties that the <see cref="System.Messaging.MessageQueue"/> receives or peeks. When the <see cref="System.Messaging.MessageQueue"/> receives
      or peeks a message from the server queue, it retrieves only those properties for which
      the <see cref="System.Messaging.MessageQueue.MessageReadPropertyFilter"/> value
      is <see langword="true"/>
      .</para>
			<para>The following shows initial property values for the
   <see cref="System.Messaging.MessageQueue.MessageReadPropertyFilter"/>
   property. These settings are identical to calling <see cref="System.Messaging.MessagePropertyFilter.SetDefaults"/> on a <see cref="System.Messaging.MessagePropertyFilter"/> .</para>
			<list type="table"><listheader>
					<term>Property</term>
					<description>Default Value</description>
				</listheader>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.Acknowledgment"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.AcknowledgeType"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.AdministrationQueue"/></term>
					<description><see langword="true"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.AppSpecific"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.ArrivedTime"/></term>
					<description><see langword="true"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.AttachSenderId"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.Authenticated"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.AuthenticationProviderName"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.AuthenticationProviderType"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.Body"/></term>
					<description><see langword="true"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.ConnectorType"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.CorrelationId"/></term>
					<description><see langword="true"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.DefaultBodySize"/></term>
					<description>1024 bytes</description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.DefaultExtensionSize"/></term>
					<description>255 bytes</description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.DefaultLabelSize"/></term>
					<description>255 bytes</description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.DestinationQueue"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.DestinationSymmetricKey"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.DigitalSignature"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.EncryptionAlgorithm"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.Extension"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.HashAlgorithm"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.Id"/></term>
					<description><see langword="true"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.IsFirstInTransaction"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.IsLastInTransaction"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.Label"/></term>
					<description><see langword="true"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.MessageType"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.Priority"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.Recoverable"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.ResponseQueue"/></term>
					<description><see langword="true"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.SenderCertificate"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.SenderId"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.SenderVersion"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.SentTime"/></term>
					<description><see langword="true"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.SourceMachine"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.TimeToBeReceived"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.TimeToReachQueue"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.TransactionId"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.TransactionStatusQueue"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.UseAuthentication"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.UseDeadLetterQueue"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.UseEncryption"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.UseJournalQueue"/></term>
					<description><see langword="false"/></description>
				</item>
				<item>
					<term><see cref="System.Messaging.MessagePropertyFilter.UseTracing"/></term>
					<description><see langword="false"/></description>
				</item>
			</list>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example uses the <see cref="System.Messaging.MessageQueue.MessageReadPropertyFilter"/> to
   restrict the message properties
   received.</para>
			<codelink SampleID="MessageQueue.MessageReadPropertyFilter" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.Path">
		<summary>
			<para> Gets or sets the queue's path. Setting the <see cref="System.Messaging.MessageQueue.Path"/> causes the <see cref="System.Messaging.MessageQueue"/> to point to a new queue.</para>
		</summary>
		<value>
			<para>The queue that is referenced by the
   <see cref="System.Messaging.MessageQueue"/> . The default depends on which
   <see cref="M:System.Messaging.MessageQueue.#ctor"/> constructor you use; it is either
   <see langword="null"/> or is specified by the
      constructor's <paramref name="path"/>
      parameter.</para>
		</value>
		<exception cref="System.ArgumentException">The path is invalid, possibly because the syntax is invalid.</exception>
		<remarks>
			<para>The syntax for the <see cref="System.Messaging.MessageQueue.Path"/>
property depends on the type of queue it points to.</para>
			<list type="table">
				<listheader>
					<term>Queue Type</term>
					<description>Syntax</description>
				</listheader>
				<item>
					<term> Public queue</term>
					<description><paramref name="MachineName"/>\<paramref name="QueueName"/></description>
				</item>
				<item>
					<term> Private queue</term>
					<description><paramref name="MachineName"/>\<see langword="Private$"/>\<paramref name="QueueName"/></description>
				</item>
				<item>
					<term> Journal queue</term>
					<description><paramref name="MachineName"/>\<paramref name="QueueName"/>\<see langword="Journal$"/></description>
				</item>
				<item>
					<term> Machine journal queue</term>
					<description><paramref name="MachineName"/>\<see langword="Journal$"/></description>
				</item>
				<item>
					<term> Machine dead-letter queue</term>
					<description><paramref name="MachineName"/>\<see langword="Deadletter$"/></description>
				</item>
				<item>
					<term> Machine transactional dead-letter queue</term>
					<description><paramref name="MachineName"/>\<see langword="XactDeadletter$"/></description>
				</item>
			</list>
			<para>Use "." to represent the local computer.</para>
			<note type="note">
   The <see cref="System.Messaging.MessageQueue.MachineName"/>, <see cref="System.Messaging.MessageQueue.Path"/>, and <see cref="System.Messaging.MessageQueue.QueueName"/> properties are related. Changing
   the <see cref="System.Messaging.MessageQueue.MachineName"/> property causes the <see cref="System.Messaging.MessageQueue.Path"/>
   property to change. It is built
   from the new <see cref="System.Messaging.MessageQueue.MachineName"/> and the <see cref="System.Messaging.MessageQueue.QueueName"/>. Changing the <see cref="System.Messaging.MessageQueue.Path"/> (for example, to use the format
   name syntax) resets the <see cref="System.Messaging.MessageQueue.MachineName"/> and <see cref="System.Messaging.MessageQueue.QueueName"/> properties to refer to the new
   queue.
</note>
			<para>Alternatively, you can use the <see cref="System.Messaging.MessageQueue.FormatName"/>
or <see cref="System.Messaging.MessageQueue.Label"/>
to describe the queue path.</para>
			<list type="table">
				<listheader>
					<term>Reference</term>
					<description>Syntax</description>
					<description>Example</description>
				</listheader>
				<item>
					<term> Format name</term>
					<description><see langword="FormatName:"/>[<paramref name="format name"/> ]</description>
					<description><see langword="FormatName:Public="/>5A5F7535-AE9A-41d4-935C-845C2AFF7112</description>
				</item>
				<item>
					<term> Label</term>
					<description><see langword="Label:"/>[<paramref name="label"/>]</description>
					<description><see langword="Label:"/>TheLabel</description>
				</item>
			</list>
			<para>If you use the label syntax for the <see cref="System.Messaging.MessageQueue.Path"/> property when you send the
message, an exception will be thrown if the <see cref="System.Messaging.MessageQueue.Label"/>
is not unique.</para>
			<para> To work offline, you must use the format name syntax, rather than
   the friendly name syntax in the first table. Otherwise, an exception is
   thrown because the primary domain controller (on which Active Directory resides) is
   not available to resolve the path to the format name.</para>
			<para> Setting a new path closes the
   message queue and releases all handles.</para>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example creates new <see cref="System.Messaging.MessageQueue"/> objects using various path
   name syntax types. In each case, it sends a message to the queue whose path is
   defined in the constructor.</para>
			<codelink SampleID="MessageQueue.Path" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.QueueName"/>
		<seealso cref="System.Messaging.MessageQueue.MachineName"/>
		<seealso cref="System.Messaging.MessageQueue.FormatName"/>
		<seealso cref="System.Messaging.MessageQueue.Label"/>
		<seealso cref="M:System.Messaging.MessageQueue.#ctor"/>
		<seealso cref="System.Messaging.MessageQueue.Create"/>
		<seealso cref="System.Messaging.MessageQueue.Delete"/>
		<seealso cref="System.Messaging.MessageQueue.Close"/>
		<seealso cref="System.Messaging.MessageQueue.Exists"/>
	</doc>
	<doc for="MessageQueue.QueueName">
		<summary>
			<para>Gets or sets the friendly
      name that identifies the queue.</para>
		</summary>
		<value>
			<para>The name that identifies the queue referenced by this <see cref="System.Messaging.MessageQueue"/> . The
   value cannot be <see langword="null"/>.</para>
		</value>
		<exception cref="System.ArgumentException">The queue name is <see langword="null"/>.</exception>
		<remarks>
			<para>You can combine the <see cref="System.Messaging.MessageQueue.QueueName"/> with
   the <see cref="System.Messaging.MessageQueue.MachineName"/> to create a friendly <see cref="System.Messaging.MessageQueue.Path"/>
   
   name for the queue. The syntax for the
   friendly-name variation of the <see cref="System.Messaging.MessageQueue.Path"/>
   property depends
   on the type of queue.</para>
			<list type="table">
				<listheader>
					<term>Queue Type</term>
					<description>Syntax</description>
				</listheader>
				<item>
					<term> Public queue</term>
					<description><paramref name="MachineName"/>\<paramref name="QueueName"/></description>
				</item>
				<item>
					<term> Private queue</term>
					<description><paramref name="MachineName"/>\<see langword="Private$"/>\<paramref name="QueueName"/></description>
				</item>
				<item>
					<term> Journal queue</term>
					<description><paramref name="MachineName"/>\<paramref name="QueueName"/>\<see langword="Journal$"/></description>
				</item>
			</list>
			<para>Use "." to represent the local computer.</para>
			<para>Changing the <see cref="System.Messaging.MessageQueue.QueueName"/> property affects the <see cref="System.Messaging.MessageQueue.Path"/> property. If you set the <see cref="System.Messaging.MessageQueue.QueueName"/>
without setting the <see cref="System.Messaging.MessageQueue.MachineName"/>
property, the <see cref="System.Messaging.MessageQueue.Path"/> property becomes
<see langword="."/> \<paramref name="QueueName"/>. Otherwise, the 
<see cref="System.Messaging.MessageQueue.Path"/> 
becomes <paramref name="MachineName"/>\<paramref name="QueueName"/>.</para>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.Path"/>
		<seealso cref="System.Messaging.MessageQueue.MachineName"/>
	</doc>
	<doc for="MessageQueue.ReadHandle">
		<summary>
			<para>Gets the native handle used to read messages from the message queue.</para>
		</summary>
		<value>
			<para>A handle to the native queue object that you use for peeking and receiving messages
      from the queue.</para>
		</value>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>The <see cref="System.Messaging.MessageQueue.ReadHandle"/> provides a native Windows handle
   to the message queue object that is used for peeking and receiving messages
   from the queue. If you change the path of the queue, the handle is
   closed and reopened with a new value. </para>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.CanRead"/>
		<seealso cref="System.Messaging.MessageQueue.WriteHandle"/>
	</doc>
	<doc for="MessageQueue.Transactional">
		<summary>
			<para>Gets a
      value indicating whether the queue accepts only transactions.</para>
		</summary>
		<value>
			<para><see langword="true"/> if the queue accepts only messages sent as
   part of a transaction; otherwise, <see langword="false"/>.</para>
		</value>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para> Transactional messaging
      refers to the coupling of several related messages into a single transaction.
      Sending messages as part of a transaction ensures that the messages
      are delivered in order, delivered only once, and successfully retrieved from their
      destination queue. </para>
			<para>If a queue is transactional, it accepts only messages that are sent as part of
      a transaction. However, a nontransactional message can be sent or received from a local
      transaction queue without explicitly using transactional <see cref="System.Messaging.MessageQueueTransaction.Begin"/>, <see cref="System.Messaging.MessageQueueTransaction.Commit"/>, and <see cref="System.Messaging.MessageQueueTransaction.Abort"/> syntax. If a
      nontransactional message is sent to a transactional queue, this component
      creates a single-message transaction for it, except in the case of referencing a
      queue on a remote computer using a direct format name. In this situation, if you
      do not specify a transaction context when sending a message, one is not created
      for you and the message will be sent to the dead-letter
      queue.
      </para>
			<note type="note">
      
      If you send a nontransactional message to a transactional
      queue, you will not be able to roll back the message in the event of an
      exception.
      
   </note>
			<note lang="VB" type="note">
				<see cref="System.Messaging.MessageQueueTransaction"/> is threading apartment aware,
      so if your apartment state is <see langword="STA"/>, you cannot use the
      transaction in multiple threads. Visual Basic sets the state of the main thread
      to <see langword="STA"/>, so you must apply the <see cref="System.MTAThreadAttribute"/> in
      the <c>Main</c> subroutine.
   Otherwise, sending a transactional message using another thread throws a <see cref="System.Messaging.MessageQueueException"/> exception. You apply the <see cref="System.MTAThreadAttribute"/> by
   using the following fragment.
</note>
			<code lang="VB">&lt;System.MTAThreadAttribute&gt;
public sub Main()
</code>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueueTransaction.Begin"/>
		<seealso cref="System.Messaging.MessageQueueTransaction.Commit"/>
		<seealso cref="System.Messaging.MessageQueueTransaction.Abort"/>
		<seealso cref="System.Messaging.Message.TransactionId" qualify="true"/>
		<seealso cref="System.Messaging.Message.IsFirstInTransaction" qualify="true"/>
		<seealso cref="System.Messaging.Message.IsLastInTransaction"/>
	</doc>
	<doc for="MessageQueue.UseJournalQueue">
		<summary>
			<para>Gets or sets a value indicating whether received messages are copied to the
      journal queue.</para>
		</summary>
		<value>
			<para><see langword="true"/> if messages received from the queue are copied to its
   journal queue; otherwise, <see langword="false"/>.</para>
		</value>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para> When the Message Queuing application creates a new
      application queue, it automatically creates an associated journal queue in the
      same location. The journal queue is used to track the messages removed from a
      queue. Setting this property modifies the Message Queuing queue. Therefore, any
      other <see cref="System.Messaging.MessageQueue"/>
      
      instances are affected by the change.</para>
			<note type="note">
      The journal queue
      does not track messages removed from the queue because their time-to-be-received timer expired, nor does it track messages
      purged from the queue by using a Message Queuing directory service (Information
      Store or Active Directory).
      
   </note>
			<para> Applications cannot send messages to journal queues; they are limited to read-only
      access of these queues. Furthermore, Message Queuing never removes messages from journal queues. The application using the
      queue must clear these messages either by receiving them or by purging the queue.</para>
			<para>The following table shows whether this property is available in various 
      Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
            name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
            name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.MaximumJournalSize"/>
	</doc>
	<doc for="MessageQueue.WriteHandle">
		<summary>
			<para> Gets the native handle used to send messages to the message queue.</para>
		</summary>
		<value>
			<para>A handle to the native queue object that you use for sending messages to the
      queue.</para>
		</value>
		<exception cref="System.Messaging.MessageQueueException">The message queue is not available for writing.</exception>
		<remarks>
			<para>The <see cref="System.Messaging.MessageQueue.WriteHandle"/> provides a native Windows handle
   to the message queue object that is used for sending messages to the queue. If you change the
   path of the queue, the handle is closed and reopened with a new
   value.</para>
			<para>The following table shows whether this property is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.CanWrite"/>
		<seealso cref="System.Messaging.MessageQueue.ReadHandle"/>
	</doc>
	<doc for="MessageQueue.BeginPeek">
		<overload>
			<para> Initiates an asynchronous peek operation by telling Message
      Queuing to begin peeking a message and notify the event handler when
      finished.</para>
		</overload>
		<summary>
			<para> Initiates an asynchronous peek
      operation that has no time-out. The operation is not complete until a message becomes
      available in the
      queue.</para>
		</summary>
		<returns>
			<para>The <see cref="System.IAsyncResult"/> that identifies
   the posted asynchronous request.</para>
		</returns>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>In asynchronous processing, you use <see cref="System.Messaging.MessageQueue.BeginPeek"/>
to raise the <see cref="E:System.Messaging.MessageQueue.PeekCompleted"/>
event when a message becomes available in the
queue.</para>
			<note type="note">
				<see cref="System.Messaging.MessageQueue.PeekCompleted"/> is also raised if a message already exists in
   the queue.
   
</note>
			<para>To use <see cref="System.Messaging.MessageQueue.BeginPeek"/> ,
create an event handler that processes the results of the asynchronous operation,
and associate it with your event delegate. <see cref="System.Messaging.MessageQueue.BeginPeek"/> initiates
an asynchronous peek operation; the <see cref="System.Messaging.MessageQueue"/> is
notified, through the raising of the <see cref="System.Messaging.MessageQueue.PeekCompleted"/>
event, when a message arrives in the
queue. The <see cref="System.Messaging.MessageQueue"/>
can then access the message by calling <see cref="System.Messaging.MessageQueue.EndPeek"/> or by
retrieving the result using the <see cref="System.Messaging.PeekCompletedEventArgs"/> .</para>
			<note type="note">
   The <see cref="System.Messaging.MessageQueue.BeginPeek"/> method returns
   immediately, but the asynchronous operation is not completed until the event
   handler is called.
   
</note>
			<para>Because <see cref="System.Messaging.MessageQueue.BeginPeek"/>
is asynchronous, you can call it to peek the queue without blocking
the current thread of execution. To synchronously peek the queue, use the
<see cref="System.Messaging.MessageQueue.Peek"/> method. </para>
			<para> Once an asynchronous operation completes, you can
   call <see cref="System.Messaging.MessageQueue.BeginPeek"/> or <see cref="System.Messaging.MessageQueue.BeginReceive"/> again
   in the event handler to keep receiving notifications. </para>
			<para> The <see cref="System.IAsyncResult"/> that <see cref="System.Messaging.MessageQueue.BeginPeek"/> returns identifies the
asynchronous operation that the method started. You can use this <see cref="System.IAsyncResult"/>
throughout the lifetime of the operation,
although you generally do not use it until <see cref="System.Messaging.MessageQueue.EndPeek"/> is called. However, if you start
several asynchronous operations, you can place their <see cref="System.IAsyncResult"/>
values in an array and specify whether to wait for all
operations or any operation to complete. In this case, you use
the <see cref="System.IAsyncResult.AsyncWaitHandle"/> property of the <see cref="System.IAsyncResult"/> to identify the completed
operation. </para>
			<para>If <see cref="System.Messaging.MessageQueue.CanRead"/> is <see langword="false"/>, the completion
event is raised, but an exception will be thrown when calling <see cref="System.Messaging.MessageQueue.EndPeek"/>.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para> The following example creates an event handler named
      <c>MyPeekCompleted</c>
      , attaches it to the <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event
      handler delegate, and calls <see cref="System.Messaging.MessageQueue.BeginPeek"/> to initiate an asynchronous peek
      operation on the queue that is located at the path ".\myQueue". When a <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event is raised, the
      example peeks
      the message and writes its body to the screen. The example then calls <see cref="System.Messaging.MessageQueue.BeginPeek"/> again to initiate a new
      asynchronous peek
      operation.</para>
			<codelink SampleID="MessageQueue.BeginPeek_noparms" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.EndPeek"/>
		<seealso cref="System.Messaging.MessageQueue.PeekCompleted"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
	</doc>
	<doc for="MessageQueue.BeginPeek1">
		<summary>
			<para> Initiates an asynchronous peek
      operation that has a specified time-out. The operation is not complete until either a message becomes available
      in the queue or the
      time-out occurs.</para>
		</summary>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the interval of time to wait for a message to become available.</param>
		<returns>
			<para>The <see cref="System.IAsyncResult"/>
that identifies the
posted asynchronous request.</para>
		</returns>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout"/> parameter is invalid.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>In asynchronous processing, you use <see cref="System.Messaging.MessageQueue.BeginPeek"/>
to raise the <see cref="E:System.Messaging.MessageQueue.PeekCompleted"/> event
when
a message becomes available in the queue or
when the specified interval of time has expired. </para>
			<note type="note">
				<see cref="System.Messaging.MessageQueue.PeekCompleted"/> is also raised if a message already exists in
   the queue.
   
</note>
			<para>To use <see cref="System.Messaging.MessageQueue.BeginPeek"/> , create an event handler that
processes the results of the asynchronous operation, and associate it with your
event delegate. <see cref="System.Messaging.MessageQueue.BeginPeek"/> initiates an asynchronous
peek operation; the <see cref="System.Messaging.MessageQueue"/> is notified, through the raising of the
<see cref="System.Messaging.MessageQueue.PeekCompleted"/> event, when a message arrives in
the queue. The <see cref="System.Messaging.MessageQueue"/> can then access the message by calling <see cref="System.Messaging.MessageQueue.EndPeek"/> or by
retrieving the result using the <see cref="System.Messaging.PeekCompletedEventArgs"/> .</para>
			<note type="note">
   The <see cref="System.Messaging.MessageQueue.BeginPeek"/> method returns
   immediately, but the asynchronous operation is not completed until the event
   handler is called.
   
</note>
			<para>Because <see cref="System.Messaging.MessageQueue.BeginPeek"/> is asynchronous, you can call
it to peek the queue without blocking the current thread of execution. To
synchronously peek the queue, use the <see cref="System.Messaging.MessageQueue.Peek"/> method. </para>
			<para> Once an asynchronous operation completes, you can
   call <see cref="System.Messaging.MessageQueue.BeginPeek"/> or <see cref="System.Messaging.MessageQueue.BeginReceive"/>
   again in the event
   handler to keep receiving notifications. </para>
			<para>The <see cref="System.IAsyncResult"/> that <see cref="System.Messaging.MessageQueue.BeginPeek"/> returns identifies
the asynchronous operation that the method started. You can use this <see cref="System.IAsyncResult"/> throughout
the lifetime of the operation, although you generally do not use it until
<see cref="System.Messaging.MessageQueue.EndPeek"/> is called. However, if you start
several asynchronous operations, you can place their <see cref="System.IAsyncResult"/> values in
an array and specify whether to wait for all operations or any operation to
complete. In this case, you use the <see cref="System.IAsyncResult.AsyncWaitHandle"/> property of the <see cref="System.IAsyncResult"/> to identify the completed
operation. </para>
			<para>This overload specifies a time-out. If the interval
   specified by the <paramref name="timeout"/> parameter expires, this component
   raises the <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event, and the <see cref="System.IAsyncResult.IsCompleted"/> property of the operation's associated <see cref="System.IAsyncResult"/> is
<see langword="true"/> . Because no message exists, a subsequent
   call to <see cref="System.Messaging.MessageQueue.EndPeek"/>
   will throw an exception. </para>
			<para>If <see cref="System.Messaging.MessageQueue.CanRead"/> is <see langword="false"/>, the completion
event is raised, but an exception will be thrown when calling <see cref="System.Messaging.MessageQueue.EndPeek"/>.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para> The following example creates an asynchronous
      peek operation, using the queue path ".\myQueue". It creates an event
      handler, <c>MyPeekCompleted</c> , and attaches it to the <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event handler delegate. <see cref="System.Messaging.MessageQueue.BeginPeek"/> is
   called with a time-out of one minute, to initiate the asynchronous peek operation. When a <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event is raised
   or the time-out expires, the message is retrieved if one exists, and its body is written to the screen. Then <see cref="System.Messaging.MessageQueue.BeginPeek"/> is called again to initiate a new
   asynchronous peek operation with the same time-out.</para>
			<codelink SampleID="MessageQueue.BeginPeek_timeout" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.EndPeek"/>
		<seealso cref="System.Messaging.MessageQueue.PeekCompleted"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.TimeSpan"/>
	</doc>
	<doc for="MessageQueue.BeginPeek2">
		<summary>
			<para> Initiates an asynchronous peek operation that has a
      specified time-out and a
      specified state object, which provides associated information
      throughout the operation's lifetime. The
      operation is not complete until either a message becomes available in the
      queue or the time-out
      occurs.</para>
		</summary>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the interval of time to wait for a message to become available.</param>
		<param name="stateObject">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
		<returns>
			<para>The <see cref="System.IAsyncResult"/> that identifies
   the posted asynchronous request.</para>
		</returns>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout "/> parameter is invalid.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>In asynchronous processing, you use <see cref="System.Messaging.MessageQueue.BeginPeek"/> to raise the
<see cref="E:System.Messaging.MessageQueue.PeekCompleted"/> 
event when a message becomes
available in the queue or when the specified interval of time has
expired.</para>
			<note type="note">
				<see cref="System.Messaging.MessageQueue.PeekCompleted"/> is also raised if
   a message already exists in the queue.
</note>
			<para>Use this overload to associate information with the operation that will
   be preserved throughout the operation's lifetime. The event handler can access this information
   by looking at the <see cref="System.IAsyncResult.AsyncState"/> property of the <see cref="System.IAsyncResult"/> that is associated
   with the operation.</para>
			<para>To use <see cref="System.Messaging.MessageQueue.BeginPeek"/> , create an event handler that
processes the results of the asynchronous operation, and associate it with your
event delegate. <see cref="System.Messaging.MessageQueue.BeginPeek"/> initiates an asynchronous
peek operation; the <see cref="System.Messaging.MessageQueue"/> is notified, through the raising of the
<see cref="System.Messaging.MessageQueue.PeekCompleted"/> event, when a message arrives in
the queue. The <see cref="System.Messaging.MessageQueue"/> can then access the message by calling <see cref="System.Messaging.MessageQueue.EndPeek"/> or by
retrieving the result using the <see cref="System.Messaging.PeekCompletedEventArgs"/> .</para>
			<note type="note">
   The <see cref="System.Messaging.MessageQueue.BeginPeek"/> method returns
   immediately, but the asynchronous operation is not completed until the event
   handler is called.
</note>
			<para>Because <see cref="System.Messaging.MessageQueue.BeginPeek"/> is asynchronous, you can call
it to peek the queue without blocking the current thread of execution. To
synchronously peek the queue, use the <see cref="System.Messaging.MessageQueue.Peek"/> method. </para>
			<para> Once an asynchronous operation completes, you can
   call <see cref="System.Messaging.MessageQueue.BeginPeek"/> or <see cref="System.Messaging.MessageQueue.BeginReceive"/> again
   in the event handler to
   keep receiving notifications. </para>
			<para><see cref="System.Messaging.MessageQueue.BeginPeek"/> returns an <see cref="System.IAsyncResult"/> that identifies the
asynchronous operation that the method started. You can use this
<see cref="System.IAsyncResult"/>
throughout the lifetime of the operation, although you generally do not use it
until <see cref="System.Messaging.MessageQueue.EndPeek"/> is called. However, if you start
several asynchronous operations, you can place their <see cref="System.IAsyncResult"/> values in
an array and specify whether to wait for all operations or any operation to
complete. In this case, you use the <see cref="System.IAsyncResult.AsyncWaitHandle"/> property of the <see cref="System.IAsyncResult"/> to identify the completed
operation. </para>
			<para>This overload specifies a time-out and a state object. If the interval specified by the
<paramref name="timeout"/> parameter
   expires, this component raises the <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event, and the <see cref="System.IAsyncResult.IsCompleted"/>
   property of the operation's associated <see cref="System.IAsyncResult"/> is <see langword="true"/> . Because no
   message exists, a subsequent call to <see cref="System.Messaging.MessageQueue.EndPeek"/> will throw an
   exception. </para>
			<para> The state object associates state information with the operation.
   For example, if you call <see cref="System.Messaging.MessageQueue.BeginPeek"/> multiple times to initiate multiple operations, you
   can identify each operation through a separate state object that you define.
   For an illustration of this scenario, see the Example section.</para>
			<para> You can also use the state object to pass information across process threads. If
   a thread is started but the callback is on a different thread in an
   asynchronous scenario, the state object is marshaled and passed back along with information
   from the event.</para>
			<para>If <see cref="System.Messaging.MessageQueue.CanRead"/> is <see langword="false"/>, the completion
event is raised, but an exception will be thrown when calling <see cref="System.Messaging.MessageQueue.EndPeek"/>.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para> The following example creates an asynchronous
      peek operation, using the queue path ".\myQueue". It creates an event
      handler, <c>MyPeekCompleted</c>
   , and attaches it to the <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event handler
   delegate. <see cref="System.Messaging.MessageQueue.BeginPeek"/> is called, with a
   time-out of one minute. Each call to <see cref="System.Messaging.MessageQueue.BeginPeek"/>
   has a unique associated integer that identifies that particular operation. When a <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event is raised or the time-out expired, the
   message, if one exists, is retrieved and its body and the operation-specific integer identifier are written to the
   screen. Then <see cref="System.Messaging.MessageQueue.BeginPeek"/> is called again to initiate a new
   asynchronous peek operation with the same time-out and the associated integer of
   the just completed operation.</para>
			<codelink SampleID="MessageQueue.BeginPeek_TimeSpanStateObject" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.EndPeek"/>
		<seealso cref="System.Messaging.MessageQueue.PeekCompleted"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.TimeSpan"/>
	</doc>
	<doc for="MessageQueue.BeginPeek3">
		<summary>
			<para> Initiates an asynchronous peek operation that has a
      specified time-out and a specified
      state
      object, which provides associated information throughout
      the operation's lifetime.
      This overload receives notification, through a callback, of the identity of the event handler
      for the operation. The operation is not complete until either a message becomes available
      in the queue or the time-out
      occurs.</para>
		</summary>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the interval of time to wait for a message to become available.</param>
		<param name="stateObject">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
		<param name="callback">The <see cref="System.AsyncCallback"/> that will receive the notification of the asynchronous operation completion.</param>
		<returns>
			<para>The <see cref="System.IAsyncResult"/>
that identifies the
posted asynchronous request.</para>
		</returns>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout"/> parameter is invalid.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>When you use this overload, the callback specified in
      the callback parameter is invoked directly when a message becomes available in
      the queue or when the specified interval of time has expired; the <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event is not raised. The other overloads of
   <see cref="System.Messaging.MessageQueue.BeginPeek"/> rely on this component to raise the
   <see cref="System.Messaging.MessageQueue.PeekCompleted"/>
   
   event. </para>
			<note type="note">
				<see cref="System.Messaging.MessageQueue.PeekCompleted"/> is also raised
   if a message already exists in the queue.
   
</note>
			<note type="note">
   The <see cref="System.Messaging.MessageQueue.BeginPeek"/> method returns
   immediately, but the asynchronous operation is not completed until the event
   handler is called.
   
</note>
			<para>Because <see cref="System.Messaging.MessageQueue.BeginPeek"/> is asynchronous, you can call
it to peek the queue without blocking the current thread of execution. To
synchronously peek the queue, use the <see cref="System.Messaging.MessageQueue.Peek"/> method. </para>
			<para> Once an asynchronous operation completes, you can
   call <see cref="System.Messaging.MessageQueue.BeginPeek"/> or <see cref="System.Messaging.MessageQueue.BeginReceive"/>
   again in the event handler to
   keep receiving notifications. </para>
			<para><see cref="System.Messaging.MessageQueue.BeginPeek"/> returns an <see cref="System.IAsyncResult"/> that identifies the
asynchronous operation that the method started. You can use this <see cref="System.IAsyncResult"/> throughout
the lifetime of the operation, although you generally do not use it until
<see cref="System.Messaging.MessageQueue.EndPeek"/> is called. However, if you start
several asynchronous operations, you can place their <see cref="System.IAsyncResult"/> values in
an array and specify whether to wait for all operations or any operation to
complete. In this case, you use the <see cref="System.IAsyncResult.AsyncWaitHandle"/> property of the <see cref="System.IAsyncResult"/> to identify the completed
operation. </para>
			<para>The state object associates state information with the operation. For
   example, if you call <see cref="System.Messaging.MessageQueue.BeginPeek"/>
   multiple times to initiate multiple
   operations, you can identify each operation through a separate state object that you
   define.</para>
			<para><see langword=""/>
			</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.EndPeek"/>
		<seealso cref="System.Messaging.MessageQueue.PeekCompleted"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.AsyncCallback"/>
		<seealso cref="System.TimeSpan"/>
	</doc>
	<doc for="MessageQueue.BeginReceive">
		<overload>
			<para> Initiates an asynchronous receive operation by telling
      Message Queuing to begin receiving a message and notify the event handler when finished.</para>
		</overload>
		<summary>
			<para> Initiates an
      asynchronous receive operation
      that has no time-out. The operation is not complete until a message becomes
      available in the
      queue.</para>
		</summary>
		<returns>
			<para>The <see cref="System.IAsyncResult"/>
that identifies the
posted asynchronous request.</para>
		</returns>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>In asynchronous processing, you use <see cref="System.Messaging.MessageQueue.BeginReceive"/> to raise
   the <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted"/> event when a message has been removed from the
   queue.</para>
			<note type="note">
				<see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> is also raised if a message already exists in
   the queue.
</note>
			<para>To use <see cref="System.Messaging.MessageQueue.BeginReceive"/> , create an
event handler that processes the results of the asynchronous operation and associate
it with your event delegate. <see cref="System.Messaging.MessageQueue.BeginReceive"/> initiates an
asynchronous receive operation; the <see cref="System.Messaging.MessageQueue"/> is
notified, through the raising of the <see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> event, when a message arrives in the
queue. The <see cref="System.Messaging.MessageQueue"/> can then access the message
by calling <see cref="System.Messaging.MessageQueue.EndReceive"/> .</para>
			<note type="note">
   The <see cref="System.Messaging.MessageQueue.BeginReceive"/> method returns immediately, but
   the asynchronous operation is not completed until the event handler is called.
   
</note>
			<para>Because <see cref="System.Messaging.MessageQueue.BeginReceive"/> is asynchronous,
you can call it to receive a message from the queue without blocking the current
thread of execution. To synchronously receive a message, use the <see cref="System.Messaging.MessageQueue.Receive"/> method.</para>
			<para> Once an asynchronous operation completes, you can
   call <see cref="System.Messaging.MessageQueue.BeginPeek"/> or <see cref="System.Messaging.MessageQueue.BeginReceive"/> again
   in the event handler to keep receiving
   notifications.</para>
			<para>The <see cref="System.IAsyncResult"/> that <see cref="System.Messaging.MessageQueue.BeginReceive"/> returns identifies the
asynchronous operation that the method started. You can use this <see cref="System.IAsyncResult"/> throughout the lifetime of
the operation, although you generally do not use it until <see cref="System.Messaging.MessageQueue.EndReceive"/> is called. However, if you start
several asynchronous operations, you can place their <see cref="System.IAsyncResult"/> values in an array and specify whether to wait for all
operations or any operation to complete. In this case, you use the <see cref="System.IAsyncResult.AsyncWaitHandle"/> property of the <see cref="System.IAsyncResult"/> to identify the completed
operation.</para>
			<para>If <see cref="System.Messaging.MessageQueue.CanRead"/> is <see langword="false"/>, the completion
event is raised, but an exception will be thrown when calling <see cref="System.Messaging.MessageQueue.EndReceive"/>
.</para>
			<note type="note">
   Do not use the asynchronous call <see cref="System.Messaging.MessageQueue.BeginReceive"/> with transactions. If you want
   to perform a transactional asynchronous operation, call <see cref="System.Messaging.MessageQueue.BeginPeek"/>
   , and put the transaction
   and the (synchronous) <see cref="System.Messaging.MessageQueue.Receive"/> method within the event handler you create for
   the peek operation. Your event handler might contain functionality as shown in the following C#
   code.
   
</note>
			<code>
myMessageQueue.BeginTransaction();
 myMessageQueue.Receive();
 myMessageQueue.CommitTransaction();
</code>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para> The following example chains asynchronous requests. It
      assumes there is a queue on the local computer called "myQueue". The <c>Main</c> function begins the
   asynchronous operation that is handled by the <c>MyReceiveCompleted</c> routine. <c>MyReceiveCompleted</c>
processes the current message and
begins a new asynchronous receive
operation.</para>
			<codelink SampleID="MessageQueue.BeginReceive_noparms_combined" SnippetID="1"/>
			<para>The following example queues asynchronous requests. The call to <see cref="System.Messaging.MessageQueue.BeginReceive"/> uses the <see cref="System.IAsyncResult.AsyncWaitHandle"/> in its return
value. The <c>Main</c> routine waits for all
asynchronous operations to be completed before exiting.</para>
			<codelink SampleID="MessageQueue.BeginReceive_noparms_combined" SnippetID="2"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.EndReceive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveCompleted"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
	</doc>
	<doc for="MessageQueue.BeginReceive1">
		<summary>
			<para> Initiates an
      asynchronous receive operation that has a specified time-out. The operation is not complete until
      either a message becomes available in the
      queue or the time-out
      occurs.</para>
		</summary>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the interval of time to wait for a message to become available.</param>
		<returns>
			<para>The <see cref="System.IAsyncResult"/>
that identifies the
posted asynchronous request.</para>
		</returns>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout "/>parameter is invalid, possibly because it represents a negative number.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>In asynchronous processing, you use <see cref="System.Messaging.MessageQueue.BeginReceive"/> to raise the <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted"/> event
   when a message becomes available in the queue or when the specified interval
   of time has expired.</para>
			<note type="note">
				<see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> is
   also raised if a message already exists in the queue.
</note>
			<para>To use <see cref="System.Messaging.MessageQueue.BeginReceive"/> , create an event handler that
processes the results of the asynchronous operation and associate it with your
event delegate. <see cref="System.Messaging.MessageQueue.BeginReceive"/> initiates an asynchronous
receive operation; the <see cref="System.Messaging.MessageQueue"/> is
notified, through the raising of the <see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> event, when a message arrives in
the queue. The <see cref="System.Messaging.MessageQueue"/> can then
access the message by calling <see cref="System.Messaging.MessageQueue.EndReceive"/> or retrieving the result using
the <see cref="System.Messaging.ReceiveCompletedEventArgs"/> .</para>
			<note type="note">
   The <see cref="System.Messaging.MessageQueue.BeginReceive"/> method returns immediately, but
   the asynchronous operation is not completed until the event handler is called.
   
</note>
			<para>Because <see cref="System.Messaging.MessageQueue.BeginReceive"/> is asynchronous, you can call it
to receive a message from the queue without blocking the current thread of
execution. To synchronously receive a message, use the <see cref="System.Messaging.MessageQueue.Receive"/> method.</para>
			<para> Once an asynchronous operation completes, you can
   call <see cref="System.Messaging.MessageQueue.BeginPeek"/> or <see cref="System.Messaging.MessageQueue.BeginReceive"/> again
   in the event handler to keep receiving
   notifications.</para>
			<para>If <see cref="System.Messaging.MessageQueue.CanRead"/> is <see langword="false"/>, the
completion event is raised, but an exception will be thrown when calling <see cref="System.Messaging.MessageQueue.EndReceive"/> .</para>
			<para>The <see cref="System.IAsyncResult"/> that <see cref="System.Messaging.MessageQueue.BeginReceive"/> returns identifies the
asynchronous operation that the method started. You can use this <see cref="System.IAsyncResult"/> throughout the lifetime of
the operation, although you generally do not use it until <see cref="System.Messaging.MessageQueue.EndReceive"/> is called. However, if you start
several asynchronous operations, you can place their <see cref="System.IAsyncResult"/> values in an array and specify whether to wait for all
operations or any operation to complete. In this case, you use the <see cref="System.IAsyncResult.AsyncWaitHandle"/> property of the
<see cref="System.IAsyncResult"/> to identify the completed 
operation.</para>
			<para>This overload specifies a time-out. If the interval specified by the
<paramref name="timeout"/> parameter expires, this component raises the <see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> event, but the <see cref="System.IAsyncResult.IsCompleted"/>
property of the operation's associated <see cref="System.IAsyncResult"/> is <see langword="false"/> . Because no
message exists, a subsequent call to <see cref="System.Messaging.MessageQueue.EndReceive"/> will throw an
exception. </para>
			<note type="note">
   Do not use the asynchronous call <see cref="System.Messaging.MessageQueue.BeginReceive"/> with
   transactions. If you want to perform a transactional asynchronous operation,
   call <see cref="System.Messaging.MessageQueue.BeginPeek"/>, and
   put the transaction and the (synchronous) <see cref="System.Messaging.MessageQueue.Receive"/> method within the event handler you create for the peek
   operation. Your event handler might contain functionality as shown in the following C#
   code.
   
</note>
			<code>
myMessageQueue.BeginTransaction();
 myMessageQueue.Receive();
 myMessageQueue.CommitTransaction();
</code>
			<para><see langword=""/>
			</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.EndReceive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveCompleted"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.TimeSpan"/>
	</doc>
	<doc for="MessageQueue.BeginReceive2">
		<summary>
			<para> Initiates an asynchronous receive operation
      that has a
      specified time-out and a specified state object, which provides associated information
      throughout the operation's lifetime. The operation
      is not complete until either a message becomes available in the queue or the
      time-out occurs.</para>
		</summary>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the interval of time to wait for a message to become available.</param>
		<param name="stateObject">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
		<returns>
			<para>The <see cref="System.IAsyncResult"/>
that identifies the
posted asynchronous request.</para>
		</returns>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout"/> parameter is invalid.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>In asynchronous processing, you use <see cref="System.Messaging.MessageQueue.BeginReceive"/> to raise the
<see cref="E:System.Messaging.MessageQueue.ReceiveCompleted"/> event when a message becomes
   available in the queue or when the specified interval of time has expired.</para>
			<note type="note">
				<see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> is also raised
   if a message already exists in the queue.
</note>
			<para>Use this overload to associate information with the operation that will be
   preserved throughout the operation's lifetime. The event handler can detect this
   information by looking at the <see cref="System.IAsyncResult.AsyncState"/> property of the <see cref="System.IAsyncResult"/> that is
   associated with the operation. </para>
			<para>To use <see cref="System.Messaging.MessageQueue.BeginReceive"/> , create an event handler that
processes the results of the asynchronous operation and associate it with your
event delegate. <see cref="System.Messaging.MessageQueue.BeginReceive"/> initiates an asynchronous
receive operation; the <see cref="System.Messaging.MessageQueue"/> is notified, through the raising of the
<see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> event, when a message arrives in
the queue. The <see cref="System.Messaging.MessageQueue"/> can then access the message by calling <see cref="System.Messaging.MessageQueue.EndReceive"/> or retrieving the result using
the <see cref="System.Messaging.ReceiveCompletedEventArgs"/> .</para>
			<note type="note">
   The <see cref="System.Messaging.MessageQueue.BeginReceive"/> method returns immediately, but
   the asynchronous operation is not completed until the event handler is called.
   
</note>
			<para>Because <see cref="System.Messaging.MessageQueue.BeginReceive"/> is asynchronous, you can call it
to receive a message from the queue without blocking the current thread of
execution. To synchronously receive a message, use the <see cref="System.Messaging.MessageQueue.Receive"/> method.</para>
			<para> Once an asynchronous operation completes, you can
   call <see cref="System.Messaging.MessageQueue.BeginPeek"/> or <see cref="System.Messaging.MessageQueue.BeginReceive"/> again
   in the event handler to
   keep receiving notifications.</para>
			<para>The <see cref="System.IAsyncResult"/> that <see cref="System.Messaging.MessageQueue.BeginReceive"/> returns
identifies the asynchronous operation that the method started. You can use this
<see cref="System.IAsyncResult"/>
throughout the lifetime of the operation, although you generally do not use it
until <see cref="System.Messaging.MessageQueue.EndReceive"/> is called. However, if you start
several asynchronous operations, you can place their <see cref="System.IAsyncResult"/> values in
an array and specify whether to wait for all operations or any operation to
complete. In this case, you use the <see cref="System.IAsyncResult.AsyncWaitHandle"/> property of the <see cref="System.IAsyncResult"/> to identify the completed
operation.</para>
			<para>This overload specifies a time-out and a state object. If the interval specified by the
<paramref name="timeout"/> parameter expires, this component raises the <see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> event, but the <see cref="System.IAsyncResult.IsCompleted"/>
property of the operation's associated <see cref="System.IAsyncResult"/> is <see langword="false"/> . Because no
message exists, a subsequent call to <see cref="System.Messaging.MessageQueue.EndReceive"/> will throw an
exception.</para>
			<para>The state object associates state information with the
   operation. For example, if you call <see cref="System.Messaging.MessageQueue.BeginReceive"/>
   multiple times to initiate multiple
   operations, you can identify each operation through a separate state object that you
   define.</para>
			<para>You can also use the state object to pass information across process threads.
   If a thread is started but the callback is on a different thread in an
   asynchronous scenario, the state object is marshaled and passed back along with
   information from the event.</para>
			<note type="note">
   Do not use the asynchronous call <see cref="System.Messaging.MessageQueue.BeginReceive"/> with
   transactions. If you want to perform a transactional asynchronous operation,
   call <see cref="System.Messaging.MessageQueue.BeginPeek"/> , and put the transaction and the
   (synchronous) <see cref="System.Messaging.MessageQueue.Receive"/> method within the event handler you create for the peek
   operation. Your event handler might contain functionality as shown in the following C#
   code.
   
</note>
			<code>
myMessageQueue.BeginTransaction();
 myMessageQueue.Receive();
 myMessageQueue.CommitTransaction();
</code>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.EndReceive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveCompleted"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.TimeSpan"/>
	</doc>
	<doc for="MessageQueue.BeginReceive3">
		<summary>
			<para> Initiates an asynchronous receive operation that has a
      specified time-out and a specified state object, which provides associated
      information throughout the operation's
      lifetime. This overload receives notification, through a callback, of the identity of
      the event handler for the operation. The operation is not complete until either
      a message becomes available in the queue or the time-out
      occurs.</para>
		</summary>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the interval of time to wait for a message to become available.</param>
		<param name="stateObject">A state object, specified by the application, that contains information associated with the asynchronous operation.</param>
		<param name="callback">The <see cref="System.AsyncCallback"/> that will receive the notification of the asynchronous operation completion.</param>
		<returns>
			<para>The <see cref="System.IAsyncResult"/> that identifies the
   posted asynchronous request.</para>
		</returns>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout "/> parameter is invalid.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>When you use this overload, the callback specified in
      the callback parameter is invoked directly when a message becomes available in
      the queue or when the specified interval of time has expired; the <see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> event
      is not raised. The other overloads of <see cref="System.Messaging.MessageQueue.BeginReceive"/> rely on this component to raise the
   <see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> event. </para>
			<para><see langword=""/>
			</para>
			<note type="note">
				<see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> is also raised
   if a message already exists in the queue.
</note>
			<para>To use <see cref="System.Messaging.MessageQueue.BeginReceive"/> , create an event handler that
processes the results of the asynchronous operation and associate it with your
event delegate. <see cref="System.Messaging.MessageQueue.BeginReceive"/> initiates an asynchronous
receive operation; the <see cref="System.Messaging.MessageQueue"/> is notified, through the raising of the
<see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> event, when a message arrives in
the queue. The <see cref="System.Messaging.MessageQueue"/> can then access the message by calling <see cref="System.Messaging.MessageQueue.EndReceive"/> or retrieving the result using
the <see cref="System.Messaging.ReceiveCompletedEventArgs"/> .</para>
			<note type="note">
   The <see cref="System.Messaging.MessageQueue.BeginReceive"/> method returns immediately, but
   the asynchronous operation is not completed until the event handler is called.
   
</note>
			<para>Because <see cref="System.Messaging.MessageQueue.BeginReceive"/> is asynchronous, you can call it
to receive a message from the queue without blocking the current thread of
execution. To synchronously receive a message, use the <see cref="System.Messaging.MessageQueue.Receive"/> method.</para>
			<para> Once an asynchronous operation completes, you can
   call <see cref="System.Messaging.MessageQueue.BeginPeek"/> or <see cref="System.Messaging.MessageQueue.BeginReceive"/> again
   in the event handler to
   keep receiving notifications.</para>
			<para>The <see cref="System.IAsyncResult"/> that <see cref="System.Messaging.MessageQueue.BeginReceive"/> returns
identifies the asynchronous operation that the method started. You can use this
<see cref="System.IAsyncResult"/>
throughout the lifetime of the operation, although you generally do not use it
until <see cref="System.Messaging.MessageQueue.EndReceive"/> is called. However, if you start
several asynchronous operations, you can place their <see cref="System.IAsyncResult"/> values in
an array and specify whether to wait for all operations or any operation to
complete. In this case, you use the <see cref="System.IAsyncResult.AsyncWaitHandle"/> property of the <see cref="System.IAsyncResult"/> to identify the completed
operation.</para>
			<para>The state object associates state information with the operation. For
   example, if you call <see cref="System.Messaging.MessageQueue.BeginReceive"/> multiple times to initiate
   multiple operations, you can identify each operation through a separate state
   object that you define.</para>
			<para>You can also use the state object to pass information across process threads.
   If a thread is started but the callback is on a different thread in an
   asynchronous scenario, the state object is marshaled and passed back along with
   information from the event.</para>
			<note type="note">
   Do not use the asynchronous call <see cref="System.Messaging.MessageQueue.BeginReceive"/> with
   transactions. If you want to perform a transactional asynchronous operation,
   call <see cref="System.Messaging.MessageQueue.BeginPeek"/>, and put the transaction and the
   (synchronous) <see cref="System.Messaging.MessageQueue.Receive"/> method within the event handler you create for the
   peek operation. Your event handler might contain functionality as shown in the following C#
   code.
   
</note>
			<code>
myMessageQueue.BeginTransaction();
 myMessageQueue.Receive();
 myMessageQueue.CommitTransaction();
</code>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.EndReceive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveCompleted"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.AsyncCallback"/>
		<seealso cref="System.TimeSpan"/>
	</doc>
	<doc for="MessageQueue.ClearConnectionCache">
		<summary>
			<para>Clears the connection cache.</para>
		</summary>
		<remarks>
			<para>When you call <see cref="System.Messaging.MessageQueue.ClearConnectionCache"/> , the format names stored in the
   cache are removed and handles opened and stored in the cache are closed.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
	</doc>
	<doc for="MessageQueue.Close">
		<summary>
			<para>Frees all resources allocated by the <see cref="System.Messaging.MessageQueue"/>
.</para>
		</summary>
		<remarks>
			<para><see cref="System.Messaging.MessageQueue.Close"/> frees all resources associated
   with a <see cref="System.Messaging.MessageQueue"/>, including shared resources if appropriate. The
   system re-acquires these resources automatically if they are still available, for example when you
   call the <see cref="System.Messaging.MessageQueue.Send"/> method, as in the following C#
   code.</para>
			<code>
myMessageQueue.Send("Text 1.");
myMessageQueue.Close();
myMessageQueue.Send("Text 2."); //Resources are reaquired.
</code>
			<para>When you call <see cref="System.Messaging.MessageQueue.Close"/>, all <see cref="System.Messaging.MessageQueue"/> properties that directly access the
Message Queuing queue are cleared out. The <see cref="System.Messaging.MessageQueue.Path"/>, <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>, <see cref="System.Messaging.MessageQueue.Formatter"/>, and <see cref="System.Messaging.MessageQueue.MessageReadPropertyFilter"/> all remain as
they were.</para>
			<para>You should call <see cref="System.Messaging.MessageQueue.Close"/> for a queue before you delete queue on the
Message Queuing server. Otherwise, messages sent to the queue could throw
exceptions or appear in the dead-letter queue.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para> The
      following example closes a Message Queuing queue.</para>
			<codelink SampleID="MessageQueue.Close" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.Delete"/>
	</doc>
	<doc for="MessageQueue.Create">
		<overload>
			<para>Creates a new queue at the specified path on a Message Queuing server.</para>
		</overload>
		<summary>
			<para> Creates a nontransactional Message Queuing queue at the
      specified path.</para>
		</summary>
		<param name="path">The path of the queue to create.</param>
		<returns>
			<para>A <see cref="System.Messaging.MessageQueue"/> that represents the
   new queue.</para>
		</returns>
		<exception cref="System.ArgumentException">The <paramref name="path "/>parameter is <see langword="null"/> or is an empty string ("").</exception>
		<exception cref="System.Messaging.MessageQueueException"><para>A queue already exists at the specified path.</para>
			<para>-or-</para>
			<para> An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>Use this overload
      to create a nontransactional Message Queuing queue.</para>
			<para>To create a new instance of the <see cref="System.Messaging.MessageQueue"/> class in your application and bind it to an existing
   queue, use the <see cref="M:System.Messaging.MessageQueue.#ctor"/>constructor. To create a new
   queue in Message Queuing, call <see cref="System.Messaging.MessageQueue.Create"/>
   .</para>
			<para>The syntax for the <paramref name="path"/>
parameter depends on the type of queue it references.</para>
			<list type="table">
				<listheader>
					<term>Queue Type</term>
					<description>Syntax</description>
				</listheader>
				<item>
					<term> Public queue</term>
					<description><paramref name="MachineName"/>\<paramref name="QueueName"/></description>
				</item>
				<item>
					<term> Private queue</term>
					<description><paramref name="MachineName"/>\Private$\<paramref name="QueueName"/></description>
				</item>
			</list>
			<para>Use "." for the local computer. For more syntax, see the
<see cref="System.Messaging.MessageQueue.Path"/> property.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<example>
			<para> The following example creates public and private queues. It sends
      a message to selected
      queues.</para>
			<codelink SampleID="MessageQueue.Create_path" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.Path"/>
		<seealso cref="System.Messaging.MessageQueue.Delete"/>
		<seealso cref="System.Messaging.MessageQueue.Exists"/>
		<seealso cref="System.Messaging.MessageQueue()"/>
	</doc>
	<doc for="MessageQueue.Create1">
		<summary>
			<para> Creates a transactional or nontransactional Message Queuing queue at the
      specified path.</para>
		</summary>
		<param name="path">The path of the queue to create.</param>
		<param name="transactional"><see langword="true"/> to create a transactional queue; <see langword="false"/> to create a nontransactional queue.</param>
		<returns>
			<para>A <see cref="System.Messaging.MessageQueue"/> that represents the new
   queue.</para>
		</returns>
		<exception cref="System.ArgumentException">The <paramref name="path "/>parameter is <see langword="null"/> or is an empty string ("").</exception>
		<exception cref="System.Messaging.MessageQueueException">A queue already exists at the specified path. <para>-or-</para><para> An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>You can use this overload to create a transactional queue in
      Message Queuing. You can create a nontransactional queue, by setting the
   <paramref name="transactional "/>parameter to <see langword="false"/> or by calling the other overload of <see cref="System.Messaging.MessageQueue.Create"/>.</para>
			<para>To create a new instance of the <see cref="System.Messaging.MessageQueue"/> class in your application and bind it to an existing queue,
   use the <see cref="M:System.Messaging.MessageQueue.#ctor"/>constructor. To create a new
   queue in Message Queuing, call <see cref="System.Messaging.MessageQueue.Create"/> .</para>
			<para>The syntax for the <paramref name="path"/> parameter depends on the type of queue it
references.</para>
			<list type="table">
				<listheader>
					<term>Queue Type</term>
					<description>Syntax</description>
				</listheader>
				<item>
					<term> Public queue</term>
					<description><paramref name="MachineName"/>\<paramref name="QueueName"/></description>
				</item>
				<item>
					<term> Private queue</term>
					<description><paramref name="MachineName"/>\Private$\<paramref name="QueueName"/></description>
				</item>
			</list>
			<para>Use "." for the local computer. For more syntax, see the
<see cref="System.Messaging.MessageQueue.Path"/> property.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example creates public and private transactional queues. It sends a message
      to selected queues.</para>
			<codelink SampleID="MessageQueue.Create_PathTransactional" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.Path"/>
		<seealso cref="System.Messaging.MessageQueue.Delete"/>
		<seealso cref="System.Messaging.MessageQueue.Exists"/>
		<seealso cref="System.Messaging.MessageQueue()"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
	</doc>
	<doc for="MessageQueue.Delete">
		<summary>
			<para> Deletes a queue on a
      Message Queuing server.</para>
		</summary>
		<param name="path">The location of the queue to be deleted.</param>
		<exception cref="System.ArgumentException">The <paramref name="path "/>parameter is <see langword="null"/> or is an empty string ("").</exception>
		<exception cref="System.Messaging.MessageQueueException"><para>The syntax for the <paramref name="path"/> parameter is invalid.</para>
			<para>-or-</para>
			<para> An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>The syntax for the <paramref name="path"/>
parameter depends on the type of queue.</para>
			<list type="table">
				<listheader>
					<term>Queue Type</term>
					<description>Syntax</description>
				</listheader>
				<item>
					<term> Public queue</term>
					<description><paramref name="MachineName"/>\<paramref name="QueueName"/></description>
				</item>
				<item>
					<term> Private queue</term>
					<description><paramref name="MachineName"/>\Private$\<paramref name="QueueName"/></description>
				</item>
			</list>
			<para>For more syntax, see the <see cref="System.Messaging.MessageQueue.Path"/>
property.</para>
			<para>Alternatively, you can use the <see cref="System.Messaging.MessageQueue.FormatName"/>
or <see cref="System.Messaging.MessageQueue.Label"/> to describe the queue path.</para>
			<list type="table">
				<listheader>
					<term>Reference</term>
					<description>Syntax</description>
				</listheader>
				<item>
					<term> Format name</term>
					<description>FormatName:[<paramref name="format name"/> ]</description>
				</item>
				<item>
					<term> Label</term>
					<description>Label:[<paramref name="label"/>]</description>
				</item>
			</list>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<example>
			<para> The following example deletes a Message Queuing queue, if it exists.</para>
			<codelink SampleID="MessageQueue.ExistsDelete" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.Create"/>
		<seealso cref="System.Messaging.MessageQueue.Close"/>
		<seealso cref="System.Messaging.MessageQueue.Path"/>
	</doc>
	<doc for="MessageQueue.Exists">
		<summary>
			<para>Determines whether a Message Queuing queue at the specified path
      exists.</para>
		</summary>
		<param name="path">The location of the queue to find.</param>
		<returns>
			<para><see langword="true"/> if a queue with the specified
   path exists; otherwise, <see langword="false"/> .</para>
		</returns>
		<exception cref="System.ArgumentException">The <paramref name="path"/> syntax is invalid.</exception>
		<exception cref="System.Messaging.MessageQueueException"><para>An error occurred when accessing a Message Queuing API.</para>
			<para>-or-</para>
			<para>The <see cref="System.Messaging.MessageQueue.Exists"/> method is being called on a remote private queue</para></exception>
		<exception cref="System.InvalidOperationException"><para>The application used a format name syntax when verifying queue existence.</para></exception>
		<remarks>
			<para>The <see cref="System.Messaging.MessageQueue.Exists"/> method determines whether a
   Message Queuing queue exists at a specified path. No method exists to determine
   whether a queue with a specified format name exists. For more information about
   the format name syntax and other path syntax forms, see the <see cref="System.Messaging.MessageQueue.Path"/>
   
   property.) </para>
			<para><see cref="System.Messaging.MessageQueue.Exists"/> is an expensive
operation. Use it
only when it is necessary within the application. </para>
			<para>The syntax for the <paramref name="path"/>
parameter depends on the type of queue.</para>
			<list type="table">
				<listheader>
					<term>Queue Type</term>
					<description>Syntax</description>
				</listheader>
				<item>
					<term> Public queue</term>
					<description><paramref name="MachineName"/>\<paramref name="QueueName"/></description>
				</item>
			</list>
			<note type="note">
				<see cref="System.Messaging.MessageQueue.Exists"/> cannot
   be called to verify the existence of a remote private queue.
</note>
			<para>For more syntax, see the <see cref="System.Messaging.MessageQueue.Path"/>
property.</para>
			<para>Alternatively, you can use
   the <see cref="System.Messaging.MessageQueue.Label"/> to describe the queue path.</para>
			<list type="table">
				<listheader>
					<term>Reference</term>
					<description>Syntax</description>
				</listheader>
				<item>
					<term> Label</term>
					<description>Label:[<paramref name="label"/>]</description>
				</item>
			</list>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example verifies whether a Message Queuing queue exists, and then deletes it.</para>
			<codelink SampleID="MessageQueue.ExistsDelete" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.Create"/>
		<seealso cref="System.Messaging.MessageQueue.Delete"/>
		<seealso cref="System.Messaging.MessageQueue.Path"/>
	</doc>
	<doc for="MessageQueue.GetAllMessages">
		<summary>
			<para>Returns all the messages that are in the queue.</para>
		</summary>
		<returns>
			<para>An array of type <see cref="System.Messaging.Message"/> that represents all the messages in the
   queue, in the same order as they appear in the Message Queuing
   queue.</para>
		</returns>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para><see cref="System.Messaging.MessageQueue.GetAllMessages"/> returns a static snapshot of the messages
   in the queue, not dynamic links to those messages. Therefore, you
   cannot use the array to modify the messages in the queue. If you want real-time,
   dynamic interaction with the queue (such as the ability to delete messages),
   call the <see cref="System.Messaging.MessageQueue.GetMessageEnumerator"/> method, which returns a dynamic list of the messages in the queue. </para>
			<para>Because <see cref="System.Messaging.MessageQueue.GetAllMessages"/> returns a copy of the messages in
the queue at the time the method was called, the array does not reflect new
messages that arrive in the queue or messages that are removed from the queue. </para>
			<note type="note">
				<see cref="System.Messaging.MessageQueue.GetAllMessages"/> retrieves only those properties not filtered
   out by the <see cref="System.Messaging.MessageQueue.MessageReadPropertyFilter"/> property.
</note>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.Message"/>
		<seealso cref="System.Messaging.MessageQueue.GetMessageEnumerator"/>
	</doc>
	<doc for="MessageQueue.GetEnumerator">
		<summary>
			<para>Enumerates the messages in a queue.</para>
		</summary>
		<returns>
			<para>An <see cref="System.Collections.IEnumerator"/> that provides a dynamic connection to the
   messages in the queue.</para>
		</returns>
		<remarks>
			<para>The following table shows whether this method is available in various 
      Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
            name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
            name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.GetMessageEnumerator"/>
	</doc>
	<doc for="MessageQueue.GetMachineId">
		<summary>
			<para> Gets the identifier of the computer on
      which the queue referenced by this <see cref="System.Messaging.MessageQueue"/>
      is located.</para>
		</summary>
		<param name="machineName">The name of the computer that contains the queue, without the two preceding backslashes (\\).</param>
		<returns>
			<para>A <see cref="System.Guid"/>
that represents a unique identifier for the computer on which the queue
is located. </para>
		</returns>
		<exception cref="System.Messaging.MessageQueueException"><para>The computer identifier could not be retrieved, possibly because the directory service is not available; for example, if you are working offline.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>You can use a computer's identifier for two purposes,
      among others: to read the computer journal and to set security certificates.
      However, you cannot call <see cref="System.Messaging.MessageQueue.GetMachineId"/> for a remote computer when you are
      working offline because the application must have access to the directory
      service on the domain controller.</para>
			<para>The computer identifier (or "machine identifier") is a
   <see cref="System.Guid"/> that Message Queuing creates
      when a computer is added to the enterprise. Message Queuing combines the
      computer identifier with the <c>Machine</c> and <c>Journal</c>
   
   keywords to create the machine journal's format name, which has the
   syntax <c>Machine=&lt;computeridentifier&gt;;Journal</c>. The
machine journal, which is also known as the journal queue, is a system queue that stores copies of application-generated messages when the
<see cref="System.Messaging.MessageQueue.UseJournalQueue"/> property is <see langword="true"/>.</para>
			<note type="note">
   This syntax for the journal
   is only valid when constructing the format name for the queue. The
   path name syntax is <paramref name="MachineName"/>\Journal$.
</note>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term> Local computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Local computer + direct format 
         name</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.MachineName"/>
		<seealso cref="System.Messaging.MessageQueue.UseJournalQueue"/>
	</doc>
	<doc for="MessageQueue.GetPrivateQueuesByMachine">
		<summary>
			<para>Retrieves all the private queues on
      the specified computer.</para>
		</summary>
		<param name="machineName">The computer from which to retrieve the private queues.</param>
		<returns>
			<para> An array of <see cref="System.Messaging.MessageQueue"/> objects
   that reference the retrieved private
   queues.</para>
		</returns>
		<exception cref="System.ArgumentException">The <paramref name="machineName"/> parameter is <see langword="null"/> or an empty string ("").</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para><see cref="System.Messaging.MessageQueue.GetPrivateQueuesByMachine"/>
retrieves a static snapshot of the queues on a specified computer.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para> The following example retrieves lists of
      queues.</para>
			<codelink SampleID="MessageQueue.GetQueueLists" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.MachineName"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueues"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByCategory"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByLabel"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByMachine"/>
		<seealso cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/>
	</doc>
	<doc for="MessageQueue.GetPublicQueues">
		<overload>
			<para>Retrieves all the public queues on the network.</para>
		</overload>
		<summary>
			<para>Retrieves all the public queues on the network.</para>
		</summary>
		<returns>
			<para>An array of <see cref="System.Messaging.MessageQueue"/>
objects that reference
the retrieved public queues.</para>
		</returns>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>Use this overload if you want a complete list of all the public queues on the network.
      If you want to restrict the list by certain criteria, such as <see cref="System.Messaging.MessageQueue.MachineName"/> , <see cref="System.Messaging.MessageQueue.Category"/>, or last modified time use
      another overload of this method. (Alternatively,
      you can use <see cref="System.Messaging.MessageQueue.GetPublicQueuesByMachine"/>, <see cref="System.Messaging.MessageQueue.GetPublicQueuesByCategory"/>, or <see cref="System.Messaging.MessageQueue.GetPublicQueuesByLabel"/>.)</para>
			<para><see cref="System.Messaging.MessageQueue.GetPublicQueues"/> retrieves a static snapshot
   of the queues. To interact with a dynamic list of the
   queues, use <see cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/>.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example retrieves lists of queues.</para>
			<codelink SampleID="MessageQueue.GetQueueLists" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByCategory"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByLabel"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByMachine"/>
		<seealso cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/>
		<seealso cref="System.Messaging.MessageQueue.GetPrivateQueuesByMachine"/>
	</doc>
	<doc for="MessageQueue.GetPublicQueues1">
		<summary>
			<para>Retrieves all the public queues on the network that meet the specified criteria.</para>
		</summary>
		<param name="criteria">A <see cref="System.Messaging.MessageQueueCriteria"/> that contains the criteria used to filter the queues.</param>
		<returns>
			<para>An array of <see cref="System.Messaging.MessageQueue"/> objects that reference
   the retrieved public queues.</para>
		</returns>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>If you want to filter all the public queues on the
      network by label, category, or computer name, the <see cref="System.Messaging.MessageQueue"/>
      class contains specific methods that provide that functionality (<see cref="System.Messaging.MessageQueue.GetPublicQueuesByLabel"/>, <see cref="System.Messaging.MessageQueue.GetPublicQueuesByCategory"/>, and <see cref="System.Messaging.MessageQueue.GetPublicQueuesByMachine"/>, respectively). Use this overload to get a
      list of all the public queues on the network that meet more than one of these
      criteria (for example, if you want to specify both a label and a category). You
      can also filter by message criteria other than <see cref="System.Messaging.MessageQueue.Label"/>, <see cref="System.Messaging.MessageQueue.Category"/>, and <see cref="System.Messaging.MessageQueue.MachineName"/> . For example, you use this overload to
      filter by a queue's last-modified time. Simply create a new instance of the
   <see cref="System.Messaging.MessageQueueCriteria"/> class, set the appropriate properties in the
      instance, and pass the instance as the <paramref name="criteria"/>
      parameter. </para>
			<para><see cref="System.Messaging.MessageQueue.GetPublicQueues"/> retrieves a static snapshot of
   the queues. To interact with a dynamic list of the queues, use <see cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/>. </para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example retrieves lists of queues.</para>
			<codelink SampleID="MessageQueue.GetQueueLists" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueueCriteria"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByCategory"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByLabel"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByMachine"/>
		<seealso cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/>
		<seealso cref="System.Messaging.MessageQueue.GetPrivateQueuesByMachine"/>
	</doc>
	<doc for="MessageQueue.GetPublicQueuesByCategory">
		<summary>
			<para>Retrieves all the public queues
      on the network that belong to the specified category.</para>
		</summary>
		<param name="category">A <see cref="System.Guid"/> that groups the set of queues to be retrieved.</param>
		<returns>
			<para>An array of <see cref="System.Messaging.MessageQueue"/>
objects that reference
the retrieved public queues.</para>
		</returns>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>Use this method to filter the public queues by category.
      The <see cref="System.Messaging.MessageQueue.Category"/>
      property provides access to the
      Message Queuing type ID property (which is read/write) of a particular
      queue. Although you can use <see cref="M:System.Guid.NewGuid"/>
      to create a category value that is unique across all <see cref="System.Guid"/> values, it is
      not necessary. The category value needs to be distinct only from other categories, not
      from all other <see cref="System.Guid"/>
      values.
      For example, you can assign {00000000-0000-0000-0000-000000000001} as the
   <see cref="System.Messaging.MessageQueue.Category"/> for one set of queues
      and {00000000-0000-0000-0000-000000000002} as the <see cref="System.Messaging.MessageQueue.Category"/>
      for another set.</para>
			<para><see cref="System.Messaging.MessageQueue.GetPublicQueuesByCategory"/>
retrieves a static snapshot of the queues. To interact with a dynamic list of
the queues, use <see cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/>
. You can specify the category
as part of the <see cref="System.Messaging.MessageQueueCriteria"/> you pass into
the method.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example retrieves lists of queues.</para>
			<codelink SampleID="MessageQueue.GetQueueLists" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.Category"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueues"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByLabel"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByMachine"/>
		<seealso cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/>
		<seealso cref="System.Messaging.MessageQueue.GetPrivateQueuesByMachine"/>
	</doc>
	<doc for="MessageQueue.GetPublicQueuesByLabel">
		<summary>
			<para>Retrieves all the public queues on the network that carry the specified label.</para>
		</summary>
		<param name="label">A label that groups the set of queues to be retrieved.</param>
		<returns>
			<para>An array of <see cref="System.Messaging.MessageQueue"/>
objects that reference
the retrieved public queues.</para>
		</returns>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<exception cref="System.ArgumentNullException">The <paramref name="label"/> parameter is <see langword="null"/>.</exception>
		<remarks>
			<para> Use this method to filter the public queues by label.</para>
			<para><see cref="System.Messaging.MessageQueue.GetPublicQueuesByLabel"/> retrieves a static snapshot of
   the queues. To interact with a dynamic list of the queues, use <see cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/> . You can specify the label as
   part of the <see cref="System.Messaging.MessageQueueCriteria"/> you pass into the method.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example retrieves lists of queues.</para>
			<codelink SampleID="MessageQueue.GetQueueLists" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.Label"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueues"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByCategory"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByMachine"/>
		<seealso cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/>
		<seealso cref="System.Messaging.MessageQueue.GetPrivateQueuesByMachine"/>
	</doc>
	<doc for="MessageQueue.GetPublicQueuesByMachine">
		<summary>
			<para>Retrieves all the public queues that reside on the specified computer.</para>
		</summary>
		<param name="machineName">The name of the computer that contains the set of public queues to be retrieved.</param>
		<returns>
			<para>An array of <see cref="System.Messaging.MessageQueue"/>
objects that
reference the public
queues on the computer.</para>
		</returns>
		<exception cref="System.ArgumentException">The <paramref name="machineName"/> parameter has incorrect syntax.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>Use this method to filter the public queues by computer.</para>
			<para><see cref="System.Messaging.MessageQueue.GetPublicQueuesByMachine"/> retrieves a static snapshot of
   the queues. To interact with a dynamic list of the queues, use <see cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/> . You can specify the computer
   name as part of the <see cref="System.Messaging.MessageQueueCriteria"/> you pass into the method.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example retrieves lists of queues.</para>
			<codelink SampleID="MessageQueue.GetQueueLists" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.MachineName"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueues"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByCategory"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByLabel"/>
		<seealso cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/>
		<seealso cref="System.Messaging.MessageQueue.GetPrivateQueuesByMachine"/>
	</doc>
	<doc for="MessageQueue.Peek">
		<overload>
			<para>Returns a copy of the first message in the queue, without removing the message from the
      queue.</para>
		</overload>
		<summary>
			<para> Returns without removing (peeks) the first
      message in the queue referenced by this <see cref="System.Messaging.MessageQueue"/> . The <see cref="System.Messaging.MessageQueue.Peek"/>
      method is
      synchronous, so it
      blocks the current thread until a message becomes
      available.</para>
		</summary>
		<returns>
			<para>The <see cref="System.Messaging.Message"/>
that represents the first message in the
queue.</para>
		</returns>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>Use this
      overload to peek a queue, or to wait until a message exists in the queue.</para>
			<para>The <see cref="System.Messaging.MessageQueue.Peek"/>
method reads, but does not remove, the first message from the queue. Therefore,
repeated calls to <see cref="System.Messaging.MessageQueue.Peek"/>
return the same message, unless a higher
priority message arrives in the queue. The <see cref="System.Messaging.MessageQueue.Receive"/> method, on the other hand, both
reads and removes the first message from the
queue. Repeated calls to <see cref="System.Messaging.MessageQueue.Receive"/>
, therefore, return different messages.</para>
			<note type="note">
   Message Queuing orders
   messages in the queue according to priority and arrival
   time. A newer message is placed before an older one only if it is of a
   higher priority.
   
</note>
			<para> Use <see cref="System.Messaging.MessageQueue.Peek"/> when it is acceptable for the
current thread to be blocked while it waits for a message to arrive in the
queue. Because
this overload does not
specify a time-out, the application might wait indefinitely. If you need the application processing to
continue without waiting, use the asynchronous <see cref="System.Messaging.MessageQueue.BeginPeek"/> method. Alternatively, you can
specify a time-out for a message to arrive in the queue by using the overload of
<see cref="System.Messaging.MessageQueue.Peek"/> that specifies a time-out.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following examples use the <see cref="System.Messaging.MessageQueue.Peek"/>
method on a queue.</para>
			<para>In the first example, the application waits until a message becomes
   available in the queue. Note that the first example does not access the message
   that arrives; it merely pauses processing until a message arrives. If a message
   already exists in the queue, it will return immediately.</para>
			<para> In the second example, a message containing an
   application-defined <c>Order</c> class is sent to the queue, and then peeked from the
queue.</para>
			<codelink SampleID="MessageQueue.Peek_noparms" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.PeekById"/>
		<seealso cref="System.Messaging.MessageQueue.PeekByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
	</doc>
	<doc for="MessageQueue.Peek1">
		<summary>
			<para>Returns without removing (peeks) the first message in the
      queue referenced by this <see cref="System.Messaging.MessageQueue"/> . The <see cref="System.Messaging.MessageQueue.Peek"/>
      method is synchronous, so
      it blocks the
      current thread until
      a message becomes available or the specified time-out
      occurs.</para>
		</summary>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the maximum time to wait for the queue to contain a message.</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/>
that represents the first message in the
queue.</para>
		</returns>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout"/> parameter is invalid, possibly <paramref name="timeout"/> is less than <see cref="System.TimeSpan.Zero" qualify="true"/> or greater than <see cref="System.TimeSpan.MaxValue" qualify="true"/>. </exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para> Use this overload to peek a queue, or to wait a specified
      period of time until a message exists in the queue.
      The method returns immediately if a message already exists in the queue.</para>
			<para>The <see cref="System.Messaging.MessageQueue.Peek"/> method reads, but does not remove,
   the first message from the queue. Therefore, repeated calls to <see cref="System.Messaging.MessageQueue.Peek"/> return the same message, unless a
   higher priority message arrives in the queue. The <see cref="System.Messaging.MessageQueue.Receive"/> method, on the
   other hand, both reads and removes the first message from the queue. Repeated
   calls to <see cref="System.Messaging.MessageQueue.Receive"/> , therefore, return different
   messages.</para>
			<note type="note">
   Message Queuing orders messages in
   the queue according to priority and arrival time. A newer message is placed
   before an older one only if it is of a higher priority.
   
</note>
			<para>Use <see cref="System.Messaging.MessageQueue.Peek"/> when it is acceptable for the
current thread to be blocked while it waits for a message to arrive in the
queue. The thread will be blocked up to the specified period of time,
or indefinitely if you indicated <see cref="System.Messaging.MessageQueue.InfiniteTimeout"/>. If you
need the application processing to continue without waiting, use the
asynchronous <see cref="System.Messaging.MessageQueue.BeginPeek"/> method.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example uses the <see cref="System.Messaging.MessageQueue.Peek"/> method with a time-out of zero to check whether the
   queue is empty.</para>
			<codelink SampleID="MessageQueue.Peek_timeout" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.InfiniteTimeout"/>
		<seealso cref="System.Messaging.MessageQueue.PeekById"/>
		<seealso cref="System.Messaging.MessageQueue.PeekByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
	</doc>
	<doc for="MessageQueue.PeekById">
		<overload>
			<para>Returns a copy of the message that has the specified message
      identifier, without removing the message from the queue.</para>
		</overload>
		<summary>
			<para>Peeks the message whose message identifier matches
      the <paramref name="id"/> parameter. </para>
		</summary>
		<param name="id">The <see cref="System.Messaging.Message.Id"/> of the message to peek.</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose <see cref="System.Messaging.Message.Id"/>
property matches the <paramref name="id"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentNullException">The <paramref name="id "/>parameter is <see langword="null"/>.</exception>
		<exception cref="System.InvalidOperationException">No message with the specified <paramref name="id"/> exists.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>Use <see cref="System.Messaging.MessageQueue.PeekById"/> to read, without removing from
   the queue, a message that has a known message identifier. The identifier of a
   message is unique across the Message Queuing enterprise, so there will be at
   most one message in the queue that matches the given <paramref name="id "/>
   parameter. This overload throws an exception if the queue does not currently
   contain the message.</para>
			<para> Two additional methods allow you to peek messages in a
   queue: <see cref="System.Messaging.MessageQueue.Peek"/>
   and <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/>. The
<see cref="System.Messaging.MessageQueue.Peek"/> method returns the first message in the queue;
<see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/>
returns an acknowledgment, report, or
application-generated response message that was created as a result of a
message sent to the queue.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.Message.Id"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.PeekByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
	</doc>
	<doc for="MessageQueue.PeekById1">
		<summary>
			<para> Peeks the message whose message identifier matches
      the <paramref name="id"/>
      parameter. Waits until the message appears in the queue or a
      time-out occurs.</para>
		</summary>
		<param name="id">The <see cref="System.Messaging.Message.Id"/> of the message to peek.</param>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the maximum amount of time to wait for the message to appear in the queue.</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose <see cref="System.Messaging.Message.Id"/> property matches the
<paramref name="id"/> parameter.</para>
		</returns>
		<exception cref="System.ArgumentNullException">The <paramref name="id"/> parameter is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout"/> parameter is invalid, possibly <paramref name="timeout"/> is less than <see cref="System.TimeSpan.Zero" qualify="true"/> or greater than <see cref="System.TimeSpan.MaxValue" qualify="true"/>. </exception>
		<exception cref="System.InvalidOperationException">The message with the specified <paramref name="id"/> does not exist in the queue and did not arrive before the period specified by the <paramref name="timeout"/> parameter expired.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>Use <see cref="System.Messaging.MessageQueue.PeekById"/> to read, without removing from
   the queue, a message that has a known message identifier. The identifier of a
   message is unique across the Message Queuing enterprise, so there will be at
   most one message in the queue that matches the given <paramref name="id "/> parameter. This overload throws an exception if
   the queue does not currently contain the message
   and the message does not arrive before the time-out occurs.</para>
			<para>Two additional methods allow you to peek messages in a queue: <see cref="System.Messaging.MessageQueue.Peek"/> and <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/>. The <see cref="System.Messaging.MessageQueue.Peek"/> method returns
the first message in the queue; <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> returns an acknowledgment,
report, or application-generated response message that was created as a result
of a message sent to the queue.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.InfiniteTimeout"/>
		<seealso cref="System.Messaging.Message.Id"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.PeekByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
	</doc>
	<doc for="MessageQueue.PeekByCorrelationId1">
		<summary>
			<para>Peeks the message that matches the given correlation identifier and waits
      until either a message with the specified correlation identifier is
      available in the queue, or the time-out expires.</para>
		</summary>
		<param name="correlationId">The <see cref="System.Messaging.Message.CorrelationId"/> of the message to peek.</param>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the time to wait until a new message is available for inspection .</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose
<see cref="System.Messaging.Message.CorrelationId"/> matches the <paramref name="correlationId"/> parameter passed in.</para>
		</returns>
		<exception cref="System.ArgumentNullException">The <paramref name="correlationId "/>parameter is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout"/> parameter is invalid, possibly <paramref name="timeout"/> is less than <see cref="System.TimeSpan.Zero" qualify="true"/> or greater than <see cref="System.TimeSpan.MaxValue" qualify="true"/>. </exception>
		<exception cref="System.InvalidOperationException"><para>The message with the specified <paramref name="correlationId"/> does not exist in the queue and did not arrive before the time-out expired.</para></exception>
		<exception cref="System.Messaging.MessageQueueException"><para>A message did not arrive before the time-out expired. </para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API. </para></exception>
		<remarks>
			<para>This method looks in the queue referenced by the <see cref="System.Messaging.MessageQueue"/> for a message
   whose <see cref="System.Messaging.Message.CorrelationId"/> matches the specified
<paramref name="correlationId"/> parameter. If no message is found that matches the
<paramref name="correlationID"/> parameter within the period specified by
   the <paramref name="timeout"/> parameter, an exception is thrown. </para>
			<para>The <see cref="System.Messaging.Message.CorrelationId"/> property is used to tie a message sent
to the queue to associated response, report, or acknowledgment
messages.</para>
			<para>Two other methods allow you to peek messages in a queue. The <see cref="System.Messaging.MessageQueue.Peek"/> method returns the first message
in the queue, and the <see cref="System.Messaging.MessageQueue.PeekById"/> method is used to retrieve a
message by specifying its unique identifier.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.InfiniteTimeout"/>
		<seealso cref="System.Messaging.Message.CorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.PeekById"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
	</doc>
	<doc for="MessageQueue.Purge">
		<summary>
			<para>Deletes all the messages contained in the queue.</para>
		</summary>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>Purging the queue causes Message Queuing to set the queue modification
      flag, which affects the <see cref="System.Messaging.MessageQueue.LastModifyTime"/> property. Messages that are
      purged from the queue are lost; they are not sent to the dead-letter queue or
      the journal queue.</para>
			<para>The following table shows whether this method is available in various 
      Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
            name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
            name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.Close"/>
		<seealso cref="System.Messaging.MessageQueue.Refresh"/>
	</doc>
	<doc for="MessageQueue.Receive">
		<overload>
			<para>Receives the first message in the queue, removing it from the queue.</para>
		</overload>
		<summary>
			<para> Receives the first message available in the queue referenced by the <see cref="System.Messaging.MessageQueue"/> . This
   call is synchronous, and blocks the current thread of execution until a message is
   available.</para>
		</summary>
		<returns>
			<para>A <see cref="System.Messaging.Message"/> that references the first message
   available in the queue.</para>
		</returns>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para> Use this overload to receive a message from a queue, or wait until there
      are messages in the queue.</para>
			<para>The <see cref="System.Messaging.MessageQueue.Receive"/> method
   allows for the synchronous reading of a message, thereby removing it from the queue.
   Subsequent calls to <see cref="System.Messaging.MessageQueue.Receive"/> will
   return the messages that follow in the queue, or new, higher priority
   messages.</para>
			<para>To read the first
   message in a queue without removing it from the queue, use the <see cref="System.Messaging.MessageQueue.Peek"/> method. The <see cref="System.Messaging.MessageQueue.Peek"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message unless a higher priority
   message arrives in the queue.</para>
			<para>Use a call to <see cref="System.Messaging.MessageQueue.Receive"/> when it is acceptable for the
current thread to be blocked while it waits for a message to arrive in the
queue. Because this overload of the <see cref="System.Messaging.MessageQueue.Receive"/> method specifies an infinite
time-out, the application might wait indefinitely. If the application processing
should continue without waiting for the message, consider using the asynchronous
method, <see cref="System.Messaging.MessageQueue.BeginReceive"/>.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para> The
      following example receives a message from a queue and outputs information
      about that message to the screen.</para>
			<codelink SampleID="MessageQueue.Receive_noparms" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.Receive2">
		<summary>
			<para> Receives the first message available in the queue
      referenced by the <see cref="System.Messaging.MessageQueue"/>
      and waits until
      either a message is available in the queue, or the time-out
      expires.</para>
		</summary>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the time to wait until a new message is available for inspection.</param>
		<returns>
			<para>A <see cref="System.Messaging.Message"/> that
   references the first message available in the
   queue.</para>
		</returns>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout"/> parameter is invalid, possibly <paramref name="timeout"/> is less than <see cref="System.TimeSpan.Zero" qualify="true"/> or greater than <see cref="System.TimeSpan.MaxValue" qualify="true"/>. </exception>
		<exception cref="System.Messaging.MessageQueueException"><para>A message did not arrive in the queue before the time-out expired.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API</para></exception>
		<remarks>
			<para>Use this overload to receive a message and return in a specified period of
      time if there are no messages in the queue.</para>
			<para>The <see cref="System.Messaging.MessageQueue.Receive"/> method allows for the synchronous
   reading of a message, removing it from the queue. Subsequent calls to <see cref="System.Messaging.MessageQueue.Receive"/> will return the messages
   that follow in the queue, or new, higher priority messages.</para>
			<para>To read the first message in a queue without removing it from the queue, use
   the <see cref="System.Messaging.MessageQueue.Peek"/> method. The <see cref="System.Messaging.MessageQueue.Peek"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue.</para>
			<para>Use a call to <see cref="System.Messaging.MessageQueue.Receive"/> when it is acceptable for the current thread
to be blocked while it waits for a message to arrive in the queue. The
thread will be blocked for the given period of time, or indefinitely if you
specified the value <see cref="System.Messaging.MessageQueue.InfiniteTimeout"/> for the <paramref name="timeout"/>
parameter. If the application processing should continue without waiting for a
message, consider using the asynchronous method, <see cref="System.Messaging.MessageQueue.BeginReceive"/>.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example receives a message from a queue and outputs
      information about that message to the screen. The example pauses execution for up
      to five seconds while waiting for a message to arrive in the
      queue.</para>
			<codelink SampleID="MessageQueue.Receive_timeout" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.InfiniteTimeout"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.Receive3">
		<summary>
			<para>Receives the first message available in the transactional queue
      referenced by the <see cref="System.Messaging.MessageQueue"/> and waits until either
      a message is available in the queue, or the time-out
      expires.</para>
		</summary>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the time to wait until a new message is available for inspection.</param>
		<param name="transaction">The <see cref="System.Messaging.MessageQueueTransaction"/> object.</param>
		<returns>
			<para>A <see cref="System.Messaging.Message"/> that
   references the first message available in the
   queue.</para>
		</returns>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout"/> parameter is invalid, possibly <paramref name="timeout"/> is less than <see cref="System.TimeSpan.Zero" qualify="true"/> or greater than <see cref="System.TimeSpan.MaxValue" qualify="true"/>. </exception>
		<exception cref="System.Messaging.MessageQueueException"><para>A message did not arrive in the queue before the time-out expired.</para>
			<para>-or-</para>
			<para>The queue is non-transactional.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>Use this overload to receive a message from a
      transactional queue using the internal transaction context defined by the
   <paramref name="transaction"/> parameter, and return
      within a specified period of time if there are no messages in the queue.</para>
			<para>The <see cref="System.Messaging.MessageQueue.Receive"/> method allows for the synchronous reading
   of a message, thereby removing it from the queue. Subsequent calls to <see cref="System.Messaging.MessageQueue.Receive"/> will return the messages that
   follow in the queue.</para>
			<para> Because this method is called on a transactional queue,
   the message that is received would be returned to the queue if the transaction
   is aborted. The message is not permanently removed from the queue until the transaction is
   committed.</para>
			<para>To read the first message in a queue without removing it from the queue, use
   the <see cref="System.Messaging.MessageQueue.Peek"/> method. The <see cref="System.Messaging.MessageQueue.Peek"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue. There is no transaction
   context associated with a message returned by a call to <see cref="System.Messaging.MessageQueue.Peek"/>. Because <see cref="System.Messaging.MessageQueue.Peek"/> does not remove any messages in
   the queue, there would be nothing to roll back by a call to <see cref="System.Messaging.MessageQueueTransaction.Abort"/>
   .</para>
			<para>Use a call to <see cref="System.Messaging.MessageQueue.Receive"/> when it is acceptable for the current thread
to be blocked while it waits for a message to arrive in the queue. The
thread will be blocked for the given period of time, or indefinitely if you
specified the value <see cref="System.Messaging.MessageQueue.InfiniteTimeout"/> for the <paramref name="timeout
"/> parameter. If the application processing should
continue without waiting for a message, consider using the asynchronous method,
<see cref="System.Messaging.MessageQueue.BeginReceive"/>.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<codelink SampleID="MessageQueue.Receive_TimeoutTransaction" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueueTransaction"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.InfiniteTimeout"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.Receive4">
		<summary>
			<para> Receives the first message available in
      the queue referenced by the <see cref="System.Messaging.MessageQueue"/> . This
      call is synchronous, and waits until
      either a message is available in the queue, or the time-out
      expires.</para>
		</summary>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the time to wait until a new message is available for inspection.</param>
		<param name="transactionType">One of the <see cref="System.Messaging.MessageQueueTransactionType"/> values, describing the type of transaction context to associate with the message.</param>
		<returns>
			<para>A <see cref="System.Messaging.Message"/> that references the first message
   available in the queue.</para>
		</returns>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout"/> parameter is invalid, possibly <paramref name="timeout"/> is less than <see cref="System.TimeSpan.Zero" qualify="true"/> or greater than <see cref="System.TimeSpan.MaxValue" qualify="true"/>. </exception>
		<exception cref="System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType"/> parameter is not one of the <see cref="System.Messaging.MessageQueueTransactionType"/> members.</exception>
		<exception cref="System.Messaging.MessageQueueException"><para>A message did not arrive in the queue before the time-out expired.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>Use this overload to receive a message from a queue
      using a transaction context defined by the <paramref name="transactionType"/>
      parameter, and return in a specified period of time if there are
      no messages in the queue.</para>
			<para>Specify <see langword="Automatic"/> for the <paramref name="transactionType"/> parameter
   if there is already an external transaction context attached to the thread that
   you want to use to receive the message. Specify <see langword="Single"/> if you
   want to receive the message as a single internal transaction. You can specify
<see langword="None"/> if you want to receive a message from a transactional queue outside of a 
   transaction context.</para>
			<para>The <see cref="System.Messaging.MessageQueue.Receive"/> method
allows for the synchronous reading of a message, thereby removing it from the queue.
Subsequent calls to <see cref="System.Messaging.MessageQueue.Receive"/> will return the messages
that follow in the queue.</para>
			<para> If this method is called to receive a message from a
   transactional queue, the message that is received would be returned to the queue
   if the transaction is aborted. The message is not permanently removed from the
   queue until the transaction is committed.</para>
			<para>To read the first
   message in a queue without removing it from the queue, use the <see cref="System.Messaging.MessageQueue.Peek"/> method. The <see cref="System.Messaging.MessageQueue.Peek"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue. There is no transaction
   context associated with a message returned by a call to <see cref="System.Messaging.MessageQueue.Peek"/>. Because <see cref="System.Messaging.MessageQueue.Peek"/> does not remove any messages in the queue,
   there would be nothing to roll back by a call to <see cref="System.Messaging.MessageQueueTransaction.Abort"/>
   .</para>
			<para>Use a call to <see cref="System.Messaging.MessageQueue.Receive"/> when it is
acceptable for the current thread to be blocked while it waits for a message to
arrive in the queue. The thread will be blocked for the given period of time, or
indefinitely if you specified the value <see cref="System.Messaging.MessageQueue.InfiniteTimeout"/> for the
<paramref name="timeout "/>parameter. If the application processing should continue without 
waiting for a message, consider using the asynchronous method, <see cref="System.Messaging.MessageQueue.BeginReceive"/>.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueueTransactionType"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.ReceiveById">
		<overload>
			<para>Receives the message that matches the given identifier, removing it from the
      queue.</para>
		</overload>
		<summary>
			<para> Receives the message that matches the given identifier from a non-transactional queue, and immediately raises
      an exception if no message with the specified identifier
      currently exists in the queue.</para>
		</summary>
		<param name="id">The <see cref="System.Messaging.Message.Id"/> of the message to receive.</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose <see cref="System.Messaging.Message.Id"/> property matches the
<paramref name="id"/> parameter passed in.</para>
		</returns>
		<exception cref="System.ArgumentNullException">The <paramref name="id "/>parameter is <see langword="null"/>.</exception>
		<exception cref="System.InvalidOperationException">The message with the specified <paramref name="id "/>could not be found.</exception>
		<exception cref="System.Messaging.MessageQueueException"><para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para> Use
      this method to read a message with a known identifier
      and remove it from the queue. This method throws an exception immediately if the message is not
      in the queue.</para>
			<para> The <see cref="System.Messaging.Message.Id"/> property of a message is unique across the
   Message Queuing enterprise, so there will be at most one message in the queue
   that matches the given <paramref name="id "/>
   parameter. . </para>
			<para>Two other methods allow you to receive messages from a queue.
   The <see cref="System.Messaging.MessageQueue.Receive"/> method returns the first message in the queue,
   and the <see cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
   method is used to retrieve an acknowledgment, report, or
   application-generated response message that was created as a result of a
   message sent to the queue. </para>
			<para>To read a message with a specified identifier without removing it from
   the queue, use the <see cref="System.Messaging.MessageQueue.PeekById"/> method. The <see cref="System.Messaging.MessageQueue.PeekById"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.ReceiveById1">
		<summary>
			<para>Receives the message that matches the given identifier,
      from a transactional queue, and immediately raises
      an exception if no message with the specified identifier
      currently exists in the queue.</para>
		</summary>
		<param name="id">The <see cref="System.Messaging.Message.Id"/> of the message to receive.</param>
		<param name="transaction">The <see cref="System.Messaging.MessageQueueTransaction"/> object .</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose <see cref="System.Messaging.Message.Id"/> property matches the
<paramref name="id"/> parameter passed in.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>The <paramref name="id "/>parameter is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>The <paramref name="transaction "/>parameter is <see langword="null"/>.</para></exception>
		<exception cref="System.InvalidOperationException">The message with the specified <paramref name="id "/>could not be found.</exception>
		<exception cref="System.Messaging.MessageQueueException"><para>The queue is non-transactional.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para> Use this method to read a message with a known
      identifier and remove it from the queue, using the internal transaction context
      defined by the <paramref name="transaction"/>
      parameter. This method throws an exception immediately if
      the message is not in the queue</para>
			<para> The <see cref="System.Messaging.Message.Id"/> property of a message is unique across
   the Message Queuing enterprise, so there will be at most one message in the
   queue that matches the given <paramref name="id "/>
   parameter.</para>
			<para>Because this method is called on a transactional queue,
   the message that is received would be returned to the queue if the transaction
   is aborted. The message is not permanently removed from the queue until the
   transaction is committed.
   </para>
			<para>Two other methods allow you to receive messages from a queue. The <see cref="System.Messaging.MessageQueue.Receive"/> method returns the first message
in the queue, and the <see cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
method is used to retrieve an acknowledgment, report, or application-generated
response message that was created as a result of a message sent to the
queue.</para>
			<para>To read a message with a specified identifier without
   removing it from the queue, use the <see cref="System.Messaging.MessageQueue.PeekById"/> method. The <see cref="System.Messaging.MessageQueue.PeekById"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue. There is no transaction
   context associated with a message returned by a call to <see cref="System.Messaging.MessageQueue.PeekById"/>. Because <see cref="System.Messaging.MessageQueue.PeekById"/> does not remove any messages in
   the queue, there would be nothing to roll back if the transaction were
   aborted. </para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueueTransaction"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.ReceiveById5">
		<summary>
			<para> Receives the message that matches the
      given identifier, and immediately raises an exception if no message with the specified
      identifier currently exists in the queue.</para>
		</summary>
		<param name="id">The <see cref="System.Messaging.Message.Id"/> of the message to receive.</param>
		<param name="transactionType">One of the <see cref="System.Messaging.MessageQueueTransactionType"/> values, describing the type of transaction context to associate with the message.</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose <see cref="System.Messaging.Message.Id"/> property matches the
<paramref name="id"/> parameter passed in.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>The <paramref name="id "/>parameter is <see langword="null"/>.</para></exception>
		<exception cref="System.InvalidOperationException">The message with the specified <paramref name="id "/>could not be found.</exception>
		<exception cref="System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType"/> parameter is not one of the <see cref="System.Messaging.MessageQueueTransactionType"/> members.</exception>
		<exception cref="System.Messaging.MessageQueueException"><para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>Use this method to read a message with a known
      identifier and remove it from the queue. This method throws an exception immediately if
      the message is not in the queue. Otherwise, the message is removed from the
      queue and returned to the application using a transaction context defined by the
   <paramref name="transactionType"/>
   parameter.</para>
			<para>Specify <see langword="Automatic"/> for the <paramref name="transactionType"/> parameter
if there is already an external transaction context attached to the thread that
you want to use to receive the message. Specify <see langword="Single"/> if you
want to receive the message as a single internal transaction. You can specify
<see langword="None"/> if you want to receive a message from a transactional queue outside of a transaction 
context.</para>
			<para>The <see cref="System.Messaging.Message.Id"/> property of a message is unique across
the Message Queuing enterprise, so there will be at most one message in the
queue that matches the given <paramref name="id "/>parameter. If the message with the
specified identifier is in a queue other than the one associated with this
<see cref="System.Messaging.MessageQueue"/> instance, the message will not be found.</para>
			<para>If this method is called to receive a message from a
   transactional queue, the message that is received would be returned to the queue
   if the transaction is aborted. The message is not permanently removed from the
   queue until the transaction is committed.
   </para>
			<para>Two other methods allow you to receive messages from a queue. The <see cref="System.Messaging.MessageQueue.Receive"/> method returns the first message
in the queue, and the <see cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/> method is used
to retrieve an acknowledgment, report, or application-generated response message
that was created as a result of a message sent to the queue.</para>
			<para>To read a message with a specified identifier without removing it from the
   queue, use the <see cref="System.Messaging.MessageQueue.PeekById"/> method. The <see cref="System.Messaging.MessageQueue.PeekById"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue. There is no transaction
   context associated with a message returned by a call to <see cref="System.Messaging.MessageQueue.PeekById"/>. Because <see cref="System.Messaging.MessageQueue.PeekById"/> does not remove any messages in
   the queue, there would be nothing to roll back if the transaction were aborted. </para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueueTransactionType"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.ReceiveById2">
		<summary>
			<para> Receives the message that matches the given identifier,
      from a nontransactional queue, and waits until either a message with
      the specified identifier is
      available in the queue or the time-out
      expires.</para>
		</summary>
		<param name="id">The <see cref="System.Messaging.Message.Id"/> of the message to receive.</param>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the time to wait until a new message is available for inspection.</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose <see cref="System.Messaging.Message.Id"/> property matches the
<paramref name="id"/> parameter passed in.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>The <paramref name="id "/>parameter is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout"/> parameter is invalid, possibly <paramref name="timeout"/> is less than <see cref="System.TimeSpan.Zero" qualify="true"/> or greater than <see cref="System.TimeSpan.MaxValue" qualify="true"/>. </exception>
		<exception cref="System.Messaging.MessageQueueException"><para>A message with the specified <paramref name="id"/> did not arrive in the queue before the time-out expired.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>Use this method to read a message with a known
      identifier and remove it from the queue. This method returns immediately if the message
      with the identifier specified by the <paramref name="id "/>
      parameter
      is in the queue. Otherwise, the method waits the given period of
      time for the message to arrive. If the message does not arrive before
      the time-out expires, an exception is thrown. </para>
			<para> The <see cref="System.Messaging.Message.Id"/> property of a message is unique across
   the Message Queuing enterprise, so there will be at most one message in the
   queue that matches the given <paramref name="id "/>
   
   parameter. </para>
			<para> Use this overload of <see cref="System.Messaging.MessageQueue.ReceiveById"/> when it is acceptable for the current thread
to be blocked while it waits for a message to arrive in the queue. The thread
will be blocked for the given period of time, or indefinitely if you specified
the value <see cref="System.Messaging.MessageQueue.InfiniteTimeout"/> for the <paramref name="timeout"/> parameter.</para>
			<para>Two other methods allow you to receive messages from a queue. The <see cref="System.Messaging.MessageQueue.Receive"/> method returns the first message
in the queue, and the <see cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
method is used to retrieve an acknowledgment, report, or application-generated
response message that was created as a result of a message sent to the
queue.</para>
			<para>To read a message with a specified identifier without removing it
   from the queue, use the <see cref="System.Messaging.MessageQueue.PeekById"/> method. The <see cref="System.Messaging.MessageQueue.PeekById"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.InfiniteTimeout"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.ReceiveById3">
		<summary>
			<para> Receives the message that matches the
      given identifier, from a transactional queue, and waits
      until either a message with the specified identifier is
      available in the queue or the time-out
      expires.</para>
		</summary>
		<param name="id">The <see cref="System.Messaging.Message.Id"/> of the message to receive.</param>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the time to wait until a new message is available for inspection.</param>
		<param name="transaction">The <see cref="System.Messaging.MessageQueueTransaction"/> object .</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose <see cref="System.Messaging.Message.Id"/> property matches the
<paramref name="id"/> parameter passed in.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>The <paramref name="id "/>parameter is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>The <paramref name="transaction "/>parameter is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout"/> parameter is invalid, possibly <paramref name="timeout"/> is less than <see cref="System.TimeSpan.Zero" qualify="true"/> or greater than <see cref="System.TimeSpan.MaxValue" qualify="true"/>. </exception>
		<exception cref="System.Messaging.MessageQueueException"><para>A message with the specified <paramref name="id"/> did not arrive in the queue before the time-out expired.</para>
			<para>-or-</para>
			<para>The queue is non-transactional.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>Use this method to read a message with a known
      identifier and remove it from the queue, using the internal transaction context
      defined by the <paramref name="transaction"/>
      parameter. This method returns immediately if the message with the identifier
      specified by the <paramref name="id "/>parameter is in the queue. Otherwise, the method
      waits the given period of time for the message to arrive. If the message does
      not arrive before the time-out expires, an exception is thrown. </para>
			<para>The <see cref="System.Messaging.Message.Id"/> property of a message is unique across
   the Message Queuing enterprise, so there will be at most one message in the
   queue that matches the given <paramref name="id "/>
   parameter. </para>
			<para> Use this overload of <see cref="System.Messaging.MessageQueue.ReceiveById"/> when it is
acceptable for the current thread to be blocked while it waits for a message to
arrive in the queue. The thread will be blocked for the given period of time, or
indefinitely if you specified the value <see cref="System.Messaging.MessageQueue.InfiniteTimeout"/> for the
<paramref name="timeout"/> parameter.</para>
			<para>Because this method is called on a transactional queue,
   the message that is received would be returned to the queue if the transaction
   is aborted. The message is not permanently removed from the queue until the
   transaction is committed.
   </para>
			<para>Two other methods allow you to receive messages from a queue. The <see cref="System.Messaging.MessageQueue.Receive"/> method returns the first message
in the queue, and the <see cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/> method
is used to retrieve an acknowledgment, report, or application-generated response
message that was created as a result of a message sent to the queue.</para>
			<para>To read a message with a specified identifier without removing it from the
   queue, use the <see cref="System.Messaging.MessageQueue.PeekById"/> method. The <see cref="System.Messaging.MessageQueue.PeekById"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message,
   unless a higher priority message arrives in the queue. There is no transaction
   context associated with a message returned by a call to <see cref="System.Messaging.MessageQueue.PeekById"/>. Because <see cref="System.Messaging.MessageQueue.PeekById"/> does not remove any messages in
   the queue, there would be nothing to roll back if the transaction were
   aborted.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueueTransaction"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.InfiniteTimeout"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.ReceiveById4">
		<summary>
			<para> Receives the message that matches the given identifier,
      and waits until either a message with the specified identifier is available in
      the queue or the time-out expires.</para>
		</summary>
		<param name="id">The <see cref="System.Messaging.Message.Id"/> of the message to receive.</param>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the time to wait until a new message is available for inspection.</param>
		<param name="transactionType">One of the <see cref="System.Messaging.MessageQueueTransactionType"/> values, describing the type of transaction context to associate with the message.</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose <see cref="System.Messaging.Message.Id"/> property matches the
<paramref name="id"/> parameter passed in.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>The <paramref name="id "/>parameter is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout"/> parameter is invalid, possibly <paramref name="timeout"/> is less than <see cref="System.TimeSpan.Zero" qualify="true"/> or greater than <see cref="System.TimeSpan.MaxValue" qualify="true"/>. </exception>
		<exception cref="System.Messaging.MessageQueueException"><para>A message with the specified <paramref name="id"/> did not arrive in the queue before the time-out expired.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API.</para></exception>
		<exception cref="System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType"/> parameter is not one of the <see cref="System.Messaging.MessageQueueTransactionType"/> members.</exception>
		<remarks>
			<para>Use this method to read a message with a known identifier and remove it from the
      queue. This method returns immediately if the message with the identifier
      specified by the <paramref name="id "/>parameter is in the queue, using a
      transaction context defined by the <paramref name="transactionType"/> parameter. Otherwise,
      the method waits the given period of time for the message to arrive. If the
      message does not arrive before the time-out expires, an exception is thrown.</para>
			<para>Specify <see langword="Automatic"/> for the <paramref name="transactionType"/> parameter
   if there is already an external transaction context attached to the thread that
   you want to use to receive the message. Specify <see langword="Single"/> if you
   want to receive the message as a single internal transaction. You can specify
<see langword="None"/> if you want to receive a message from a transactional queue outside of a transaction 
   context.</para>
			<para>The <see cref="System.Messaging.Message.Id"/> property of a message is unique across
the Message Queuing enterprise, so there will be at most one message in the
queue that matches the given <paramref name="id "/>parameter. If the message with the
specified identifier is in a queue other than the one associated with this
<see cref="System.Messaging.MessageQueue"/> instance, the message will not be found.</para>
			<para>Use this overload of <see cref="System.Messaging.MessageQueue.ReceiveById"/> when it is
acceptable for the current thread to be blocked while it waits for a message to
arrive in the queue. The thread will be blocked for the given period of time, or
indefinitely if you specified the value <see cref="System.Messaging.MessageQueue.InfiniteTimeout"/> for the
<paramref name="timeout"/> 
parameter.</para>
			<para>If this method is called to receive a message from a
   transactional queue, the message that is received would be returned to the queue
   if the transaction is aborted. The message is not permanently removed from the
   queue until the transaction is committed.
   </para>
			<para>Two other methods allow you to receive messages from a queue. The <see cref="System.Messaging.MessageQueue.Receive"/> method returns the first message
in the queue, and the <see cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/> method is used
to retrieve an acknowledgment, report, or application-generated response message
that was created as a result of a message sent to the queue.</para>
			<para>To read a message with a specified identifier without removing it from the
   queue, use the <see cref="System.Messaging.MessageQueue.PeekById"/> method. The <see cref="System.Messaging.MessageQueue.PeekById"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue. There is no transaction
   context associated with a message returned by a call to <see cref="System.Messaging.MessageQueue.PeekById"/>. Because <see cref="System.Messaging.MessageQueue.PeekById"/> does not remove any messages in
   the queue, there would be nothing to roll back if the transaction were aborted. </para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueueTransactionType"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.ReceiveByCorrelationId5">
		<summary>
			<para> Receives the message that matches the given correlation
      identifier, and immediately raises an exception if no message with the specified correlation
      identifier currently exists in the queue.</para>
		</summary>
		<param name="correlationId">The <see cref="System.Messaging.Message.CorrelationId"/> of the message to receive.</param>
		<param name="transactionType">One of the <see cref="System.Messaging.MessageQueueTransactionType"/> values, describing the type of transaction context to associate with the message.</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose <see cref="System.Messaging.Message.CorrelationId"/> matches the
<paramref name="correlationId"/> parameter passed in.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>The <paramref name="correlationId "/>parameter is <see langword="null"/>.</para></exception>
		<exception cref="System.InvalidOperationException">The message with the specified <paramref name="correlationId "/>could not be found.</exception>
		<exception cref="System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType"/> parameter is not one of the <see cref="System.Messaging.MessageQueueTransactionType"/> members.</exception>
		<exception cref="System.Messaging.MessageQueueException"><para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para> This method looks in the queue referenced by the <see cref="System.Messaging.MessageQueue"/>
for a message whose <see cref="System.Messaging.Message.CorrelationId"/> matches the specified
<paramref name="correlationId"/> parameter. If no message is found that matches the
<paramref name="correlationID"/> parameter, an 
exception is thrown. Otherwise, the message is removed from the queue and
returned to the application using a transaction context defined by the
<paramref name="transactionType"/>
parameter.</para>
			<para>Specify <see langword="Automatic"/> for the <paramref name="transactionType"/> parameter
if there is already an external transaction context attached to the thread that
you want to use to receive the message. Specify <see langword="Single"/> if you
want to receive the message as a single internal transaction. You can specify
<see langword="None"/> if you want to receive a message from a transactional queue outside of a transaction 
context.</para>
			<para>If this method is called to receive a message from a
   transactional queue, the message that is received would be returned to the queue
   if the transaction is aborted. The message is not permanently removed from the
   queue until the transaction is committed.
   </para>
			<para>The <see cref="System.Messaging.Message.CorrelationId"/> property is used to tie a message sent
to the queue to associated response, report, or acknowledgment messages. </para>
			<para>Two other methods allow you to receive messages from a
   queue. The <see cref="System.Messaging.MessageQueue.Receive"/> method returns the first message in the queue,
   and the <see cref="System.Messaging.MessageQueue.ReceiveById"/> method is used to retrieve a
   message by specifying its unique identifier.</para>
			<para>To read a message with a specified correlation identifier without removing it
   from the queue, use the <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> method. The
<see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue. There is no transaction
   context associated with a message returned by a call to <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/>. Because <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> does not remove any messages in
   the queue, there would be nothing to roll back if the transaction were
   aborted.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueueTransactionType"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.ReceiveByCorrelationId2">
		<summary>
			<para>Receives the message that matches the given correlation identifier, from a nontransactional queue, and waits
      until either a message with the specified correlation identifier is available in
      the queue, or the time-out expires.</para>
		</summary>
		<param name="correlationId">The <see cref="System.Messaging.Message.CorrelationId"/> of the message to receive.</param>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the time to wait until a new message is available for inspection .</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose <see cref="System.Messaging.Message.CorrelationId"/> matches the
<paramref name="correlationId"/> parameter passed in.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>The <paramref name="correlationId "/>parameter is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout"/> parameter is invalid, possibly <paramref name="timeout"/> is less than <see cref="System.TimeSpan.Zero" qualify="true"/> or greater than <see cref="System.TimeSpan.MaxValue" qualify="true"/>. </exception>
		<exception cref="System.Messaging.MessageQueueException"><para>The message with the specified <paramref name="correlationId"/> does not exist in the queue and did not arrive before the time-out expired.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>This method looks in the nontransactional queue referenced by the <see cref="System.Messaging.MessageQueue"/>
for a message whose <see cref="System.Messaging.Message.CorrelationId"/> matches the specified
<paramref name="correlationId"/> parameter. This
method returns immediately if the message with the correlation identifier
specified by the <paramref name="correlationId "/>parameter is in the queue. Otherwise, the
method waits the given period of time for the message to arrive. If the message does
not arrive before the time-out expires, an exception is thrown.</para>
			<para>The <see cref="System.Messaging.Message.CorrelationId"/> property is used to tie a message sent
to the queue to associated response, report, or acknowledgment messages. </para>
			<para>Two other methods allow you to receive messages from a queue.
   The <see cref="System.Messaging.MessageQueue.Receive"/> method returns the first message
   in the queue, and the <see cref="System.Messaging.MessageQueue.ReceiveById"/> method is used to retrieve a
   message by specifying its unique identifier.</para>
			<para>To read a message with a specified correlation identifier without removing it
   from the queue, use the <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> method. The
<see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.InfiniteTimeout"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.ReceiveByCorrelationId3">
		<summary>
			<para> Receives the message
      that matches the given correlation identifier, from
      a transactional queue, and waits until either a message with
      the specified correlation identifier is available in
      the queue, or the time-out expires.</para>
		</summary>
		<param name="correlationId">The <see cref="System.Messaging.Message.CorrelationId"/> of the message to receive.</param>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the time to wait until a new message is available for inspection .</param>
		<param name="transaction">The <see cref="System.Messaging.MessageQueueTransaction"/> object.</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose <see cref="System.Messaging.Message.CorrelationId"/> matches the
<paramref name="correlationId"/> parameter passed in.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>The <paramref name="correlationId "/>parameter is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>The <paramref name="transaction "/>parameter is <see langword="null"/>.</para></exception>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout"/> parameter is invalid, possibly <paramref name="timeout"/> is less than <see cref="System.TimeSpan.Zero" qualify="true"/> or greater than <see cref="System.TimeSpan.MaxValue" qualify="true"/>. </exception>
		<exception cref="System.Messaging.MessageQueueException"><para>The message with the specified <paramref name="correlationId"/> does not exist in the queue and did not arrive before the time-out expired.</para>
			<para>-or-</para>
			<para>The queue is non-transactional.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>This method looks in the transactional queue referenced by the <see cref="System.Messaging.MessageQueue"/>
for a message whose <see cref="System.Messaging.Message.CorrelationId"/> matches the specified
<paramref name="correlationId"/> parameter. This method
returns immediately if the message with the correlation identifier specified by
the <paramref name="correlationId "/>parameter is in the queue,
using the internal transaction context defined by the <paramref name="transaction"/> parameter. Otherwise, the method waits
the given period of time for the message to arrive. If the message does
not arrive before the time-out expires, an exception is thrown.</para>
			<para>Because this method is called on a transactional queue,
   the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from
   the queue until the transaction is committed.</para>
			<para>The <see cref="System.Messaging.Message.CorrelationId"/> property is used to tie a message sent
to the queue to associated response, report, or acknowledgment messages. </para>
			<para>Two other methods allow you to receive messages from a queue. The <see cref="System.Messaging.MessageQueue.Receive"/> method returns the first message
in the queue, and the <see cref="System.Messaging.MessageQueue.ReceiveById"/> method is used to retrieve a
message by specifying its unique identifier.</para>
			<para>To read a message with a specified correlation identifier without removing it
   from the queue, use the <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> method. The
<see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue. There is no transaction
   context associated with a message returned by a call to <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/>. Because <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> does not remove any messages in
   the queue, there would be nothing to roll back if the transaction were
   aborted.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueueTransaction"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.InfiniteTimeout"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.ReceiveByCorrelationId4">
		<summary>
			<para> Receives the message that matches the given correlation identifier, and
      waits until either a message with the specified correlation identifier is available in
      the queue, or the time-out expires.</para>
		</summary>
		<param name="correlationId">The <see cref="System.Messaging.Message.CorrelationId"/> of the message to receive.</param>
		<param name="timeout">A <see cref="System.TimeSpan"/> that indicates the time to wait until a new message is available for inspection .</param>
		<param name="transactionType">One of the <see cref="System.Messaging.MessageQueueTransactionType"/> values, describing the type of transaction context to associate with the message.</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose <see cref="System.Messaging.Message.CorrelationId"/> matches the
<paramref name="correlationId"/> parameter passed in.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>The <paramref name="correlationId "/>parameter is <see langword="null"/>.</para></exception>
		<exception cref="System.InvalidOperationException">The message with the specified <paramref name="correlationId "/>could not be found.</exception>
		<exception cref="System.ArgumentException">The value specified for the <paramref name="timeout"/> parameter is invalid, possibly <paramref name="timeout"/> is less than <see cref="System.TimeSpan.Zero" qualify="true"/> or greater than <see cref="System.TimeSpan.MaxValue" qualify="true"/>. </exception>
		<exception cref="System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType"/> parameter is not one of the <see cref="System.Messaging.MessageQueueTransactionType"/> members.</exception>
		<exception cref="System.Messaging.MessageQueueException"><para>The message with the specified <paramref name="correlationId"/> does not exist in the queue and did not arrive before the time-out expired.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para> This method looks in the queue referenced by the <see cref="System.Messaging.MessageQueue"/>
for a message whose <see cref="System.Messaging.Message.CorrelationId"/> matches the specified
<paramref name="correlationId"/> parameter. This method 
returns immediately if the message with the correlation identifier specified by
the <paramref name="correlationId "/>parameter is in the queue, using a transaction context
defined by the <paramref name="transactionType"/> parameter. Otherwise, the method waits the
given period of time for the message to arrive. If the message does not arrive
before the time-out expires, an exception is
thrown.</para>
			<para>Specify <see langword="Automatic"/> for the <paramref name="transactionType"/> parameter
if there is already an external transaction context attached to the thread that
you want to use to receive the message. Specify <see langword="Single"/> if you
want to receive the message as a single internal transaction. You can specify
<see langword="None"/> if you want to receive a message from a transactional queue outside of a transaction 
context.</para>
			<para>If this method is called to receive a message from a
   transactional queue, the message that is received would be returned to the queue
   if the transaction is aborted. The message is not permanently removed from the
   queue until the transaction is committed.</para>
			<para>The <see cref="System.Messaging.Message.CorrelationId"/> property is used to tie a message sent
to the queue to associated response, report, or acknowledgment messages. </para>
			<para>Two other methods allow you to receive messages from a
   queue. The <see cref="System.Messaging.MessageQueue.Receive"/> method returns the first message in the queue,
   and the <see cref="System.Messaging.MessageQueue.ReceiveById"/> method is used to retrieve a
   message by specifying its unique identifier.</para>
			<para>To read a message with a specified correlation identifier without removing it
   from the queue, use the <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> method. The
<see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue. There is no transaction
   context associated with a message returned by a call to <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/>. Because <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> does not remove any messages in
   the queue, there would be nothing to roll back if the transaction were
   aborted.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueueTransactionType"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.Refresh">
		<summary>
			<para>Refreshes the properties presented by the <see cref="System.Messaging.MessageQueue"/>
to reflect the current state of the
resource.</para>
		</summary>
		<remarks>
			<para><see cref="System.Messaging.MessageQueue.Refresh"/> synchronizes the properties of a
<see cref="System.Messaging.MessageQueue"/> with its associated Message Queuing
   server resource. If any property, such as <see cref="System.Messaging.MessageQueue.Label"/> or <see cref="System.Messaging.MessageQueue.Category"/> , has changed on the server since
   the time the <see cref="System.Messaging.MessageQueue"/> was created, <see cref="System.Messaging.MessageQueue.Refresh"/>
   updates the <see cref="System.Messaging.MessageQueue"/>
   with the new information.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueues"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByCategory"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByLabel"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByMachine"/>
	</doc>
	<doc for="MessageQueue.Send">
		<overload>
			<para>Sends an object to a queue.</para>
		</overload>
		<summary>
			<para> Sends an object to nontransactional queue referenced by this <see cref="System.Messaging.MessageQueue"/>
.</para>
		</summary>
		<param name="obj">The object to send to the queue.</param>
		<exception cref="System.Messaging.MessageQueueException"><para>The <see cref="System.Messaging.MessageQueue.Path"/> property has not been set.</para>
			<para>-or-</para><para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>Use this overload to send a message containing the
   <paramref name="obj"/> parameter to the queue referenced by the <see cref="System.Messaging.MessageQueue"/>
   . The object you send to the queue can be a <see cref="System.Messaging.Message"/> or any
   managed object. If you send any object other than a <see cref="System.Messaging.Message"/>, the object is serialized
   and inserted into the body of the message.</para>
			<para>If you use this overload to send a message to a
   transactional queue, the message will be sent to the dead-letter queue. If you
   want the message to be part of a transaction that contains other messages, use
   an overload that takes a <see cref="System.Messaging.MessageQueueTransaction"/> or <see cref="System.Messaging.MessageQueueTransactionType"/> as a
   parameter.</para>
			<para> If you do not set the <see cref="System.Messaging.MessageQueue.Formatter"/> property before calling
<see cref="System.Messaging.MessageQueue.Send"/>, the formatter defaults to the <see cref="System.Messaging.XmlMessageFormatter"/>.</para>
			<para> The <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>
property applies to any object other
than a <see cref="System.Messaging.Message"/> . If you specify, for example, a label
or a priority using the <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>
member, these values apply to any message that contains an object that is not of
type <see cref="System.Messaging.Message"/>
when your application sends it to the
queue. When sending a <see cref="System.Messaging.Message"/>
, the property values set for the <see cref="System.Messaging.Message"/> take precedence over <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>, and the message's <see cref="System.Messaging.Message.Formatter" qualify="true"/> property takes precedence over
the queue's <see cref="System.Messaging.MessageQueue.Formatter" qualify="true"/> property. </para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example connects to a message queue and
      sends a message to the queue.</para>
			<codelink SampleID="MessageQueue.Send_obj" SnippetID="1"/>
			<para>The following example sends an application-defined Order class to a queue and 
then receives a message from that queue.</para>
		</example>
		<seealso cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>
		<seealso cref="System.Messaging.Message"/>
		<seealso cref="System.Messaging.MessageQueue.Path"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.Send1">
		<summary>
			<para>Sends an object to the transactional queue referenced by this <see cref="System.Messaging.MessageQueue"/>
.</para>
		</summary>
		<param name="obj">The object to send to the queue.</param>
		<param name="transaction">The <see cref="System.Messaging.MessageQueueTransaction"/> object.</param>
		<exception cref="System.ArgumentNullException"><para>The <paramref name="transaction"/> parameter is <see langword="null"/>.</para></exception>
		<exception cref="System.Messaging.MessageQueueException"><para>The <see cref="System.Messaging.MessageQueue.Path"/> property has not been set.</para>
			<para>-or-</para><para>The Message Queuing application indicated an incorrect transaction usage.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>Use this overload to send a message containing the <paramref name="obj"/> parameter to the
   transactional queue referenced by the <see cref="System.Messaging.MessageQueue"/>, using an internal
   transaction context defined by the <paramref name="transaction"/> parameter. The object you send to the queue can be a <see cref="System.Messaging.Message"/> or any managed
   object. If you send any object other than a <see cref="System.Messaging.Message"/>, the
   object is serialized
   and inserted into the body of the message.</para>
			<para>If you use this overload to send a message to a nontransactional queue, the
   message might be sent to the dead-letter queue without throwing an
   exception.</para>
			<para> If you do not set the
<see cref="System.Messaging.MessageQueue.Formatter"/> property before calling <see cref="System.Messaging.MessageQueue.Send"/>, the formatter defaults to the
<see cref="System.Messaging.XmlMessageFormatter"/>.</para>
			<para>The <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/> property
applies to any object other than a <see cref="System.Messaging.Message"/> . If you specify, for example, a label
or a priority using the <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/> member, these
values apply to any message that contains an object that is not of type <see cref="System.Messaging.Message"/> when
your application sends it to the queue. When sending a <see cref="System.Messaging.Message"/>
, the property values set for the <see cref="System.Messaging.Message"/> take precedence over
<see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>, and the message's <see cref="System.Messaging.Message.Formatter" qualify="true"/> property takes precedence over the
queue's <see cref="System.Messaging.MessageQueue.Formatter" qualify="true"/> property.</para>
			<note lang="VB" type="note">
				<see cref="System.Messaging.MessageQueueTransaction"/> is threading apartment aware,
   so if your apartment state is <see langword="STA"/>, you cannot use the
   transaction in multiple threads. Visual Basic sets the state of the main thread
   to <see langword="STA"/>, so you must apply the <see cref="System.MTAThreadAttribute"/> in
   the <c>Main</c> subroutine.
Otherwise, sending a transactional message using another thread throws a <see cref="System.Messaging.MessageQueueException"/> exception. You apply the <see cref="System.MTAThreadAttribute"/> by
using the following fragment.
</note>
			<code lang="VB">&lt;System.MTAThreadAttribute&gt;
public sub Main()
</code>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example sends a string to a transactional queue and then
      receives a message from that queue.</para>
			<codelink SampleID="MessageQueue.Send_ObjectTransaction" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>
		<seealso cref="System.Messaging.Message"/>
		<seealso cref="System.Messaging.MessageQueueTransaction"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.Send5">
		<summary>
			<para> Sends an object to the queue referenced by this <see cref="System.Messaging.MessageQueue"/>
.</para>
		</summary>
		<param name="obj">The object to send to the queue.</param>
		<param name="transactionType">One of the <see cref="System.Messaging.MessageQueueTransactionType"/> values, describing the type of transaction context to associate with the message.</param>
		<exception cref="System.Messaging.MessageQueueTransaction">The Message Queuing application indicated an incorrect transaction usage.</exception>
		<exception cref="System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType"/> parameter is not one of the <see cref="System.Messaging.MessageQueueTransactionType"/> members.</exception>
		<exception cref="System.Messaging.MessageQueueException"><para>The <see cref="System.Messaging.MessageQueue.Path"/> property has not been set.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>Use this overload to send a message containing the <paramref name="obj"/> parameter to
   the queue referenced by the <see cref="System.Messaging.MessageQueue"/>, using a
   transaction context defined by the <paramref name="transactionType"/> parameter. Specify
<see langword="Automatic"/> for the <paramref name="transactionType"/> parameter if there 
   is already an external transaction context attached to the thread that you want
   to use to send the message. Specify <see langword="Single"/> if you want
   to send the message as a single internal transaction. You can
   specify <see langword="None"/> if you want to send a transactional message to a nontransactional thread. </para>
			<para> The object you send to the queue can be a <see cref="System.Messaging.Message"/>
or any managed object. If you send any object other than a <see cref="System.Messaging.Message"/>, the
object is serialized
and inserted into the body of the message.</para>
			<para> If you do not set the
<see cref="System.Messaging.MessageQueue.Formatter"/> property before calling <see cref="System.Messaging.MessageQueue.Send"/>, the formatter defaults to the
<see cref="System.Messaging.XmlMessageFormatter"/>.</para>
			<para>The <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/> property
applies to any object other than a <see cref="System.Messaging.Message"/> . If you specify, for example, a label
or a priority using the <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/> member, these
values apply to any message that contains an object that is not of type <see cref="System.Messaging.Message"/> when
your application sends it to the queue. When sending a <see cref="System.Messaging.Message"/>
, the property values set for the <see cref="System.Messaging.Message"/> take precedence over
<see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>, and the message's <see cref="System.Messaging.Message.Formatter" qualify="true"/> property takes precedence over the
queue's <see cref="System.Messaging.MessageQueue.Formatter" qualify="true"/> property.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueueTransactionType"/>
		<seealso cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>
		<seealso cref="System.Messaging.Message"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.Send2">
		<summary>
			<para> Sends an object to the nontransactional queue referenced by this <see cref="System.Messaging.MessageQueue"/>
and specifies
a label for the message.</para>
		</summary>
		<param name="obj">The object to send to the queue.</param>
		<param name="label">The label of the message.</param>
		<exception cref="System.ArgumentNullException"><para>The <paramref name="label"/> parameter is <see langword="null"/>.</para></exception>
		<exception cref="System.Messaging.MessageQueueException"><para>The <see cref="System.Messaging.MessageQueue.Path"/> property has not been set.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>Use this overload to send a message containing the <paramref name="obj"/> parameter to the queue referenced by the <see cref="System.Messaging.MessageQueue"/> . With
   this overload, you can specify the string label that identifies the message. The object
   you send to the queue can be a <see cref="System.Messaging.Message"/>, a structure, a data object, or any managed
   object. If you send any object other than a <see cref="System.Messaging.Message"/>, the object is serialized and
   inserted into the body of the message.</para>
			<note type="note">
   The message label is distinct
   from the message queue label, but both are application-dependent and have no
   inherit meaning to Message Queuing.
   
</note>
			<para> If you use this overload to send a message to a
   transactional queue, the message will be sent to the dead-letter queue. If you
   want the message to be part of a transaction that contains other messages, use
   an overload that takes a <see cref="System.Messaging.MessageQueueTransaction"/> or <see cref="System.Messaging.MessageQueueTransactionType"/> as a
   parameter.</para>
			<para>The <see cref="System.Messaging.MessageQueue.Path"/> property for this <see cref="System.Messaging.MessageQueue"/>
instance must be specified before you send the message. If you do not set the
<see cref="System.Messaging.MessageQueue.Formatter"/> property before calling <see cref="System.Messaging.MessageQueue.Send"/>, the formatter defaults to the
<see cref="System.Messaging.XmlMessageFormatter"/>.</para>
			<para>The <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/> property applies to any object
other than a <see cref="System.Messaging.Message"/> . If you specify, for example, a label
or a priority using the <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/> member, these
values apply to any message that contains an object that is not of type <see cref="System.Messaging.Message"/> when
your application sends it to the queue. When sending a <see cref="System.Messaging.Message"/>
, the property values set for the <see cref="System.Messaging.Message"/> take precedence over
<see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>, and the message's <see cref="System.Messaging.Message.Formatter" qualify="true"/> property takes precedence over the
queue's <see cref="System.Messaging.MessageQueue.Formatter" qualify="true"/> property.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>
		<seealso cref="System.Messaging.Message"/>
		<seealso cref="System.Messaging.MessageQueue.Label"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.Send3">
		<summary>
			<para>Sends an object to the transactional queue referenced by this <see cref="System.Messaging.MessageQueue"/>
and
specifies a label for the message.</para>
		</summary>
		<param name="obj">The object to send to the queue.</param>
		<param name="label">The label of the message.</param>
		<param name="transaction">The <see cref="System.Messaging.MessageQueueTransaction"/> object.</param>
		<exception cref="System.ArgumentNullException"><para>The <paramref name="label"/> parameter is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>The <paramref name="transaction"/> parameter is <see langword="null"/>.</para></exception>
		<exception cref="System.Messaging.MessageQueueException"><para>The <see cref="System.Messaging.MessageQueue.Path"/> property has not been set.</para>
			<para>-or-</para>
			<para>The Message Queuing application indicated an incorrect transaction usage.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>Use this overload to send a message containing the <paramref name="obj"/> parameter to
   the transactional queue referenced by the <see cref="System.Messaging.MessageQueue"/> , using an
   internal transaction context defined by the <paramref name="transaction"/> parameter. With this overload, you can specify
   the string label that identifies the message. The object you send to the queue
   can be a <see cref="System.Messaging.Message"/>, a structure, a
   data object, or any managed object. If you send any object other than a <see cref="System.Messaging.Message"/>, the
   object is serialized and inserted into the body of the
   message.</para>
			<note type="note">
   The message label is distinct from
   the message queue label, but both are application-dependent and have no inherit
   meaning to Message Queuing.
   
</note>
			<para>If you use this overload to send a message to a nontransactional queue, the message might
   be sent to the dead-letter queue without throwing an
   exception.</para>
			<para> If you do not set the
<see cref="System.Messaging.MessageQueue.Formatter"/> property before calling <see cref="System.Messaging.MessageQueue.Send"/>, the formatter defaults to the
<see cref="System.Messaging.XmlMessageFormatter"/>.</para>
			<para>The <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/> property applies to any object
other than a <see cref="System.Messaging.Message"/> . If you specify, for example, a label
or a priority using the <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/> member, these
values apply to any message that contains an object that is not of type <see cref="System.Messaging.Message"/> when
your application sends it to the queue. When sending a <see cref="System.Messaging.Message"/>
, the property values set for the <see cref="System.Messaging.Message"/> take precedence over
<see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>, and the message's <see cref="System.Messaging.Message.Formatter" qualify="true"/> property takes precedence over the
queue's <see cref="System.Messaging.MessageQueue.Formatter" qualify="true"/> property</para>
			<note lang="VB" type="note">
				<see cref="System.Messaging.MessageQueueTransaction"/> is threading apartment aware,
   so if your apartment state is <see langword="STA"/>, you cannot use the
   transaction in multiple threads. Visual Basic sets the state of the main thread
   to <see langword="STA"/>, so you must apply the <see cref="System.MTAThreadAttribute"/> in
   the <c>Main</c> subroutine.
Otherwise, sending a transactional message using another thread throws a <see cref="System.Messaging.MessageQueueException"/> exception. You apply the <see cref="System.MTAThreadAttribute"/> by
using the following fragment.
</note>
			<code lang="VB">&lt;System.MTAThreadAttribute&gt;
public sub Main()
</code>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>
		<seealso cref="System.Messaging.Message"/>
		<seealso cref="System.Messaging.MessageQueueTransaction"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.Label"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.ResetPermissions">
		<summary>
			<para>Resets the permission list to the operating system's default
      values. Removes any queue permissions you have appended to the default list.</para>
		</summary>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>When you call <see cref="System.Messaging.MessageQueue.ResetPermissions"/> , you return the permission list to its default
   values. Generally, this grants the queue creator all permissions, and gives the
   group Everyone the following rights:</para>
			<list type="bullet"><item>
					<term>
      Get the properties of the queue.</term>
				</item>
				<item>
					<term>
      Get queue permissions.</term>
				</item>
				<item>
					<term>
      Write to the queue.</term>
				</item>
			</list>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.SetPermissions"/>
	</doc>
	<doc for="MessageQueue.SetPermissions">
		<overload>
			<para>Adds permissions to the current set. This controls who has access rights to
      queue properties and messages in the queue.</para>
		</overload>
		<summary>
			<para>Gives a computer, group, or user the specified access
      rights.</para>
		</summary>
		<param name="user">The individual, group, or computer that gets additional rights to the queue.</param>
		<param name=" rights">A <see cref="System.Messaging.MessageQueueAccessRights"/> that indicates the set of rights to the queue that Message Queuing assigns to the <paramref name="user"/> passed in.</param>
		<exception cref="System.ArgumentException">The <paramref name="user "/>is <see langword="null"/>.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para> Use this overload to grant specified rights to an
      individual user. The user can be any valid trustee, which includes individual
      users, groups of users, or a computer. If the user is an individual, use the
      format <see langword="DOMAIN"/>\<paramref name="user"/> for the
   <paramref name="user"/> parameter. You can specify "." for the <paramref name="user"/> 
   parameter to indicate the local computer. </para>
			<para>The permissions you assign through <see cref="System.Messaging.MessageQueue.SetPermissions"/> add rights to the existing list. By
default, the creator of a public or private queue has full control, and the
domain group Everyone has permission to get queue properties, get permissions,
and write to the queue. When you call <see cref="System.Messaging.MessageQueue.SetPermissions"/>, the user and permissions information
is appended to the bottom of the existing list.</para>
			<para>The system examines each <see cref="System.Messaging.AccessControlEntry"/> in sequence until one of the following events
occurs:</para>
			<list type="bullet"><item>
					<term>
      
      An access-denied <see cref="System.Messaging.AccessControlEntry"/> explicitly
      denies any of the requested access rights to one of the trustees listed in the
      thread's access token.</term>
				</item>
				<item>
					<term>
      
      One or more access-allowed <see cref="System.Messaging.AccessControlEntry"/> items for
      trustees listed in the thread's access token explicitly grant all the
      requested access rights.</term>
				</item>
				<item>
					<term>
      
      All <see cref="System.Messaging.AccessControlEntry"/> items have been checked and there is still
      at least one requested access right that has not been explicitly allowed, in
      which case, access is implicitly denied.</term>
				</item>
			</list>
			<para>The rights to a queue, specified in the <paramref name="rights"/> parameter, can be any combination of the following:</para>
			<list type="bullet"><item>
					<term>
      
      Full Control</term>
				</item>
				<item>
					<term>
      
      Delete Message</term>
				</item>
				<item>
					<term>
      
      Receive Message</term>
				</item>
				<item>
					<term>
      
      Peek Message</term>
				</item>
				<item>
					<term>
      
      Receive Journal Message</term>
				</item>
				<item>
					<term>
      
      Get Queue Properties</term>
				</item>
				<item>
					<term>
      
      Set Queue Properties</term>
				</item>
				<item>
					<term>
      
      Get Permissions</term>
				</item>
				<item>
					<term>
      
      Set Permissions</term>
				</item>
				<item>
					<term>
      
      Take Queue Ownership</term>
				</item>
				<item>
					<term>
      
      Write Message</term>
				</item>
			</list>
			<para>The <see cref="System.Messaging.MessageQueueAccessRights"/> enumeration
represents a set of bit flags
that you can combine using the bitwise operator OR to build the <paramref name="rights"/>
parameter.</para>
			<para>With this overload, you can only grant permissions; you cannot revoke or deny
   them. You must use a different overload to explicitly grant any <see cref="System.Messaging.AccessControlEntryType"/> other than <see langword="Allow"/>. </para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.ResetPermissions"/>
		<seealso cref="System.Messaging.Trustee"/>
		<seealso cref="System.Messaging.MessageQueueAccessRights"/>
	</doc>
	<doc for="MessageQueue.SetPermissions2">
		<summary>
			<para>Assigns access rights to the queue based on the
      contents of an access control entry.</para>
		</summary>
		<param name="ace">A <see cref="System.Messaging.MessageQueueAccessControlEntry"/> that specifies a user, an access type, and a permission type.</param>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>Use this overload to grant, deny, or revoke rights by using an access control
      entry to specify trustee and rights information. </para>
			<para>The trustee you specify when you construct
      the <paramref name="ace"/> parameter can be an individual user, a group of
      users, or a computer. If the trustee is an individual, use the format <see langword="DOMAIN"/>\<paramref name="user"/>.
      You can specify "." for the trustee to indicate the local computer. </para>
			<para>The permissions you assign through <see cref="System.Messaging.MessageQueue.SetPermissions"/> add rights to
   the existing list. By default, the creator of a public or private queue has full
   control, and the domain group Everyone has permission to get queue properties,
   get permissions, and write to the queue. When you call <see cref="System.Messaging.MessageQueue.SetPermissions"/> , the user and permissions information is appended
   to the bottom of the existing list.</para>
			<para>The system examines each <see cref="System.Messaging.AccessControlEntry"/> in sequence until one of the following events
occurs:</para>
			<list type="bullet"><item>
					<term>
      
      An access-denied <see cref="System.Messaging.AccessControlEntry"/> explicitly
      denies any of the requested access rights to one of the trustees listed in the
      thread's access token.</term>
				</item>
				<item>
					<term>
      
      One or more access-allowed <see cref="System.Messaging.AccessControlEntry"/> items for
      trustees listed in the thread's access token explicitly grant all the
      requested access rights.</term>
				</item>
				<item>
					<term>
      
      All <see cref="System.Messaging.AccessControlEntry"/> items have been checked and there is still
      at least one requested access right that has not been explicitly allowed, in
      which case, access is implicitly denied.</term>
				</item>
			</list>
			<para>The rights to a queue, which you specify in the <paramref name="rights"/> parameter when you construct your <see cref="System.Messaging.MessageQueueAccessControlEntry"/> , can be any
combination of the following:</para>
			<list type="bullet"><item>
					<term>
      
      Full Control</term>
				</item>
				<item>
					<term>
      
      Delete Message</term>
				</item>
				<item>
					<term>
      
      Receive Message</term>
				</item>
				<item>
					<term>
      
      Peek Message</term>
				</item>
				<item>
					<term>
      
      Receive Journal Message</term>
				</item>
				<item>
					<term>
      
      Get Queue Properties</term>
				</item>
				<item>
					<term>
      
      Set Queue Properties</term>
				</item>
				<item>
					<term>
      
      Get Permissions</term>
				</item>
				<item>
					<term>
      
      Set Permissions</term>
				</item>
				<item>
					<term>
      
      Take Queue Ownership</term>
				</item>
				<item>
					<term>
      
      Write Message</term>
				</item>
			</list>
			<para>The <paramref name="rights"/> parameter you specify in the
constructor for the <paramref name="ace"/> parameter is a flag of the <see cref="System.Messaging.MessageQueueAccessRights"/> enumeration. It represents a set of bit flags that
you can combine using the bitwise operator OR when you build the <paramref name="rights"/> parameter.</para>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.ResetPermissions"/>
		<seealso cref="System.Messaging.Trustee"/>
		<seealso cref="System.Messaging.MessageQueueAccessRights"/>
		<seealso cref="System.Messaging.MessageQueueAccessControlEntry"/>
	</doc>
	<doc for="MessageQueue.SetPermissions3">
		<summary>
			<para>Assigns access rights to the queue based on the contents
      of an access control list.</para>
		</summary>
		<param name="dacl">An <see cref="System.Messaging.AccessControlList"/> that contains one or more access control entries that specify the trustees and the permissions to grant.</param>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>Use this overload to grant, deny, or revoke rights by
      using a collection of access control entries to specify trustee and permissions
      information. This is used, for example, to grant permissions to multiple users
      at the same time.</para>
			<para>The trustee you specify when you construct the
   <paramref name="ace"/> parameter can be an individual user, a group of users, or a computer.
      If the trustee is an individual, use the format <see langword="DOMAIN"/>\<paramref name="user"/> .
      You can specify "." for the trustee to indicate the local computer.</para>
			<para>The permissions you assign through <see cref="System.Messaging.MessageQueue.SetPermissions"/> add rights to the existing list.
   By default, the creator of a public or private queue has full control, and the
   domain group Everyone has permission to get queue properties, get permissions,
   and write to the queue. When you call <see cref="System.Messaging.MessageQueue.SetPermissions"/>
   , the user and permissions information is appended to the
   bottom of the existing list.</para>
			<para>The system examines each <see cref="System.Messaging.AccessControlEntry"/> in sequence until one of the following events
occurs:</para>
			<list type="bullet"><item>
					<term>
      
      An access-denied <see cref="System.Messaging.AccessControlEntry"/> explicitly
      denies any of the requested access rights to one of the trustees listed in the
      thread's access token.</term>
				</item>
				<item>
					<term>
      
      One or more access-allowed <see cref="System.Messaging.AccessControlEntry"/> items for
      trustees listed in the thread's access token explicitly grant all the
      requested access rights.</term>
				</item>
				<item>
					<term>
      
      All <see cref="System.Messaging.AccessControlEntry"/> items have been checked and there is still
      at least one requested access right that has not been explicitly allowed, in
      which case, access is implicitly denied.</term>
				</item>
			</list>
			<para>When you construct the <paramref name="dacl"/> parameter, you add
<see cref="System.Messaging.AccessControlEntry"/> instances to your <see cref="System.Messaging.AccessControlList"/> collection. When you construct each access
control entry, you can specify generic or standard access rights.
The rights to a queue can be any combination of the following:</para>
			<list type="bullet"><item>
					<term>
      
      Delete</term>
				</item>
				<item>
					<term>
      
      Read Security</term>
				</item>
				<item>
					<term>
      
      Write Security</term>
				</item>
				<item>
					<term>
      
      Synchronize</term>
				</item>
				<item>
					<term>
      
      Modify Owner</term>
				</item>
				<item>
					<term>
      
      Read</term>
				</item>
				<item>
					<term>
      
      Write</term>
				</item>
				<item>
					<term>
      
      Execute</term>
				</item>
				<item>
					<term>
      
      Required</term>
				</item>
				<item>
					<term>
      
      All</term>
				</item>
				<item>
					<term>
      
      None</term>
				</item>
			</list>
			<para>These rights are a set of bit flags that you can
   combine using the OR bitwise operator.</para>
			<list type="bullet"><item>
					<term>
      
      Full Control</term>
				</item>
				<item>
					<term>
      
      Delete Message</term>
				</item>
				<item>
					<term>
      
      Receive Message</term>
				</item>
				<item>
					<term>
      
      Peek Message</term>
				</item>
				<item>
					<term>
      
      Receive Journal Message</term>
				</item>
				<item>
					<term>
      
      Get Queue Properties</term>
				</item>
				<item>
					<term>
      
      Set Queue Properties</term>
				</item>
				<item>
					<term>
      
      Get Permissions</term>
				</item>
				<item>
					<term>
      
      Set Permissions</term>
				</item>
				<item>
					<term>
      
      Take Queue Ownership</term>
				</item>
				<item>
					<term>
      
      Write Message</term>
				</item>
			</list>
			<para>The following table shows whether this method is available in various 
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format 
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format 
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.ResetPermissions"/>
		<seealso cref="System.Messaging.Trustee"/>
		<seealso cref="System.Messaging.AccessControlList"/>
	</doc>
	<doc for="MessageQueue.MessageQueue">
		<overload>
			<para>Initializes a new instance of the <see cref="System.Messaging.MessageQueue"/> class.</para>
		</overload>
		<summary>
			<para>Initializes a new instance of the <see cref="System.Messaging.MessageQueue"/> class. After the default constructor initializes the new instance, you must set
   the instance's <see cref="System.Messaging.MessageQueue.Path"/> property before you
   can use the instance.</para>
		</summary>
		<remarks>
			<para> Use this overload to create a new instance of the
      <see cref="System.Messaging.MessageQueue"/> class that is not
      immediately tied to a queue on the Message Queuing server.
      Before using this instance, you
      must connect it to an existing Message
      Queuing queue by setting the <see cref="System.Messaging.MessageQueue.Path"/>
      property. Alternatively, you can set the <see cref="System.Messaging.MessageQueue"/>
      reference to the <see cref="System.Messaging.MessageQueue.Create"/> method's return value, thereby
      creating a new Message Queuing queue.</para>
			<note type="note">
      The <see cref="System.Messaging.MessageQueue()"/>
      constructor instantiates a new instance of the <see cref="System.Messaging.MessageQueue"/>
      class; it does not create a new Message Queuing queue.
      
      </note>
			<para>The following table shows initial property values for an instance of <see cref="System.Messaging.MessageQueue"/> .</para>
			<list type="table">
				<listheader>
					<term>Property</term>
					<description>Initial Value</description>
				</listheader>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/></term>
					<description>The values set by the default constructor of the
      <see cref="System.Messaging.DefaultPropertiesToSend"/>
   class.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.Formatter"/></term>
					<description><see cref="System.Messaging.XmlMessageFormatter"/>
						<see langword=" "/></description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.MessageReadPropertyFilter"/></term>
					<description>The values set by the default constructor of the
   <see cref="System.Messaging.MessagePropertyFilter"/>
class. All the filter
values are set to <see langword="true"/>.</description>
				</item>
				<item>
					<term>
						<see cref="System.Messaging.MessageQueue.DenySharedReceive"/></term>
					<description><see langword="false"/></description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.Path"/>
		<seealso cref="System.Messaging.MessageQueue.QueueName"/>
		<seealso cref="System.Messaging.MessageQueue.FormatName"/>
		<seealso cref="System.Messaging.MessageQueue.Label"/>
		<seealso cref="System.Messaging.MessageQueue.Create"/>
	</doc>
	<doc for="MessageQueue.LastModifyTime">
		<summary>
			<para>Gets the last time the properties of a queue were modified.</para>
		</summary>
		<value>
			<para>A <see cref="System.DateTime"/>
that indicates when the queue properties were last modified. </para>
		</value>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>The last modification time includes when the queue was
      created and any <see cref="System.Messaging.MessageQueue"/> property that modifies the Message Queuing
      queue, such as <see cref="System.Messaging.MessageQueue.BasePriority"/> . The value of the <see cref="System.Messaging.MessageQueue.LastModifyTime"/> property represents the system time of the
      local computer.</para>
			<para>You must call <see cref="System.Messaging.MessageQueue.Refresh"/> before getting the <see cref="System.Messaging.MessageQueue.LastModifyTime"/> property; otherwise, the modification time
   associated with this <see cref="System.Messaging.MessageQueue"/> might not be current. </para>
			<para>The following table shows whether this property is available in various
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.CreateTime"/>
		<seealso cref="System.Messaging.MessageQueue.DenySharedReceive"/>
	</doc>
	<doc for="MessageQueue.Receive5">
		<summary>
			<para> Receives the first message available in
      the queue referenced by the <see cref="System.Messaging.MessageQueue"/> . This
      call is synchronous, and blocks the current thread of execution until a message is
      available.</para>
		</summary>
		<param name="transactionType">One of the <see cref="System.Messaging.MessageQueueTransactionType"/> values, describing the type of transaction context to associate with the message.</param>
		<returns>
			<para>A <see cref="System.Messaging.Message"/> that references the first message
   available in the queue.</para>
		</returns>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<exception cref="System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType"/> parameter is not one of the <see cref="System.Messaging.MessageQueueTransactionType"/> members.</exception>
		<remarks>
			<para>Use this overload to receive a message from a queue
      using a transaction context defined by the <paramref name="transactionType"/> parameter, or wait until there
      are messages in the queue.</para>
			<para>Specify <see langword="Automatic"/> for the <paramref name="transactionType"/> parameter
   if there is already an external transaction context attached to the thread that
   you want to use to receive the message. Specify <see langword="Single"/> if you
   want to receive the message as a single internal transaction. You can specify
<see langword="None"/> if you want to receive a message from a transactional queue outside of a 
   transaction context.</para>
			<para>The <see cref="System.Messaging.MessageQueue.Receive"/> method
allows for the synchronous reading of a message, thereby removing it from the queue.
Subsequent calls to <see cref="System.Messaging.MessageQueue.Receive"/> will return the messages
that follow in the queue.</para>
			<para> If this method is called to receive a message from a
   transactional queue, the message that is received would be returned to the queue
   if the transaction is aborted. The message is not permanently removed from the
   queue until the transaction is committed.</para>
			<para>To read the first
   message in a queue without removing it from the queue, use the <see cref="System.Messaging.MessageQueue.Peek"/> method. The <see cref="System.Messaging.MessageQueue.Peek"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue. There is no transaction
   context associated with a message returned by a call to <see cref="System.Messaging.MessageQueue.Peek"/>. Because <see cref="System.Messaging.MessageQueue.Peek"/> does not remove any messages in the queue,
   there would be nothing to roll back by a call to <see cref="System.Messaging.MessageQueueTransaction.Abort"/>
   .</para>
			<para>Use a call to <see cref="System.Messaging.MessageQueue.Receive"/> when it is acceptable for the
current thread to be blocked while it waits for a message to arrive in the
queue. Because this overload of the <see cref="System.Messaging.MessageQueue.Receive"/> method specifies an infinite
time-out, the application might wait indefinitely. If the application processing
should continue without waiting for the message, consider using the asynchronous
method, <see cref="System.Messaging.MessageQueue.BeginReceive"/>.</para>
			<para>The following table shows whether this method is available in various
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueueTransactionType"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.ReceiveByCorrelationId1">
		<summary>
			<para> Receives the message that matches the given correlation identifier, from a transactional
      queue, and immediately raises an exception if no message with the specified correlation
      identifier currently exists in the queue.</para>
		</summary>
		<param name="correlationId">The <see cref="System.Messaging.Message.CorrelationId"/> of the message to receive.</param>
		<param name="transaction">The <see cref="System.Messaging.MessageQueueTransaction"/> object.</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose <see cref="System.Messaging.Message.CorrelationId"/> matches the
<paramref name="correlationId"/> parameter passed in.</para>
		</returns>
		<exception cref="System.ArgumentNullException"><para>The <paramref name="correlationId "/>parameter is <see langword="null"/>.</para>
			<para>-or-</para>
			<para>The <paramref name="transaction "/>parameter is <see langword="null"/>.</para></exception>
		<exception cref="System.InvalidOperationException">The message with the specified <paramref name="correlationId "/>could not be found.</exception>
		<exception cref="System.Messaging.MessageQueueException"><para>The queue is non-transactional.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Messsage Queuing API.</para></exception>
		<remarks>
			<para>This method looks in the transactional queue referenced by the <see cref="System.Messaging.MessageQueue"/>
for a message whose <see cref="System.Messaging.Message.CorrelationId"/> matches the specified
<paramref name="correlationId"/> parameter. If no message is found that matches the
<paramref name="correlationID"/> parameter, 
an exception is thrown. Otherwise, the message is removed from the queue and
returned to the application using the internal transaction context defined
by the <paramref name="transaction"/>
parameter.</para>
			<para>Because this method is called on a transactional queue,
   the message that is received would be returned to the queue if the transaction is aborted. The message is not permanently removed from
   the queue until the transaction is committed.</para>
			<para>The <see cref="System.Messaging.Message.CorrelationId"/> property is used to tie a message sent
to the queue to associated response, report, or acknowledgment messages.</para>
			<para>Two other methods allow you to receive messages from a
   queue. The <see cref="System.Messaging.MessageQueue.Receive"/> method returns the first message in the queue,
   and the <see cref="System.Messaging.MessageQueue.ReceiveById"/> method is used to retrieve a
   message by specifying its unique identifier.</para>
			<para>To read a message with a specified correlation identifier without removing it
   from the queue, use the <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> method. The
<see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue. There is no transaction
   context associated with a message returned by a call to <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/>. Because <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> does not remove any messages in
   the queue, there would be nothing to roll back if the transaction were
   aborted.</para>
			<para>The following table shows whether this method is available in various
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueueTransaction"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.Send4">
		<summary>
			<para> Sends an object to the queue referenced by this <see cref="System.Messaging.MessageQueue"/>
and specifies a
label for the message.</para>
		</summary>
		<param name="obj">The object to send to the queue.</param>
		<param name=" label">The label of the message.</param>
		<param name="transactionType">One of the <see cref="System.Messaging.MessageQueueTransactionType"/> values, describing the type of transaction context to associate with the message.</param>
		<exception cref="System.ArgumentNullException"><para>The <paramref name="label"/> parameter is <see langword="null"/>.</para></exception>
		<exception cref="System.Messaging.MessageQueueTransaction">The Message Queuing application indicated an incorrect transaction usage.</exception>
		<exception cref="System.ComponentModel.InvalidEnumArgumentException">The <paramref name="transactionType"/> parameter is not one of the <see cref="System.Messaging.MessageQueueTransactionType"/> members.</exception>
		<exception cref="System.Messaging.MessageQueueException"><para>The <see cref="System.Messaging.MessageQueue.Path"/> property has not been set.</para>
			<para>-or-</para>
			<para>An error occurred when accessing a Message Queuing API.</para></exception>
		<remarks>
			<para>Use this overload to send a message containing the <paramref name="obj"/> parameter to
   the queue referenced by the <see cref="System.Messaging.MessageQueue"/>, using a
   transaction context defined by the <paramref name="transactionType"/> parameter. Specify
<see langword="Automatic"/> for the <paramref name="transactionType"/> parameter if there 
   is already an external transaction context attached to the thread that you want
   to use to send the message. Specify <see langword="Single"/> if you want
   to send the message as a single internal transaction. You can
   specify <see langword="None"/> if you want to send a transactional message to a nontransactional thread. </para>
			<para>The object you send to the queue can be a <see cref="System.Messaging.Message"/>
or any managed object. If you send any object other than a
<see cref="System.Messaging.Message"/>, the object is serialized and inserted into the
body of the message. With this overload, you can specify the string label that
identifies the message.</para>
			<note type="note">
   The message label is distinct from
   the message queue label, but both are application-dependent and have no inherit
   meaning to Message Queuing.
</note>
			<para> If you do not set the
<see cref="System.Messaging.MessageQueue.Formatter"/> property before calling <see cref="System.Messaging.MessageQueue.Send"/>, the formatter defaults to the
<see cref="System.Messaging.XmlMessageFormatter"/>.</para>
			<para>The <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/> property
applies to any object other than a <see cref="System.Messaging.Message"/> . If you specify, for example, a label
or a priority using the <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/> member, these
values apply to any message that contains an object that is not of type <see cref="System.Messaging.Message"/> when
your application sends it to the queue. When sending a <see cref="System.Messaging.Message"/>
, the property values set for the <see cref="System.Messaging.Message"/> take precedence over
<see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>, and the message's <see cref="System.Messaging.Message.Formatter" qualify="true"/> property takes precedence over the
queue's <see cref="System.Messaging.MessageQueue.Formatter" qualify="true"/> property.</para>
			<para>The following table shows whether this method is available in various
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueueTransactionType"/>
		<seealso cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>
		<seealso cref="System.Messaging.Message"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.Label"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.SetPermissions1">
		<summary>
			<para>Gives a computer, group, or user the specified access
      rights, with the specified access control type (allow, deny, revoke, or set).</para>
		</summary>
		<param name="user">The individual, group, or computer that gets additional rights to the queue.</param>
		<param name=" rights">A <see cref="System.Messaging.MessageQueueAccessRights"/> that indicates the set of rights to the queue that Message Queuing assigns to the <paramref name="user"/> passed in.</param>
		<param name=" entryType">An <see cref="System.Messaging.AccessControlEntryType"/> that specifies whether to grant, deny, or revoke the permissions specified by the <paramref name="rights"/> parameter. </param>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>Use this overload to grant, deny, or revoke specified
      rights for an individual user. The user can be any valid trustee, which includes
      individual users, groups of users, or a computer. If the user is an individual,
      use the format <see langword="DOMAIN"/>\<paramref name="user"/> for the <paramref name="user"/> parameter. You can specify "." for the <paramref name="user"/>
      parameter to indicate the local computer. </para>
			<para>The permissions you assign through <see cref="System.Messaging.MessageQueue.SetPermissions"/> add
   rights to the existing list. By default, the creator of a public or private
   queue has full control, and the domain group Everyone has permission to get
   queue properties, get permissions, and write to the queue. When you call <see cref="System.Messaging.MessageQueue.SetPermissions"/>, the user and permissions information
   is appended to the bottom of the existing list.</para>
			<para>The system examines each <see cref="System.Messaging.AccessControlEntry"/> in sequence until one of the following events
occurs:</para>
			<list type="bullet"><item>
					<term>
      An access-denied <see cref="System.Messaging.AccessControlEntry"/> explicitly
      denies any of the requested access rights to one of the trustees listed in the
      thread's access token.</term>
				</item>
				<item>
					<term>
      One or more access-allowed <see cref="System.Messaging.AccessControlEntry"/> items for
      trustees listed in the thread's access token explicitly grant all the
      requested access rights.</term>
				</item>
				<item>
					<term>
      All <see cref="System.Messaging.AccessControlEntry"/> items have been checked and there is still
      at least one requested access right that has not been explicitly allowed, in
      which case, access is implicitly denied.</term>
				</item>
			</list>
			<para>The rights to a queue, specified in the <paramref name="rights"/>
parameter, can be any combination of the following:</para>
			<list type="bullet"><item>
					<term>
      Full Control</term>
				</item>
				<item>
					<term>
      Delete Message</term>
				</item>
				<item>
					<term>
      Receive Message</term>
				</item>
				<item>
					<term>
      Peek Message</term>
				</item>
				<item>
					<term>
      Receive Journal Message</term>
				</item>
				<item>
					<term>
      Get Queue Properties</term>
				</item>
				<item>
					<term>
      Set Queue Properties</term>
				</item>
				<item>
					<term>
      Get Permissions</term>
				</item>
				<item>
					<term>
      Set Permissions</term>
				</item>
				<item>
					<term>
      Take Queue Ownership</term>
				</item>
				<item>
					<term>
      Write Message</term>
				</item>
			</list>
			<para>The <see cref="System.Messaging.MessageQueueAccessRights"/> enumeration
represents a set of bit flags
that you can combine using the bitwise operator OR to build the <paramref name="rights"/>
parameter.</para>
			<para>The following table shows whether this method is available in various
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<seealso cref="System.Messaging.MessageQueue.ResetPermissions"/>
		<seealso cref="System.Messaging.Trustee"/>
		<seealso cref="System.Messaging.MessageQueueAccessRights"/>
		<seealso cref="System.Messaging.AccessControlEntry"/>
	</doc>
	<doc for="MessageQueue.Formatter">
		<summary>
			<para>Gets or sets the formatter used to serialize an object
      into or deserialize
      an object
      from the body of a message read from or written
      to the queue.</para>
		</summary>
		<value>
			<para>The <see cref="System.Messaging.IMessageFormatter"/> that produces a
   stream to be
   written to or read from the message body. The default is <see cref="System.Messaging.XmlMessageFormatter"/>.</para>
		</value>
		<remarks>
			<para> The <see cref="System.Messaging.MessageQueue.Formatter"/>
property contains an instance of a formatter object,
which transforms messages when your application reads or writes to the
queue.</para>
			<para>When the application sends message to the queue, the formatter
   serializes the object into a stream and inserts it into the message body.
   When reading from a queue, the formatter deserializes the message data into the
<see cref="System.Messaging.Message.Body"/> property of a <see cref="System.Messaging.Message"/> .</para>
			<para>The <see cref="System.Messaging.XmlMessageFormatter"/> is loosely coupled, so it is not necessary to
have the same object type on the sender and receiver when using this format. The
<see cref="System.Messaging.ActiveXMessageFormatter"/> and <see cref="System.Messaging.BinaryMessageFormatter"/> serialize the data into binary representation.
The <see cref="System.Messaging.ActiveXMessageFormatter"/> is used when sending or receiving COM
components.</para>
			<para><see cref="System.Messaging.BinaryMessageFormatter"/> and <see cref="System.Messaging.ActiveXMessageFormatter"/> provide faster
throughput than the <see cref="System.Messaging.XmlMessageFormatter"/>. The <see cref="System.Messaging.ActiveXMessageFormatter"/>
allows interoperability with Visual Basic 6.0 Message Queuing applications.</para>
			<para> When your application sends messages to the queue, the
<see cref="System.Messaging.MessageQueue.Formatter" qualify="true"/>
applies
only to those messages that use the default
message properties, <see cref="System.Messaging.MessageQueue.DefaultPropertiesToSend"/>. If
you send a <see cref="System.Messaging.Message"/> to the queue, Message Queuing uses
the formatter defined in the <see cref="System.Messaging.Message.Formatter" qualify="true"/> property to serialize the body
instead.</para>
			<note type="note">
   The <see cref="System.Messaging.MessageQueue"/> class will always use a
<see cref="System.Messaging.Message"/> to receive or peek a message from the queue. 
   The message is deserialized
   using the <see cref="System.Messaging.MessageQueue.Formatter" qualify="true"/>
   property.
   
</note>
			<para>The following table shows whether this property is available in various
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term>Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Local computer + direct format
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term>Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term>Remote computer + direct format
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example demonstrates formatting a message body using
      <see cref="System.Messaging.BinaryMessageFormatter"/>.</para>
			<codelink SampleID="MessagingBinaryFormatter" SnippetID="1"/>
			<para>The following example demonstrates formatting a message body 
using <see cref="System.Messaging.XmlMessageFormatter"/>.</para>
			<codelink SampleID="Message.Body" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.XmlMessageFormatter"/>
		<seealso cref="System.Messaging.ActiveXMessageFormatter"/>
		<seealso cref="System.Messaging.BinaryMessageFormatter"/>
		<seealso cref="System.Messaging.Message.Formatter" qualify="true"/>
	</doc>
	<doc for="MessageQueue.EndReceive">
		<summary>
			<para> Completes the specified asynchronous receive
      operation.</para>
		</summary>
		<param name="asyncResult">The <see cref="System.IAsyncResult"/> that identifies the asynchronous receive operation to finish, and from which to retrieve an end result.</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/>
associated with the completed asynchronous operation.</para>
		</returns>
		<exception cref="System.ArgumentNullException">The <paramref name="asyncResult"/> parameter is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException">The syntax of the <paramref name="asyncResult "/> parameter is invalid.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>When the <see cref="M:System.Messaging.MessageQueue.ReceiveCompleted"/> event is raised, <see cref="System.Messaging.MessageQueue.EndReceive"/> completes the operation that
   was initiated by the <see cref="System.Messaging.MessageQueue.BeginReceive"/> call. To do so, <see cref="System.Messaging.MessageQueue.EndReceive"/> receives the message.</para>
			<para><see cref="System.Messaging.MessageQueue.BeginReceive"/> can specify a time-out, which
causes the <see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> event to be raised if the time-out occurs
before a message appears in the queue. In this case, the <see cref="System.IAsyncResult.IsCompleted"/>
property of the <paramref name="asyncResult"/> parameter is set to <see langword="true"/>, but no message is associated with the operation. When a time-out occurs without
a message arriving in the queue, a subsequent call to <see cref="System.Messaging.MessageQueue.EndReceive"/> throws an exception. </para>
			<para><see cref="System.Messaging.MessageQueue.EndReceive"/> is used to read (removing from
the queue) the message that caused the <see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> event to be raised. </para>
			<para>If you want to continue to asynchronously receive messages, you can
   again call <see cref="System.Messaging.MessageQueue.BeginReceive"/> after calling <see cref="System.Messaging.MessageQueue.EndReceive"/>.</para>
			<para>The following table shows whether this method is available in various
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term> Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Local computer + direct format
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer + direct format
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example chains asynchronous requests. It assumes there is a 
      queue on the local computer called "myQueue". The <c>Main</c> function begins the asynchronous operation that
   is handled by the <c>MyReceiveCompleted</c> routine. <c>MyReceiveCompleted</c> processes the current message and begins a new
asynchronous receive operation.</para>
			<codelink SampleID="MessageQueue.BeginReceive_noparms_combined" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveCompleted"/>
		<seealso cref="System.Messaging.MessageQueue.EndPeek"/>
	</doc>
	<doc for="MessageQueue.GetMessageQueueEnumerator">
		<overload>
			<para>Creates an enumerator object for a dynamic listing of the public queues on the
      network.</para>
		</overload>
		<summary>
			<para>Provides forward-only cursor semantics to enumerate through all public
      queues on the network.</para>
		</summary>
		<returns>
			<para>A <see cref="System.Messaging.MessageQueueEnumerator"/> that provides a dynamic listing of all the public message
   queues on the network.</para>
		</returns>
		<remarks>
			<para>This overload of <see cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/>
returns an enumeration
of all the public queues that are on the network.</para>
			<para> Because the cursor is associated with a dynamic listing, the enumeration reflects any modification
   you make to a queue list for queues deleted or added beyond the
   cursor's current position. Additions or deletion of queues located before the cursor's
   current position are not reflected. For example, the enumerator can automatically access a queue appended beyond
   the cursor position but not one inserted before that position. However, you
   can reset the enumeration, thereby moving the cursor back to the beginning of
   the list, by calling <see cref="System.Messaging.MessageQueueEnumerator.Reset"/> for the <see cref="System.Messaging.MessageQueueEnumerator"/> .</para>
			<note type="note">
   There is
   no defined ordering
   of queues in a network. An
   enumerator does not order them, for example, by computer, label, public or private
   status, or any other accessible criteria.
   
</note>
			<para> If you want a static snapshot of the queues on the network
   rather than a dynamic connection to them, call <see cref="System.Messaging.MessageQueue.GetPublicQueues"/> or <see cref="System.Messaging.MessageQueue.GetPrivateQueuesByMachine"/>. Each
   of these two methods returns an
   array of <see cref="System.Messaging.MessageQueue"/> objects, which represent the queues at the time
   the method was called. </para>
			<para>The following table shows whether this method is available in various
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term> Local computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Local computer + direct format
         name</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer + direct format
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example iterates through all the message queues in the network, 
      and examines the path for each queue. Finally, it displays the
      number of public queues on the network. </para>
			<codelink SampleID="MessageQueue.GetMessageQueueEnumerator_noparms" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.GetPrivateQueuesByMachine"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueues"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByCategory"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByLabel"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByMachine"/>
		<seealso cref="System.Messaging.MessageQueue.GetMessageEnumerator"/>
	</doc>
	<doc for="MessageQueue.PeekByCorrelationId">
		<overload>
			<para> Peeks a message that matches a given correlation identifier.</para>
		</overload>
		<summary>
			<para> Peeks the message that matches
      the given
      correlation identifier and immediately raises an exception if no message with
      the specified correlation identifier currently exists in the
      queue.</para>
		</summary>
		<param name="correlationId">The <see cref="System.Messaging.Message.CorrelationId"/> of the message to peek.</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose
<see cref="System.Messaging.Message.CorrelationId"/> matches the <paramref name="correlationId"/> parameter passed in.</para>
		</returns>
		<exception cref="System.ArgumentNullException">The <paramref name="correlationId "/>parameter is <see langword="null"/>.</exception>
		<exception cref="System.InvalidOperationException"><para>The message with the specified <paramref name="correlationId"/> could not be found. </para></exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>This method looks in the queue referenced by the <see cref="System.Messaging.MessageQueue"/> for a message whose <see cref="System.Messaging.Message.CorrelationId"/> matches the specified <paramref name="correlationId"/> parameter. If no message is found that
   matches the <paramref name="correlationID"/> parameter, an exception is thrown.</para>
			<para>The <see cref="System.Messaging.Message.CorrelationId"/> property is used to tie a message sent
to the queue to associated response, report, or acknowledgment
messages.</para>
			<para>Two other methods allow you to peek messages in a queue. The
<see cref="System.Messaging.MessageQueue.Peek"/> method returns the first message
   in the queue, and the <see cref="System.Messaging.MessageQueue.PeekById"/> method is used to retrieve a
   message by specifying its unique identifier.</para>
			<para>The following table shows whether this method is available in various
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term> Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Local computer + direct format
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer + direct format
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example sends and receives a message containing an order to and 
      from a queue. It specifically requests a positive acknowledgment when the
      original message reaches or is retrieved from the queue.</para>
			<codelink SampleID="Message.Acknowledgment" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.Message.CorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.PeekById"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
	</doc>
	<doc for="MessageQueue.Receive1">
		<overload>
			<para>Receives the first message in the queue.</para>
		</overload>
		<summary>
			<para>Receives the first message available in the
      transactional queue referenced by the <see cref="System.Messaging.MessageQueue"/> . This
      call is synchronous, and blocks the current thread of execution until a message is
      available.</para>
		</summary>
		<param name="transaction">The <see cref="System.Messaging.MessageQueueTransaction"/> object.</param>
		<returns>
			<para>A <see cref="System.Messaging.Message"/> that references the first message
   available in the queue.</para>
		</returns>
		<exception cref="System.Messaging.MessageQueueException"><para> An error occurred when accessing a Message Queuing API.</para>
			<para>-or-</para>
			<para>The queue is non-transactional.</para></exception>
		<remarks>
			<para>Use this overload to receive a message from a
      transactional queue using the internal transaction context defined by the
   <paramref name="transaction"/> parameter, or wait until there
      are messages in the queue.</para>
			<para>The <see cref="System.Messaging.MessageQueue.Receive"/> method
   allows for the synchronous reading of a message, thereby removing it from the queue.
   Subsequent calls to <see cref="System.Messaging.MessageQueue.Receive"/> will return the messages
   that follow in the queue.</para>
			<para> Because this method is called on a transactional queue,
   the message that is received would be returned to the queue if the
   transaction is aborted. The message is not permanently removed from the
   queue until the transaction is committed.</para>
			<para>To read the first
   message in a queue without removing it from the queue, use the <see cref="System.Messaging.MessageQueue.Peek"/> method. The <see cref="System.Messaging.MessageQueue.Peek"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue. There is no transaction
   context associated with a message returned by a call to <see cref="System.Messaging.MessageQueue.Peek"/>. Because <see cref="System.Messaging.MessageQueue.Peek"/> does not remove any messages in the queue,
   there would be nothing to roll back by a call to <see cref="System.Messaging.MessageQueueTransaction.Abort"/>
   .</para>
			<para>Use a call to <see cref="System.Messaging.MessageQueue.Receive"/> when it is acceptable for the
current thread to be blocked while it waits for a message to arrive in the
queue. Because this overload of the <see cref="System.Messaging.MessageQueue.Receive"/> method specifies an infinite
time-out, the application might wait indefinitely. If the application processing
should continue without waiting for the message, consider using the asynchronous
method, <see cref="System.Messaging.MessageQueue.BeginReceive"/>.</para>
			<para>The following table shows whether this method is available in various
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term> Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Local computer + direct format
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer + direct format
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example connects to a transactional queue on the local computer 
      and sends a message to the queue. It then receives the message containing an
      order. If it encounters a nontransactional queue, it will throw and
      exception and rollback the transaction.</para>
			<codelink SampleID="MessageQueue.Receive_transaction" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueueTransaction"/>
		<seealso cref="System.Messaging.MessageQueue.Transactional"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveByCorrelationId"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.ReceiveByCorrelationId">
		<overload>
			<para>Receives a message that matches a given correlation identifier.</para>
		</overload>
		<summary>
			<para>Receives the message that matches the given correlation identifier, from a nontransactional queue, and
      immediately raises an exception if no message with the specified correlation
      identifier currently exists in the queue.</para>
		</summary>
		<param name="correlationId">The <see cref="System.Messaging.Message.CorrelationId"/> of the message to receive.</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> whose <see cref="System.Messaging.Message.CorrelationId"/> matches the
<paramref name="correlationId"/> parameter passed in.</para>
		</returns>
		<exception cref="System.ArgumentNullException">The <paramref name="correlationId "/>parameter is <see langword="null"/>.</exception>
		<exception cref="System.InvalidOperationException">The message with the specified <paramref name="correlationId "/>could not be found.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>This method looks in the nontransactional queue referenced by the <see cref="System.Messaging.MessageQueue"/>
for a message whose <see cref="System.Messaging.Message.CorrelationId"/> matches the specified
<paramref name="correlationId"/> parameter. If no message is found that matches the
<paramref name="correlationID"/> parameter, an exception is thrown. Otherwise, the message
is removed from the queue and returned to the application.</para>
			<para>The <see cref="System.Messaging.Message.CorrelationId"/> property is used to tie a message sent
to the queue to associated response, report, or acknowledgment messages.</para>
			<para>Two other methods allow you to receive messages from a
   queue. The <see cref="System.Messaging.MessageQueue.Receive"/> method returns the first message in the queue,
   and the <see cref="System.Messaging.MessageQueue.ReceiveById"/> method retrieves a
   message by specifying its unique identifier.</para>
			<para>To read a message with a specified correlation identifier without removing it
   from the queue, use the <see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> method. The
<see cref="System.Messaging.MessageQueue.PeekByCorrelationId"/> method always returns the first
   message in the queue, so subsequent calls to the method return the same message
   unless a higher priority message arrives in the queue.</para>
			<para>The following table shows whether this method is available in various
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term> Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Local computer + direct format
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer + direct format
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example sends and receives a message containing an order to and 
      from a queue. It specifically requests a positive acknowledgment when the
      original message reaches or is retrieved from the queue.</para>
			<codelink SampleID="Message.Acknowledgment" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.ReceiveById"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
	</doc>
	<doc for="MessageQueue.GetMessageQueueEnumerator1">
		<summary>
			<para>Provides forward-only cursor semantics to enumerate through all public queues on the
      network that meet the specified criteria.</para>
		</summary>
		<param name="criteria">A <see cref="System.Messaging.MessageQueueCriteria"/> that contains the criteria used to filter the available message queues.</param>
		<returns>
			<para>A <see cref="System.Messaging.MessageQueueEnumerator"/> that provides a dynamic
   listing of the public message queues on the network that satisfy the restrictions
   specified by the <paramref name="criteria"/>
   parameter.</para>
		</returns>
		<remarks>
			<para>This overload of <see cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/>
returns a listing of
all the public queues on the network that satisfy criteria defined in the application criteria.
You can specify the criteria to include, for example, queue creation or
modification time, computer name, label, category, or any combination of these.</para>
			<para> Because the cursor is associated with a dynamic listing, the
   enumeration reflects any modification you make to a queue that occurs beyond the cursor's
   current position. Changes to queues located before the cursor's current position
   are not reflected. For example, the enumerator can automatically access
   a queue appended beyond the cursor position but not one inserted before
   that position. However, you can reset the enumeration, thereby moving
   the cursor back to the beginning of the list, by calling <see cref="System.Messaging.MessageQueueEnumerator.Reset"/> for the <see cref="System.Messaging.MessageQueueEnumerator"/> .</para>
			<note type="note">
   There is
   no defined ordering of queues in
   a network. An enumerator does not order them, for example, by computer, label,
   public or private status, or any other accessible criteria.
   
</note>
			<para>If you want a static snapshot of the queues on the
   network rather than a dynamic connection to them, specify criteria for <see cref="System.Messaging.MessageQueue.GetPublicQueues"/> or call <see cref="System.Messaging.MessageQueue.GetPrivateQueuesByMachine"/>. Each of these two methods
   returns an array of <see cref="System.Messaging.MessageQueue"/> objects, which represent the queues at the
   time the method was called. Calling <see cref="System.Messaging.MessageQueue.GetPublicQueuesByCategory"/>, <see cref="System.Messaging.MessageQueue.GetPublicQueuesByLabel"/>, or <see cref="System.Messaging.MessageQueue.GetPublicQueuesByMachine"/> provides the same results as
   calling <see cref="System.Messaging.MessageQueue.GetPublicQueues"/> with the filtering
   criteria of <see cref="System.Messaging.MessageQueue.Category"/>, <see cref="System.Messaging.MessageQueue.Label"/>, and
<see cref="System.Messaging.MessageQueue.MachineName"/>
respectively. </para>
			<para>The following table shows whether this method is available in various
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term> Local computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Local computer + direct format
         name</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer + direct format
         name</term>
					<description>No</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example iterates through message queues and displays the path 
      of each queue that was created in the last day and that exists on the computer
      "MyComputer". </para>
			<codelink SampleID="MessageQueue.GetMessageQueueEnumerator_criteria" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.GetPrivateQueuesByMachine"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueues"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByCategory"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByLabel"/>
		<seealso cref="System.Messaging.MessageQueue.GetPublicQueuesByMachine"/>
		<seealso cref="System.Messaging.MessageQueue.GetMessageEnumerator"/>
	</doc>
	<doc for="MessageQueue.ReceiveCompleted">
		<summary>
			<para> Occurs when a message has been removed from the queue.
      This event is raised by the asynchronous operation, <see cref="System.Messaging.MessageQueue.BeginReceive"/>.</para>
		</summary>
		<remarks>
			<para><see cref="System.Messaging.MessageQueue.BeginReceive"/> is used in asynchronous processing to raise
   the <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted"/> event when a message is available in the
   queue.</para>
			<para><see cref="System.Messaging.MessageQueue.EndReceive"/> is used to complete the operation initiated by
a call to <see cref="System.Messaging.MessageQueue.BeginReceive"/> and peek the message when the <see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> event is raised.</para>
			<para>When you create a <see cref="System.Messaging.ReceiveCompletedEventHandler"/> delegate, you identify the
method that will handle the event. To associate the event with your
event handler, add an instance of the delegate to the event. The event
handler is called whenever the event occurs, unless you remove the delegate. For
more information about event handler delegates, see <see topic="cpconEventsDelegates"/>.</para>
		</remarks>
		<example>
			<para>The following example creates an event handler named <c>MyReceiveCompleted</c> , attaches it to the <see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> event handler delegate, and calls 
<see cref="System.Messaging.MessageQueue.BeginReceive"/> to initiate an asynchronous 
receive operation on the queue that is located at the path ".\myQueue". When a
<see cref="System.Messaging.MessageQueue.ReceiveCompleted"/> event is raised, the example 
receives the message and writes its body to the screen. The example then calls
<see cref="System.Messaging.MessageQueue.BeginReceive"/> again to initiate a new 
asynchronous receive operation.</para>
			<codelink SampleID="MessageQueue.ReceiveCompleted" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
		<seealso cref="System.Messaging.MessageQueue.EndReceive"/>
		<seealso cref="System.Messaging.MessageQueue.PeekCompleted"/>
		<seealso cref="System.TimeSpan"/>
		<seealso cref="System.AsyncCallback"/>
		<seealso cref="System.IAsyncResult"/>
	</doc>
	<doc for="MessageQueue.EndPeek">
		<summary>
			<para> Completes the specified asynchronous peek
      operation.</para>
		</summary>
		<param name="asyncResult">The <see cref="System.IAsyncResult"/> that identifies the asynchronous peek operation to finish, and from which to retrieve an end result.</param>
		<returns>
			<para>The <see cref="System.Messaging.Message"/> associated with the completed asynchronous
   operation.</para>
		</returns>
		<exception cref="System.ArgumentNullException">The <paramref name="asyncResult"/> parameter is <see langword="null"/>.</exception>
		<exception cref="System.ArgumentException">The syntax of the <paramref name="asyncResult "/> parameter is invalid.</exception>
		<exception cref="System.Messaging.MessageQueueException">An error occurred when accessing a Message Queuing API.</exception>
		<remarks>
			<para>When the <see cref="M:System.Messaging.MessageQueue.PeekCompleted"/> event is
   raised, <see cref="System.Messaging.MessageQueue.EndPeek"/> completes the
   operation that was initiated by the <see cref="System.Messaging.MessageQueue.BeginPeek"/> call. To do so, <see cref="System.Messaging.MessageQueue.EndPeek"/> peeks the message.</para>
			<para><see cref="System.Messaging.MessageQueue.BeginPeek"/>
can specify
a time-out, which causes the <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event
to be raised if the time-out occurs before a message appears in the queue. In this case, the <see cref="System.IAsyncResult.IsCompleted"/> property of the <paramref name="asyncResult"/> parameter is set to
<see langword="true"/>, but no message is associated with the operation. When a
time-out occurs without a message arriving in the queue, a subsequent call to <see cref="System.Messaging.MessageQueue.EndPeek"/> throws an exception. </para>
			<para><see cref="System.Messaging.MessageQueue.EndPeek"/> is used to read the message that caused
the <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event
to be raised.</para>
			<para>If you want to continue to asynchronously peek messages,
   you can again call <see cref="System.Messaging.MessageQueue.BeginPeek"/> after calling <see cref="System.Messaging.MessageQueue.EndPeek"/>.</para>
			<para>The following table shows whether this method is available in various
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term> Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Local computer + direct format
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Remote computer</term>
					<description>No</description>
				</item>
				<item>
					<term> Remote computer + direct format
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example creates an event handler named <c>MyPeekCompleted</c> , attaches it to the <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event handler delegate, and calls
<see cref="System.Messaging.MessageQueue.BeginPeek"/> to initiate an asynchronous peek 
operation on the queue that is located at the path ".\myQueue". When a <see cref="System.Messaging.MessageQueue.PeekCompleted"/> event is raised, the example
peeks the message and writes its body to the screen. The example then calls
<see cref="System.Messaging.MessageQueue.BeginPeek"/> again to initiate a new 
asynchronous peek operation.</para>
			<codelink SampleID="MessageQueue.BeginPeek_noparms" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
		<seealso cref="System.Messaging.MessageQueue.PeekCompleted"/>
		<seealso cref="System.Messaging.MessageQueue.EndReceive"/>
	</doc>
	<doc for="MessageQueue">
		<summary>
			<para> Provides access to a queue on a Message Queuing server.</para>
		</summary>
		<threadsafe>
			<para>Only the following methods are safe for multithreaded
      operations: <see cref="System.Messaging.MessageQueue.BeginPeek"/>, <see cref="System.Messaging.MessageQueue.BeginReceive"/>, <see cref="System.Messaging.MessageQueue.EndPeek"/>, <see cref="System.Messaging.MessageQueue.EndReceive"/>, <see cref="System.Messaging.MessageQueue.GetAllMessages"/>, and <see cref="System.Messaging.MessageQueue.Peek"/>, <see cref="System.Messaging.MessageQueue.Receive"/>. </para>
		</threadsafe>
		<remarks>
			<para>Message Queuing technology allows applications running at
      different times to communicate across heterogeneous networks and systems,
      which might be temporarily offline. Applications send, receive, or
      peek (read without removing) messages from queues. Message Queuing
      is an optional component of Windows 2000 and Windows NT, and must be installed
      separately.</para>
			<para>The <see cref="System.Messaging.MessageQueue"/> class is a wrapper around Message Queuing.
   There are multiple versions of Message Queuing, and using the <see cref="System.Messaging.MessageQueue"/>
   class can result in slightly different behavior, depending on the operating
   system you are using. For information about specific features of each version of Message
   Queuing, see the topic "What's New in Message Queuing" in the Platform SDK
   in MSDN.</para>
			<para>The <see cref="System.Messaging.MessageQueue"/>
class provides a reference to a Message Queuing queue.
You can specify a path in the <see cref="System.Messaging.MessageQueue()"/> constructor to
connect to an existing resource, or you can create a new queue on
the server. Before you can call <see cref="System.Messaging.MessageQueue.Send"/>, <see cref="System.Messaging.MessageQueue.Peek"/>, or <see cref="System.Messaging.MessageQueue.Receive"/> , you must associate the new
instance of the <see cref="System.Messaging.MessageQueue"/> class with an existing queue.
At that point, you can manipulate the queue properties such as
<see cref="System.Messaging.MessageQueue.Category"/> and <see cref="System.Messaging.MessageQueue.Label"/>.</para>
			<para><see cref="System.Messaging.MessageQueue"/> supports two types of message retrieval:
synchronous and asynchronous. The synchronous methods, <see cref="System.Messaging.MessageQueue.Peek"/> and <see cref="System.Messaging.MessageQueue.Receive"/>, cause
the process thread to wait a
specified time interval for a new message to arrive in the queue.
The asynchronous methods, <see cref="System.Messaging.MessageQueue.BeginPeek"/> and <see cref="System.Messaging.MessageQueue.BeginReceive"/> ,
allow the main application tasks to continue in a separate thread until a
message arrives in the queue. These methods work by using callback
objects and state objects to communicate information between
threads.</para>
			<para>When you create a new instance of the <see cref="System.Messaging.MessageQueue"/>
class, you are not creating a new Message
Queuing queue. Instead, you can use the <see cref="System.Messaging.MessageQueue.Create"/>, <see cref="System.Messaging.MessageQueue.Delete"/>, and <see cref="System.Messaging.MessageQueue.Purge"/> methods
to manage queues on the server.</para>
			<note type="note">
   Unlike <see cref="System.Messaging.MessageQueue.Purge"/>,
<see cref="System.Messaging.MessageQueue.Create"/> and <see cref="System.Messaging.MessageQueue.Delete"/> are <see langword="static"/> members, so you can call them without
   creating a new instance of the <see cref="System.Messaging.MessageQueue"/>
   class.
   
</note>
			<para>You can set the <see cref="System.Messaging.MessageQueue"/>
object's <see cref="System.Messaging.MessageQueue.Path"/> property with one of three names:
the friendly name, the <see cref="System.Messaging.MessageQueue.FormatName"/>, or the <see cref="System.Messaging.MessageQueue.Label"/>
. The friendly name, which is defined by the queue's
<see cref="System.Messaging.MessageQueue.MachineName"/> and <see cref="System.Messaging.MessageQueue.QueueName"/>
properties, is <see cref="System.Messaging.MessageQueue.MachineName"/>\<see cref="System.Messaging.MessageQueue.QueueName"/> for
a public queue, and <see cref="System.Messaging.MessageQueue.MachineName"/>\<see langword="Private$"/>\<see cref="System.Messaging.MessageQueue.QueueName"/> for a private queue. The <see cref="System.Messaging.MessageQueue.FormatName"/> property allows offline access
to message queues. Lastly, you can use the queue's <see cref="System.Messaging.MessageQueue.Label"/>
property to set the queue's
<see cref="System.Messaging.MessageQueue.Path"/>. </para>
			<para>For a list of initial property values for an instance of <see cref="System.Messaging.MessageQueue"/>
, see the <see cref="System.Messaging.MessageQueue()"/> constructor.</para>
		</remarks>
		<example>
			<para>The following example creates new <see cref="System.Messaging.MessageQueue"/> objects using various path
   name syntax types. In each case, it sends a message to the queue whose path is
   defined in the constructor.</para>
			<codelink SampleID="MessageQueue.Path" SnippetID="1"/>
			<para>The following example sends a message to a queue, and receives a message from a queue, using an application-specific class 
called "Order".</para>
			<codelink SampleID="MessageQueue.Receive_noparms" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.Message"/>
		<seealso cref="System.Messaging.DefaultPropertiesToSend"/>
		<seealso cref="System.Messaging.MessageQueueException"/>
		<seealso cref="M:System.Messaging.MessageQueue.#ctor"/>
		<seealso cref="System.Messaging.MessageQueue.Send"/>
		<seealso cref="System.Messaging.MessageQueue.Peek"/>
		<seealso cref="System.Messaging.MessageQueue.Receive"/>
		<seealso cref="System.Messaging.MessageQueue.BeginPeek"/>
		<seealso cref="System.Messaging.MessageQueue.BeginReceive"/>
		<seealso cref="System.Messaging.MessageQueue.Path"/>
		<seealso cref="System.Messaging.MessageQueue.Label"/>
		<seealso cref="System.Messaging.MessageQueue.FormatName"/>
		<seealso cref="System.Messaging.MessageQueue.QueueName"/>
		<seealso cref="System.Messaging.MessageQueue.MachineName"/>
		<seealso cref="System.Messaging.MessageQueue.Create"/>
	</doc>
	<doc for="MessageQueue.GetMessageEnumerator">
		<summary>
			<para> Creates an enumerator object for all the
      messages in the
      queue.</para>
		</summary>
		<returns>
			<para>The <see cref="System.Messaging.MessageEnumerator"/> holding
   the messages that
   are contained in the
   queue.</para>
		</returns>
		<remarks>
			<para><see cref="System.Messaging.MessageQueue.GetMessageEnumerator"/>
creates a dynamic list of all the messages in a queue. You can remove from the
queue the message at the enumerator's current position by calling <see cref="System.Messaging.MessageEnumerator.RemoveCurrent"/> for the <see cref="System.Messaging.MessageEnumerator"/> that <see cref="System.Messaging.MessageQueue.GetMessageEnumerator"/>
returns.</para>
			<para>Because the cursor is associated with the dynamic list of messages in
   the queue, the enumeration reflects any modification you make to the messages in
   the queue, if the message is beyond the current cursor position. For example,
   the enumerator can automatically access a lower-priority message placed beyond
   the cursor's current position, but not a higher-priority message inserted before
   that position. However, you can reset the enumeration, thereby moving
   the cursor back to the beginning of the list, by calling <see cref="System.Messaging.MessageEnumerator.Reset"/> for the <see cref="System.Messaging.MessageEnumerator"/>.</para>
			<note type="note">
   The
   order
   of the messages in the enumeration reflects their order in the queue, so
   higher-priority messages will appear before lower-priority ones.
   
</note>
			<para>If you want a static snapshot of the messages in the queue rather than a
   dynamic connection to them, call <see cref="System.Messaging.MessageQueue.GetAllMessages"/>. This method returns an array of
<see cref="System.Messaging.Message"/> objects, which represent the messages at the
   time the method was called. </para>
			<para>The following table shows whether this method is available in various
   Workgroup modes.</para>
			<list type="table">
				<listheader>
					<term>Workgroup Mode</term>
					<description>Available</description>
				</listheader>
				<item>
					<term> Local computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Local computer + direct format
         name</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Remote computer</term>
					<description>Yes</description>
				</item>
				<item>
					<term> Remote computer + direct format
         name</term>
					<description>Yes</description>
				</item>
			</list>
		</remarks>
		<example>
			<para>The following example gets a dynamic list of messages in
      a queue and counts all messages with the <see cref="System.Messaging.Message.Priority"/> property set to <see cref="System.Messaging.MessagePriority.Lowest" qualify="true"/>.</para>
			<codelink SampleID="MessageQueue.GetMessageEnumerator" SnippetID="1"/>
		</example>
		<seealso cref="System.Messaging.MessageQueue.GetAllMessages"/>
		<seealso cref="System.Messaging.MessageQueue.GetEnumerator"/>
		<seealso cref="System.Messaging.MessageQueue.GetMessageQueueEnumerator"/>
	</doc>
</docs>
