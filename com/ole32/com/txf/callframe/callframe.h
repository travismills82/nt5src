//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// CallFrame.h
//
#include "CallFrameImpl.h"

//////////////////////////////////////////////////////////////////////////////////////////////////

class CallFrame : 
  public ICallFrame, 
  public ICallFrameInit,
  public DedicatedAllocator<CallFrame>
{
  public:
    ///////////////////////////////////////////////////////////////////
    //
    // State of valid interest outside of any worker routine
    //
    ///////////////////////////////////////////////////////////////////

    BYTE* PMemberFirst() { return (BYTE*)&m_pmd; }

    // Our meta data reference
    MD_METHOD*                  m_pmd;

    // Pointer to the stack frame containing the argument data
    PVOID                       m_pvArgs;
    BOOL                        m_fIsCopy;      // Are we a copy? (that is, generated by a copy or unmarshal?)
    BOOL                        m_fIsUnmarshal; // Are we an unmarshalled call frame?


    // The return value of an invocation on us. Is REGISTER_TYPE in order that it can
    // be directly marshalled.
    REGISTER_TYPE               m_hrReturnValue;

    // Current location in the one-off block of memory we use for private buffer management
    PVOID                       m_pvMemCur;

    // If we share memory with someone, then this is the stack of the guy with whom we do
    PVOID                       m_pvArgsSrc;

    // Do our in-parameters share state with our parent frame
    BOOL                        DoWeShareMemory()   { return m_pvArgsSrc != NULL; }

#ifdef DBG
    // If true, then we definitely have made a call on this frame
    BOOL                        m_fAfterCall;
#endif

    // Our interceptor. We need to keep it alive as long as we are alive. 
    //
    Interceptor*                m_pInterceptor;

    ///////////////////////////////////////////////////////////////////
    //
    // State used to communicate with various worker routines as we
    // copy, free, etc.
    //
    ///////////////////////////////////////////////////////////////////

    BOOL                        m_fPropogatingOutParam;
    BOOL                        m_fWorkingOnInParam;
    BOOL                        m_fWorkingOnOutParam;

    // The frame that should allocate memory as we need it
    CallFrame*                  m_pAllocatorFrame;

    // Used during a Copy etc call as the guy who should get our callbacks
    ICallFrameWalker*           m_pWalkerCopy;
    ICallFrameWalker*           m_pWalkerFree;
    ICallFrameWalker*           m_pWalkerWalk;


    ///////////////////////////////////////////////////////////////////
    //
    // State used to mirror NDR runtime pStubMsg state
    //
    ///////////////////////////////////////////////////////////////////

    BYTE*                       m_StackTop;             // base pointer used for FC_TOP_LEVEL_CONFORMANCE conformance computations
    BYTE*                       m_Memory;               // base pointer used for FC_POINTER_CONFORMANCE   conformance computations

    SIZE_T                      m_MaxCount;             // Holds the max counts for a conformant array
    SIZE_T                      m_Offset;               // Holds the offsets for a varying array
    SIZE_T                      m_ActualCount;          // Holds the actual counts for a varying array
    PARRAY_INFO                 m_pArrayInfo;

    // Set limit pointer as to what we zero out during construction
    // 
    BYTE* PMemberMax() { return (BYTE*)&m_pArrayInfo + sizeof(m_pArrayInfo); }


    ///////////////////////////////////////////////////////////////////
    //
    // Construction
    //
    ///////////////////////////////////////////////////////////////////

    friend GenericInstantiator<CallFrame>;

    CallFrame()
    {
        m_refs              = 1;    // nb starts at one

        ZeroMemory(PMemberFirst(), PMemberMax() - PMemberFirst());

        Zero(&m_blobBuffer);
        m_fWeOwnBlobBuffer = FALSE;

        m_pvMemCur = &m_pvMem[0];
        m_fIsCopy = FALSE;

#ifdef DBG
        memset(&m_pvMem[0], 0xBB, CB_PRIVATE_BUFFER);   // init to something we'll recognize in the debugger
#endif
    }

    ~CallFrame();

    HRESULT Init() const
    {
        return S_OK;
    }

#define SetStackLocation_(pvArgs) { m_pvArgs = pvArgs; }

    void Init(void* pvArgs, MD_METHOD* pmdMethod, Interceptor* pInterceptor);

    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrame
    //
    ///////////////////////////////////////////////////////////////////

    HRESULT STDCALL GetInfo(CALLFRAMEINFO *pInfo);

    HRESULT STDCALL GetIIDAndMethod(IID*, ULONG*);

    HRESULT STDCALL GetNames(LPWSTR* pwszInterface, LPWSTR* pwszMethod);

    PVOID STDCALL GetStackLocation()
    {
        return m_pvArgs;
    }

    void STDCALL SetStackLocation(PVOID pvArgs)
    {
        SetStackLocation_(pvArgs);
    }

    HRESULT STDCALL GetMarshalSizeMax(
        CALLFRAME_MARSHALCONTEXT *pmshlContext, 
        MSHLFLAGS mshlflags, 
        ULONG *pcbBufferNeeded);

    HRESULT STDCALL Marshal( 
        CALLFRAME_MARSHALCONTEXT  *pmshlContext,
        MSHLFLAGS	mshlflags,	/* As in the IMarshal interface */
        PVOID pBuffer,
        ULONG cbBuffer,
        ULONG  *pcbBufferUsed,
        RPCOLEDATAREP* pdataRep,
        ULONG *prpcFlags);

    void MarshalParam(
        MIDL_STUB_MESSAGE& stubMsg, 
        ULONG iParam, 
        const PARAM_DESCRIPTION& param, 
        const PARAM_ATTRIBUTES paramAttr, 
        PBYTE pArg);

    HRESULT STDCALL Unmarshal(
        PVOID pBuffer, 
        ULONG cbBuffer,
        RPCOLEDATAREP dataRep, 
        CALLFRAME_MARSHALCONTEXT*, 
        ULONG* pcbUnmarhalled);

    HRESULT STDCALL ReleaseMarshalData(
        PVOID pBuffer, 
        ULONG cbBuffer, 
        ULONG ibFirstRelease, 
        RPCOLEDATAREP dataRep, 
        CALLFRAME_MARSHALCONTEXT* pctx);
    
    void UnmarshalParam(
        MIDL_STUB_MESSAGE& stubMsg, 
        const PARAM_DESCRIPTION& param, 
        const PARAM_ATTRIBUTES paramAttr, 
        PBYTE pArg);
    
    HRESULT STDCALL Free( 
        ICallFrame*        pframeArgsDest,
        ICallFrameWalker*  pWalkerFreeDest,
        ICallFrameWalker*  pWalkerCopy,
        DWORD              freeFlags,
        ICallFrameWalker*  pWalkerFree,
        DWORD              nullFlags);

    HRESULT STDCALL FreeParam(
        ULONG              iparam,
        DWORD              freeFlags,
        ICallFrameWalker*  pWalkerFree,
        DWORD              nullFlags);
    
    void STDCALL SetReturnValue(HRESULT hrReturnValue)
    {
        m_hrReturnValue = hrReturnValue;
    }
    HRESULT STDCALL GetReturnValue()
    {
        return (HRESULT)m_hrReturnValue;
    }
    HRESULT GetReturnValueFast()
    {
        return (HRESULT)m_hrReturnValue;
    }

    HRESULT STDCALL Invoke(void *pvReceiver, ...);

    HRESULT STDCALL Copy(
        CALLFRAME_COPY callControl,
        ICallFrameWalker* pWalker,
        ICallFrame** ppFrame
    );

    HRESULT STDCALL WalkFrame(DWORD walkWhat, ICallFrameWalker *pWalker);

    HRESULT STDCALL GetParamInfo(IN ULONG iparam, OUT CALLFRAMEPARAMINFO*);
    HRESULT STDCALL GetParam(ULONG iparam, VARIANT* pvar);
    HRESULT STDCALL SetParam(ULONG iparam, VARIANT* pvar);


    ///////////////////////////////////////////////////////////////////
    //
    // ICallFrameInit
    //
    ///////////////////////////////////////////////////////////////////

    CallFrame* STDCALL GetCallFrame()
    {
        return this;
    }

    ///////////////////////////////////////////////////////////////////
    //
    // Standard COM infrastructure stuff
    //
    ///////////////////////////////////////////////////////////////////

    LONG        m_refs;

    HRESULT STDCALL QueryInterface(REFIID iid, LPVOID* ppv);
    ULONG   STDCALL AddRef()   { ASSERT(m_refs>0); InterlockedIncrement(&m_refs); return m_refs;}
    ULONG   STDCALL Release()  { long crefs = InterlockedDecrement(&m_refs); if (crefs == 0) delete this; return crefs; }

    ///////////////////////////////////////////////////////////////////
    //
    // Memory management
    //
    ///////////////////////////////////////////////////////////////////

    enum { CB_PRIVATE_BUFFER = 256 };
    //
    // We maintain inside ourselves a chunk of memory that we use in order to do very quickly
    // get memory needed in copied frames. If we run out of this memory, we start getting memory
    // from the task allocator. We also use this memory for the child stack itself, so the size
    // of this buffer effectively puts a limit on the size of a stack frame we can deal with.
    //
    BYTE  m_pvMem[CB_PRIVATE_BUFFER];
    BOOL  m_fCanUseBuffer;
    //
    // Also, during an unmarshal call, we are given a buffer into which some of the umarshalled
    // data might eventually point. We are not to free such pointers, of course. Further we might
    // actually own the buffer, and so be responsible for freeing it when we go bye bye.
    //
    BLOB  m_blobBuffer;
    BOOL  m_fWeOwnBlobBuffer;


    void* AllocBuffer(size_t cb);
    void* Alloc(size_t cb);

    void* Alloc(size_t cb, BOOL fForceAlloc)
    {
        if (!m_fCanUseBuffer)
        {
            fForceAlloc = TRUE;
        }

        if (fForceAlloc)
        {
            return Alloc(cb);
        }
        else
        {
            return AllocBuffer(cb);
        }
    }


    HRESULT AllocStack(size_t cb, BOOL fForceUserMode = FALSE)
    {
        ASSERT(m_pvArgs == NULL);
        //
        // Automatically determine size if we can and if asked to
        //
        if (cb == 0)
        {
            cb = m_pmd->m_cbPushedByCaller;
        }
        ASSERT(cb > 0); // should always have at least a receiver

        if (m_fIsCopy)
            Free(m_pvArgs);

        // SetStackLocation assigns to m_pvArgs.
        SetStackLocation_(AllocBuffer(cb));

        if (NULL != m_pvArgs)
        {
            m_fIsCopy = TRUE;
            ZeroMemory(m_pvArgs, cb);

            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    void  Free(void* pv);
    BOOL  WeOwn(void* pv);

    ///////////////////////////////////////////////////////////////////
    //
    // Worker routines
    //
    ///////////////////////////////////////////////////////////////////

    void           CopyWorker                (BYTE* pMemoryFrom, BYTE** ppMemoryTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);
    void           CopyConformantArrayPriv   (BYTE* pMemoryFrom, BYTE** ppMemoryTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);
    void           CopyEmbeddedPointers      (BYTE* pbFrom, BYTE* pbTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);
    PFORMAT_STRING CopyEmbeddedRepeatPointers(BYTE* pbFrom, BYTE* pbTo, PFORMAT_STRING pFormat, BOOL fMustAlloc);

    void           FreeWorker                (BYTE* pMemoryFrom, PFORMAT_STRING pFormat, BOOL fFreePointer);
    void           FreeEmbeddedPointers      (BYTE* pMemory,     PFORMAT_STRING pFormat);
    PFORMAT_STRING FreeEmbeddedRepeatPointers(BYTE* pMemory,     PFORMAT_STRING pFormat);

    void            WalkWorker                  (BYTE* pMemory, PFORMAT_STRING pFormat);
    void            WalkConformantArrayPriv     (BYTE* pMemory, PFORMAT_STRING pFormat);
    PFORMAT_STRING  WalkEmbeddedRepeatPointers  (BYTE* pMemory, PFORMAT_STRING pFormat);
    void            WalkEmbeddedPointers        (BYTE* pMemory, PFORMAT_STRING pFormat);

    void OutInit(CallFrame*, BYTE** ppArgFrom, BYTE** ppArgTo, PFORMAT_STRING pFormat);
    void OutCopy(            BYTE*  pMemFrom,  BYTE*  pMemTo,  PFORMAT_STRING pFormat);
    void OutZero(            BYTE*  pMem,                      PFORMAT_STRING pFormat, BOOL fDst = TRUE);

//Review API Change for WIN64
#ifndef _WIN64
    ULONG ComputeConformance(BYTE* pMemory, PFORMAT_STRING pFormat,                                BOOL fProbeSrc);
#else
    ULONGLONG ComputeConformance(BYTE* pMemory, PFORMAT_STRING pFormat,                                BOOL fProbeSrc);
#endif

    void  ComputeVariance   (BYTE* pMemory, PFORMAT_STRING pFormat, ULONG* pOffset, ULONG* pCount, BOOL fProbeSrc);
    BYTE* MemoryIncrement   (BYTE* pMemory, PFORMAT_STRING pFormat,                                BOOL fProbeSrc);

    BOOL ByValue(const PARAM_ATTRIBUTES& paramAttr, PFORMAT_STRING pFormatParam,   BOOL fFromCopy) const;
    BOOL FIndirect(BYTE bPointerAttributes,         PFORMAT_STRING pFormatPointee, BOOL fFromCopy) const;
    BOOL IsSafeArray(PFORMAT_STRING pFormat) const;

    // Get a new pointer that will probe correctly in the destination space. pbIn
    // should be a stack variable that we might use for scratch.
    PBYTE* GetAllocatedPointer(PBYTE& pbIn)
    {
        return &pbIn;
    }

    void FreeAllocatedPointer(PBYTE* ppb)
    {
#ifndef _WIN64
        DEBUG(*ppb = (PBYTE)0xfefefefe);
#else
        DEBUG(*ppb = (PBYTE)0xfefefefefefefefe);
#endif
    }

    BYTE* SetMemory(BYTE* pMemory)
    {
        BYTE* p = m_Memory;
        m_Memory = pMemory;
        return p;
    }
    
    CallFrame* GetFrame(CallFrame*& pFrame, PVOID pvArgs);

    OAUTIL GetHelper() const
    {
        return OAUTIL(m_pWalkerCopy, m_pWalkerFree, m_pWalkerWalk, m_fWorkingOnInParam, m_fWorkingOnOutParam);
    }

    OAUTIL GetWalker() const
    {
        return OAUTIL(m_pWalkerCopy, m_pWalkerFree, m_pWalkerWalk, m_fWorkingOnInParam, m_fWorkingOnOutParam);
    }

    BOOL AnyWalkers() const
    {
        return m_pWalkerCopy || m_pWalkerFree || m_pWalkerWalk;
    }

    BOOL CanShareParameter(ULONG iparam) const
    {
        return m_pmd->m_rgParams[iparam].m_fCanShare;
    }

    ULONG CbParam(ULONG iparam, const PARAM_DESCRIPTION& param) const
    {
        return (iparam == m_pmd->m_numberOfParams ? m_pmd->m_cbPushedByCaller : m_pmd->m_params[iparam+1].StackOffset) - param.StackOffset;
    }
    
    void GetStackSize(ULONG* pcbArgs) const
    {
        *pcbArgs = m_pmd->m_cbPushedByCaller;
    }

    ///////////////////////////////////////////////////////////////////
    //
    // Misc
    //
    ///////////////////////////////////////////////////////////////////

    PMIDL_STUB_DESC GetStubDesc() const
    {
        PMIDL_SERVER_INFO pServerInfo = (PMIDL_SERVER_INFO) m_pmd->m_pHeader->pServerInfo;
        return pServerInfo->pStubDesc;
    }

    //////////////////////////////////////////

    BSTR SysAllocStringSrc(LPCWSTR wszSrc)
    {
		return g_oaUtil.SysAllocString(wszSrc);
    }

	BSTR SysCopyBSTRSrc(BSTR bstrSrc)
    {
		UINT len = g_oaUtil.SysStringByteLen(bstrSrc);
		return g_oaUtil.SysAllocStringByteLen((LPCSTR)bstrSrc, len);
    }

    void SysFreeStringDst(BSTR bstrDst)
    {
        if (bstrDst)
        {
            BSTR_INTERNAL* pint = BSTR_INTERNAL::From(bstrDst);
            g_oaUtil.SysFreeString(bstrDst);
        }
    }

};

//////////////////////////////////////////////////////////////////////////////////////////////////



