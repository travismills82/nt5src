#include <windows.h>
#include <wincrypt.h>
#include <winscard.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

/*
    A list of the API calls made by enrollment:
    
    CryptAcquireContext
    CRYPT_VERIFYCONTEXT
    
    CryptGetProvParam
    PP_ENUMALGS_EX
    PP_ENUMALGS
    PP_KEYSPEC
    PP_NAME
    PP_UNIQUE_CONTAINER
    PP_PROVTYPE
    
    CryptReleaseContext
    
    CryptGetUserKey
    AT_KEYEXCHANGE
    
    CryptGenKey
    
    CryptDestroyKey
    
    CryptExportKey
    PUBLICKEYBLOB
    
    CryptCreateHash
    CALG_SHA
    
    CryptHashData
    
    CryptSignHash
    AT_KEYEXCHANGE
    
    CryptDestroyHash
*/

#define TEST_CASE(X) { if (ERROR_SUCCESS != (dwSts = X)) { printf("%s", #X); goto Ret; } }

#define CAPI_TEST_CASE(X) { if (! X) { dwSts = GetLastError(); printf("%s", #X); goto Ret; } }

BYTE rgbTestCer [] = {
0x30, 0x82, 0x05, 0x8f, 0x30, 0x82, 0x04, 0xf8, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x0a, 0x1e,
0x39, 0xa7, 0x1c, 0x00, 0x01, 0x00, 0x0f, 0xc9, 0x64, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,
0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x4b, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03,
0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x0a,
0x13, 0x09, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x31, 0x0e, 0x30, 0x0c, 0x06,
0x03, 0x55, 0x04, 0x0b, 0x13, 0x05, 0x4e, 0x74, 0x64, 0x65, 0x76, 0x31, 0x18, 0x30, 0x16, 0x06,
0x03, 0x55, 0x04, 0x03, 0x13, 0x0f, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x20, 0x49, 0x53, 0x53, 0x55,
0x45, 0x33, 0x20, 0x43, 0x41, 0x30, 0x1e, 0x17, 0x0d, 0x30, 0x31, 0x31, 0x31, 0x31, 0x39, 0x32,
0x31, 0x32, 0x39, 0x31, 0x34, 0x5a, 0x17, 0x0d, 0x30, 0x32, 0x30, 0x39, 0x32, 0x30, 0x32, 0x31,
0x33, 0x33, 0x32, 0x38, 0x5a, 0x30, 0x7b, 0x31, 0x13, 0x30, 0x11, 0x06, 0x0a, 0x09, 0x92, 0x26,
0x89, 0x93, 0xf2, 0x2c, 0x64, 0x01, 0x19, 0x16, 0x03, 0x63, 0x6f, 0x6d, 0x31, 0x19, 0x30, 0x17,
0x06, 0x0a, 0x09, 0x92, 0x26, 0x89, 0x93, 0xf2, 0x2c, 0x64, 0x01, 0x19, 0x16, 0x09, 0x6d, 0x69,
0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x31, 0x15, 0x30, 0x13, 0x06, 0x0a, 0x09, 0x92, 0x26,
0x89, 0x93, 0xf2, 0x2c, 0x64, 0x01, 0x19, 0x16, 0x05, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x31, 0x0c,
0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x03, 0x49, 0x54, 0x47, 0x31, 0x0e, 0x30, 0x0c,
0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x05, 0x55, 0x73, 0x65, 0x72, 0x73, 0x31, 0x14, 0x30, 0x12,
0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x0b, 0x44, 0x61, 0x6e, 0x20, 0x47, 0x72, 0x69, 0x66, 0x66,
0x69, 0x6e, 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01,
0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0x89,
0x9f, 0x70, 0xb2, 0x5e, 0xfd, 0x99, 0x31, 0xb8, 0xcd, 0x17, 0xba, 0x2f, 0x7c, 0xb9, 0xed, 0xde,
0x56, 0xff, 0xb3, 0x37, 0x78, 0xd0, 0x51, 0xae, 0x14, 0x7c, 0xae, 0x91, 0x1f, 0xb0, 0x26, 0x87,
0xaf, 0x43, 0x3e, 0xde, 0x59, 0xbb, 0xc8, 0xcf, 0xbe, 0x25, 0x03, 0x0a, 0x1c, 0xd8, 0x18, 0x4d,
0x1a, 0xbd, 0xe3, 0xb0, 0x73, 0xc9, 0x2b, 0x29, 0x0b, 0x0a, 0x12, 0xdd, 0x55, 0x37, 0xcb, 0x2b,
0x8f, 0xf2, 0xe6, 0x2c, 0x2e, 0x7f, 0x8d, 0x71, 0x9a, 0x77, 0xf6, 0x4e, 0x4e, 0x3e, 0x94, 0x2e,
0xdb, 0x3c, 0xd4, 0xde, 0x32, 0x1f, 0xc7, 0xb9, 0x96, 0x72, 0xbb, 0x0d, 0x80, 0xc9, 0xc0, 0x3e,
0x84, 0xee, 0x33, 0x3c, 0x62, 0x46, 0x17, 0x7d, 0x27, 0x83, 0x15, 0xdd, 0x2f, 0x2f, 0x0a, 0xb3,
0xcf, 0x76, 0xf6, 0x9b, 0x0d, 0x70, 0x6d, 0x99, 0x5b, 0xca, 0xba, 0x07, 0x8a, 0x44, 0xd3, 0x02,
0x03, 0x01, 0x00, 0x01, 0xa3, 0x82, 0x03, 0x48, 0x30, 0x82, 0x03, 0x44, 0x30, 0x0b, 0x06, 0x03,
0x55, 0x1d, 0x0f, 0x04, 0x04, 0x03, 0x02, 0x05, 0xa0, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e,
0x04, 0x16, 0x04, 0x14, 0x38, 0xef, 0x1a, 0xde, 0x6f, 0x3e, 0xa8, 0x73, 0x86, 0x74, 0xb8, 0x27,
0x4b, 0x9e, 0x8a, 0x98, 0xf7, 0x67, 0x70, 0x47, 0x30, 0x2b, 0x06, 0x09, 0x2b, 0x06, 0x01, 0x04,
0x01, 0x82, 0x37, 0x14, 0x02, 0x04, 0x1e, 0x1e, 0x1c, 0x00, 0x53, 0x00, 0x6d, 0x00, 0x61, 0x00,
0x72, 0x00, 0x74, 0x00, 0x63, 0x00, 0x61, 0x00, 0x72, 0x00, 0x64, 0x00, 0x4c, 0x00, 0x6f, 0x00,
0x67, 0x00, 0x6f, 0x00, 0x6e, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x18, 0x30, 0x16,
0x80, 0x14, 0xc9, 0x44, 0x56, 0x4a, 0x90, 0x13, 0x7c, 0xa9, 0xf3, 0x33, 0x06, 0x6b, 0xde, 0xd0,
0x99, 0xbb, 0xe7, 0xc8, 0xce, 0xe9, 0x30, 0x82, 0x01, 0x26, 0x06, 0x03, 0x55, 0x1d, 0x1f, 0x04,
0x82, 0x01, 0x1d, 0x30, 0x82, 0x01, 0x19, 0x30, 0x82, 0x01, 0x15, 0xa0, 0x82, 0x01, 0x11, 0xa0,
0x82, 0x01, 0x0d, 0x86, 0x81, 0xc4, 0x6c, 0x64, 0x61, 0x70, 0x3a, 0x2f, 0x2f, 0x2f, 0x43, 0x4e,
0x3d, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x25, 0x32, 0x30, 0x49, 0x53, 0x53, 0x55, 0x45, 0x33, 0x25,
0x32, 0x30, 0x43, 0x41, 0x2c, 0x43, 0x4e, 0x3d, 0x57, 0x48, 0x49, 0x43, 0x41, 0x33, 0x2c, 0x43,
0x4e, 0x3d, 0x43, 0x44, 0x50, 0x2c, 0x43, 0x4e, 0x3d, 0x50, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x25,
0x32, 0x30, 0x4b, 0x65, 0x79, 0x25, 0x32, 0x30, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73,
0x2c, 0x43, 0x4e, 0x3d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2c, 0x43, 0x4e, 0x3d,
0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x44, 0x43,
0x3d, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2c, 0x44, 0x43, 0x3d, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73,
0x6f, 0x66, 0x74, 0x2c, 0x44, 0x43, 0x3d, 0x63, 0x6f, 0x6d, 0x3f, 0x63, 0x65, 0x72, 0x74, 0x69,
0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x52, 0x65, 0x76, 0x6f, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e,
0x4c, 0x69, 0x73, 0x74, 0x3f, 0x62, 0x61, 0x73, 0x65, 0x3f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
0x43, 0x6c, 0x61, 0x73, 0x73, 0x3d, 0x63, 0x52, 0x4c, 0x44, 0x69, 0x73, 0x74, 0x72, 0x69, 0x62,
0x75, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x86, 0x44, 0x68, 0x74, 0x74, 0x70,
0x3a, 0x2f, 0x2f, 0x77, 0x68, 0x69, 0x63, 0x61, 0x33, 0x2e, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2e,
0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x43, 0x65,
0x72, 0x74, 0x45, 0x6e, 0x72, 0x6f, 0x6c, 0x6c, 0x2f, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x25, 0x32,
0x30, 0x49, 0x53, 0x53, 0x55, 0x45, 0x33, 0x25, 0x32, 0x30, 0x43, 0x41, 0x2e, 0x63, 0x72, 0x6c,
0x30, 0x82, 0x01, 0x42, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x82,
0x01, 0x34, 0x30, 0x82, 0x01, 0x30, 0x30, 0x81, 0xbd, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05,
0x07, 0x30, 0x02, 0x86, 0x81, 0xb0, 0x6c, 0x64, 0x61, 0x70, 0x3a, 0x2f, 0x2f, 0x2f, 0x43, 0x4e,
0x3d, 0x4e, 0x54, 0x44, 0x45, 0x56, 0x25, 0x32, 0x30, 0x49, 0x53, 0x53, 0x55, 0x45, 0x33, 0x25,
0x32, 0x30, 0x43, 0x41, 0x2c, 0x43, 0x4e, 0x3d, 0x41, 0x49, 0x41, 0x2c, 0x43, 0x4e, 0x3d, 0x50,
0x75, 0x62, 0x6c, 0x69, 0x63, 0x25, 0x32, 0x30, 0x4b, 0x65, 0x79, 0x25, 0x32, 0x30, 0x53, 0x65,
0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x2c, 0x43, 0x4e, 0x3d, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
0x65, 0x73, 0x2c, 0x43, 0x4e, 0x3d, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74,
0x69, 0x6f, 0x6e, 0x2c, 0x44, 0x43, 0x3d, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2c, 0x44, 0x43, 0x3d,
0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2c, 0x44, 0x43, 0x3d, 0x63, 0x6f, 0x6d,
0x3f, 0x63, 0x41, 0x43, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x65, 0x3f, 0x62,
0x61, 0x73, 0x65, 0x3f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x3d,
0x63, 0x65, 0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x75, 0x74,
0x68, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x30, 0x6e, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07,
0x30, 0x02, 0x86, 0x62, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x68, 0x69, 0x63, 0x61,
0x33, 0x2e, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2e, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66,
0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x43, 0x65, 0x72, 0x74, 0x45, 0x6e, 0x72, 0x6f, 0x6c, 0x6c,
0x2f, 0x57, 0x48, 0x49, 0x43, 0x41, 0x33, 0x2e, 0x6e, 0x74, 0x64, 0x65, 0x76, 0x2e, 0x6d, 0x69,
0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d, 0x5f, 0x4e, 0x54, 0x44, 0x45,
0x56, 0x25, 0x32, 0x30, 0x49, 0x53, 0x53, 0x55, 0x45, 0x33, 0x25, 0x32, 0x30, 0x43, 0x41, 0x28,
0x31, 0x29, 0x2e, 0x63, 0x72, 0x74, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x25, 0x04, 0x18, 0x30,
0x16, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x14, 0x02, 0x02, 0x06, 0x08, 0x2b,
0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x02, 0x30, 0x37, 0x06, 0x03, 0x55, 0x1d, 0x11, 0x04, 0x30,
0x30, 0x2e, 0xa0, 0x2c, 0x06, 0x0a, 0x2b, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x14, 0x02, 0x03,
0xa0, 0x1e, 0x0c, 0x1c, 0x64, 0x61, 0x6e, 0x67, 0x72, 0x69, 0x66, 0x66, 0x40, 0x6e, 0x74, 0x64,
0x65, 0x76, 0x2e, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x2e, 0x63, 0x6f, 0x6d,
0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03,
0x81, 0x81, 0x00, 0x92, 0xe6, 0x34, 0x6a, 0x1b, 0x71, 0xe6, 0x91, 0x4a, 0x92, 0x35, 0x00, 0x2d,
0xe3, 0x20, 0x50, 0x68, 0x01, 0x7d, 0x92, 0xe7, 0xc1, 0x5c, 0xfd, 0x13, 0xb5, 0x49, 0x31, 0xc5,
0xc5, 0x0d, 0x5f, 0xa5, 0xf3, 0xa6, 0xd1, 0xb4, 0x28, 0x7b, 0x70, 0xfd, 0x16, 0xd2, 0x60, 0x3a,
0xa9, 0xa5, 0x39, 0x08, 0xed, 0x36, 0x76, 0xa5, 0x44, 0xf3, 0x45, 0x8e, 0x56, 0x63, 0xd6, 0xfe,
0x0e, 0xbd, 0x41, 0xf0, 0xdf, 0x2c, 0xa7, 0xdf, 0x03, 0xda, 0xf0, 0x35, 0x2f, 0x51, 0xab, 0xa3,
0x0d, 0x94, 0xb2, 0x89, 0x12, 0xe0, 0x30, 0x6f, 0xee, 0x1f, 0x09, 0x21, 0xe4, 0x3e, 0x51, 0x4f,
0xf0, 0x4a, 0xb3, 0x30, 0x87, 0xef, 0x7a, 0x49, 0x2f, 0x0e, 0x30, 0x4d, 0xd0, 0xd5, 0x4b, 0xfc,
0x77, 0xac, 0x81, 0xb8, 0xf1, 0x36, 0xfa, 0x9e, 0xbb, 0x35, 0x5b, 0xf7, 0x4a, 0x5f, 0x81, 0x16,
0x98, 0x27, 0xd7
};

#define cbTestCer sizeof(rgbTestCer)

//
// Function: AllocH
//
LPVOID WINAPI AllocH(
    IN SIZE_T cBytes)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cBytes);
}

//
// Function: FreeH
//
void WINAPI FreeH(
    IN LPVOID pMem)
{
    HeapFree(GetProcessHeap(), 0, pMem);
}

//
// Function: PrintBytes
//
#define CROW 8
void PrintBytes(LPSTR pszHdr, BYTE *pb, DWORD cbSize)
{
    ULONG cb, i;
    CHAR rgsz[1024];

    printf("\n  %s, %d bytes ::\n", pszHdr, cbSize);

    while (cbSize > 0)
    {
        // Start every row with an extra space
        printf(" ");

        cb = min(CROW, cbSize);
        cbSize -= cb;
        for (i = 0; i < cb; i++)
            printf(" %02x", pb[i]);
        for (i = cb; i < CROW; i++)
            printf("   ");
        printf("    '");
        for (i = 0; i < cb; i++)
        {
            if (pb[i] >= 0x20 && pb[i] <= 0x7f)
                printf("%c", pb[i]);
            else
                printf(".");
        }
        printf("\n");
        pb += cb;
    }
}

DWORD TestLogon(void)
{
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hHelperEncryptKey = 0;
    DWORD dwSts = ERROR_SUCCESS;
    DWORD cbCertificate = 0;
    PBYTE pbCertificate = NULL;
    DWORD cbSignature = 0;
    PBYTE pbSignature = NULL;
    HCRYPTPROV hHelperProv = 0;
    HCRYPTKEY hPublicKey = 0;
    DWORD cbPublicKey = 0;
    PBYTE pbPublicKey = NULL;
    HCRYPTHASH hHelperHash = 0;
    DWORD cbEncrypted = 0;
    PBYTE pbEncrypted = NULL;
    DWORD cb = 0;
    DWORD cbEncryptedKey = 0;
    PBYTE pbEncryptedKey = NULL;
    HCRYPTKEY hDecryptKey = 0;

    CAPI_TEST_CASE(CryptAcquireContext(
        &hProv, 
        L"\\\\.\\Gemplus GemPC430 0\\" /*NULL*/, 
        MS_SCARD_PROV, 
        PROV_RSA_FULL, 
        CRYPT_SILENT | CRYPT_MACHINE_KEYSET));

    CAPI_TEST_CASE(CryptGetUserKey(
        hProv, AT_KEYEXCHANGE, &hKey));
    
    //
    // Get the user logon certificate
    //
    CAPI_TEST_CASE(CryptGetKeyParam(
        hKey, KP_CERTIFICATE, NULL, &cbCertificate, 0));

    pbCertificate = AllocH(cbCertificate);

    if (NULL == pbCertificate)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptGetKeyParam(
        hKey, KP_CERTIFICATE, pbCertificate, &cbCertificate, 0));

    PrintBytes("KP_CERTIFICATE", pbCertificate, cbCertificate);

    //
    // Hash the certificate
    //
    CAPI_TEST_CASE(CryptCreateHash(
        hProv, CALG_MD5, 0, 0, &hHash));

    CAPI_TEST_CASE(CryptHashData(
        hHash, pbCertificate, cbCertificate, 0));

    CAPI_TEST_CASE(CryptSetProvParam(
        hProv, PP_SIGNATURE_PIN, (PBYTE) "0000", 0));

    //
    // Sign the hash
    //
    CAPI_TEST_CASE(CryptSignHash(
        hHash, AT_KEYEXCHANGE, NULL, 0, NULL, &cbSignature))

    pbSignature = AllocH(cbSignature);

    if (NULL == pbSignature)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptSignHash(
        hHash, AT_KEYEXCHANGE, NULL, 0, pbSignature, &cbSignature));

    //
    // Export the public key
    //
    CAPI_TEST_CASE(CryptExportKey(
        hKey, 0, PUBLICKEYBLOB, 0, NULL, &cbPublicKey));

    pbPublicKey = AllocH(cbPublicKey);

    if (NULL == pbPublicKey)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptExportKey(
        hKey, 0, PUBLICKEYBLOB, 0, pbPublicKey, &cbPublicKey));

    //
    // Import the public key into the helper CSP
    //
    CAPI_TEST_CASE(CryptAcquireContext(
        &hHelperProv, NULL, MS_STRONG_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT));

    CAPI_TEST_CASE(CryptImportKey(
        hHelperProv, pbPublicKey, cbPublicKey, 0, 0, &hPublicKey));

    //
    // Now hash the cert with the helper CSP
    //
    CAPI_TEST_CASE(CryptCreateHash(
        hHelperProv, CALG_MD5, 0, 0, &hHelperHash));

    CAPI_TEST_CASE(CryptHashData(
        hHelperHash, pbCertificate, cbCertificate, 0));

    //
    // Verify the signature on our cert hash
    //
    CAPI_TEST_CASE(CryptVerifySignature(
        hHelperHash, pbSignature, cbSignature, hPublicKey, NULL, 0));

    //
    // Derive a session key from the hash
    //
    CAPI_TEST_CASE(CryptDeriveKey(
        hHelperProv, 
        CALG_3DES, 
        hHelperHash, 
        CRYPT_EXPORTABLE, 
        &hHelperEncryptKey));

    //
    // Encrypt the cert with the session key
    //
    cbEncrypted = cbCertificate;

    CAPI_TEST_CASE(CryptEncrypt(
        hHelperEncryptKey, 0, TRUE, 0, NULL, &cbEncrypted, 0));

    pbEncrypted = AllocH(cbEncrypted);

    if (NULL == pbEncrypted)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    memcpy(
        pbEncrypted,
        pbCertificate,
        cbCertificate);

    cb = cbCertificate;

    CAPI_TEST_CASE(CryptEncrypt(
        hHelperEncryptKey, 0, TRUE, 0, pbEncrypted, &cb, cbEncrypted));

    // 
    // Export the encryption key, encrypted with the public key
    //
    CAPI_TEST_CASE(CryptExportKey(
        hHelperEncryptKey, hPublicKey, SIMPLEBLOB, 0, NULL, &cbEncryptedKey));

    pbEncryptedKey = AllocH(cbEncryptedKey);

    if (NULL == pbEncryptedKey)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptExportKey(
        hHelperEncryptKey, 
        hPublicKey, 
        SIMPLEBLOB, 
        0, 
        pbEncryptedKey, 
        &cbEncryptedKey));

    //
    // Import the encrypted session key into the smartcard CSP, decrypting it
    // with the private key
    //
    CAPI_TEST_CASE(CryptImportKey(
        hProv, pbEncryptedKey, cbEncryptedKey, hKey, 0, &hDecryptKey));

    //
    // Decrypt the encrypted certificate using the session key
    //
    CAPI_TEST_CASE(CryptDecrypt(
        hDecryptKey, 0, TRUE, 0, pbEncrypted, &cbEncrypted));

    //
    // Compare the decrypted certificate with the original
    //
    if (cbCertificate != cbEncrypted ||
        0 != memcmp(pbEncrypted, pbCertificate, cbCertificate))
    {
        printf("ERROR: Decrypted cert doesn't match\n");
        dwSts = -1;
    }

Ret:

    if (pbEncrypted)
        FreeH(pbEncrypted);
    if (pbCertificate)
        FreeH(pbCertificate);
    if (pbEncryptedKey)
        FreeH(pbEncryptedKey);
    if (pbSignature)
        FreeH(pbSignature);
    if (pbPublicKey)
        FreeH(pbPublicKey);

    if (hDecryptKey)
        CryptDestroyKey(hDecryptKey);
    if (hKey)
        CryptDestroyKey(hKey);
    if (hPublicKey)
        CryptDestroyKey(hPublicKey);
    if (hHelperEncryptKey)
        CryptDestroyKey(hHelperEncryptKey);
    if (hHash)
        CryptDestroyHash(hHash);
    if (hHelperHash)
        CryptDestroyHash(hHelperHash);

    if (hProv)
        CryptReleaseContext(hProv, 0);
    if (hHelperProv)
        CryptReleaseContext(hHelperProv, 0);

    return dwSts;
}

DWORD CheckCertUsageForDefaultContainer(
    PBYTE pbEncodedCert,
    DWORD cbEncodedCert,
    BOOL *pfMakeDefault)
{
    DWORD dwSts = 0;
    PCCERT_CONTEXT pCertCtx = NULL;
    PCERT_ENHKEY_USAGE pUsage = NULL;
    DWORD cbUsage = 0;

    *pfMakeDefault = FALSE;

    pCertCtx = CertCreateCertificateContext(
        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        pbEncodedCert,
        cbEncodedCert);

    if (NULL == pCertCtx)
    {
        dwSts = GetLastError();
        goto Ret;
    }

    if (! CertGetEnhancedKeyUsage(
        pCertCtx,
        0,
        NULL,
        &cbUsage))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    pUsage = (PCERT_ENHKEY_USAGE) AllocH(cbUsage);

    if (NULL == pUsage)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    if (! CertGetEnhancedKeyUsage(
        pCertCtx,
        0,
        pUsage,
        &cbUsage))
    {
        dwSts = GetLastError();
        goto Ret;
    }

    while (pUsage->cUsageIdentifier)
    {
        pUsage->cUsageIdentifier -= 1;

        if (0 == strcmp(
                szOID_KP_SMARTCARD_LOGON,
                pUsage->rgpszUsageIdentifier[pUsage->cUsageIdentifier]) ||
            0 == strcmp(
                szOID_ENROLLMENT_AGENT,
                pUsage->rgpszUsageIdentifier[pUsage->cUsageIdentifier]))
        {
            *pfMakeDefault = TRUE;
        }
    }

Ret:

    if (pUsage)
        FreeH(pUsage);
    if (pCertCtx)
        CertFreeCertificateContext(pCertCtx);

    return dwSts;
}


DWORD TestEnrollment(void)
{
    HCRYPTPROV hProv = 0;
    DWORD dwSts = 0;
    DWORD dwData = 0;
    DWORD cbData = 0;
    PROV_ENUMALGS_EX EnumalgsEx;
    DWORD dwFlags = 0;
    HCRYPTKEY hKey = 0;
    PBYTE pbData = NULL;
    LPSTR szContainer = NULL;
    LPSTR szName = NULL;
    HCRYPTHASH hHash = 0;
    BOOL fDefault = FALSE;

    memset(&EnumalgsEx, 0, sizeof(EnumalgsEx));

    CAPI_TEST_CASE(CryptAcquireContext(
        &hProv, NULL, MS_SCARD_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT));

    // Used only for enrollment station - filtering for smartcard CSP's
    cbData = sizeof(DWORD);
    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_IMPTYPE, (PBYTE) &dwData, &cbData, 0));

    printf(" ImpType: %d\n", dwData);

    cbData = sizeof(DWORD);
    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_KEYSPEC, (PBYTE) &dwData, &cbData, 0));

    printf(" Keyspec: %d\n", dwData);

    cbData = sizeof(DWORD);
    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_PROVTYPE, (PBYTE) &dwData, &cbData, 0));

    printf(" Provtype: %d\n", dwData);

    cbData = 0;
    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_NAME, NULL, &cbData, 0));

    szName = (LPSTR) AllocH(cbData);

    if (NULL == szName)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_NAME, (PBYTE) szName, &cbData, 0));

    printf(" Prov name: %s\n", szName);

    dwFlags = CRYPT_FIRST;
    cbData = sizeof(EnumalgsEx);

    while (CryptGetProvParam(
        hProv, PP_ENUMALGS_EX, (PBYTE) &EnumalgsEx, &cbData, dwFlags))
    {
        printf(" %s\n", EnumalgsEx.szName);
        dwFlags = 0;
    }

    if (ERROR_NO_MORE_ITEMS != (dwSts = GetLastError()))
    {
        if (ERROR_SUCCESS == dwSts)
            dwSts = -1;

        goto Ret;
    }

    dwSts = ERROR_SUCCESS;

    CAPI_TEST_CASE(CryptReleaseContext(hProv, 0));
    hProv = 0;
    
    CAPI_TEST_CASE(CryptAcquireContext(
        &hProv, NULL, MS_SCARD_PROV, PROV_RSA_FULL, CRYPT_NEWKEYSET));

    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_CONTAINER, NULL, &cbData, 0));

    szContainer = (LPSTR) AllocH(cbData);

    if (NULL == szContainer)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_CONTAINER, (PBYTE) szContainer, &cbData, 0));

    printf(" Container name: %s\n", szContainer);

    FreeH(szContainer);
    szContainer = NULL;

    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_UNIQUE_CONTAINER, NULL, &cbData, 0));

    szContainer = (LPSTR) AllocH(cbData);

    if (NULL == szContainer)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    
    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_UNIQUE_CONTAINER, (PBYTE) szContainer, &cbData, 0));

    printf(" Unique container: %s\n", szContainer);

    // Eliminate the SetProv step to force the CSP to show pin UI
    /*
    CAPI_TEST_CASE(CryptSetProvParam(
        hProv, PP_SIGNATURE_PIN, (PBYTE) "0000", 0));
        */

    CAPI_TEST_CASE(CryptGenKey(
        hProv, AT_KEYEXCHANGE, 0, &hKey));

    //
    // Test creating and signing a hash
    //
    CAPI_TEST_CASE(CryptCreateHash(
        hProv, CALG_SHA, 0, 0, &hHash));

    CAPI_TEST_CASE(CryptSignHash(
        hHash, AT_KEYEXCHANGE, NULL, 0, NULL, &cbData));

    pbData = AllocH(cbData);

    if (NULL == pbData)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptSignHash(
        hHash, AT_KEYEXCHANGE, NULL, 0, pbData, &cbData));

    PrintBytes("Signature blob", pbData, cbData);

    CAPI_TEST_CASE(CryptVerifySignature(
        hHash, pbData, cbData, hKey, NULL, 0));

    CAPI_TEST_CASE(CryptDestroyHash(hHash));
    hHash = 0;

    FreeH(pbData);
    pbData = NULL;

    //
    // Test writing a reading a user certificate
    //

    dwSts = CheckCertUsageForDefaultContainer(
        rgbTestCer,
        sizeof(rgbTestCer),
        &fDefault);

    if (ERROR_SUCCESS != dwSts)
        goto Ret;

    CAPI_TEST_CASE(CryptSetKeyParam(
        hKey, KP_CERTIFICATE, rgbTestCer, 0));

    CAPI_TEST_CASE(CryptGetKeyParam(
        hKey, KP_CERTIFICATE, NULL, &cbData, 0));

    pbData = AllocH(cbData);

    if (NULL == pbData)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptGetKeyParam(
        hKey, KP_CERTIFICATE, pbData, &cbData, 0));

    PrintBytes("KP_CERTIFICATE", pbData, cbData);

    FreeH(pbData);
    pbData = NULL;

    CAPI_TEST_CASE(CryptDestroyKey(hKey));
    hKey = 0;

    //
    // Test exporting a public key
    //
    CAPI_TEST_CASE(CryptGetUserKey(
        hProv, AT_KEYEXCHANGE, &hKey));

    CAPI_TEST_CASE(CryptExportKey(
        hKey, 0, PUBLICKEYBLOB, 0, NULL, &cbData));

    pbData = AllocH(cbData);

    if (NULL == pbData)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }

    CAPI_TEST_CASE(CryptExportKey(
        hKey, 0, PUBLICKEYBLOB, 0, pbData, &cbData));

    PrintBytes("PUBLICKEYBLOB", pbData, cbData);

    FreeH(pbData);
    pbData = NULL;

    CAPI_TEST_CASE(CryptDestroyKey(hKey));
    hKey = 0;

Ret:
    if (hHash)
        CryptDestroyHash(hHash);
    if (hKey)
        CryptDestroyKey(hKey);
    if (hProv)
        CryptReleaseContext(hProv, 0);
    if (pbData)
        FreeH(pbData);
    if (szName)
        FreeH(szName);

    return dwSts;
}

DWORD TestCertPropagation(void)
{
    DWORD dwSts = ERROR_SUCCESS;
    HCRYPTPROV hProv = 0;
    HCRYPTKEY hKey = 0;
    PBYTE pbCert = NULL;
    DWORD cbCert = 0;

    CAPI_TEST_CASE(CryptAcquireContext(
        &hProv, 
        /*L"\\\\.\\GemPlus SCR 500\\My Big - long container"*/ NULL, 
        MS_SCARD_PROV, 
        PROV_RSA_FULL, 
        0));

    CAPI_TEST_CASE(CryptGetUserKey(
        hProv, AT_KEYEXCHANGE, &hKey));

    CAPI_TEST_CASE(CryptGetKeyParam(
        hKey, KP_CERTIFICATE, NULL, &cbCert, 0));

    pbCert = AllocH(cbCert);

    if (NULL == pbCert)
    {
        dwSts = ERROR_NOT_ENOUGH_MEMORY;
        goto Ret;
    }
    
    CAPI_TEST_CASE(CryptGetKeyParam(
        hKey, KP_CERTIFICATE, pbCert, &cbCert, 0));

    PrintBytes("User Cert", pbCert, cbCert);

Ret:
    if (pbCert)
        FreeH(pbCert);

    return dwSts;
}

DWORD Cleanup(void)
{
    DWORD dwSts = ERROR_SUCCESS;
    HCRYPTPROV hProv = 0;
    CHAR rgszContainer [MAX_PATH];
    DWORD cbContainer = sizeof(rgszContainer);

    CAPI_TEST_CASE(CryptAcquireContext(
        &hProv, NULL, MS_SCARD_PROV, PROV_RSA_FULL, 0));

    CAPI_TEST_CASE(CryptGetProvParam(
        hProv, PP_CONTAINER, (PBYTE) rgszContainer, &cbContainer, 0));

    CAPI_TEST_CASE(CryptReleaseContext(hProv, 0));

    printf("Deleting default container ...\n");

    CAPI_TEST_CASE(CryptAcquireContextA(
        &hProv, rgszContainer, MS_SCARD_PROV_A, PROV_RSA_FULL, CRYPT_DELETEKEYSET));

Ret:

    return dwSts;
}

void DisplayHelp(void)
{
    printf("Usage: scnarios [option]\n");
    printf(" -1 : Test simulated enrollment\n");
    printf(" -2 : Test simulated certificate propagation\n");
    printf(" -3 : Test simulated logon\n");
    printf(" -c : Cleanup (delete default container)\n");
}

int _cdecl main(int argc, char * argv[])
{
    DWORD dwSts = ERROR_SUCCESS;
    BOOL fDisplayHelp = FALSE;

    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case '1':

                dwSts = TestEnrollment();

                if (ERROR_SUCCESS != dwSts)
                    goto Ret;

                break;

            case '2':

                dwSts = TestCertPropagation();

                if (ERROR_SUCCESS != dwSts)
                    goto Ret;

                break;

            case '3':

                dwSts = TestLogon();

                if (ERROR_SUCCESS != dwSts)
                    goto Ret;

                break;

            case 'c':

                dwSts = Cleanup();

                if (ERROR_SUCCESS != dwSts)
                    goto Ret;

                break;

            case '?':
                fDisplayHelp = TRUE;
                break;

            default:
                printf("Invalid args\n");
                fDisplayHelp = TRUE;
                goto Ret;
            }
        }
    }

Ret:
    
    if (TRUE == fDisplayHelp)
    {
        DisplayHelp();
    }
    else
    {
        if (ERROR_SUCCESS != dwSts)
            printf(" failed, 0x%x\n", dwSts);
        else 
            printf("Success.\n");
    }

    return 0;
}

