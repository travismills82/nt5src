//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       drs.idl
//
//--------------------------------------------------------------------------

/*
**                       Important version information
**                      -------------------------------
**
**  Down-level clients are orphaned whenever the IDL major version number in
**  the version() field of the interface header is changed, which is hence to
**  be avoided to retain backward compatibility.  This interface facilitates
**  backward compatibility by incorporating bind-time version information and
**  an extensible message format.
**
**  To safely extend the interface, you _cannot_:
**
**      o   redefine existing structures,
**      o   reorder the functions in the interface (e.g., by inserting a new
**          function at the top), or
**      o   change the parameters of existing functions.
**
**  You _can_:
**
**      o   add new structures,
**      o   add new functions _to_the_end_of_the_list_, and
**      o   add new members to unions (e.g., new DRS_MSG_XXX_VN elements).
**
**  The trick is you cannot use any of your extensions when talking to a
**  down-level client or server that does not understand them.  How do you
**  know if the other half of the connection understands your extensions?
**  Through bind-time version information.
**
**  A set of bit flags is passed from client to server when IDL_DRSBind is
**  called, and a similar set of flags is returned to the client.  When a
**  new extension is added, a bit number is defined for it in this IDL file
**  (see the DRS_EXT_* enum below).  Each end of the connection can then
**  test for the bit (via IS_DRS_EXT_SUPPORTED()) in its copy of the other's
**  extensions set.
**
**  If you do find it necessary to make a change that orphans existing clients
**  (which should _never_ happen once the first retail version is shipped),
**  you must increment the major version number below.  You must also increment
**  the version in the IfHandle #define's, just below that.  You can then
**  eliminate all currently defined extensions and modify the existing code
**  that checks for these extensions to assume those that are supported by the
**  current code base.
**
**  If you extend the interface without orphaning existing clients, be sure to:
**
**      o   add a new DRS_EXT_* to the extensions enum,
**      o   always use IS_DRS_EXT_SUPPORTED() against the remote extension set
**          before taking advantage of your extension, and
**      o   heed the can's and cannot's above.
**
**  NOTE: IF YOU ADD A FUNCTION TO THIS INTERFACE, be sure to add a
**  corresponding [notify] entry to DRS.ACF (and an IDL_DRSxxx_notify()
**  function to dsamain\drsserv\idlnotif.c).  This ensures that thread states
**  are properly freed on thread termination.
**
**  Note that the sender always determines the message version it sends to the
**  other end.  This is especially important in the case where the server sends
**  a response message to the client, as it allows the client and server to
**  negotiate a return message version, rather than having it specified up-
**  front by the client.  (I.e., in the "sender determines" case we can always
**  have the client request a specific version, but if the server disagrees it
**  can return a different version without having to tell the client "no, send
**  me another packet with a different message level in the request".  The
**  server has the client's extensions set, and thus knows what versions of each
**  message the client expects and supports.  If the server tries to return a
**  message level that the client doesn't handle, the client will blow up in RPC
**  before control ever returns to drsuapi.c.  In the extensions set model, it
**  is the responsibility of both the client and the server not to send message
**  versions down the pipe that the other end does not understand, and it's
**  the existence of the extensions set on both ends that allows them to
**  make that determination.  If either end of the connection were not
**  backwards compatible, we would not be able to mix and match, say, NT6
**  with NT5 DSAs, as a single binary image of ntdsa.dll must always act as
**  both a client and a server with other DSAs in the enterprise.
**
**  Recommendations:  Use explicit pointer types on all variables.  Use [ref] 
**  whenever applicable (input cannot be NULL), and do not use [ptr] at all if 
**  possible (this allows aliasing, and unless used exactly right, can be a 
**  security concern).  Do not use linked lists.  Pass arrays of objects bound
**  with a size_is parameter.  Use [range(0,something)] on *all* parameters 
**  used with a size_is clause.  If you add new message types, please follow
**  these standards.
**
**  SECURITY NOTE:  Input validation security is done with [unique],[ref],etc.  
**  In order to make the security more explicit, don't leave any MIDL datatypes 
**  as a default.  All DRS_HANDLES should be of type [ref], and all MSG types
**  should also be [ref].  Ideally, datatypes should be declared so that
**  all validation can be done by RPC.  Regardless, if you extend or add to an interface
**  you must create corresponding validation functions.  Use IDL_DRSReplicaSync, 
**  DRSReplicaSync_InputValidate, DRS_MSG_REPSYNC_V1_Validate, etc as a guide and
**  template if you add a new interface function or datatype.  If you modify
**  an interface function or datatype, you may need to modify the corresponding
**  validation functions.
*/

// range constants
#define TEN_THOUSAND_B 10000
#define ONE_MB 1024*1024
#define TEN_MB 10*ONE_MB

#define TEN_THOUSAND_VALUES 10000
#define ONE_MB_VALUES ONE_MB
#define TEN_MB_VALUES TEN_MB

#define MAX_REPLINF_IN_GETCHGREPLY_V6      1024*1024 //MAX_ASYNC_PACKET_BYTES   // maximum number of linked values able to replicate via mail
#define MAX_CB_OF_DRS_COMPRESSED_BLOB      10*1024*1024 //MAX_MAX_PACKET_BYTES     // maximum number of compressed bytes in compression blobs
#define MAX_PDSNAME_IN_VERIFYREQ_V1        TEN_THOUSAND_VALUES            // maximum number of names to verify with verify names
#define MAX_PDSNAME_IN_VERIFYREPLY_V1      MAX_PDSNAME_IN_VERIFYREQ_V1
#define MAX_DSNAME_IN_REVMEMB_REQ_V1       TEN_THOUSAND_VALUES            // maximum number of reverse membership retreival names.
#define MAX_DSNAME_IN_REVMEMB_REPLY_V1     MAX_DSNAME_IN_REVMEMB_REQ_V1 
#define MAX_SID_IN_REVMEMB_REPLY_V1        TEN_THOUSAND_VALUES            // maximum number of sid histories returned in reverse membership retreval
#define MAX_CB_OF_BUFFER_IN_DRS_SECBUFF    TEN_THOUSAND_B                   // maximum bytes of SecBuffer
#define MAX_DRS_SECBUFFER_IN_SECBUFFDESC   TEN_THOUSAND_VALUES            // maximum number of SecBuffer in SecBufferDesc
#define MAX_WCHAR_IN_CRACKREQ_V1           TEN_THOUSAND_VALUES            // maximum number of names to crack
#define MAX_CB_OF_RESTART_CHGLOG_REQ_V1    TEN_MB                   // maximum bytes of nt4 changelog request restart package
#define MAX_BYTES_OF_RESTART_CHGLOG_REPLY_V1 MAX_CB_OF_RESTART_CHGLOG_REQ_V1
#define MAX_BYTES_OF_LOG_CHGLOG_REPLY_V1   TEN_MB                   // maximum bytes of nt4 change log in reply
#define MAX_WCHAR_IN_SPNREQ_V1             TEN_THOUSAND_VALUES            // maximum size of the SPN string for SPN requests
#define MAX_DOM_CNTRLR_INFO_1W_IN_DCINOFREPLY_V1 TEN_THOUSAND_VALUES      // maximum dc's to return info for
#define MAX_DOM_CNTRLR_INFO_2W_IN_DCINOFREPLY_V2 MAX_DOM_CNTRLR_INFO_1W_IN_DCINOFREPLY_V1
#define MAX_DOM_CNTRLR_INFO_FFFFFFFFW_IN_DCINOFREPLY_VFFFFFFFF MAX_DOM_CNTRLR_INFO_1W_IN_DCINOFREPLY_V1
#define MAX_ADDENTRY_REPLY_INFO_IN_ADDENTRYREPLY_V2 TEN_THOUSAND_VALUES   // maximum number of objects to add
#define MAX_ADDENTRY_REPLY_INFO_IN_ADDENTRYREPLY_V3 MAX_ADDENTRY_REPLY_INFO_IN_ADDENTRYREPLY_V2
#define MAX_CLIENT_CONTEXTS                TEN_THOUSAND_VALUES            // maximum number of client contexts to return/have
#define MAX_OUTGOING_CALLS                 256 //BHCacheSize              // maximum number of outgoing calls
#define MAX_WCHAR_OF_SRCCREDS_USR_IN_ADDSIDREQ_V1 256               // maximum size of * for credentials
#define MAX_WCHAR_OF_SRCCREDS_DMN_IN_ADDSIDREQ_V1 256              
#define MAX_WCHAR_OF_SRCCREDS_PWD_IN_ADDSIDREQ_V1 256              
#define MAX_REVMEMB_REQ_V1_IN_GETMEMB2_REQ_V1 TEN_THOUSAND_VALUES         // maximum number of getmembership2 requests
#define MAX_REVMEMB_REPLY_V1_IN_GETMEMB2_REPLY_V1 MAX_REVMEMB_REQ_V1_IN_GETMEMB2_REQ_V1
#define MAX_UUID_IN_EXISTREPLY_V1          TEN_MB_VALUES            // maximum number of object to check existence simultaneously
#define MAX_WCHAR_IN_QUERY_SITESREQ_V1     TEN_THOUSAND_VALUES            // maximum number of sites to query cost by
#define MAX_WCHAR_IN_QUERY_SITESREPLY_V1   MAX_WCHAR_IN_QUERY_SITESREQ_V1
#define MAX_CB_OF_PASSWORD_IN_EXECUTE_SCPT_REQ_V1 1024            // maximum size of password
#define MAX_CB_OF_PASSWORD_IN_PRPRE_SCPT_REPLY_V1 MAX_CB_OF_PASSWORD_IN_EXECUTE_SCPT_REQ_V1
#define MAX_CB_OF_HASHBOD_IN_PRPRE_SCPT_REPLY_V1 TEN_MB             // maximum size of hash body
#define MAX_CB_OF_HASHSIG_IN_PRPRE_SCPT_REPLY_V1 TEN_MB             // maximum size of hash sig

// This interface is solely for those structures that need to be encoded and
// decoded -- i.e., those sent/received during mail-based replication.
// They must be defined in a seperate interface due to MIDL bug 339196.
[
        uuid (0a215117-0993-11d3-96a6-0000f8080663), version(4.0),
        pointer_default (unique)
] interface drsuapi_pickle
{
import "wtypes.idl";
import "ntdsimp.idl";   // a means to get data structures in ntdsapi.h

// Embedded structure inside mail-based requests.
typedef struct _DRS_MSG_GETCHGREQ_V3
{
         UUID                uuidDsaObjDest;         // GUID of destination (i.e., calling) DSA's msftDSA obj
         UUID                uuidInvocIdSrc;         // invocationID of source (i.e., called) DSA

[ref]    PDSNAME             pNC;                    // from which NC are changes requested?
         USN_VECTOR          usnvecFrom;             // send changes made after this point
[unique] UPTODATE_VECTOR_V1_WIRE *pUpToDateVecDestV1; // destination propagation state (for filtering)
[unique] PARTIAL_ATTR_VECTOR_V1_EXT *pPartialAttrVecDestV1;   // destination partial attribute vector (NULL if dest is a full replica)
         SCHEMA_PREFIX_TABLE PrefixTableDest;        // destination prefix table (for mapping destination
                                                     //   ATTRTYPs to source ATTRTYPs)
         ULONG               ulFlags;

         ULONG               cMaxObjects;            // preferred maximum number of object changes
         ULONG               cMaxBytes;              // preferred maximum number of bytes in reply

         ULONG               ulExtendedOp;           // holds flags for extended operations;
                                                     // e.g., a FSMO transfer request
} DRS_MSG_GETCHGREQ_V3, *PDRS_MSG_GETCHGREQ_V3;

// Win2k format to request updates via mail.  V3 plus a few fields needed only
// for asynchronous replication.
typedef struct _DRS_MSG_GETCHGREQ_V4
{
        UUID                  uuidTransportObj;   // uuid of transport by which to send reply
[ref]   MTX_ADDR *            pmtxReturnAddress;  // transport-specific address to which to send reply
        DRS_MSG_GETCHGREQ_V3  V3;                 // the V3 request
} DRS_MSG_GETCHGREQ_V4, *PDRS_MSG_GETCHGREQ_V4;

// Mail-based Whistler request.
// Note that for mail requests, there is no bind negotiation.
// New versions must always be supersets of prior.
typedef struct _DRS_MSG_GETCHGREQ_V7
{
        // \/ \/ \/ V4 fields from Win2k
        UUID                  uuidTransportObj;   // uuid of transport by which to send reply
[ref]   MTX_ADDR *            pmtxReturnAddress;  // transport-specific address to which to send reply
        DRS_MSG_GETCHGREQ_V3  V3;                 // the V3 request
        // /\ /\ /\ V4 fields from Win2k 

        // \/ \/ \/ Fields added for Whistler
[unique] PARTIAL_ATTR_VECTOR_V1_EXT *pPartialAttrSet;    // destination partial attribute vector
[unique] PARTIAL_ATTR_VECTOR_V1_EXT *pPartialAttrSetEx;  // Extended dest partial attribute vector
         SCHEMA_PREFIX_TABLE PrefixTableDest;        // destination prefix table (for mapping destination
                                                     //   ATTRTYPs to source ATTRTYPs)
        // <--- Put new Whistler-release changes here
        // /\ /\ /\ Fields added for Whistler
} DRS_MSG_GETCHGREQ_V7, *PDRS_MSG_GETCHGREQ_V7;

// Win2k format get changes reply.
typedef struct _DRS_MSG_GETCHGREPLY_V1
{
         UUID                   uuidDsaObjSrc;      // GUID of source (i.e., called) DSA's msftDSA obj
         UUID                   uuidInvocIdSrc;     // invocationID of source (i.e., called) DSA

[unique] PDSNAME                pNC;                // from which NC were changes requested?
         USN_VECTOR             usnvecFrom;         // state before these changes are applied
                                                    //   this is used in mail replication to ensure that
                                                    //   the packet of changes received is the same as
                                                    //   that which was last requested
         USN_VECTOR             usnvecTo;           // state after these changes are applied
[unique] UPTODATE_VECTOR_V1_WIRE *pUpToDateVecSrcV1;// source propagation state (for use in updating dest vector)
         SCHEMA_PREFIX_TABLE    PrefixTableSrc;     // source prefix table (for mapping source
                                                    //   ATTRTYPs to destination ATTRTYPs)

         ULONG                  ulExtendedRet;      // return code from extended op

         ULONG                  cNumObjects;        // number of objects returned

                                                    // ISSUE:  BAD FORM:  if we know "cNumObjects", then
                                                    // why use a linked list, why not an array?
                                                    // with the linked list we can't get RPC to
                                                    // validate size for us.  So we have to do this
                                                    // ourselves in the code (ie count=
                                                    // number of elements(FirstAnyVal))

         ULONG                  cNumBytes;

                                                    // ISSUE:  BAD FORM:  We'd really like RPC to do
                                                    // all applicable validation, but it can't do this, 
                                                    // so to validate this value, we have to calculate
                                                    // the bytes ourselves and then why send it at all?

[unique] REPLENTINFLIST *       pObjects;           // returned linked-list of objects

         BOOL                   fMoreData;          // is there more data to be retrieved?
} DRS_MSG_GETCHGREPLY_V1;

// Whistler format get changes reply -- V3 + UTD V2 support + reply status.
typedef struct _DRS_MSG_GETCHGREPLY_V6 {
         // \/ \/ \/ V1 fields from Win2k -- except for UTD vec, which is now V2
         UUID                   uuidDsaObjSrc;      // GUID of source (i.e., called) DSA's msftDSA obj
         UUID                   uuidInvocIdSrc;     // invocationID of source (i.e., called) DSA

[unique] PDSNAME                pNC;                // from which NC were changes requested?
         USN_VECTOR             usnvecFrom;         // state before these changes are applied
                                                    //   this is used in mail replication to ensure that
                                                    //   the packet of changes received is the same as
                                                    //   that which was last requested
         USN_VECTOR             usnvecTo;           // state after these changes are applied
[unique] UPTODATE_VECTOR_V2_WIRE *pUpToDateVecSrc;  // source propagation state (for use in updating dest vector)
         SCHEMA_PREFIX_TABLE    PrefixTableSrc;     // source prefix table (for mapping source
                                                    //   ATTRTYPs to destination ATTRTYPs)

         ULONG                  ulExtendedRet;      // return code from FSMO operation

         ULONG                  cNumObjects;        // number of objects returned

                                                    // ISSUE:  See BAD FORM in DRS_MSG_GETCHGREPLY_V1

         ULONG                  cNumBytes;

                                                    // ISSUE:  See BAD FORM in DRS_MSG_GETCHGREPLY_V1

[unique] REPLENTINFLIST *       pObjects;           // returned linked-list of objects

         BOOL                   fMoreData;          // is there more data to be retrieved?
         // /\ /\ /\ V1 fields from Win2k -- except for UTD vec, which is now V2
         
         // \/ \/ \/ Fields added for Whistler beta 1
         ULONG                  cNumNcSizeObjects;   // Estimate of # objects in nc
         ULONG                  cNumNcSizeValues;    // Estimate of # values in nc
[range(0, MAX_REPLINF_IN_GETCHGREPLY_V6)]        
         DWORD                  cNumValues;          // Number of values returned
[size_is(cNumValues)] REPLVALINF *rgValues;          // returned array of values
         // /\ /\ /\ Fields added for Whistler beta 1 

         // \/ \/ \/ Fields added for Whistler beta 2
         DWORD                  dwDRSError;
         // /\ /\ /\ Fields added for Whistler beta 2
         
} DRS_MSG_GETCHGREPLY_V6;

}


// This is the "real" drsuapi interface.
[
        uuid (e3514235-4b06-11d1-ab04-00c04fc2dcd2), version(4.0),
        pointer_default (unique)
] interface drsuapi
{
import "wtypes.idl";
import "ntdsimp.idl";   // a means to get data structures in ntdsapi.h

cpp_quote("#define DRS_IDL_UUID_A \"E3514235-4B06-11D1-AB04-00C04FC2DCD2\"")
cpp_quote("#define DRS_IDL_UUID_W L\"E3514235-4B06-11D1-AB04-00C04FC2DCD2\"")

/* define a version independent constant for the interface spec  */
cpp_quote("#define drsuapi_ClientIfHandle drsuapi_v4_0_c_ifspec")
cpp_quote("#define _drsuapi_ClientIfHandle _drsuapi_v4_0_c_ifspec")
cpp_quote("#define drsuapi_ServerIfHandle drsuapi_v4_0_s_ifspec")

typedef [context_handle] void * DRS_HANDLE;

// Define a GUID which the ntdsapi.dll client will use as the puuidClientDsa
// parameter when calling IDL_DRSBind.
cpp_quote("#define NtdsapiClientGuid {0xe24d201a,0x4fd6,0x11d1,{0xa3,0xda,0x00,0x00,0xf8,0x75,0xae,0x0d}}")


// Solely to satisfy MIDL enough to honor our drs.acf request for it to build
// an encoding routine, even though the structure is not defined in this IDL.
// (It's defined in ntdsa.h.)
typedef REPLENTINFLIST REPLENTINFLIST2;
cpp_quote("#define REPLENTINFLIST_AlignSize REPLENTINFLIST2_AlignSize")
typedef REPLVALINF REPLVALINF2;
cpp_quote("#define REPLVALINF_AlignSize REPLVALINF2_AlignSize")

//
// Compressed data blob.  Compression/uncompression performed by
// draCompressBlob()/draUncompressBlob().
//
// PORTABILITY WARNING: See notes in draCompressBlob() regarding embedded
// 32-bit integers.  Intel/NT byte ordering (i.e., little-endian) is assumed.
//
typedef struct _DRS_COMPRESSED_BLOB {
                                DWORD   cbUncompressedSize;
    [range(1, MAX_CB_OF_DRS_COMPRESSED_BLOB)]
                                DWORD   cbCompressedSize;
    [size_is(cbCompressedSize)] BYTE *  pbCompressedData;
} DRS_COMPRESSED_BLOB;


// Request updates via RPC -- V3 + llFsmoInfo - partial attr vec - prefix table.
typedef struct _DRS_MSG_GETCHGREQ_V5
{
         UUID                uuidDsaObjDest;         // GUID of destination (i.e., calling) DSA's msftDSA obj
         UUID                uuidInvocIdSrc;         // invocationID of source (i.e., called) DSA

[ref]    PDSNAME             pNC;                    // from which NC are changes requested?
         USN_VECTOR          usnvecFrom;             // send changes made after this point
[unique] UPTODATE_VECTOR_V1_WIRE *pUpToDateVecDestV1; // destination propagation state (for filtering)
         ULONG               ulFlags;

         ULONG               cMaxObjects;            // preferred maximum number of object changes
         ULONG               cMaxBytes;              // preferred maximum number of bytes in reply

         ULONG               ulExtendedOp;           // holds flags for extended operations;
                                                     // e.g., a FSMO transfer request

         ULARGE_INTEGER      liFsmoInfo;             // Information for the FSMO master

} DRS_MSG_GETCHGREQ_V5, *PDRS_MSG_GETCHGREQ_V5;


// Request updates via RPC V8 -- V5 + partial attr vecs + prefix table
typedef struct _DRS_MSG_GETCHGREQ_V8
{
         UUID                uuidDsaObjDest;         // GUID of destination (i.e., calling) DSA's msftDSA obj
         UUID                uuidInvocIdSrc;         // invocationID of source (i.e., called) DSA

[ref]    PDSNAME             pNC;                    // from which NC are changes requested?
         USN_VECTOR          usnvecFrom;             // send changes made after this point
[unique] UPTODATE_VECTOR_V1_WIRE *pUpToDateVecDest;  // destination propagation state (for filtering)
         ULONG               ulFlags;

         ULONG               cMaxObjects;            // preferred maximum number of object changes
         ULONG               cMaxBytes;              // preferred maximum number of bytes in reply

         ULONG               ulExtendedOp;           // holds flags for extended operations;
                                                     // e.g., a FSMO transfer request

         ULARGE_INTEGER      liFsmoInfo;             // Information for the FSMO master
[unique] PARTIAL_ATTR_VECTOR_V1_EXT *pPartialAttrSet; // destination partial attribute vector
[unique] PARTIAL_ATTR_VECTOR_V1_EXT *pPartialAttrSetEx;  // Extended dest partial attribute vector
         SCHEMA_PREFIX_TABLE PrefixTableDest;        // destination prefix table (for mapping destination
                                                     //   ATTRTYPs to source ATTRTYPs)

} DRS_MSG_GETCHGREQ_V8, *PDRS_MSG_GETCHGREQ_V8;

// Does the DSA support DRS_MSG_GETCHGREQ_V5?
cpp_quote("#define IS_DRS_GETCHGREQ_V5_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_GETCHGREQ_V5)")

// Does the DSA support DRS_MSG_GETCHGREQ_V8?
cpp_quote("#define IS_DRS_GETCHGREQ_V8_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_GETCHGREQ_V8)")

// Native request message format.
typedef DRS_MSG_GETCHGREQ_V8 DRS_MSG_GETCHGREQ_NATIVE;
cpp_quote("#define DRS_MSG_GETCHGREQ_NATIVE_VERSION (8)")

typedef [switch_type(DWORD)] union _DRS_MSG_GETCHGREQ
{
    // [case(1)]   DRS_MSG_GETCHGREQ_V1   V1;   // obsolete pre-Win2k RC1 format
    // [case(2)]   DRS_MSG_GETCHGREQ_V2   V2;   // obsolete mail format
    // [case(3)]   DRS_MSG_GETCHGREQ_V3   V3;   // obsolete pre-Win2k RC2 format
    [case(4)]   DRS_MSG_GETCHGREQ_V4   V4;      // win2k mail-based request
    [case(5)]   DRS_MSG_GETCHGREQ_V5   V5;      // rpc request, w2k,
    // [case(6)]   DRS_MSG_GETCHGREQ_V6   V6;   // obsolete rpc request, whistler preview 1
    [case(7)]   DRS_MSG_GETCHGREQ_V7   V7;      // mail request, whistler
    [case(8)]   DRS_MSG_GETCHGREQ_V8   V8;      // rpc request, whistler
} DRS_MSG_GETCHGREQ, *PDRS_MSG_GETCHGREQ;

// Native reply message format.
typedef DRS_MSG_GETCHGREPLY_V6 DRS_MSG_GETCHGREPLY_NATIVE;
cpp_quote("#define DRS_MSG_GETCHGREPLY_NATIVE_VERSION (6)")

// Such that if we later change the preferred version for asynchronous
// replication we don't need to change 100 occurrences of _V1 to _Vx.

// A compressed V1 message.
typedef struct _DRS_MSG_GETCHGREPLY_V2
{
    DRS_COMPRESSED_BLOB CompressedV1;
} DRS_MSG_GETCHGREPLY_V2;

// Compression Algorithm Type
// This enumeration is used to identify the compression algorithm that has been used.
typedef enum {
    DRS_COMP_ALG_NONE=0,     // No compression: Raw data
    DRS_COMP_ALG_MRCF,       // Obsolete: formerly used for mail-based replication
    DRS_COMP_ALG_MSZIP,      // MSZIP algorithm (The only algorithm supported by Win2K)
    DRS_COMP_ALG_XPRESS      // Xpress algorithm
} DRS_COMP_ALG_TYPE;

// Compressed reply message
// This message can store a message of any version and allows
// different compression algorithms to be selected.
typedef struct _DRS_MSG_GETCHGREPLY_V7
{
    DWORD               dwCompressedVersion;
    DRS_COMP_ALG_TYPE   CompressionAlg;
    DRS_COMPRESSED_BLOB CompressedAny;
} DRS_MSG_GETCHGREPLY_V7;

// Does the DSA support DRS_MSG_GETCHGREPLY_V2?
cpp_quote("#define IS_DRS_GETCHGREPLY_V2_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_GETCHG_COMPRESS)")

typedef [switch_type(DWORD)] union _DRS_MSG_GETCHGREPLY
{
    [case(1)]   DRS_MSG_GETCHGREPLY_V1  V1; // w2k reply
    [case(2)]   DRS_MSG_GETCHGREPLY_V2  V2;  // Compressed V1
    // [case(3)]   DRS_MSG_GETCHGREPLY_V3  V3;  // Obsolete Whistler Beta 1 reply 
    // [case(4)]   DRS_MSG_GETCHGREPLY_V4  V4;  // Obsolete Whistler Beta 2 Compressed any
    // [case(5)]   DRS_MSG_GETCHGREPLY_V5  V5;  // Obsolete Whistler Beta 2 reply
    [case(6)]   DRS_MSG_GETCHGREPLY_V6  V6; // Whistler reply
    [case(7)]   DRS_MSG_GETCHGREPLY_V7  V7;  // Compressed: any message type, any comp. alg.
} DRS_MSG_GETCHGREPLY, *PDRS_MSG_GETCHGREPLY;

// Does the destination DSA require instance types in the inbound replication
// stream for only new objects, or for all objects?
cpp_quote("#define IS_DRS_INSTANCE_TYPE_REQ_FOR_MODS(pext) !IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_INSTANCE_TYPE_NOT_REQ_ON_MOD)")

// Is the DSA aware of the schema versioning blob stuck into the prefix table?
cpp_quote("#define IS_DRS_SCHEMA_INFO_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_POST_BETA3)")


/*
** Replica sync messages (to trigger inbound replication).
*/

typedef struct _DRS_MSG_REPSYNC_V1
{
    [ref]       DSNAME *    pNC;
                UUID        uuidDsaSrc;
    [unique]    SZ          pszDsaSrc;
                ULONG       ulOptions;
} DRS_MSG_REPSYNC_V1;

typedef  [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_REPSYNC_V1  V1;
} DRS_MSG_REPSYNC;

/*
** Update refs messages (to add/remove an outbound replication target).
*/

typedef struct _DRS_MSG_UPDREFS_V1
{
    [ref]   DSNAME *    pNC;
    [ref]   SZ          pszDsaDest;
            UUID        uuidDsaObjDest;
            ULONG       ulOptions;
} DRS_MSG_UPDREFS_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_UPDREFS_V1  V1;
} DRS_MSG_UPDREFS;

/*
** Replica add messages (to add a new inbound replication source).
*/

typedef struct _DRS_MSG_REPADD_V1
{
    [ref]   DSNAME *    pNC;
    [ref]   SZ          pszDsaSrc;
            REPLTIMES   rtSchedule;
            ULONG       ulOptions;
} DRS_MSG_REPADD_V1;

typedef struct _DRS_MSG_REPADD_V2
{
    [ref]   DSNAME *    pNC;
 [unique]   DSNAME *    pSourceDsaDN;
 [unique]   DSNAME *    pTransportDN;
    [ref]   SZ          pszSourceDsaAddress;
            REPLTIMES   rtSchedule;
            ULONG       ulOptions;
} DRS_MSG_REPADD_V2;

// Does the DSA support DRS_MSG_REPADD_V2?
cpp_quote("#define IS_DRS_REPADD_V2_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_ASYNCREPL)")

typedef  [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_REPADD_V1   V1;
    [case(2)]   DRS_MSG_REPADD_V2   V2;
} DRS_MSG_REPADD;

/*
** Replica delete messages (to remove an inbound replication source).
*/

typedef struct _DRS_MSG_REPDEL_V1
{
    [ref]    DSNAME *    pNC;
             SZ          pszDsaSrc;
             ULONG       ulOptions;
} DRS_MSG_REPDEL_V1;

typedef  [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_REPDEL_V1   V1;
} DRS_MSG_REPDEL;

/*
** Replica modify messages (to modify an inbound replication source).
*/

typedef struct _DRS_MSG_REPMOD_V1
{
    [ref]       DSNAME *    pNC;
                UUID        uuidSourceDRA;
    [unique]    SZ          pszSourceDRA;
                REPLTIMES   rtSchedule;
                ULONG       ulReplicaFlags;
                ULONG       ulModifyFields;
                ULONG       ulOptions;
} DRS_MSG_REPMOD_V1;

typedef  [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_REPMOD_V1   V1;
} DRS_MSG_REPMOD;

/*
** Messages for Verification of DS Names and Sids
*/
cpp_quote("#define DRS_VERIFY_DSNAMES   0")
cpp_quote("#define DRS_VERIFY_SIDS      1")
cpp_quote("#define DRS_VERIFY_SAM_ACCOUNT_NAMES     2")
cpp_quote("#define DRS_VERIFY_FPOS      3")

typedef struct _DRS_MSG_VERIFYREQ_V1
{
                        DWORD               dwFlags;
    [range(1,MAX_PDSNAME_IN_VERIFYREQ_V1)]                    
                        DWORD               cNames;
    [size_is(cNames)]   PDSNAME             *rpNames;
                        ATTRBLOCK           RequiredAttrs;
                        SCHEMA_PREFIX_TABLE PrefixTable;
} DRS_MSG_VERIFYREQ_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_VERIFYREQ_V1  V1;
} DRS_MSG_VERIFYREQ;

typedef struct _DRS_MSG_VERIFYREPLY_V1
{
                        DWORD               error;
    [range(0,MAX_PDSNAME_IN_VERIFYREPLY_V1)]
                        DWORD               cNames;
    [size_is(cNames)]   ENTINF              *rpEntInf;
                        SCHEMA_PREFIX_TABLE PrefixTable;
} DRS_MSG_VERIFYREPLY_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_VERIFYREPLY_V1  V1;
} DRS_MSG_VERIFYREPLY;

/*
** Transitive Reverse Membership Retreive Request Message
*/

cpp_quote("#define DRS_REVMEMB_FLAG_GET_ATTRIBUTES   0x1")

// if you add, remove, or re-order this enumeration, be
// sure to modify the range in DRS_MSG_REVMEMB_REQ_V1
typedef enum
{
    RevMembGetGroupsForUser=1,
    RevMembGetAliasMembership,
    RevMembGetAccountGroups,
    RevMembGetResourceGroups,
    RevMembGetUniversalGroups,
    GroupMembersTransitive,
    RevMembGlobalGroupsNonTransitive
} REVERSE_MEMBERSHIP_OPERATION_TYPE;

typedef struct _DRS_MSG_REVMEMB_REQ_V1
{
    [range(1,MAX_DSNAME_IN_REVMEMB_REQ_V1)]
                            ULONG      cDsNames;
    [size_is(cDsNames,)]    DSNAME     **ppDsNames;
                            DWORD      dwFlags;
    [range(RevMembGetGroupsForUser, RevMembGlobalGroupsNonTransitive)]
 REVERSE_MEMBERSHIP_OPERATION_TYPE     OperationType;
                            PDSNAME    pLimitingDomain;
} DRS_MSG_REVMEMB_REQ_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_REVMEMB_REQ_V1 V1;
} DRS_MSG_REVMEMB_REQ;


/*
** Transitive Reverse Membership Retreive Reply Packet
*/


typedef struct _DRS_MSG_REVMEMB_REPLY_V1
{
    ULONG   errCode;
    [range(0,MAX_DSNAME_IN_REVMEMB_REPLY_V1)]
       ULONG   cDsNames;
    [range(0,MAX_SID_IN_REVMEMB_REPLY_V1)]
       ULONG   cSidHistory;
    [size_is(cDsNames,)] DSNAME **ppDsNames;
    [size_is(cDsNames)]  DWORD   *pAttributes;
    [size_is(cSidHistory,)] NT4SID **ppSidHistory;

} DRS_MSG_REVMEMB_REPLY_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_REVMEMB_REPLY_V1 V1;
} DRS_MSG_REVMEMB_REPLY;

// Cross-Domain Move Message Request/Reply Blocks

typedef struct _DRS_MSG_MOVEREQ_V1
{
              CHAR                *pSourceDSA;
              ENTINF              *pObject;
              UUID                *pParentUUID;
              SCHEMA_PREFIX_TABLE PrefixTable;
              ULONG               ulFlags;
} DRS_MSG_MOVEREQ_V1;

typedef struct _DRS_SecBuffer
{
    [range(0,MAX_CB_OF_BUFFER_IN_DRS_SECBUFF)]
       unsigned long       cbBuffer;
    unsigned long       BufferType;
    [size_is(cbBuffer)] BYTE *pvBuffer;
} DRS_SecBuffer;

typedef struct _DRS_SecBufferDesc
{
    unsigned long       ulVersion;
    [range(0,MAX_DRS_SECBUFFER_IN_SECBUFFDESC)]
       unsigned long       cBuffers;
    [size_is(cBuffers)] DRS_SecBuffer *Buffers;
} DRS_SecBufferDesc;

typedef struct _DRS_MSG_MOVEREQ_V2
{
             DSNAME              *pSrcDSA;
             ENTINF              *pSrcObject;
             DSNAME              *pDstName;
             DSNAME              *pExpectedTargetNC;
             DRS_SecBufferDesc   *pClientCreds;
             SCHEMA_PREFIX_TABLE PrefixTable;
             ULONG               ulFlags;
} DRS_MSG_MOVEREQ_V2;

// Does the DSA support DRS_MSG_MOVEREQ_V2 ?
cpp_quote("#define IS_DRS_MOVEREQ_V2_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_MOVEREQ_V2)")

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_MOVEREQ_V1  V1;
    [case(2)]   DRS_MSG_MOVEREQ_V2  V2;
} DRS_MSG_MOVEREQ;

typedef struct _DRS_MSG_MOVEREPLY_V1
{
             ENTINF              **ppResult;
             SCHEMA_PREFIX_TABLE PrefixTable;
             ULONG               *pError;
} DRS_MSG_MOVEREPLY_V1;

typedef struct _DRS_MSG_MOVEREPLY_V2
{
    ULONG               win32Error;
    [unique] DSNAME     *pAddedName;
} DRS_MSG_MOVEREPLY_V2;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_MOVEREPLY_V1  V1;
    [case(2)]   DRS_MSG_MOVEREPLY_V2  V2;
} DRS_MSG_MOVEREPLY;

typedef struct _DRS_MSG_CRACKREQ_V1
{
                    ULONG                   CodePage;
                    ULONG                   LocaleId;
                    DWORD                   dwFlags;
                    DWORD                   formatOffered;
                    DWORD                   formatDesired;
    [range(1,MAX_WCHAR_IN_CRACKREQ_V1)]
                    DWORD                   cNames;
    [string, size_is(cNames)] WCHAR **      rpNames;
} DRS_MSG_CRACKREQ_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_CRACKREQ_V1 V1;
} DRS_MSG_CRACKREQ;

typedef struct _DRS_MSG_CRACKREPLY_V1
{
    DS_NAME_RESULTW *       pResult;
} DRS_MSG_CRACKREPLY_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_CRACKREPLY_V1 V1;
} DRS_MSG_CRACKREPLY;


//
// NT4 change log retrieve request packet
//
cpp_quote("#define DRS_NT4_CHGLOG_GET_CHANGE_LOG 0x1")
cpp_quote("#define DRS_NT4_CHGLOG_GET_SERIAL_NUMBERS 0x2")

typedef struct _DRS_MSG_NT4_CHGLOG_REQ_V1
{
                            DWORD       dwFlags;
                            DWORD       PreferredMaximumLength;
    [range(0,MAX_CB_OF_RESTART_CHGLOG_REQ_V1)]
                            DWORD       cbRestart;
    [size_is(cbRestart)]    BYTE       *pRestart;

} DRS_MSG_NT4_CHGLOG_REQ_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_NT4_CHGLOG_REQ_V1 V1;
} DRS_MSG_NT4_CHGLOG_REQ;


//
// NT4 change log reply packet
//

typedef struct _NT4_REPLICATION_STATE
{
    LARGE_INTEGER SamSerialNumber;
    LARGE_INTEGER SamCreationTime;
    LARGE_INTEGER BuiltinSerialNumber;
    LARGE_INTEGER BuiltinCreationTime;
    LARGE_INTEGER LsaSerialNumber;
    LARGE_INTEGER LsaCreationTime;
} NT4_REPLICATION_STATE;

typedef struct _DRS_MSG_NT4_CHGLOG_REPLY_V1
{
    [range(0,MAX_BYTES_OF_RESTART_CHGLOG_REPLY_V1)]
                            DWORD       cbRestart;
    [range(0,MAX_BYTES_OF_LOG_CHGLOG_REPLY_V1)]
                            DWORD       cbLog;
                            NT4_REPLICATION_STATE ReplicationState;
                            DWORD       ActualNtStatus;
    [size_is(cbRestart)]    BYTE        *pRestart;
    [size_is(cbLog)]        BYTE        *pLog;

} DRS_MSG_NT4_CHGLOG_REPLY_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_NT4_CHGLOG_REPLY_V1 V1;
} DRS_MSG_NT4_CHGLOG_REPLY;

//
// SPN - Server Principal Name Request/Reply definitions
//

typedef struct _DRS_MSG_SPNREQ_V1
{
                            DWORD       operation;
                            DWORD       flags;
    [string]                const WCHAR *     pwszAccount;
    [range(0,MAX_WCHAR_IN_SPNREQ_V1)]
                            DWORD       cSPN;
    [string, size_is(cSPN)] const WCHAR **    rpwszSPN;
} DRS_MSG_SPNREQ_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_SPNREQ_V1 V1;
} DRS_MSG_SPNREQ;

typedef struct _DRS_MSG_SPNREPLY_V1
{
                            DWORD       retVal;
} DRS_MSG_SPNREPLY_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_SPNREPLY_V1 V1;
} DRS_MSG_SPNREPLY;

//
// Remove DsServer/DsDomain structures
//

// Does the DSA support these functions ?
cpp_quote("#define IS_DRS_REMOVEAPI_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_REMOVEAPI)")

typedef struct _DRS_MSG_RMSVRREQ_V1
{
    [string] LPWSTR  ServerDN;
    [string] LPWSTR  DomainDN;
             BOOL    fCommit;

} DRS_MSG_RMSVRREQ_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_RMSVRREQ_V1 V1;
} DRS_MSG_RMSVRREQ;

typedef struct _DRS_MSG_RMSVRREPLY_V1
{
    BOOL  fLastDcInDomain;
} DRS_MSG_RMSVRREPLY_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_RMSVRREPLY_V1 V1;

} DRS_MSG_RMSVRREPLY;

typedef struct _DRS_MSG_RMDMNREQ_V1
{
    [string] LPWSTR  DomainDN;

} DRS_MSG_RMDMNREQ_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_RMDMNREQ_V1 V1;

} DRS_MSG_RMDMNREQ;

typedef struct _DRS_MSG_RMDMNREPLY_V1
{
//
// In the original version, there are no out parameters.  This structure
// is added to make future modifications a bit easier.
//
    DWORD  Reserved;

} DRS_MSG_RMDMNREPLY_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_RMDMNREPLY_V1 V1;

} DRS_MSG_RMDMNREPLY;

//
// DRS_DomainControllerInfo structures
//

typedef struct _DRS_MSG_DCINFOREQ_V1
{
    [string]    WCHAR       *Domain;
                     DWORD       InfoLevel;

} DRS_MSG_DCINFOREQ_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_DCINFOREQ_V1 V1;

} DRS_MSG_DCINFOREQ, *PDRS_MSG_DCINFOREQ;

// Each new info level should get a new DS_DOMAIN_CONTROLLER_INFO_? definition
// in sdk\nc\ntdsapi.h and a corresponding DRS_MSG_DCINFOREPLY_V? definition
// below.  However, all DRS_MSG_DCINFOREPL_V* structs should have cItems
// and *rItems as their only components.  This way the client side can just
// hand back the rItems pointer to its caller w/o reallocating data.
// A corollary of this is that the server implementation should always
// return a reply version identical to the InfoLevel requested in DCINFOREQ_V1.
// I.e. We expect DCINFOREQ_V1 to be used forever, but new DSINFOREPLY versions
// to be defined to keep pace with new DS_DOMAIN_CONTROLLER_INFO versions.

typedef struct _DRS_MSG_DCINFOREPLY_V1
{
    [range(0,MAX_DOM_CNTRLR_INFO_1W_IN_DCINOFREPLY_V1)]        
                        DWORD                           cItems;
    [size_is(cItems)]   DS_DOMAIN_CONTROLLER_INFO_1W    *rItems;

} DRS_MSG_DCINFOREPLY_V1;

typedef struct _DRS_MSG_DCINFOREPLY_V2
{
    [range(0,MAX_DOM_CNTRLR_INFO_2W_IN_DCINOFREPLY_V2)]
                        DWORD                           cItems;
    [size_is(cItems)]   DS_DOMAIN_CONTROLLER_INFO_2W    *rItems;

} DRS_MSG_DCINFOREPLY_V2;

typedef struct _DRS_MSG_DCINFOREPLY_VFFFFFFFF
{
    [range(0,MAX_DOM_CNTRLR_INFO_FFFFFFFFW_IN_DCINOFREPLY_VFFFFFFFF)]
                        DWORD                                 cItems;
    [size_is(cItems)]   DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW   *rItems;

} DRS_MSG_DCINFOREPLY_VFFFFFFFF;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_DCINFOREPLY_V1 V1;
    [case(2)]   DRS_MSG_DCINFOREPLY_V2 V2;
    [case(0xFFFFFFFF)]   DRS_MSG_DCINFOREPLY_VFFFFFFFF VFFFFFFFF;

} DRS_MSG_DCINFOREPLY, *PDRS_MSG_DCINFOREPLY;

//
// DRS_AddEntry structures
//

// Does the DSA support DRS_MSG_ADDENTRYREQ_V2 ?
cpp_quote("#define IS_DRS_ADDENTRY_V2_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_ADDENTRY_V2)")

// Does the DSA support DRS_MSG_ADDENTRYREQ_V3 ?
cpp_quote("#define IS_DRS_ADDENTRY_V3_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_NONDOMAIN_NCS)")

typedef struct _DRS_MSG_ADDENTRYREQ_V1
{
        [ref]   PDSNAME         pObject;
                ATTRBLOCK       AttrBlock;
} DRS_MSG_ADDENTRYREQ_V1;

typedef struct _DRS_MSG_ADDENTRYREQ_V2
{
        ENTINFLIST              EntInfList;
} DRS_MSG_ADDENTRYREQ_V2;

typedef struct _DRS_MSG_ADDENTRYREQ_V3 {
             ENTINFLIST          EntInfList;
             DRS_SecBufferDesc * pClientCreds;
} DRS_MSG_ADDENTRYREQ_V3;


typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_ADDENTRYREQ_V1 V1;
    [case(2)]   DRS_MSG_ADDENTRYREQ_V2 V2;
    [case(3)]   DRS_MSG_ADDENTRYREQ_V3 V3;

} DRS_MSG_ADDENTRYREQ, *PDRS_MSG_ADDENTRYREQ;

typedef struct _DRS_MSG_ADDENTRYREPLY_V1
{
        GUID                    Guid;
        NT4SID                  Sid;
        DWORD                   errCode;
        DWORD                   dsid;
        DWORD                   extendedErr;
        DWORD                   extendedData;
        USHORT                  problem;

} DRS_MSG_ADDENTRYREPLY_V1;

typedef struct _ADDENTRY_REPLY_INFO
{
        GUID   objGuid;
        NT4SID objSid;

} ADDENTRY_REPLY_INFO;

typedef struct _DRS_MSG_ADDENTRYREPLY_V2
{
[unique] DSNAME                 *pErrorObject;
         DWORD                   errCode;
         DWORD                   dsid;
         DWORD                   extendedErr;
         DWORD                   extendedData;
         USHORT                  problem;
[range(0,MAX_ADDENTRY_REPLY_INFO_IN_ADDENTRYREPLY_V2)]
         ULONG                   cObjectsAdded;
[size_is(cObjectsAdded)] ADDENTRY_REPLY_INFO    *infoList;

} DRS_MSG_ADDENTRYREPLY_V2;

typedef struct _DRS_ERROR_DATA_V1 {
     // This is the error if we want just a Win32 replication error.
     DWORD                                       dwRepError;  // Replication 
     // If errCode != 0 then pErrInfo will be the DIRERR_DRS_WIRE_V1 data.
     DWORD                                       errCode;  // pTHS->errCode
     [switch_is(errCode)] DIRERR_DRS_WIRE_V1 *   pErrInfo;  // approximately pTHS->pErrInfo
} DRS_ERROR_DATA_V1;

typedef [switch_type(DWORD)] union {
    [case(1)]   DRS_ERROR_DATA_V1 V1;
} DRS_ERROR_DATA;

typedef struct _DRS_MSG_ADDENTRYREPLY_V3 {
    // Object that probably caused the problem.
    PDSNAME                                          pdsErrObject;
    DWORD                                            dwErrVer;
    // This might be NULL if we couldn't allocate the memory for
    // the error data.
    [switch_is(dwErrVer)] DRS_ERROR_DATA *           pErrData;
    [range(0,MAX_ADDENTRY_REPLY_INFO_IN_ADDENTRYREPLY_V3)]
       ULONG                                            cObjectsAdded;
    [size_is(cObjectsAdded)] ADDENTRY_REPLY_INFO *   infoList;

} DRS_MSG_ADDENTRYREPLY_V3;

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_ADDENTRYREPLY_V1 V1;
    [case(2)]   DRS_MSG_ADDENTRYREPLY_V2 V2;
    [case(3)]   DRS_MSG_ADDENTRYREPLY_V3 V3;


} DRS_MSG_ADDENTRYREPLY, *PDRS_MSG_ADDENTRYREPLY;

/*
** KCC execution request.
*/

typedef struct _DRS_MSG_KCC_EXECUTE_V1
{
    DWORD   dwTaskID;
    DWORD   dwFlags;
} DRS_MSG_KCC_EXECUTE_V1;

// Does the DSA support DRS_MSG_KCC_EXECUTE_V1?
cpp_quote("#define IS_DRS_KCC_EXECUTE_V1_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_KCC_EXECUTE)")

typedef [switch_type(DWORD)] union
{
    [case(1)]   DRS_MSG_KCC_EXECUTE_V1  V1;
} DRS_MSG_KCC_EXECUTE;


//
// IDL_DRSGetReplInfo() structures.
//

// Private info returnable by IDL_DRSGetReplInfo().
// Enumerated beginning with 0xFFFFFFFF on down to avoid conflict/confusion
// with the public DS_REPL_INFO_TYPE enumeration.
typedef enum _DS_REPL_INFO_TYPEP {
    DS_REPL_INFO_QUEUE_B3RC0        = 0xFFFFFFFF,  // No longer valid.
    DS_REPL_INFO_REPSTO             = 0xFFFFFFFE,  // returns DS_REPL_NEIGHBORSW *
    DS_REPL_INFO_QUEUE_B3RTM        = 0xFFFFFFFD,  // No longer valid.
    DS_REPL_INFO_CLIENT_CONTEXTS    = 0xFFFFFFFC,  // List of oustanding client ctx
    DS_REPL_INFO_UPTODATE_VECTOR_V1 = 0xFFFFFFFB, // Up to dateness vector
    DS_REPL_INFO_SERVER_OUTGOING_CALLS = 0xFFFFFFFA, // Serv to Serv outgoing calls
    // <- insert new private DS_REPL_INFO_* types here, and update
    // DS_REPL_INFO_TYPE_MIN below.
    DS_REPL_INFO_TYPEP_MIN          = 0xFFFFFFF9
} DS_REPL_INFO_TYPEP;

typedef struct _DS_REPL_CLIENT_CONTEXT {
    ULONGLONG           hCtx;
    LONG                lReferenceCount;  // number of users of this struct
    BOOL                fIsBound;         // is still bound?
    UUID                uuidClient;       // objectGuid of client's ntdsDSA obj,
                                          //    or NtdsapiClientGuid if ntdsapi
                                          //    client
    DSTIME              timeLastUsed;     // time client last used this ctx
    ULONG               IPAddr;           // IP address of client machine
    INT                 pid;              // ID of binding client process
} DS_REPL_CLIENT_CONTEXT;

typedef struct _DS_REPL_CLIENT_CONTEXTS {
    [range(0,MAX_CLIENT_CONTEXTS)]
       DWORD                       cNumContexts;
    DWORD                       dwReserved;
    [size_is(cNumContexts)]
        DS_REPL_CLIENT_CONTEXT  rgContext[];
} DS_REPL_CLIENT_CONTEXTS;

typedef struct _DS_REPL_SERVER_OUTGOING_CALL {
  [string] LPWSTR pszServerName;
  BOOL fIsHandleBound;
  BOOL fIsHandleFromCache;
  BOOL fIsHandleInCache;
  DWORD dwThreadId;
  DWORD dwBindingTimeoutMins;
  DSTIME dstimeCreated;
  DWORD dwCallType;
} DS_REPL_SERVER_OUTGOING_CALL;

typedef struct _DS_REPL_SERVER_OUTGOING_CALLS {
    [range(0,MAX_OUTGOING_CALLS)]
    DWORD                       cNumCalls;
    DWORD                       dwReserved;
    [size_is(cNumCalls)]
        DS_REPL_SERVER_OUTGOING_CALL  rgCall[];
} DS_REPL_SERVER_OUTGOING_CALLS;

typedef struct _DRS_MSG_GETREPLINFO_REQ_V1 {
             DWORD   InfoType;

    [string] LPWSTR  pszObjectDN;
             UUID    uuidSourceDsaObjGuid;
} DRS_MSG_GETREPLINFO_REQ_V1;

// This form allows you to specify an attribute name and
// enumeration context.
typedef struct _DRS_MSG_GETREPLINFO_REQ_V2 {
// DRS_MSG_GETREPLINFO_REQ_V1 ;
             DWORD   InfoType;
    [string] LPWSTR  pszObjectDN;
             UUID    uuidSourceDsaObjGuid;
// DRS_MSG_GETREPLINFO_REQ_V1 ;
             DWORD   ulFlags;
    [string] LPWSTR  pszAttributeName;
    [string] LPWSTR  pszValueDN;
             DWORD   dwEnumerationContext;
} DRS_MSG_GETREPLINFO_REQ_V2;

typedef [switch_type(DWORD)] union _DRS_MSG_GETREPLINFO_REQ {
    [case(1)] DRS_MSG_GETREPLINFO_REQ_V1 V1;
    [case(2)] DRS_MSG_GETREPLINFO_REQ_V2 V2;
} DRS_MSG_GETREPLINFO_REQ;

typedef [switch_type(DWORD)] union _DRS_MSG_GETREPLINFO_REPLY {
    // Public.
    [case(DS_REPL_INFO_NEIGHBORS)]        DS_REPL_NEIGHBORSW *    pNeighbors;
    [case(DS_REPL_INFO_CURSORS_FOR_NC)]   DS_REPL_CURSORS *       pCursors;
    [case(DS_REPL_INFO_METADATA_FOR_OBJ)] DS_REPL_OBJ_META_DATA * pObjMetaData;
    
    [case(DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES)]
        DS_REPL_KCC_DSA_FAILURESW * pConnectFailures;
    
    [case(DS_REPL_INFO_KCC_DSA_LINK_FAILURES)]
        DS_REPL_KCC_DSA_FAILURESW * pLinkFailures;
    
    [case(DS_REPL_INFO_PENDING_OPS)]      DS_REPL_PENDING_OPSW *  pPendingOps;
    
    [case(DS_REPL_INFO_METADATA_FOR_ATTR_VALUE)]
        DS_REPL_ATTR_VALUE_META_DATA * pAttrValueMetaData;
    
    [case(DS_REPL_INFO_CURSORS_2_FOR_NC)] DS_REPL_CURSORS_2 *     pCursors2;
    [case(DS_REPL_INFO_CURSORS_3_FOR_NC)] DS_REPL_CURSORS_3W *    pCursors3;
    
    [case(DS_REPL_INFO_METADATA_2_FOR_OBJ)]
        DS_REPL_OBJ_META_DATA_2 * pObjMetaData2;
    
    [case(DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE)]
        DS_REPL_ATTR_VALUE_META_DATA_2 * pAttrValueMetaData2;

    // Private.
    [case(DS_REPL_INFO_REPSTO)]           DS_REPL_NEIGHBORSW *    pRepsTo;
    [case(DS_REPL_INFO_CLIENT_CONTEXTS)]
        DS_REPL_CLIENT_CONTEXTS *   pClientContexts;
    [case(DS_REPL_INFO_UPTODATE_VECTOR_V1)]
        UPTODATE_VECTOR_V1_WIRE *   pUpToDateVec;
    [case(DS_REPL_INFO_SERVER_OUTGOING_CALLS)]
        DS_REPL_SERVER_OUTGOING_CALLS *   pServerOutgoingCalls;
} DRS_MSG_GETREPLINFO_REPLY;

// Does the DSA support IDL_DRSGetReplInfo?
cpp_quote("#define IS_DRS_GET_REPL_INFO_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_GET_REPL_INFO)")

// Does the DSA support DS_REPL_INFO_KCC_DSA_(CONNECT|LINK)_FAILURES?
cpp_quote("#define IS_DRS_GET_REPL_INFO_KCC_DSA_FAILURES_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_POST_BETA3)")

// Does the DSA support DS_REPL_INFO_PENDING_OPS?
cpp_quote("#define IS_DRS_GET_REPL_INFO_PENDING_SYNCS_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_POST_BETA3)")

// Does the DSA support DRS_MSG_GETREPLINFO_REQ_V2?
cpp_quote("#define IS_DRS_GET_REPL_INFO_REQ_V2_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_GETCHGREQ_V8)")

// Does the DSA support DS_REPL_INFO_METADATA_FOR_ATTR_VALUE?
cpp_quote("#define IS_DRS_GET_REPL_INFO_METADATA_FOR_ATTR_VALUE_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_GETCHGREQ_V8)")

// Does the DSA support DS_REPL_INFO_CURSORS_2_FOR_NC?
cpp_quote("#define IS_DRS_GET_REPL_INFO_CURSORS_2_FOR_NC_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_GETCHGREPLY_V6)")

// Does the DSA support DS_REPL_INFO_CURSORS_3_FOR_NC?
cpp_quote("#define IS_DRS_GET_REPL_INFO_CURSORS_3_FOR_NC_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_GETCHGREPLY_V6)")

// Does the DSA support DS_REPL_INFO_METADATA_2_FOR_OBJ?
cpp_quote("#define IS_DRS_GET_REPL_INFO_METADATA_2_FOR_OBJ_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_GETCHGREPLY_V6)")
    
// Does the DSA support DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE?
cpp_quote("#define IS_DRS_GET_REPL_INFO_METADATA_2_FOR_ATTR_VALUE_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_GETCHGREPLY_V6)")

typedef struct _DRS_MSG_ADDSIDREQ_V1
{
                                                DWORD   Flags;
    [string]                                    WCHAR   *SrcDomain;
    
    // ISSUE:  This should have been [ref] - but cannot be changed without breaking backwards compat
    [string]                                    WCHAR   *SrcPrincipal;

    // ISSUE:  There is no reason this needs to be [ptr] type, this could be a security issue.
    //         - but cannot be changed without breaking backwards compat
    [string, ptr]                               WCHAR   *SrcDomainController;
    [range(0,MAX_WCHAR_OF_SRCCREDS_USR_IN_ADDSIDREQ_V1)]
                                                DWORD   SrcCredsUserLength;
    [size_is(SrcCredsUserLength)]               WCHAR   *SrcCredsUser;
    [range(0,MAX_WCHAR_OF_SRCCREDS_DMN_IN_ADDSIDREQ_V1)]
                                                DWORD   SrcCredsDomainLength;
    [size_is(SrcCredsDomainLength)]             WCHAR   *SrcCredsDomain;
    [range(0,MAX_WCHAR_OF_SRCCREDS_PWD_IN_ADDSIDREQ_V1)]
                                                DWORD   SrcCredsPasswordLength;
    [size_is(SrcCredsPasswordLength)]           WCHAR   *SrcCredsPassword;
    [string]                                    WCHAR   *DstDomain;

    // ISSUE:  This should have been [ref] - but cannot be changed without breaking backwards compat
    [string]                                    WCHAR   *DstPrincipal;
} DRS_MSG_ADDSIDREQ_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]       DRS_MSG_ADDSIDREQ_V1 V1;
} DRS_MSG_ADDSIDREQ;

typedef struct _DRS_MSG_ADDSIDREPLY_V1
{
    DWORD           dwWin32Error;
} DRS_MSG_ADDSIDREPLY_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]       DRS_MSG_ADDSIDREPLY_V1 V1;
} DRS_MSG_ADDSIDREPLY;

cpp_quote("#define IS_DRS_GETMEMBERSHIPS2_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_GETMEMBERSHIPS2)")

typedef struct _DRS_MSG_GETMEMBERSHIPS2_REQ_V1
{
    [range(1,MAX_REVMEMB_REQ_V1_IN_GETMEMB2_REQ_V1)] ULONG Count;
    [size_is(Count)] DRS_MSG_REVMEMB_REQ_V1 *Requests;

}DRS_MSG_GETMEMBERSHIPS2_REQ_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]       DRS_MSG_GETMEMBERSHIPS2_REQ_V1 V1;

} DRS_MSG_GETMEMBERSHIPS2_REQ;


typedef struct _DRS_MSG_GETMEMBERSHIPS2_REPLY_V1
{
    [range(0,MAX_REVMEMB_REPLY_V1_IN_GETMEMB2_REPLY_V1)] ULONG Count;
    [size_is(Count)] DRS_MSG_REVMEMB_REPLY_V1 *Replies;

}DRS_MSG_GETMEMBERSHIPS2_REPLY_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]       DRS_MSG_GETMEMBERSHIPS2_REPLY_V1 V1;

} DRS_MSG_GETMEMBERSHIPS2_REPLY;

typedef struct _DRS_MSG_REPVERIFYOBJ_V1
{
   [ref]            DSNAME *                pNC;
                    UUID                    uuidDsaSrc;
                    ULONG                   ulOptions;
} DRS_MSG_REPVERIFYOBJ_V1;

typedef [switch_type(DWORD)] union
{
   [case(1)]        DRS_MSG_REPVERIFYOBJ_V1 V1;

} DRS_MSG_REPVERIFYOBJ;

// Does the DSA support DRS_MSG_REPVERIFYOBJ_V1
cpp_quote("#define IS_DRS_REPLICA_VERIFY_OBJECT_V1_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_VERIFY_OBJECT)")


typedef struct _DRS_MSG_EXISTREQ_V1
{
                    UUID                     guidStart;
                    DWORD                    cGuids;

                    // ISSUE:  This should have been [ref] - but cannot be changed without breaking backwards compat
                    DSNAME *                 pNC;

                    // ISSUE:  This should have been [ref] - but cannot be changed without breaking backwards compat
                    UPTODATE_VECTOR_V1_WIRE *pUpToDateVecCommonV1;
                    UCHAR                    Md5Digest[16]; // MD5DIGESTLEN
} DRS_MSG_EXISTREQ_V1;

typedef [switch_type(DWORD)] union
{
   [case(1)]        DRS_MSG_EXISTREQ_V1     V1;

} DRS_MSG_EXISTREQ;

cpp_quote("#define DRS_EXIST_MATCH (0x1)")

typedef struct _DRS_MSG_EXISTREPLY_V1
{
                        DWORD                    dwStatusFlags;
   [range(0,MAX_UUID_IN_EXISTREPLY_V1)]
                        DWORD                    cNumGuids;        // Number of values returned
   [size_is(cNumGuids)] UUID *                   rgGuids;          // Returned array of values

} DRS_MSG_EXISTREPLY_V1;

typedef [switch_type(DWORD)] union
{
   [case(1)] DRS_MSG_EXISTREPLY_V1 V1;
} DRS_MSG_EXISTREPLY;

// QuerySitesByCost Support
// Note that the DRS_EXT_QUERYSITESBYCOST_V1 bit is a recycled bit. There are many builds
// which have this bit set but do not actually support QuerySitesByCost. Windows .NET Server
// Beta 3 is a good example. If all machines are upgraded to the RTM build then this
// extension bit will reliably indicate whether or not QuerySitesByCost is supported.
cpp_quote("#define IS_DRS_QUERYSITESBYCOST_V1_SUPPORTED(pext) IS_DRS_EXT_SUPPORTED(pext, DRS_EXT_QUERYSITESBYCOST_V1)")

// QuerySitesByCost Request (version 1)
typedef struct _DRS_MSG_QUERYSITESREQ_V1
{
    // ISSUE:  This should have been [ref] - but cannot be changed without breaking backwards compat
    [string]                    const WCHAR *                       pwszFromSite;
    [range(1,MAX_WCHAR_IN_QUERY_SITESREQ_V1)]
                                DWORD                               cToSites;
    [string, size_is(cToSites)] WCHAR **                            rgszToSites;
                                DWORD                               dwFlags;
} DRS_MSG_QUERYSITESREQ_V1;

// QuerySitesByCost Request (versioned union)
typedef [switch_type(DWORD)] union
{
    [case(1)]                   DRS_MSG_QUERYSITESREQ_V1            V1;
} DRS_MSG_QUERYSITESREQ;

// QuerySitesByCost Reply (array element)
typedef struct _DRS_MSG_QUERYSITESREPLYELEMENT_V1
{
                                DWORD                               dwErrorCode;
                                DWORD                               dwCost;
} DRS_MSG_QUERYSITESREPLYELEMENT_V1;

// QuerySitesByCost Reply (version 1)
typedef struct _DRS_MSG_QUERYSITESREPLY_V1
{
    [range(0,MAX_WCHAR_IN_QUERY_SITESREPLY_V1)]
                                DWORD                               cToSites;
    [size_is(cToSites)]         DRS_MSG_QUERYSITESREPLYELEMENT_V1*  rgCostInfo;
                                DWORD                               dwFlags;
} DRS_MSG_QUERYSITESREPLY_V1;

// QuerySitesByCost Reply (versioned union)
typedef [switch_type(DWORD)] union
{
    [case(1)]                   DRS_MSG_QUERYSITESREPLY_V1          V1;
} DRS_MSG_QUERYSITESREPLY;

// Note in the below that there *is* a difference between the types
// DRS_EXTENSIONS * and PDRS_EXTENSIONS -- the latter is not freed by RPC.
// (See drs.acf.)

ULONG
IDL_DRSBind(
    [in]            handle_t                rpc_handle,
    [in]  [unique]  UUID *                  puuidClientDsa,
    [in]  [unique]  DRS_EXTENSIONS *        pextClient,
    [out]           PDRS_EXTENSIONS *       ppextServer,
    [out] [ref]     DRS_HANDLE *            phDrs
    );

ULONG
IDL_DRSUnbind(
    [in, out] [ref] DRS_HANDLE *            phDrs
    );

ULONG
IDL_DRSReplicaSync(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwVersion,
    [in]  [ref] [switch_is(dwVersion)]
                    DRS_MSG_REPSYNC *       pmsgSync
    );

ULONG
IDL_DRSGetNCChanges(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwInVersion,
    [in]  [ref] [switch_is(dwInVersion)]
                    DRS_MSG_GETCHGREQ *     pmsgIn,
    [out] [ref]     DWORD *                 pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_GETCHGREPLY *   pmsgOut
    );

ULONG
IDL_DRSUpdateRefs(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwVersion,
    [in]  [ref] [switch_is(dwVersion)]
                    DRS_MSG_UPDREFS *       pmsgUpdRefs
    );

ULONG
IDL_DRSReplicaAdd(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwVersion,
    [in]  [ref] [switch_is(dwVersion)]
                    DRS_MSG_REPADD *        pmsgAdd
    );

ULONG
IDL_DRSReplicaDel(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwVersion,
    [in]  [ref] [switch_is(dwVersion)]
                    DRS_MSG_REPDEL *        pmsgDel
    );

ULONG
IDL_DRSReplicaModify(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwVersion,
    [in]  [ref] [switch_is(dwVersion)]
                    DRS_MSG_REPMOD *        pmsgMod
    );

ULONG
IDL_DRSVerifyNames(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwInVersion,
    [in]  [ref] [switch_is(dwInVersion)]
                    DRS_MSG_VERIFYREQ *     pmsgIn,
    [out] [ref]     DWORD *                 pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_VERIFYREPLY *   pmsgOut
    );

ULONG
IDL_DRSGetMemberships(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwInVersion,
    [in] [ref] [switch_is(dwInVersion)]
                    DRS_MSG_REVMEMB_REQ *   pmsgIn,
    [out] [ref]     DWORD *                 pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_REVMEMB_REPLY * pmsgOut
    );

ULONG
IDL_DRSInterDomainMove(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwInVersion,
    [in]  [ref] [switch_is(dwInVersion)]
                    DRS_MSG_MOVEREQ *       pmsgIn,
    [out] [ref]     DWORD *                 pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_MOVEREPLY *     pmsgOut
    );

ULONG
IDL_DRSGetNT4ChangeLog(
   [in]   [ref]     DRS_HANDLE              hDrs,
   [in]             DWORD                   dwInVersion,
   [in]   [ref] [switch_is(dwInVersion)]
                    DRS_MSG_NT4_CHGLOG_REQ * pmsgIn,
   [out]  [ref]     DWORD*                  pdwOutVersion,
   [out]  [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_NT4_CHGLOG_REPLY * pmsgOut
   );

ULONG
IDL_DRSCrackNames(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwInVersion,
    [in]  [ref] [switch_is(dwInVersion)]
                    DRS_MSG_CRACKREQ *      pmsgIn,
    [out] [ref]     DWORD *                 pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_CRACKREPLY *    pmsgOut
    );

ULONG
IDL_DRSWriteSPN(   // SPN - Server Principal Name
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwInVersion,
    [in]  [ref] [switch_is(dwInVersion)]
                    DRS_MSG_SPNREQ *        pmsgIn,
    [out] [ref]     DWORD *                 pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_SPNREPLY *      pmsgOut
    );

ULONG
IDL_DRSRemoveDsServer(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwInVersion,
    [in]  [ref] [switch_is(dwInVersion)]
                    DRS_MSG_RMSVRREQ *      pmsgIn,
    [out] [ref]     DWORD *                 pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_RMSVRREPLY *    pmsgOut
    );

ULONG
IDL_DRSRemoveDsDomain(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwInVersion,
    [in]  [ref] [switch_is(dwInVersion)]
                    DRS_MSG_RMDMNREQ *      pmsgIn,
    [out] [ref]     DWORD *                 pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_RMDMNREPLY *    pmsgOut
    );

ULONG
IDL_DRSDomainControllerInfo(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwInVersion,
    [in]  [ref] [switch_is(dwInVersion)]
                    DRS_MSG_DCINFOREQ *     pmsgIn,
    [out] [ref]     DWORD *                 pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_DCINFOREPLY *   pmsgOut
    );

ULONG
IDL_DRSAddEntry(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwInVersion,
    [in]  [ref] [switch_is(dwInVersion)]
                    DRS_MSG_ADDENTRYREQ *   pmsgIn,
    [out] [ref]     DWORD *                 pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_ADDENTRYREPLY * pmsgOut
    );

ULONG
IDL_DRSExecuteKCC(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwInVersion,
    [in]  [ref] [switch_is(dwInVersion)]
                    DRS_MSG_KCC_EXECUTE *   pmsgIn
    );

ULONG
IDL_DRSGetReplInfo(
    [in]  [ref]     DRS_HANDLE                  hDrs,
    [in]            DWORD                       dwInVersion,
    [in]  [ref] [switch_is(dwInVersion)]
                    DRS_MSG_GETREPLINFO_REQ *   pmsgIn,
    [out] [ref]     DWORD *                     pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_GETREPLINFO_REPLY * pmsgOut
    );

ULONG
IDL_DRSAddSidHistory(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwInVersion,
    [in]  [ref] [switch_is(dwInVersion)]
                    DRS_MSG_ADDSIDREQ *     pmsgIn,
    [out] [ref]     DWORD *                 pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_ADDSIDREPLY *   pmsgOut
    );

ULONG
IDL_DRSGetMemberships2(
    [in]  [ref]     DRS_HANDLE              hDrs,
    [in]            DWORD                   dwInVersion,
    [in] [ref] [switch_is(dwInVersion)]
                    DRS_MSG_GETMEMBERSHIPS2_REQ *   pmsgIn,
    [out] [ref]     DWORD *                 pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_GETMEMBERSHIPS2_REPLY * pmsgOut
    );

ULONG
IDL_DRSReplicaVerifyObjects(
   [in] [ref]       DRS_HANDLE              hDrs,
   [in]             DWORD                   dwVersion,
   [in] [ref] [switch_is(dwVersion)]        
                    DRS_MSG_REPVERIFYOBJ *  pmsgVerify
   );

ULONG
IDL_DRSGetObjectExistence(
   [in] [ref]       DRS_HANDLE              hDrs,
   [in]             DWORD                   dwInVersion,
   [in] [ref] [switch_is(dwInVersion)]
                    DRS_MSG_EXISTREQ *      pmsgIn,
   [out] [ref]      DWORD *                 pdwOutVersion,
   [out] [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_EXISTREPLY *    pmsgOut
   );

ULONG
IDL_DRSQuerySitesByCost(
   [in] [ref]       DRS_HANDLE               hDrs,
   [in]             DWORD                    dwInVersion,
   [in] [ref] [switch_is(dwInVersion)]
                    DRS_MSG_QUERYSITESREQ*   pmsgIn,
   [out] [ref]      DWORD *                  pdwOutVersion,
   [out] [ref] [switch_is(*pdwOutVersion)]
                    DRS_MSG_QUERYSITESREPLY* pmsgOut
   );

// If you add a new function (always at the bottom!), be sure to add a
// corresponding [notify] entry to drs.acf.
}



// This is the "real" ntdscript interface.
[
uuid(7c44d7d4-31d5-424c-bd5e-2b3e1f323d22), version(1.0),
   pointer_default (unique)
]
interface dsaop
{
/* define a version independent constant for the interface spec  */
cpp_quote("#define dsaop_ClientIfHandle dsaop_v1_0_c_ifspec")
cpp_quote("#define _dsaop_ClientIfHandle _dsaop_v1_0_c_ifspec")
cpp_quote("#define dsaop_ServerIfHandle dsaop_v1_0_s_ifspec")


// execute script related in / out structures
//

typedef struct _DSA_MSG_EXECUTE_SCRIPT_REQ_V1
{
                                        DWORD   Flags;
    [range(1,MAX_CB_OF_PASSWORD_IN_EXECUTE_SCPT_REQ_V1)]
                                        DWORD   cbPassword;
    [size_is(cbPassword)]               BYTE   *pbPassword;
} DSA_MSG_EXECUTE_SCRIPT_REQ_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]       DSA_MSG_EXECUTE_SCRIPT_REQ_V1 V1;
} DSA_MSG_EXECUTE_SCRIPT_REQ;



typedef struct _DSA_MSG_EXECUTE_SCRIPT_REPLY_V1
{
                                        DWORD   dwOperationStatus;
    [ string ]                          LPWSTR  pwErrMessage;

} DSA_MSG_EXECUTE_SCRIPT_REPLY_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]       DSA_MSG_EXECUTE_SCRIPT_REPLY_V1 V1;
} DSA_MSG_EXECUTE_SCRIPT_REPLY;


typedef struct _DSA_MSG_PREPARE_SCRIPT_REQ_V1
{
                                        DWORD   Reserved;
} DSA_MSG_PREPARE_SCRIPT_REQ_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]       DSA_MSG_PREPARE_SCRIPT_REQ_V1 V1;
} DSA_MSG_PREPARE_SCRIPT_REQ;



typedef struct _DSA_MSG_PREPARE_SCRIPT_REPLY_V1
{
                                        DWORD   dwOperationStatus;
    [ string ]                          LPWSTR  pwErrMessage;
    [range(0,MAX_CB_OF_PASSWORD_IN_PRPRE_SCPT_REPLY_V1)]
                                        DWORD   cbPassword;
    [size_is(cbPassword)]               BYTE   *pbPassword;
    [range(0,MAX_CB_OF_HASHBOD_IN_PRPRE_SCPT_REPLY_V1)]
                                        DWORD   cbHashBody;
    [size_is(cbHashBody)]               BYTE   *pbHashBody;
    [range(0,MAX_CB_OF_HASHSIG_IN_PRPRE_SCPT_REPLY_V1)]
                                        DWORD   cbHashSignature;
    [size_is(cbHashSignature)]          BYTE   *pbHashSignature;

} DSA_MSG_PREPARE_SCRIPT_REPLY_V1;

typedef [switch_type(DWORD)] union
{
    [case(1)]       DSA_MSG_PREPARE_SCRIPT_REPLY_V1 V1;
} DSA_MSG_PREPARE_SCRIPT_REPLY;


ULONG
IDL_DSAPrepareScript(
    [in]		        handle_t	                     hRpc,
    [in]            DWORD                          dwInVersion,
    [in]  [ref] [switch_is(dwInVersion)]
                    DSA_MSG_PREPARE_SCRIPT_REQ *   pmsgIn,
    [out] [ref]     DWORD *                        pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DSA_MSG_PREPARE_SCRIPT_REPLY * pmsgOut
    );

ULONG
IDL_DSAExecuteScript(
    [in]		        handle_t	                     hRpc,
    [in]            DWORD                          dwInVersion,
    [in]  [ref] [switch_is(dwInVersion)]
                    DSA_MSG_EXECUTE_SCRIPT_REQ *   pmsgIn,
    [out] [ref]     DWORD *                        pdwOutVersion,
    [out] [ref] [switch_is(*pdwOutVersion)]
                    DSA_MSG_EXECUTE_SCRIPT_REPLY * pmsgOut
    );

}

